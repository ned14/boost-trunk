[/
          Copyright Oliver Kowalke 2009.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]

[section:motivation Motivation]

In order to support a broad range of execution control behaviour __push_coro__ and
__pull_coro__ can be used to ['escape-and-reenter] loops, to ['escape-and-reenter]
recursive computations and for ['cooperative] multitasking
helping to solve problems in a much simpler and more elegant way than with only
a single flow of control.


[heading 'same fringe' problem]

The advantages can be seen particularly clearly with the use of a recursive
function, such as traversal of trees.
If traversing two different trees in the same deterministic order produces the
same list of leaf nodes, then both trees have the same fringe.

[$../../../../libs/coroutine/doc/images/fringe.png [align center]]

Both trees in the picture have the same fringe even though the structure of the
trees is different.

The same fringe problem could be solved using coroutines by iterating over the
leaf nodes and comparing this sequence via \cpp{std::equal()}. The range of leaf
nodes is generated by a visitor which recursively traverses the tree and passes
leaf nodes to its coroutine.

        node::ptr_t create_tree1(){
            return branch::create(
                leaf::create("a"),
                branch::create(
                    leaf::create("b"),
                    leaf::create("c")));
        }

        node::ptr_t create_tree2(){
            return branch::create(
                branch::create(
                    leaf::create("a"),
                    leaf::create("b")),
                leaf::create("c"));
        }

        // create tree t1
        node::ptr_t t1=create_tree1();
        // create a coroutine, recursivly iterates trough t1
        // returning leaf nodes
        std::coroutine<leaf&>::pull_type c1(
            [&](std::coroutine<leaf&>::push_type& c){
                // create visitor, attached to coroutine
                coro_visitor v(c);
                // traverse t1 recursivly
                t1->accept(v);
            });

        // create tree t2
        node::ptr_t t2=create_tree2();
        // create a coroutine, recursivly iterates trough t2
        // returning leaf nodes
        std::coroutine<leaf&>::pull_type c2(
            [&](std::coroutine<leaf&>::push_type& c){
                // create visitor, attached to coroutine
                coro_visitor v(c);
                // traverse t2 recursivly
                t2->accept(v);
            });

        // compare leaf node ranges of t1 and t2
        bool result = std::equal(
                std::begin(c1),
                std::end(c1),
                std::begin(c2));

        std::cout << std::boolalpha << "same fringe == " << result;

A tree consists of branch and leaf nodes. Each branch node has two children;
leaf nodes have none. Trees t1 and t2 have a different tree structure but the
same fringe.
For each tree a __pull_coro__ is created while in the associated __coro_fn__
['coro_visitor] traverses the tree.
__pull_coro__-iterator, created from __pull_coro__, steps over the leaf nodes of its tree
and ['std::equal()] compares the iterator ranges.

        class coro_visitor : public visitor
        {
        private:
            // coroutine used to pass leaf node back to caller
            std::coroutine<leaf&>::push_type & c_;

        public:
            coro_visitor(std::coroutine<leaf&>::push_type& c) :
                c_(c)
            {}

            void visit(branch & b){
                // traverse tree
                if (b.left) b.left->accept(*this);
                if (b.right) b.right->accept(*this);
            }

            void visit(leaf & l){
                // return leaf node to caller
                c_(l);
            }
        };

The visitor inspects recursively the tree - on each leaf node it escapes the
recursive computation and makes the leaf node available to the iterator (via
__push_coro__). After re-entering the visitor the recursive traversing of the tree
continues.


[heading asynchronous operations with boost.asio]

In the past the code using asio's ['asynchronous operations] was scattered by callbacks.
__boost_asio__ provides with its new ['asynchronous result] feature a new way to simplify the
code and make it easier to read.
__yield_context__ uses internally __boost_coroutine__:

        void echo(boost::asio::ip::tcp::socket& socket,boost::asio::yield_context yield){
            char data[128];
            // read asynchronous data from socket
            // execution context will be suspended until
            // some bytes are read from socket
            std::size_t n=socket.async_read_some(boost::asio::buffer(data),yield);
            // write some bytes asynchronously
            boost::asio::async_write(socket,boost::asio::buffer(data,n),yield);
        }

[endsect]
