<?xml version="1.0" standalone="yes"?>
<library-reference><header name="boost/xpressive/proto/args.hpp"><para>Contains definition of args&lt;&gt; class template. </para><namespace name="boost"><namespace name="proto"><struct name="args1"><template>
      <template-type-parameter name="Arg0"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the expr&lt;&gt; class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the expr&lt;&gt; class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="size" specifiers="static"><type>const long</type></data-member><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>mpl::void_</type></typedef><typedef name="arg2"><type>mpl::void_</type></typedef><typedef name="arg3"><type>mpl::void_</type></typedef><typedef name="arg4"><type>mpl::void_</type></typedef></struct><struct name="args2"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the expr&lt;&gt; class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the expr&lt;&gt; class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="size" specifiers="static"><type>const long</type></data-member><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>Arg1</type></typedef><typedef name="arg2"><type>mpl::void_</type></typedef><typedef name="arg3"><type>mpl::void_</type></typedef><typedef name="arg4"><type>mpl::void_</type></typedef></struct><struct name="args3"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
      <template-type-parameter name="Arg2"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the expr&lt;&gt; class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the expr&lt;&gt; class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="size" specifiers="static"><type>const long</type></data-member><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>Arg1</type></typedef><typedef name="arg2"><type>Arg2</type></typedef><typedef name="arg3"><type>mpl::void_</type></typedef><typedef name="arg4"><type>mpl::void_</type></typedef></struct><struct name="args4"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
      <template-type-parameter name="Arg2"/>
      <template-type-parameter name="Arg3"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the expr&lt;&gt; class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the expr&lt;&gt; class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="size" specifiers="static"><type>const long</type></data-member><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>Arg1</type></typedef><typedef name="arg2"><type>Arg2</type></typedef><typedef name="arg3"><type>Arg3</type></typedef><typedef name="arg4"><type>mpl::void_</type></typedef></struct><struct name="args5"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
      <template-type-parameter name="Arg2"/>
      <template-type-parameter name="Arg3"/>
      <template-type-parameter name="Arg4"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the expr&lt;&gt; class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the expr&lt;&gt; class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="size" specifiers="static"><type>const long</type></data-member><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>Arg1</type></typedef><typedef name="arg2"><type>Arg2</type></typedef><typedef name="arg3"><type>Arg3</type></typedef><typedef name="arg4"><type>Arg4</type></typedef></struct></namespace></namespace></header><header name="boost/xpressive/proto/context.hpp"><para>Definintion of context&lt;&gt;, a default evaluation context for expr&lt;&gt;eval() that uses Boost.Typeof to deduce return types of the built-in operators. </para><namespace name="boost"><namespace name="proto"><struct name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
      <template-type-parameter name="Tag"><default>typename Expr::tag_type</default></template-type-parameter>
      <template-nontype-parameter name="Arity"><type>long</type><default>Expr::arity::value</default></template-nontype-parameter>
    </template></struct><struct name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
      <template-nontype-parameter name="Arity"><type>long</type><default>Expr::arity::value</default></template-nontype-parameter>
    </template></struct><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::tag_type, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference)&gt;::<classname>type</classname></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::tag_type, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 1 &gt;::const_reference)&gt;::<classname>type</classname></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>3</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::tag_type, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 1 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 2 &gt;::const_reference)&gt;::<classname>type</classname></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>4</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::tag_type, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 1 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 2 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 3 &gt;::const_reference)&gt;::<classname>type</classname></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>5</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::tag_type, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 1 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 2 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 3 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 4 &gt;::const_reference)&gt;::<classname>type</classname></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct name="default_context"><description><para>default_context </para></description><struct name="eval"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::default_eval&lt; Expr, default_context &gt;</inherit><description><para>default_context::eval </para></description></struct></struct><struct name="callable_context"><template>
      <template-type-parameter name="Context"/>
    </template><description><para>callable_context </para></description><struct name="eval"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::callable_eval&lt; Expr, Context &gt;</inherit><description><para>callable_context::eval </para></description></struct></struct><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::unary_plus</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::unary_minus</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::unary_star</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::complement</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::address_of</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::logical_not</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::pre_inc</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::pre_dec</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::left_shift</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::right_shift</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::multiply</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::divide</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::modulus</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::add</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::subtract</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::less</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::greater</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::less_equal</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::greater_equal</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::equal</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::not_equal</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::logical_or</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::logical_and</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_and</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_or</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_xor</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::mem_ptr</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::left_shift_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::right_shift_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::multiply_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::divide_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::modulus_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::add_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::subtract_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_and_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_or_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_xor_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::terminal</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type>mpl::if_&lt; is_const&lt; Expr &gt;, typename <classname>proto::result_of::arg</classname>&lt; Expr &gt;::const_reference, typename <classname>proto::result_of::arg</classname>&lt; Expr &gt;::reference &gt;::<classname>type</classname></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name=""><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::post_inc</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::post_dec</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::subscript</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::comma</template-arg><template-arg>2</template-arg></specialization><typedef name="arg0_type"><type><classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 0 &gt;::<classname>type</classname>, Context &gt;::<classname>type</classname></type></typedef><typedef name="arg1_type"><type><classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 1 &gt;::<classname>type</classname>, Context &gt;::<classname>type</classname></type></typedef><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>1</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type()&gt;::<classname>type</classname></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>2</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 1 &gt;::<classname>type</classname>, Context &gt;::<classname>type</classname>)&gt;::<classname>type</classname></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>3</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 1 &gt;::<classname>type</classname>, Context &gt;::<classname>type</classname>, typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 2 &gt;::<classname>type</classname>, Context &gt;::<classname>type</classname>)&gt;::<classname>type</classname></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>4</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 1 &gt;::<classname>type</classname>, Context &gt;::<classname>type</classname>, typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 2 &gt;::<classname>type</classname>, Context &gt;::<classname>type</classname>, typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 3 &gt;::<classname>type</classname>, Context &gt;::<classname>type</classname>)&gt;::<classname>type</classname></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>5</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 1 &gt;::<classname>type</classname>, Context &gt;::<classname>type</classname>, typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 2 &gt;::<classname>type</classname>, Context &gt;::<classname>type</classname>, typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 3 &gt;::<classname>type</classname>, Context &gt;::<classname>type</classname>, typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 4 &gt;::<classname>type</classname>, Context &gt;::<classname>type</classname>)&gt;::<classname>type</classname></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization></namespace></namespace></header><header name="boost/xpressive/proto/debug.hpp"><para>Utilities for debugging proto expression trees </para><namespace name="boost"><namespace name="proto"><namespace name="op"><struct name="display_expr"><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>expr&lt; <classname>tag::terminal</classname>, Args, 1 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>expr&lt; Tag, Args, 1 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>expr&lt; Tag, Args, 2 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>expr&lt; Tag, Args, 3 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>expr&lt; Tag, Args, 2 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>expr&lt; Tag, Args, 1 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>expr&lt; Tag, Args, 0 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></method></method-group><constructor><parameter name="depth"><paramtype>int</paramtype><default>0</default></parameter><parameter name="sout"><paramtype>std::ostream &amp;</paramtype><default>std::cout</default></parameter></constructor></struct></namespace><namespace name="tag"><function name="proto_tag_name"><type>char const *</type><template>
          <template-type-parameter name="Tag"/>
        </template><parameter name=""><paramtype>Tag</paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::unary_plus</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::unary_minus</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::unary_star</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::complement</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::address_of</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::logical_not</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::pre_inc</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::pre_dec</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::post_inc</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::post_dec</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::left_shift</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::right_shift</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::multiply</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::divide</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::modulus</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::add</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::subtract</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::less</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::greater</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::less_equal</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::greater_equal</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::equal</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::not_equal</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::logical_or</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::logical_and</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_and</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_or</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_xor</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::comma</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::mem_ptr</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::left_shift_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::right_shift_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::multiply_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::divide_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::modulus_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::add_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::subtract_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_and_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_or_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_xor_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::subscript</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::function</classname></paramtype></parameter></function></namespace><function name="display_expr"><type>void</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></function><function name="display_expr"><type>void</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="sout"><paramtype>std::ostream &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/xpressive/proto/deep_copy.hpp"><para>Replace all nodes stored by reference by nodes stored by value. </para><namespace name="boost"><namespace name="proto"><namespace name="op"><struct name="deep_copy"><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::deep_copy</classname>&lt; Expr &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct></namespace><namespace name="result_of"><struct name="deep_copy"><template>
      <template-type-parameter name="Expr"/>
    </template></struct></namespace><data-member name="deep_copy"><type><classname>op::deep_copy</classname> const</type></data-member></namespace></namespace></header><header name="boost/xpressive/proto/domain.hpp"><para>Contains definition of domain&lt;&gt; class template, for defining domains with a grammar for controlling operator overloading. </para><namespace name="boost"><namespace name="proto"><struct name="domain"><template>
      <template-type-parameter name="Grammar"/>
    </template><typedef name="grammar"><type>Grammar</type></typedef></struct></namespace></namespace></header><header name="boost/xpressive/proto/eval.hpp"><para>Contains the eval() expression evaluator. </para><namespace name="boost"><namespace name="proto"><namespace name="op"><struct name="eval"><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>Context)</template-arg></specialization><inherit access="public">boost::proto::result_of::eval&lt; remove_reference&lt; Expr &gt;::type, remove_reference&lt; Context &gt;::type &gt;</inherit></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>Context::template <classname>eval</classname>&lt; Expr &gt;::result_type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="Context"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>Context::template <classname>eval</classname>&lt; Expr &gt;::result_type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="Context"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context const &amp;</paramtype></parameter></method></method-group></struct></namespace><namespace name="result_of"><struct name="eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><typedef name="type"><type>Context::template <classname>eval</classname>&lt; Expr &gt;::result_type</type></typedef></struct></namespace><data-member name="eval"><type><classname>op::eval</classname> const</type></data-member></namespace></namespace></header><header name="boost/xpressive/proto/expr.hpp"><para>Contains definition of expr&lt;&gt; class template. </para><namespace name="boost"><namespace name="proto"><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>1</template-arg></specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>1 &gt;::appl</template-arg></specialization><typedef name="type"><type>Expr_</type></typedef></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Sig"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>1 &gt;::resul</template-arg></specialization></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>1 &gt;::result&lt; This()</template-arg></specialization><typedef name="type"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref</classname>&lt; expr const  &gt; &gt; &gt;</type></typedef></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>1 &gt;::result&lt; This(A0)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop1&lt; expr const, remove_reference&lt; A0 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>1 &gt;::result&lt; This(A0</template-arg><template-arg>A1)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop2&lt; expr const, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>1 &gt;::result&lt; This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop3&lt; expr const, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>1 &gt;::result&lt; This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop4&lt; expr const, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type, remove_reference&lt; A3 &gt;::type &gt;</inherit></struct-specialization><typedef name="tag_type"><type>Tag</type></typedef><typedef name="type"><type>expr</type></typedef><typedef name="args_type"><type>Args</type></typedef><typedef name="domain"><type><classname>default_domain</classname></type></typedef><typedef name="arity"><type>mpl::long_&lt; 1 &gt;</type></typedef><typedef name="fusion_tag"><type>proto_expr_tag</type></typedef><typedef name="is_boost_proto_expr_"><type>void</type></typedef><typedef name="boost_proto_expr_type_"><type>expr</type></typedef><typedef name="arg0_type"><type>Args::arg0</type></typedef><typedef name="arg1_type"><type>void</type></typedef><typedef name="arg2_type"><type>void</type></typedef><typedef name="arg3_type"><type>void</type></typedef><typedef name="arg4_type"><type>void</type></typedef><typedef name="address_of_hack_type_"><type><emphasis>unspecified</emphasis></type></typedef><data-member name="arg0"><type>arg0_type</type></data-member><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></method></method-group><method-group name="public member functions"><method name="cast" cv=""><type>expr &amp;</type></method><method name="cast" cv="const"><type>expr const &amp;</type></method><method name="conversion-operator" cv="const"><type>address_of_hack_type_</type></method><method name="operator[]" cv=""><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv=""><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref</classname>&lt; expr const  &gt; &gt; &gt; const</type></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>2</template-arg></specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>2 &gt;::appl</template-arg></specialization><typedef name="type"><type>Expr_</type></typedef></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Sig"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>2 &gt;::resul</template-arg></specialization></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>2 &gt;::result&lt; This()</template-arg></specialization><typedef name="type"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref</classname>&lt; expr const  &gt; &gt; &gt;</type></typedef></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>2 &gt;::result&lt; This(A0)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop1&lt; expr const, remove_reference&lt; A0 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>2 &gt;::result&lt; This(A0</template-arg><template-arg>A1)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop2&lt; expr const, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>2 &gt;::result&lt; This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop3&lt; expr const, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>2 &gt;::result&lt; This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop4&lt; expr const, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type, remove_reference&lt; A3 &gt;::type &gt;</inherit></struct-specialization><typedef name="tag_type"><type>Tag</type></typedef><typedef name="type"><type>expr</type></typedef><typedef name="args_type"><type>Args</type></typedef><typedef name="domain"><type><classname>default_domain</classname></type></typedef><typedef name="arity"><type>mpl::long_&lt; 2 &gt;</type></typedef><typedef name="fusion_tag"><type>proto_expr_tag</type></typedef><typedef name="is_boost_proto_expr_"><type>void</type></typedef><typedef name="boost_proto_expr_type_"><type>expr</type></typedef><typedef name="arg0_type"><type>Args::arg0</type></typedef><typedef name="arg1_type"><type>Args::arg1</type></typedef><typedef name="arg2_type"><type>void</type></typedef><typedef name="arg3_type"><type>void</type></typedef><typedef name="arg4_type"><type>void</type></typedef><data-member name="arg0"><type>arg0_type</type></data-member><data-member name="arg1"><type>arg1_type</type></data-member><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter></method></method-group><method-group name="public member functions"><method name="cast" cv=""><type>expr &amp;</type></method><method name="cast" cv="const"><type>expr const &amp;</type></method><method name="operator[]" cv=""><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv=""><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref</classname>&lt; expr const  &gt; &gt; &gt; const</type></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>3</template-arg></specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>3 &gt;::appl</template-arg></specialization><typedef name="type"><type>Expr_</type></typedef></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Sig"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>3 &gt;::resul</template-arg></specialization></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>3 &gt;::result&lt; This()</template-arg></specialization><typedef name="type"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref</classname>&lt; expr const  &gt; &gt; &gt;</type></typedef></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>3 &gt;::result&lt; This(A0)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop1&lt; expr const, remove_reference&lt; A0 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>3 &gt;::result&lt; This(A0</template-arg><template-arg>A1)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop2&lt; expr const, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>3 &gt;::result&lt; This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop3&lt; expr const, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>3 &gt;::result&lt; This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop4&lt; expr const, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type, remove_reference&lt; A3 &gt;::type &gt;</inherit></struct-specialization><typedef name="tag_type"><type>Tag</type></typedef><typedef name="type"><type>expr</type></typedef><typedef name="args_type"><type>Args</type></typedef><typedef name="domain"><type><classname>default_domain</classname></type></typedef><typedef name="arity"><type>mpl::long_&lt; 3 &gt;</type></typedef><typedef name="fusion_tag"><type>proto_expr_tag</type></typedef><typedef name="is_boost_proto_expr_"><type>void</type></typedef><typedef name="boost_proto_expr_type_"><type>expr</type></typedef><typedef name="arg0_type"><type>Args::arg0</type></typedef><typedef name="arg1_type"><type>Args::arg1</type></typedef><typedef name="arg2_type"><type>Args::arg2</type></typedef><typedef name="arg3_type"><type>void</type></typedef><typedef name="arg4_type"><type>void</type></typedef><data-member name="arg0"><type>arg0_type</type></data-member><data-member name="arg1"><type>arg1_type</type></data-member><data-member name="arg2"><type>arg2_type</type></data-member><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter></method></method-group><method-group name="public member functions"><method name="cast" cv=""><type>expr &amp;</type></method><method name="cast" cv="const"><type>expr const &amp;</type></method><method name="operator[]" cv=""><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv=""><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref</classname>&lt; expr const  &gt; &gt; &gt; const</type></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>4</template-arg></specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>4 &gt;::appl</template-arg></specialization><typedef name="type"><type>Expr_</type></typedef></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Sig"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>4 &gt;::resul</template-arg></specialization></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>4 &gt;::result&lt; This()</template-arg></specialization><typedef name="type"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref</classname>&lt; expr const  &gt; &gt; &gt;</type></typedef></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>4 &gt;::result&lt; This(A0)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop1&lt; expr const, remove_reference&lt; A0 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>4 &gt;::result&lt; This(A0</template-arg><template-arg>A1)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop2&lt; expr const, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>4 &gt;::result&lt; This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop3&lt; expr const, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>4 &gt;::result&lt; This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop4&lt; expr const, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type, remove_reference&lt; A3 &gt;::type &gt;</inherit></struct-specialization><typedef name="tag_type"><type>Tag</type></typedef><typedef name="type"><type>expr</type></typedef><typedef name="args_type"><type>Args</type></typedef><typedef name="domain"><type><classname>default_domain</classname></type></typedef><typedef name="arity"><type>mpl::long_&lt; 4 &gt;</type></typedef><typedef name="fusion_tag"><type>proto_expr_tag</type></typedef><typedef name="is_boost_proto_expr_"><type>void</type></typedef><typedef name="boost_proto_expr_type_"><type>expr</type></typedef><typedef name="arg0_type"><type>Args::arg0</type></typedef><typedef name="arg1_type"><type>Args::arg1</type></typedef><typedef name="arg2_type"><type>Args::arg2</type></typedef><typedef name="arg3_type"><type>Args::arg3</type></typedef><typedef name="arg4_type"><type>void</type></typedef><data-member name="arg0"><type>arg0_type</type></data-member><data-member name="arg1"><type>arg1_type</type></data-member><data-member name="arg2"><type>arg2_type</type></data-member><data-member name="arg3"><type>arg3_type</type></data-member><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter></method></method-group><method-group name="public member functions"><method name="cast" cv=""><type>expr &amp;</type></method><method name="cast" cv="const"><type>expr const &amp;</type></method><method name="operator[]" cv=""><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv=""><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref</classname>&lt; expr const  &gt; &gt; &gt; const</type></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>5</template-arg></specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>5 &gt;::appl</template-arg></specialization><typedef name="type"><type>Expr_</type></typedef></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Sig"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>5 &gt;::resul</template-arg></specialization></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>5 &gt;::result&lt; This()</template-arg></specialization><typedef name="type"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref</classname>&lt; expr const  &gt; &gt; &gt;</type></typedef></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>5 &gt;::result&lt; This(A0)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop1&lt; expr const, remove_reference&lt; A0 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>5 &gt;::result&lt; This(A0</template-arg><template-arg>A1)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop2&lt; expr const, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>5 &gt;::result&lt; This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop3&lt; expr const, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>5 &gt;::result&lt; This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg></specialization><inherit access="public">boost::proto::result_of::funop4&lt; expr const, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type, remove_reference&lt; A3 &gt;::type &gt;</inherit></struct-specialization><typedef name="tag_type"><type>Tag</type></typedef><typedef name="type"><type>expr</type></typedef><typedef name="args_type"><type>Args</type></typedef><typedef name="domain"><type><classname>default_domain</classname></type></typedef><typedef name="arity"><type>mpl::long_&lt; 5 &gt;</type></typedef><typedef name="fusion_tag"><type>proto_expr_tag</type></typedef><typedef name="is_boost_proto_expr_"><type>void</type></typedef><typedef name="boost_proto_expr_type_"><type>expr</type></typedef><typedef name="arg0_type"><type>Args::arg0</type></typedef><typedef name="arg1_type"><type>Args::arg1</type></typedef><typedef name="arg2_type"><type>Args::arg2</type></typedef><typedef name="arg3_type"><type>Args::arg3</type></typedef><typedef name="arg4_type"><type>Args::arg4</type></typedef><data-member name="arg0"><type>arg0_type</type></data-member><data-member name="arg1"><type>arg1_type</type></data-member><data-member name="arg2"><type>arg2_type</type></data-member><data-member name="arg3"><type>arg3_type</type></data-member><data-member name="arg4"><type>arg4_type</type></data-member><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
          <template-type-parameter name="A4"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><parameter name="a4"><paramtype>A4 const &amp;</paramtype></parameter></method></method-group><method-group name="public member functions"><method name="cast" cv=""><type>expr &amp;</type></method><method name="cast" cv="const"><type>expr const &amp;</type></method><method name="operator[]" cv=""><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv=""><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref</classname>&lt; expr const  &gt; &gt; &gt; const</type></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment></struct-specialization><namespace name="result_of"><struct name="funop1"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
    </template><typedef name="type"><type>expr&lt; <classname>tag::function</classname>, <classname>args2</classname>&lt; <classname>ref</classname>&lt; Expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A0 &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter></method></method-group></struct><struct name="funop2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><typedef name="type"><type>expr&lt; <classname>tag::function</classname>, <classname>args3</classname>&lt; <classname>ref</classname>&lt; Expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A0 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A1 &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter></method></method-group></struct><struct name="funop3"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><typedef name="type"><type>expr&lt; <classname>tag::function</classname>, <classname>args4</classname>&lt; <classname>ref</classname>&lt; Expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A0 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A1 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A2 &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 &amp;</paramtype></parameter></method></method-group></struct><struct name="funop4"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><typedef name="type"><type>expr&lt; <classname>tag::function</classname>, <classname>args5</classname>&lt; <classname>ref</classname>&lt; Expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A0 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A1 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A2 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A3 &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/extends.hpp"><para>Macros and a base class for defining end-user expression types </para><namespace name="boost"><namespace name="proto"><struct name="is_proto_expr"><purpose>Empty type to be used as a dummy template parameter of POD expression wrappers. It allows argument-dependent lookup to find proto's operator overloads. </purpose><description><para>For example:</para><para>template&lt; typename T, typename Dummy = proto::is_proto_expr &gt; struct my_terminal { BOOST_PROTO_EXTENDS( typename proto::terminal&lt;T&gt;type , my_terminal&lt;T&gt; , default_domain ) };</para><para>my_terminal&lt;int&gt; _1, _2; _1 + _2; // OK, uses proto::operator+</para><para>Without the second Dummy template parameter, Proto's operator overloads would not be considered by name lookup. </para></description></struct><struct name="extends"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Derived"/>
      <template-type-parameter name="Domain"/>
    </template><purpose>extends&lt;&gt; class template for adding behaviors to a proto expression template </purpose><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>This()</template-arg></specialization><typedef name="type"><type><classname>boost::proto::generate</classname>&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::function</classname>, <classname>boost::proto::args1</classname>&lt; <classname>boost::proto::ref</classname>&lt; Derived const &gt; &gt; &gt; &gt;::type</type></typedef></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>This(A0)</template-arg></specialization><inherit access="public">boost::proto::generate&lt; Domain, Expr &gt;</inherit></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>This(A0</template-arg><template-arg>A1)</template-arg></specialization><inherit access="public">boost::proto::generate&lt; Domain, Expr &gt;</inherit></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg></specialization><inherit access="public">boost::proto::generate&lt; Domain, Expr &gt;</inherit></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg></specialization><inherit access="public">boost::proto::generate&lt; Domain, Expr &gt;</inherit></struct-specialization><data-member name="expr"><type>Expr</type></data-member><typedef name="type"><type>Expr</type></typedef><typedef name="domain"><type>Domain</type></typedef><typedef name="boost_proto_expr_type_"><type>Derived</type></typedef><typedef name="tag_type"><type>Expr::tag_type</type></typedef><typedef name="args_type"><type>Expr::args_type</type></typedef><typedef name="arity"><type>Expr::arity</type></typedef><typedef name="is_boost_proto_expr_"><type>void</type></typedef><typedef name="fusion_tag"><type>boost::proto::proto_expr_tag</type></typedef><typedef name="arg0_type"><type>Expr::arg0_type</type></typedef><typedef name="arg1_type"><type>Expr::arg1_type</type></typedef><typedef name="arg2_type"><type>Expr::arg2_type</type></typedef><typedef name="arg3_type"><type>Expr::arg3_type</type></typedef><typedef name="arg4_type"><type>Expr::arg4_type</type></typedef><method-group name="public member functions"><method name="cast" cv=""><type>Expr &amp;</type></method><method name="cast" cv="const"><type>Expr const &amp;</type></method><method name="operator[]" cv=""><type><classname>boost::proto::generate</classname>&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; <classname>boost::proto::ref</classname>&lt; Derived &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv=""><type><classname>boost::proto::generate</classname>&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; <classname>boost::proto::ref</classname>&lt; Derived &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator[]" cv="const"><type><classname>boost::proto::generate</classname>&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; <classname>boost::proto::ref</classname>&lt; Derived const &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv="const"><type><classname>boost::proto::generate</classname>&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; <classname>boost::proto::ref</classname>&lt; Derived const &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>boost::proto::generate</classname>&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::function</classname>, <classname>boost::proto::args1</classname>&lt; <classname>boost::proto::ref</classname>&lt; Derived const &gt; &gt; &gt; &gt;::type const</type></method><method name="operator()" cv="const"><type><classname>boost::proto::generate</classname>&lt; Domain, typename <classname>boost::proto::result_of::funop1</classname>&lt; Derived const , const A0 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>boost::proto::generate</classname>&lt; Domain, typename <classname>boost::proto::result_of::funop2</classname>&lt; Derived const , const A0, const A1 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>boost::proto::generate</classname>&lt; Domain, typename <classname>boost::proto::result_of::funop3</classname>&lt; Derived const , const A0, const A1, const A2 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>boost::proto::generate</classname>&lt; Domain, typename <classname>boost::proto::result_of::funop4</classname>&lt; Derived const , const A0, const A1, const A2, const A3 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter></method></method-group><constructor/><constructor><parameter name="that"><paramtype><classname>extends</classname> const &amp;</paramtype></parameter></constructor><constructor><parameter name="expr_"><paramtype>Expr const &amp;</paramtype></parameter></constructor><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static Derived const</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></header><header name="boost/xpressive/proto/fusion.hpp"><para>Make any Proto parse tree a valid Fusion sequence </para><namespace name="boost"><namespace name="fusion"><namespace name="extension"><struct name="as_element"><template>
      <template-type-parameter name="Tag"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Expr"/>
    </template></struct><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result</classname>&lt; Expr &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="is_view_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_tag</template-arg></specialization><struct-specialization name="is_view_impl"><template>
      <template-type-parameter name="Iterator"/>
    </template><specialization><template-arg>proto::proto_ref_tag &gt;::appl</template-arg></specialization></struct-specialization></struct-specialization><struct-specialization name="is_view_impl"><template>
    </template><specialization><template-arg>proto::proto_expr_tag</template-arg></specialization><struct-specialization name="is_view_impl"><template>
      <template-type-parameter name="Iterator"/>
    </template><specialization><template-arg>proto::proto_expr_tag &gt;::appl</template-arg></specialization></struct-specialization></struct-specialization><struct-specialization name="value_of_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_iterator_tag</template-arg></specialization><struct-specialization name="value_of_impl"><template>
      <template-type-parameter name="Iterator"/>
    </template><specialization><template-arg>proto::proto_ref_iterator_tag &gt;::appl</template-arg></specialization><inherit access="public">boost::proto::result_of::arg&lt; Iterator::expr_type, Iterator::index &gt;</inherit></struct-specialization></struct-specialization><struct-specialization name="deref_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_iterator_tag</template-arg></specialization><struct-specialization name="deref_impl"><template>
      <template-type-parameter name="Iterator"/>
    </template><specialization><template-arg>proto::proto_ref_iterator_tag &gt;::appl</template-arg></specialization><typedef name="type"><type><classname>proto::result_of::arg</classname>&lt; typename Iterator::expr_type, typename Iterator::index &gt;::type const &amp;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type</type><parameter name="iter"><paramtype>Iterator const &amp;</paramtype></parameter></method></method-group></struct-specialization></struct-specialization><struct-specialization name="advance_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_iterator_tag</template-arg></specialization><struct-specialization name="advance_impl"><template>
      <template-type-parameter name="Iterator"/>
      <template-type-parameter name="N"/>
    </template><specialization><template-arg>proto::proto_ref_iterator_tag &gt;::appl</template-arg></specialization><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>type</classname></type><parameter name="iter"><paramtype>Iterator const &amp;</paramtype></parameter></method></method-group></struct-specialization></struct-specialization><struct-specialization name="distance_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_iterator_tag</template-arg></specialization><struct-specialization name="distance_impl"><template>
      <template-type-parameter name="IteratorFrom"/>
      <template-type-parameter name="IteratorTo"/>
    </template><specialization><template-arg>proto::proto_ref_iterator_tag &gt;::appl</template-arg></specialization><typedef name="type"><type>mpl::long_&lt; IteratorTo::index::value-IteratorFrom::index::value &gt;</type></typedef></struct-specialization></struct-specialization><struct-specialization name="next_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_iterator_tag</template-arg></specialization><struct-specialization name="next_impl"><template>
      <template-type-parameter name="Iterator"/>
    </template><specialization><template-arg>proto::proto_ref_iterator_tag &gt;::appl</template-arg></specialization></struct-specialization></struct-specialization><struct-specialization name="prior_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_iterator_tag</template-arg></specialization><struct-specialization name="prior_impl"><template>
      <template-type-parameter name="Iterator"/>
    </template><specialization><template-arg>proto::proto_ref_iterator_tag &gt;::appl</template-arg></specialization></struct-specialization></struct-specialization><struct-specialization name="category_of_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_tag</template-arg></specialization><struct-specialization name="category_of_impl"><template>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>proto::proto_ref_tag &gt;::appl</template-arg></specialization><typedef name="type"><type>random_access_traversal_tag</type></typedef></struct-specialization></struct-specialization><struct-specialization name="size_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_tag</template-arg></specialization><struct-specialization name="size_impl"><template>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>proto::proto_ref_tag &gt;::appl</template-arg></specialization></struct-specialization></struct-specialization><struct-specialization name="begin_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_tag</template-arg></specialization><struct-specialization name="begin_impl"><template>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>proto::proto_ref_tag &gt;::appl</template-arg></specialization><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>type</classname></type><parameter name="seq"><paramtype>Sequence &amp;</paramtype></parameter></method></method-group></struct-specialization></struct-specialization><struct-specialization name="end_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_tag</template-arg></specialization><struct-specialization name="end_impl"><template>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>proto::proto_ref_tag &gt;::appl</template-arg></specialization><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>type</classname></type><parameter name="seq"><paramtype>Sequence &amp;</paramtype></parameter></method></method-group></struct-specialization></struct-specialization><struct-specialization name="value_at_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_tag</template-arg></specialization><struct-specialization name="value_at_impl"><template>
      <template-type-parameter name="Sequence"/>
      <template-type-parameter name="N"/>
    </template><specialization><template-arg>proto::proto_ref_tag &gt;::appl</template-arg></specialization><typedef name="type"><type><classname>proto::result_of::arg</classname>&lt; Sequence, N &gt;::type</type></typedef></struct-specialization></struct-specialization><struct-specialization name="at_impl"><template>
    </template><specialization><template-arg>proto::proto_ref_tag</template-arg></specialization><struct-specialization name="at_impl"><template>
      <template-type-parameter name="Sequence"/>
      <template-type-parameter name="N"/>
    </template><specialization><template-arg>proto::proto_ref_tag &gt;::appl</template-arg></specialization><typedef name="type"><type><classname>proto::result_of::arg</classname>&lt; Sequence, N &gt;::type const &amp;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type</type><parameter name="seq"><paramtype>Sequence &amp;</paramtype></parameter></method></method-group></struct-specialization></struct-specialization><struct-specialization name="is_segmented_impl"><template>
    </template><specialization><template-arg>proto::proto_expr_tag</template-arg></specialization><struct-specialization name="is_segmented_impl"><template>
      <template-type-parameter name="Iterator"/>
    </template><specialization><template-arg>proto::proto_expr_tag &gt;::appl</template-arg></specialization></struct-specialization></struct-specialization><struct-specialization name="segments_impl"><template>
    </template><specialization><template-arg>proto::proto_expr_tag</template-arg></specialization><struct-specialization name="segments_impl"><template>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>proto::proto_expr_tag &gt;::appl</template-arg></specialization><typedef name="tag_type"><type>Sequence::tag_type</type></typedef><typedef name="type"><type>fusion::transform_view&lt; <classname>proto::ref</classname>&lt; Sequence &gt;, <classname>as_element</classname>&lt; tag_type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type</type><parameter name="sequence"><paramtype>Sequence &amp;</paramtype></parameter></method></method-group></struct-specialization></struct-specialization><struct-specialization name="category_of_impl"><template>
    </template><specialization><template-arg>proto::proto_expr_tag</template-arg></specialization><struct-specialization name="category_of_impl"><template>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>proto::proto_expr_tag &gt;::appl</template-arg></specialization><typedef name="type"><type>forward_traversal_tag</type></typedef></struct-specialization></struct-specialization><struct-specialization name="begin_impl"><template>
    </template><specialization><template-arg>proto::proto_expr_tag</template-arg></specialization><struct-specialization name="begin_impl"><template>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>proto::proto_expr_tag &gt;::appl</template-arg></specialization></struct-specialization></struct-specialization><struct-specialization name="end_impl"><template>
    </template><specialization><template-arg>proto::proto_expr_tag</template-arg></specialization><struct-specialization name="end_impl"><template>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>proto::proto_expr_tag &gt;::appl</template-arg></specialization></struct-specialization></struct-specialization><struct-specialization name="size_impl"><template>
    </template><specialization><template-arg>proto::proto_expr_tag</template-arg></specialization><struct-specialization name="size_impl"><template>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>proto::proto_expr_tag &gt;::appl</template-arg></specialization></struct-specialization></struct-specialization></namespace></namespace><namespace name="proto"><struct name="children"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::ref&lt; Expr &gt;</inherit><method-group name="public member functions"/><constructor><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></constructor></struct><struct name="eval_fun"><template>
      <template-type-parameter name="Context"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>Context::template eval&lt; typename remove_reference&lt; Expr &gt;::type &gt;::result_type</type></typedef></struct><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result</classname>&lt; Expr &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method></method-group><constructor><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></constructor></struct><function name="children_of"><type><classname>children</classname>&lt; Expr &gt;</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/xpressive/proto/generate.hpp"><para>Contains definition of generate&lt;&gt; class template, which end users can specialize for generating domain-specific expression wrappers. </para><namespace name="boost"><namespace name="proto"><struct name="generate"><template>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>Expr</type></typedef><method-group name="public static functions"><method name="make" cv=""><type>static Expr const &amp;</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="is_allowed"><template>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="EnableIf"/>
    </template><inherit access="public">boost::proto::matches&lt; Expr, Domain::grammar &gt;</inherit></struct></namespace></namespace></header><header name="boost/xpressive/proto/literal.hpp"><para>The literal&lt;&gt; terminal wrapper, and the proto::lit() function for creating literal&lt;&gt; wrappers. </para><namespace name="boost"><namespace name="proto"><struct name="literal"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"/>
    </template><inherit access="public">boost::proto::extends&lt; terminal&lt; T &gt;::type, literal&lt; T, Domain &gt;, Domain &gt;</inherit><typedef name="terminal_type"><type><classname>terminal</classname>&lt; T &gt;::type</type></typedef><typedef name="base_type"><type><classname>extends</classname>&lt; terminal_type, <classname>literal</classname>&lt; T, Domain &gt;, Domain &gt;</type></typedef><method-group name="public member functions"/><constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype>U &amp;</paramtype></parameter></constructor><constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype>U const &amp;</paramtype></parameter></constructor><constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype><classname>literal</classname>&lt; U, Domain &gt; const &amp;</paramtype></parameter></constructor></struct><overloaded-function name="lit"><signature><type><classname>literal</classname>&lt; T &amp; &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></signature><signature><type><classname>literal</classname>&lt; T const &amp; &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></signature><description><para>lit </para></description></overloaded-function></namespace></namespace></header><header name="boost/xpressive/proto/make_expr.hpp"><para>Given a Fusion sequence of arguments and the type of a proto Expression, unpacks the sequence into the Expression. </para><namespace name="boost"><namespace name="proto"><namespace name="result_of"><struct-specialization name="make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg></specialization></struct-specialization><struct-specialization name="make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg></specialization></struct-specialization><struct-specialization name="make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg></specialization></struct-specialization><struct-specialization name="make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg></specialization></struct-specialization><struct-specialization name="make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4</template-arg></specialization></struct-specialization><struct name="unpack_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Sequence"/>
    </template></struct></namespace><function name="make_expr"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></function><function name="make_expr"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter></function><function name="make_expr"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter></function><function name="make_expr"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter></function><function name="make_expr"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
          <template-type-parameter name="A4"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><parameter name="a4"><paramtype>A4 const &amp;</paramtype></parameter></function><function name="unpack_expr"><type><classname>result_of::unpack_expr</classname>&lt; Tag, Sequence const &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="sequence"><paramtype>Sequence const &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/xpressive/proto/matches.hpp"><para>Contains definition of matches&lt;&gt; metafunction for determining if a given expression matches a given pattern. </para><namespace name="boost"><namespace name="proto"><struct name="matches"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Grammar"/>
    </template></struct><struct name="or_"><template>
      <template-type-parameter name="G0"/>
      <template-type-parameter name="G1"/>
      <template-type-parameter name="G2"/>
      <template-type-parameter name="G3"/>
      <template-type-parameter name="G4"/>
      <template-type-parameter name="G5"/>
      <template-type-parameter name="G6"/>
      <template-type-parameter name="G7"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><typedef name="which"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="type"><type>which::template <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type></typedef></struct><typedef name="type"><type><classname>or_</classname></type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="and_"><template>
      <template-type-parameter name="G0"/>
      <template-type-parameter name="G1"/>
      <template-type-parameter name="G2"/>
      <template-type-parameter name="G3"/>
      <template-type-parameter name="G4"/>
      <template-type-parameter name="G5"/>
      <template-type-parameter name="G6"/>
      <template-type-parameter name="G7"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><typedef name="which"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="type"><type>which::template <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type></typedef></struct><typedef name="type"><type><classname>and_</classname></type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="switch_"><template>
      <template-type-parameter name="Cases"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><typedef name="type"><type><classname>switch_</classname></type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="_"><inherit access="public">boost::proto::has_identity_transform</inherit><typedef name="type"><type><classname>_</classname></type></typedef></struct><struct name="if_"><template>
      <template-type-parameter name="Pred"/>
    </template><inherit access="public">boost::proto::has_identity_transform</inherit><typedef name="type"><type><classname>if_</classname></type></typedef></struct><struct name="not_"><template>
      <template-type-parameter name="Pred"/>
    </template><inherit access="public">boost::proto::has_identity_transform</inherit><typedef name="type"><type><classname>not_</classname></type></typedef></struct><struct name="vararg"><template>
      <template-type-parameter name="Grammar"/>
    </template><typedef name="boost_proto_is_vararg_"><type>void</type></typedef></struct><struct name="if_matches"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Return"/>
    </template></struct><struct name="if_not_matches"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Return"/>
    </template></struct><struct name="exact"><template>
      <template-type-parameter name="T"/>
    </template></struct></namespace></namespace></header><header name="boost/xpressive/proto/operators.hpp"><para>Contains all the overloaded operators that make it possible to build expression templates using proto components </para><namespace name="boost"><namespace name="proto"><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator~"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator~"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator!"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator!"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function></namespace></namespace></header><header name="boost/xpressive/proto/proto.hpp"><para>The proto expression template compiler and supporting utilities. </para></header><header name="boost/xpressive/proto/proto_fwd.hpp"><para>Forward declarations of all of proto's public types and functions. </para><namespace name="boost"><namespace name="proto"><struct name="has_identity_transform"><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method></method-group></struct><namespace name="op"/><namespace name="result_of"/><namespace name="tag"/><namespace name="transform"/><data-member name="N"><type>int const</type></data-member><typedef name="unary_type"><type><classname>tag::unary</classname></type></typedef><typedef name="binary_tag"><type><classname>tag::binary</classname></type></typedef><typedef name="nary_tag"><type><classname>tag::nary</classname></type></typedef><typedef name="terminal_tag"><type><classname>tag::terminal</classname></type></typedef><typedef name="unary_plus_tag"><type><classname>tag::unary_plus</classname></type></typedef><typedef name="unary_minus_tag"><type><classname>tag::unary_minus</classname></type></typedef><typedef name="unary_star_tag"><type><classname>tag::unary_star</classname></type></typedef><typedef name="complement_tag"><type><classname>tag::complement</classname></type></typedef><typedef name="address_of_tag"><type><classname>tag::address_of</classname></type></typedef><typedef name="logical_not_tag"><type><classname>tag::logical_not</classname></type></typedef><typedef name="pre_inc_tag"><type><classname>tag::pre_inc</classname></type></typedef><typedef name="pre_dec_tag"><type><classname>tag::pre_dec</classname></type></typedef><typedef name="post_inc_tag"><type><classname>tag::post_inc</classname></type></typedef><typedef name="post_dec_tag"><type><classname>tag::post_dec</classname></type></typedef><typedef name="left_shift_tag"><type><classname>tag::left_shift</classname></type></typedef><typedef name="right_shift_tag"><type><classname>tag::right_shift</classname></type></typedef><typedef name="multiply_tag"><type><classname>tag::multiply</classname></type></typedef><typedef name="divide_tag"><type><classname>tag::divide</classname></type></typedef><typedef name="modulus_tag"><type><classname>tag::modulus</classname></type></typedef><typedef name="add_tag"><type><classname>tag::add</classname></type></typedef><typedef name="subtract_tag"><type><classname>tag::subtract</classname></type></typedef><typedef name="less_tag"><type><classname>tag::less</classname></type></typedef><typedef name="greater_tag"><type><classname>tag::greater</classname></type></typedef><typedef name="less_equal_tag"><type><classname>tag::less_equal</classname></type></typedef><typedef name="greater_equal_tag"><type><classname>tag::greater_equal</classname></type></typedef><typedef name="equal_tag"><type><classname>tag::equal</classname></type></typedef><typedef name="not_equal_tag"><type><classname>tag::not_equal</classname></type></typedef><typedef name="logical_or_tag"><type><classname>tag::logical_or</classname></type></typedef><typedef name="logical_and_tag"><type><classname>tag::logical_and</classname></type></typedef><typedef name="bitwise_and_tag"><type><classname>tag::bitwise_and</classname></type></typedef><typedef name="bitwise_or_tag"><type><classname>tag::bitwise_or</classname></type></typedef><typedef name="bitwise_xor_tag"><type><classname>tag::bitwise_xor</classname></type></typedef><typedef name="comma_tag"><type><classname>tag::comma</classname></type></typedef><typedef name="mem_ptr_tag"><type><classname>tag::mem_ptr</classname></type></typedef><typedef name="assign_tag"><type><classname>tag::assign</classname></type></typedef><typedef name="left_shift_assign_tag"><type><classname>tag::left_shift_assign</classname></type></typedef><typedef name="right_shift_assign_tag"><type><classname>tag::right_shift_assign</classname></type></typedef><typedef name="multiply_assign_tag"><type><classname>tag::multiply_assign</classname></type></typedef><typedef name="divide_assign_tag"><type><classname>tag::divide_assign</classname></type></typedef><typedef name="modulus_assign_tag"><type><classname>tag::modulus_assign</classname></type></typedef><typedef name="add_assign_tag"><type><classname>tag::add_assign</classname></type></typedef><typedef name="subtract_assign_tag"><type><classname>tag::subtract_assign</classname></type></typedef><typedef name="bitwise_and_assign_tag"><type><classname>tag::bitwise_and_assign</classname></type></typedef><typedef name="bitwise_or_assign_tag"><type><classname>tag::bitwise_or_assign</classname></type></typedef><typedef name="bitwise_xor_assign_tag"><type><classname>tag::bitwise_xor_assign</classname></type></typedef><typedef name="subscript_tag"><type><classname>tag::subscript</classname></type></typedef><typedef name="function_tag"><type><classname>tag::function</classname></type></typedef><typedef name="bitor_tag"><type><classname>bitwise_or_tag</classname></type></typedef><typedef name="bitand_tag"><type><classname>bitwise_and_tag</classname></type></typedef><typedef name="bitxor_tag"><type><classname>bitwise_xor_tag</classname></type></typedef><typedef name="bitor_assign_tag"><type><classname>bitwise_or_assign_tag</classname></type></typedef><typedef name="bitand_assign_tag"><type><classname>bitwise_and_assign_tag</classname></type></typedef><typedef name="bitxor_assign_tag"><type><classname>bitwise_xor_assign_tag</classname></type></typedef><typedef name="default_domain"><type><classname>domain</classname>&lt;  &gt;</type></typedef></namespace></namespace></header><header name="boost/xpressive/proto/ref.hpp"><para>Utility for storing a sub-expr by reference </para><namespace name="boost"><namespace name="proto"><struct name="ref"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>Expr::type</type></typedef><typedef name="tag_type"><type>Expr::tag_type</type></typedef><typedef name="args_type"><type>Expr::args_type</type></typedef><typedef name="arity"><type>Expr::arity</type></typedef><typedef name="domain"><type>Expr::domain</type></typedef><typedef name="fusion_tag"><type>proto_ref_tag</type></typedef><typedef name="is_boost_proto_ref_"><type>void</type></typedef><typedef name="is_boost_proto_expr_"><type>void</type></typedef><typedef name="boost_proto_expr_type_"><type>Expr</type></typedef><typedef name="arg0_type"><type>Expr::arg0_type</type></typedef><typedef name="arg1_type"><type>Expr::arg1_type</type></typedef><typedef name="arg2_type"><type>Expr::arg2_type</type></typedef><typedef name="arg3_type"><type>Expr::arg3_type</type></typedef><typedef name="arg4_type"><type>Expr::arg4_type</type></typedef><data-member name="expr"><type>Expr &amp;</type></data-member><method-group name="public member functions"><method name="cast" cv="const"><type>mpl::if_&lt; is_const&lt; Expr &gt;, type const &amp;, type &amp; &gt;::type</type></method></method-group><method-group name="public static functions"><method name="make" cv=""><type>static <classname>ref</classname>&lt; Expr &gt;</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="ref"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>ref&lt; Expr &gt;</template-arg></specialization></struct-specialization><namespace name="op"><struct name="unref"><struct name="result"><template>
      <template-type-parameter name="T"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>T &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>T const &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>T &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype><classname>ref</classname>&lt; T &gt; &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>T &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype><classname>ref</classname>&lt; T &gt; const &amp;</paramtype></parameter></method></method-group></struct></namespace><namespace name="result_of"><struct name="unref"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="type"><type>T</type></typedef><typedef name="reference"><type>T &amp;</type></typedef><typedef name="const_reference"><type>T const &amp;</type></typedef></struct><struct-specialization name="unref"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>ref&lt; T &gt;</template-arg></specialization><typedef name="type"><type>T::boost_proto_expr_type_</type></typedef><typedef name="reference"><type>T &amp;</type></typedef><typedef name="const_reference"><type>T &amp;</type></typedef></struct-specialization><struct-specialization name="unref"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T &amp;</template-arg></specialization><typedef name="type"><type>T</type></typedef><typedef name="reference"><type>T &amp;</type></typedef><typedef name="const_reference"><type>T &amp;</type></typedef></struct-specialization><struct-specialization name="unref"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T const &amp;</template-arg></specialization><typedef name="type"><type>T</type></typedef><typedef name="reference"><type>T const &amp;</type></typedef><typedef name="const_reference"><type>T const &amp;</type></typedef></struct-specialization></namespace><data-member name="unref"><type><classname>op::unref</classname> const</type></data-member></namespace></namespace></header><header name="boost/xpressive/proto/tags.hpp"><para>Contains the tags for all the overloadable operators in C++, as well as the base tags unary, binary and nary, as well as the is_unary&lt;&gt;, is_binary&lt;&gt; and is_nary&lt;&gt; predicates. </para><namespace name="boost"><namespace name="proto"><namespace name="tag"><struct name="unary"/><struct name="binary"/><struct name="nary"/><struct name="terminal"><inherit access="public">boost::proto::tag::unary</inherit></struct><struct name="unary_plus"><inherit access="public">boost::proto::tag::unary</inherit></struct><struct name="unary_minus"><inherit access="public">boost::proto::tag::unary</inherit></struct><struct name="unary_star"><inherit access="public">boost::proto::tag::unary</inherit></struct><struct name="complement"><inherit access="public">boost::proto::tag::unary</inherit></struct><struct name="address_of"><inherit access="public">boost::proto::tag::unary</inherit></struct><struct name="logical_not"><inherit access="public">boost::proto::tag::unary</inherit></struct><struct name="pre_inc"><inherit access="public">boost::proto::tag::unary</inherit></struct><struct name="pre_dec"><inherit access="public">boost::proto::tag::unary</inherit></struct><struct name="post_inc"><inherit access="public">boost::proto::tag::unary</inherit></struct><struct name="post_dec"><inherit access="public">boost::proto::tag::unary</inherit></struct><struct name="left_shift"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="right_shift"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="multiply"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="divide"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="modulus"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="add"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="subtract"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="less"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="greater"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="less_equal"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="greater_equal"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="equal"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="not_equal"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="logical_or"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="logical_and"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="bitwise_and"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="bitwise_or"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="bitwise_xor"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="comma"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="mem_ptr"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="assign"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="left_shift_assign"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="right_shift_assign"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="multiply_assign"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="divide_assign"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="modulus_assign"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="add_assign"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="subtract_assign"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="bitwise_and_assign"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="bitwise_or_assign"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="bitwise_xor_assign"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="subscript"><inherit access="public">boost::proto::tag::binary</inherit></struct><struct name="function"><inherit access="public">boost::proto::tag::nary</inherit></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/traits.hpp"><para>Contains definitions for arg&lt;&gt;, arg_c&lt;&gt;, left&lt;&gt;, right&lt;&gt;, tag&lt;&gt;, and the helper functions arg(), arg_c(), left() and right(). </para><namespace name="boost"><namespace name="proto"><struct name="is_ref"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="EnableIf"/>
    </template></struct><struct name="is_expr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="EnableIf"/>
    </template></struct><struct name="terminal"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_identity_transform</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::terminal</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::terminal</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="unary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; unary_expr&lt; Tag, T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type>Tag</type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="binary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; binary_expr&lt; Tag, T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type>Tag</type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="unary_plus"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; unary_plus&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::unary_plus</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::unary_plus</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="unary_minus"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; unary_minus&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::unary_minus</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::unary_minus</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="unary_star"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; unary_star&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::unary_star</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::unary_star</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="complement"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; complement&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::complement</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::complement</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="address_of"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; address_of&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::address_of</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::address_of</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="logical_not"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; logical_not&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::logical_not</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::logical_not</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="pre_inc"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; pre_inc&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::pre_inc</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::pre_inc</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="pre_dec"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; pre_dec&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::pre_dec</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::pre_dec</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="post_inc"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; post_inc&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::post_inc</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::post_inc</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="post_dec"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; post_dec&lt; T &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::post_dec</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::post_dec</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="left_shift"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; left_shift&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::left_shift</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::left_shift</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="right_shift"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; right_shift&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::right_shift</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::right_shift</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="multiply"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; multiply&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::multiply</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::multiply</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="divide"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; divide&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::divide</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::divide</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="modulus"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; modulus&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::modulus</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::modulus</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="add"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; add&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::add</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::add</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="subtract"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; subtract&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::subtract</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::subtract</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="less"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; less&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::less</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::less</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="greater"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; greater&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::greater</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::greater</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="less_equal"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; less_equal&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::less_equal</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::less_equal</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="greater_equal"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; greater_equal&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::greater_equal</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::greater_equal</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="equal"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; equal&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::equal</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::equal</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="not_equal"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; not_equal&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::not_equal</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::not_equal</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="logical_or"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; logical_or&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::logical_or</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::logical_or</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="logical_and"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; logical_and&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::logical_and</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::logical_and</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="bitwise_and"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; bitwise_and&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::bitwise_and</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::bitwise_and</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="bitwise_or"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; bitwise_or&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::bitwise_or</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::bitwise_or</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="bitwise_xor"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; bitwise_xor&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::bitwise_xor</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::bitwise_xor</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="comma"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; comma&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::comma</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::comma</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="mem_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; mem_ptr&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::mem_ptr</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::mem_ptr</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="left_shift_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; left_shift_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::left_shift_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::left_shift_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="right_shift_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; right_shift_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::right_shift_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::right_shift_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="multiply_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; multiply_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::multiply_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::multiply_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="divide_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; divide_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::divide_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::divide_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="modulus_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; modulus_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::modulus_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::modulus_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="add_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; add_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::add_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::add_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="subtract_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; subtract_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::subtract_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::subtract_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="bitwise_and_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; bitwise_and_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::bitwise_and_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::bitwise_and_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="bitwise_or_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; bitwise_or_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::bitwise_or_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::bitwise_or_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="bitwise_xor_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; bitwise_xor_assign&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::bitwise_xor_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::bitwise_xor_assign</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="subscript"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_pass_through_transform&lt; subscript&lt; T, U &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::subscript</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::subscript</classname></type></typedef><typedef name="arg0_type"><type>T</type></typedef><typedef name="arg1_type"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="tag_of"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>Expr::tag_type</type></typedef></struct><struct name="id"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::result_of::deep_copy&lt; Expr &gt;</inherit></struct><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; function&lt; A0, void, void, void, void, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::function</classname>, <classname>args1</classname>&lt; A0 &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::function</classname></type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg2_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg3_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg4_type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; nary_expr&lt; Tag, A0, void, void, void, void, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args1</classname>&lt; A0 &gt; &gt;</type></typedef><typedef name="tag_type"><type>Tag</type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg2_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg3_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg4_type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; function&lt; A0, A1, void, void, void, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::function</classname>, <classname>args2</classname>&lt; A0, A1 &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::function</classname></type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type>A1</type></typedef><typedef name="arg2_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg3_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg4_type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; nary_expr&lt; Tag, A0, A1, void, void, void, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args2</classname>&lt; A0, A1 &gt; &gt;</type></typedef><typedef name="tag_type"><type>Tag</type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type>A1</type></typedef><typedef name="arg2_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg3_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg4_type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; function&lt; A0, A1, A2, void, void, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::function</classname>, <classname>args3</classname>&lt; A0, A1, A2 &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::function</classname></type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type>A1</type></typedef><typedef name="arg2_type"><type>A2</type></typedef><typedef name="arg3_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg4_type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; nary_expr&lt; Tag, A0, A1, A2, void, void, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args3</classname>&lt; A0, A1, A2 &gt; &gt;</type></typedef><typedef name="tag_type"><type>Tag</type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type>A1</type></typedef><typedef name="arg2_type"><type>A2</type></typedef><typedef name="arg3_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="arg4_type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; function&lt; A0, A1, A2, A3, void, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::function</classname>, <classname>args4</classname>&lt; A0, A1, A2, A3 &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::function</classname></type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type>A1</type></typedef><typedef name="arg2_type"><type>A2</type></typedef><typedef name="arg3_type"><type>A3</type></typedef><typedef name="arg4_type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; nary_expr&lt; Tag, A0, A1, A2, A3, void, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args4</classname>&lt; A0, A1, A2, A3 &gt; &gt;</type></typedef><typedef name="tag_type"><type>Tag</type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type>A1</type></typedef><typedef name="arg2_type"><type>A2</type></typedef><typedef name="arg3_type"><type>A3</type></typedef><typedef name="arg4_type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; function&lt; A0, A1, A2, A3, A4, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::function</classname>, <classname>args5</classname>&lt; A0, A1, A2, A3, A4 &gt; &gt;</type></typedef><typedef name="tag_type"><type><classname>proto::tag::function</classname></type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type>A1</type></typedef><typedef name="arg2_type"><type>A2</type></typedef><typedef name="arg3_type"><type>A3</type></typedef><typedef name="arg4_type"><type>A4</type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_pass_through_transform&lt; nary_expr&lt; Tag, A0, A1, A2, A3, A4, void &gt; &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args5</classname>&lt; A0, A1, A2, A3, A4 &gt; &gt;</type></typedef><typedef name="tag_type"><type>Tag</type></typedef><typedef name="arg0_type"><type>A0</type></typedef><typedef name="arg1_type"><type>A1</type></typedef><typedef name="arg2_type"><type>A2</type></typedef><typedef name="arg3_type"><type>A3</type></typedef><typedef name="arg4_type"><type>A4</type></typedef></struct-specialization><struct-specialization name="is_ref"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>typename T::is_boost_proto_ref_</template-arg></specialization></struct-specialization><struct-specialization name="is_expr"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>typename T::is_boost_proto_expr_</template-arg></specialization></struct-specialization><namespace name="op"><struct name="as_expr"><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T)</template-arg></specialization><inherit access="public">boost::proto::result_of::as_expr&lt; remove_reference&lt; T &gt;::type &gt;</inherit></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::as_expr</classname>&lt; T &gt;::result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::as_expr</classname>&lt; T const  &gt;::result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></method></method-group></struct><struct name="as_arg"><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T)</template-arg></specialization><inherit access="public">boost::proto::result_of::as_arg&lt; remove_reference&lt; T &gt;::type &gt;</inherit></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::as_arg</classname>&lt; T &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::as_arg</classname>&lt; T const  &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></method></method-group></struct><struct name="arg_c"><template>
      <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
    </template><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result_of::arg_c&lt; Expr, N &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>result_of::arg_c&lt; Expr, N &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="arg"><template>
      <template-type-parameter name="N"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::arg</classname>&lt; Expr, N &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::arg</classname>&lt; Expr, N &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="left"><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::left</classname>&lt; Expr &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::left</classname>&lt; Expr &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="right"><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::right</classname>&lt; Expr &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::right</classname>&lt; Expr &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct></namespace><namespace name="result_of"><struct name="as_expr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="EnableIf"/>
    </template><typedef name="arg0_type"><type>mpl::if_&lt; mpl::or_&lt; boost::is_array&lt; T &gt;, is_function&lt; T &gt; &gt;, T &amp;, typename remove_cv&lt; T &gt;::type &gt;::type</type></typedef><typedef name="type"><type>expr&lt; <classname>proto::tag::terminal</classname>, <classname>args1</classname>&lt; arg0_type &gt; &gt;</type></typedef><typedef name="result_type"><type>type</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static result_type</type><parameter name="t"><paramtype>T &amp;</paramtype></parameter></method></method-group></struct><struct name="as_arg"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="EnableIf"/>
    </template><typedef name="type"><type>expr&lt; <classname>proto::tag::terminal</classname>, <classname>args1</classname>&lt; T &amp; &gt; &gt;</type></typedef></struct><struct name="arg"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="N"/>
    </template></struct><struct name="left"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::result_of::unref&lt; Expr::arg0_type &gt;</inherit></struct><struct name="right"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::result_of::unref&lt; Expr::arg1_type &gt;</inherit></struct><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>0</template-arg></specialization><inherit access="public">boost::proto::result_of::unref&lt; Expr::arg0_type &gt;</inherit><method-group name="public static functions"><method name="call" cv=""><type>static arg_c::reference</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="call" cv=""><type>static arg_c::const_reference</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>0</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 0 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>1</template-arg></specialization><inherit access="public">boost::proto::result_of::unref&lt; Expr::arg1_type &gt;</inherit><method-group name="public static functions"><method name="call" cv=""><type>static arg_c::reference</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="call" cv=""><type>static arg_c::const_reference</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>1</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 1 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>2</template-arg></specialization><inherit access="public">boost::proto::result_of::unref&lt; Expr::arg2_type &gt;</inherit><method-group name="public static functions"><method name="call" cv=""><type>static arg_c::reference</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="call" cv=""><type>static arg_c::const_reference</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>2</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 2 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>3</template-arg></specialization><inherit access="public">boost::proto::result_of::unref&lt; Expr::arg3_type &gt;</inherit><method-group name="public static functions"><method name="call" cv=""><type>static arg_c::reference</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="call" cv=""><type>static arg_c::const_reference</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>3</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 3 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>4</template-arg></specialization><inherit access="public">boost::proto::result_of::unref&lt; Expr::arg4_type &gt;</inherit><method-group name="public static functions"><method name="call" cv=""><type>static arg_c::reference</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="call" cv=""><type>static arg_c::const_reference</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>4</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 4 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>5</template-arg></specialization><inherit access="public">boost::proto::result_of::unref&lt; Expr::arg5_type &gt;</inherit><method-group name="public static functions"><method name="call" cv=""><type>static arg_c::reference</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="call" cv=""><type>static arg_c::const_reference</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>5</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 5 &gt;</inherit></struct-specialization><struct-specialization name="as_expr"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>typename T::is_boost_proto_expr_</template-arg></specialization><typedef name="type"><type>T::boost_proto_expr_type_</type></typedef><typedef name="result_type"><type>T &amp;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static result_type</type><parameter name="t"><paramtype>T &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="as_arg"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>typename T::is_boost_proto_expr_</template-arg></specialization><typedef name="type"><type><classname>ref</classname>&lt; T &gt;</type></typedef></struct-specialization></namespace><data-member name="as_expr"><type><classname>op::as_expr</classname> const</type></data-member><data-member name="as_arg"><type><classname>op::as_arg</classname> const</type></data-member><data-member name="left"><type><classname>op::left</classname> const</type></data-member><data-member name="right"><type><classname>op::right</classname> const</type></data-member><overloaded-function name="arg"><signature><type><classname>result_of::unref</classname>&lt; typename Expr::type::arg0_type &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></signature><signature><type><classname>result_of::unref</classname>&lt; typename Expr::type::arg0_type &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></signature><description><para>arg </para></description></overloaded-function><overloaded-function name="arg_c"><signature><type>result_of::arg_c&lt; Expr, N &gt;::reference</type><template>
          <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></signature><signature><type>result_of::arg_c&lt; Expr, N &gt;::const_reference</type><template>
          <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></signature><description><para>arg_c </para></description></overloaded-function></namespace></namespace></header><header name="boost/xpressive/proto/transform/arg.hpp"><para>Proto transforms for extracting arguments from expressions. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="arg"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="N"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><inherit access="public">boost::proto::result_of::arg&lt; Grammar::template apply&lt; Expr, State, Visitor &gt;::type, N &gt;</inherit></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="arg_c"><template>
      <template-type-parameter name="Grammar"/>
      <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="left"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><inherit access="public">boost::proto::result_of::left&lt; Grammar::template apply&lt; Expr, State, Visitor &gt;::type &gt;</inherit></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="right"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><inherit access="public">boost::proto::result_of::right&lt; Grammar::template apply&lt; Expr, State, Visitor &gt;::type &gt;</inherit></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="state"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name=""/>
      <template-type-parameter name="State"/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>State</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static State const &amp;</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name=""><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state_"><paramtype>State const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="visitor"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
      <template-type-parameter name="Visitor"/>
    </template><typedef name="type"><type>Visitor</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static Visitor &amp;</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name=""><paramtype>Expr const &amp;</paramtype></parameter><parameter name=""><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor_"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="always"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Always"/>
      <template-type-parameter name="Factory"/>
    </template><struct name="apply"><template>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Always</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static Always</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name=""><paramtype>Expr const &amp;</paramtype></parameter><parameter name=""><paramtype>State const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="identity"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/branch.hpp"><para>A special-purpose proto transform for transforming one branch of the expression tree separately from the rest. Given an expression and a new state, it transforms the expression using the new state. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="branch"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="BranchState"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name=""><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/compose.hpp"><para>A special-purpose proto transform for composing two transfomations. Given two Grammars, expressions that match the first grammar are transformed according to that grammar, and the result is forwarded to the second for further transformation. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="compose"><template>
      <template-type-parameter name="Grammar1"/>
      <template-type-parameter name="Grammar2"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><typedef name="type"><type>Grammar2::template <classname>apply</classname>&lt; typename Grammar1::template <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type, State, Visitor &gt;::type</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/conditional.hpp"><para>A special-purpose proto transform for selecting between two transforms based on a compile-time predicate. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="conditional"><template>
      <template-type-parameter name="Predicate"/>
      <template-type-parameter name="Grammar0"/>
      <template-type-parameter name="Grammar1"/>
    </template><inherit access="public">boost::proto::or_&lt; proto::and_&lt; proto::if_&lt; Predicate &gt;, Grammar0 &gt;, proto::and_&lt; proto::not_&lt; proto::if_&lt; Predicate &gt; &gt;, Grammar1 &gt; &gt;</inherit></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/construct.hpp"><para>For constructing an arbitrary type from a bunch of transforms. This assumes that all the grammars corresponding to the transforms are equivalent; that is, that they match the same expressions. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct-specialization name="construct"><template>
      <template-type-parameter name="Type"/>
      <template-type-parameter name="Grammar0"/>
    </template><specialization><template-arg>Type</template-arg><template-arg>Grammar0</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><struct-specialization name="construct"><template>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><specialization><template-arg>Type</template-arg><template-arg>Grammar0</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void &gt;::appl</template-arg></specialization><typedef name="type"><type>Type</type></typedef></struct-specialization><method-group name="public static functions"><method name="call" cv=""><type>static Type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="construct"><template>
      <template-type-parameter name="Type"/>
      <template-type-parameter name="Grammar0"/>
      <template-type-parameter name="Grammar1"/>
    </template><specialization><template-arg>Type</template-arg><template-arg>Grammar0</template-arg><template-arg>Grammar1</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><struct-specialization name="construct"><template>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><specialization><template-arg>Type</template-arg><template-arg>Grammar0</template-arg><template-arg>Grammar1</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void &gt;::appl</template-arg></specialization><typedef name="type"><type>Type</type></typedef></struct-specialization><method-group name="public static functions"><method name="call" cv=""><type>static Type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="construct"><template>
      <template-type-parameter name="Type"/>
      <template-type-parameter name="Grammar0"/>
      <template-type-parameter name="Grammar1"/>
      <template-type-parameter name="Grammar2"/>
    </template><specialization><template-arg>Type</template-arg><template-arg>Grammar0</template-arg><template-arg>Grammar1</template-arg><template-arg>Grammar2</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><struct-specialization name="construct"><template>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><specialization><template-arg>Type</template-arg><template-arg>Grammar0</template-arg><template-arg>Grammar1</template-arg><template-arg>Grammar2</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void &gt;::appl</template-arg></specialization><typedef name="type"><type>Type</type></typedef></struct-specialization><method-group name="public static functions"><method name="call" cv=""><type>static Type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="construct"><template>
      <template-type-parameter name="Type"/>
      <template-type-parameter name="Grammar0"/>
      <template-type-parameter name="Grammar1"/>
      <template-type-parameter name="Grammar2"/>
      <template-type-parameter name="Grammar3"/>
    </template><specialization><template-arg>Type</template-arg><template-arg>Grammar0</template-arg><template-arg>Grammar1</template-arg><template-arg>Grammar2</template-arg><template-arg>Grammar3</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><struct-specialization name="construct"><template>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><specialization><template-arg>Type</template-arg><template-arg>Grammar0</template-arg><template-arg>Grammar1</template-arg><template-arg>Grammar2</template-arg><template-arg>Grammar3</template-arg><template-arg>void</template-arg><template-arg>void &gt;::appl</template-arg></specialization><typedef name="type"><type>Type</type></typedef></struct-specialization><method-group name="public static functions"><method name="call" cv=""><type>static Type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="construct"><template>
      <template-type-parameter name="Type"/>
      <template-type-parameter name="Grammar0"/>
      <template-type-parameter name="Grammar1"/>
      <template-type-parameter name="Grammar2"/>
      <template-type-parameter name="Grammar3"/>
      <template-type-parameter name="Grammar4"/>
    </template><specialization><template-arg>Type</template-arg><template-arg>Grammar0</template-arg><template-arg>Grammar1</template-arg><template-arg>Grammar2</template-arg><template-arg>Grammar3</template-arg><template-arg>Grammar4</template-arg><template-arg>void</template-arg></specialization><struct-specialization name="construct"><template>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><specialization><template-arg>Type</template-arg><template-arg>Grammar0</template-arg><template-arg>Grammar1</template-arg><template-arg>Grammar2</template-arg><template-arg>Grammar3</template-arg><template-arg>Grammar4</template-arg><template-arg>void &gt;::appl</template-arg></specialization><typedef name="type"><type>Type</type></typedef></struct-specialization><method-group name="public static functions"><method name="call" cv=""><type>static Type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/fold.hpp"><para>A special-purpose proto transform for merging sequences of binary operations. It transforms the right operand and passes the result as state while transforming the left. Or, it might do the left first, if you choose. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="fold"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="reverse_fold"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/fold_to_list.hpp"><para>A higher-level transform that uses the fold, branch and list transforms to fold a binary tree into a fusion cons-list. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="fold_to_list"><template>
      <template-type-parameter name="Grammar"/>
    </template><data-member name="mpl_assertion_in_line_91" specifiers="static"><type>const std::size_t</type></data-member></struct><struct name="reverse_fold_to_list"><template>
      <template-type-parameter name="Grammar"/>
    </template><data-member name="mpl_assertion_in_line_106" specifiers="static"><type>const std::size_t</type></data-member></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/list.hpp"><para>A special-purpose proto transform for putting things into a fusion::cons&lt;&gt; list. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="list"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><typedef name="type"><type>fusion::cons&lt; typename Grammar::template <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type, State &gt;</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="tail"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><typedef name="type"><type>Grammar::template <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type::cdr_type</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/pass_through.hpp"><para>TODO </para><namespace name="boost"><namespace name="proto"><struct name="has_pass_through_transform"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><namespace name="transform"><struct name="pass_through"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::<classname>type</classname></type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header></library-reference>
