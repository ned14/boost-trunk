[/ 
  (C) Copyright Edward Diener 2011
  Use, modification and distribution are subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:tti_intro Introduction]

Welcome to the Type Traits Introspection library version 1.4.

The Type Traits Introspection library, or TTI for short, is a library 
of macros generating metafunctions, and a set of parallel nullary type 
metafunctions, which provide the ability to introspect by name the 
elements of a type at compile time. 

The name of the library is chosen because the library offers 
compile time functionality on a type, similar to the Boost Type Traits library, 
and because the functionality the library offers is the ability to introspect 
a type about the existence of a specific element. 

I use the word "introspect" in a very broad sense here. Normally language 
introspection means initially asking for information to be returned by name, 
which can then further be used to introspect for more specific information.
In the TTI library one must always supply the name, and use the functionality 
for the correct type of inner element to find out if the particular named entity exists.
You may prefer the term "query" instead of "introspection" to denote what this 
library does, but I use terminology based on the word "introspect" throughout 
this documentation.

The functionality of the library may be summed up as:

* Provide the means to introspect a type at compile time 
  using a set of macros. Each macro takes the name of the 
  type's element and generates a metafunction which can be 
  subsequently invoked to determine whether or not the 
  element exists within the type. These metafunctions 
  will be called "macro metafunctions" in the documentation.
* Provide corresponding metafunctions which can operate 
  on almost all of the macro metafunctions generated. 
  These secondary metafunctions provide 
  the same set of introspection as the macro metafunctions but 
  allow for an easier to use syntax, where 
  the types being passed are in the form of nullary metafunctions
  themselves. They always work with individual types 
  when specifying function syntax rather than a 
  composite type. These metafunctions are called 'nullary type
  metafunctions' in the documentation.
* Provide a set of macros for all of the macro metafunctions
  which create metafunction classes, so the metafunctions 
  generated by the macro metafunctions can be passed as metadata.
  These can be used by the nullary type metafunctions, and may 
  find other uses for the template metaprogrammer.
   
The library is dependent on Boost PP, Boost MPL, 
Boost Type Traits, and Boost Function Types. 
The library is also dependent 
on the `variadic_macro_data` library currently in the sandbox 
if the variadic macros in the library are used.

The library is a header only library.

Since the dependencies of the library are all header only 
libraries, there is no need to build anything in order to use 
the TTI library.

[section:tti_headers Header Files]

There are two separate general header files in the library, 
divided depending on whether or not the library 
functionality supporting variadic macros is to be used,
which bring in all the rest of the specific header files.

# The main header, which does not require using the library 
support for variadic macros, is `tti.hpp`.
This can be used for the vast majority of functionality in the library.
# The secondary header, which uses a small subset of the 
library functionality, providing an alternate use of particular 
macros with variadic macro support, is `tti_vm.hpp`.

There are also separate specific header files for each of the elements to be 
introspected by the library. This allows for finer-grained inclusion
of nested elements to be introspected. These header files are: 

[table:tbheaders TTI Header Files
  [
    [Inner Element]
    [File]
  ]
  [
    [Type]
    [[headerref boost/tti/type.hpp `type.hpp`]]
  ]
  [
    [Template]
    [[headerref boost/tti/template.hpp `template.hpp`]]
  ]
  [
    [Template with params]
    [[headerref boost/tti/template_params.hpp `template_params.hpp`]]
  ]
  [
    [Template with params - variadic macros]
    [[headerref boost/tti/vm_template_params.hpp `vm_template_params.hpp`]]
  ]
  [
    [Member data]
    [[headerref boost/tti/mem_data.hpp `mem_data.hpp`]]
  ]
  [
    [Member function]
    [[headerref boost/tti/mem_fun.hpp `mem_fun.hpp`]]
  ]
  [
    [Member function - composite syntax]
    [[headerref boost/tti/comp_mem_fun.hpp `comp_mem_fun.hpp`]]
  ]
  [
    [Static member data]
    [[headerref boost/tti/static_mem_data.hpp `static_mem_data.hpp`]]
  ]
  [
    [Static member function]
    [[headerref boost/tti/static_mem_fun.hpp `static_mem_fun.hpp`]]
  ]
  [
    [Static member function - composite syntax]
    [[headerref boost/tti/comp_static_mem_fun.hpp `comp_static_mem_fun.hpp`]]
  ]
  [
    [Member type]
    [[headerref boost/tti/mem_type.hpp `mem_type.hpp`]]
  ]
]

If the general header file `tti_vm.hpp`
or the specific header file 
[headerref boost/tti/vm_template_params.hpp `vm_template_params.hpp`],
are used the library is also dependent 
on the `variadic_macro_data` library currently in the sandbox. 
If this header is not used there is no need to download 
the `variadic_macro_data` library and use it in any way.

[endsect]

[endsect]
