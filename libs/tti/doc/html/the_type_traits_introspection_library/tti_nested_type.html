<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Nested Types</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.0">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;The Type Traits Introspection Library 1.4">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;The Type Traits Introspection Library 1.4">
<link rel="prev" href="tti_detail.html" title="Macro Metafunctions">
<link rel="next" href="tti_usingMM.html" title="Using the Macro Metafunctions">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="tti_detail.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="tti_usingMM.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="the_type_traits_introspection_library.tti_nested_type"></a><a class="link" href="tti_nested_type.html" title="Nested Types">Nested
    Types</a>
</h2></div></div></div>
<a name="the_type_traits_introspection_library.tti_nested_type.the_problem"></a><h4>
<a name="the_type_traits_introspection_library.tti_nested_type.the_problem-heading"></a>
      <a class="link" href="tti_nested_type.html#the_type_traits_introspection_library.tti_nested_type.the_problem">The
      problem</a>
    </h4>
<p>
      The goal of the TTI library is never to produce a compiler error by just using
      the functionality in the library, whether it is invoking its function-like
      macros or instantiating the macro metafunctions created by them, and whether
      the inner element exists or not. In this sense The TTI library macros for introspecting
      an enclosing type for an inner element work very well. But there is one exception
      to this general case. That exception is the crux of the discussion regarding
      nested types which follows.
    </p>
<p>
      The metafunctions generated by the TTI macros all work with types, whether
      in specifying an enclosing type or in specifying the type of some inner element,
      which may also involve types in the signature of that element, such as a parameter
      or return type of a function. The C++ notation for a nested type, given an
      enclosing type 'T' and an inner type 'InnerType', is 'T::InnerType'. If either
      the enclosing type 'T' does not exist, or the inner type 'InnerType' does not
      exist within 'T', the expression 'T::InnerType' will give a compiler error
      if we attempt to use it in our template instantiation of one of TTI's macro
      metafunctions.
    </p>
<p>
      We want to be able to introspect for the existence of inner elements to an
      enclosing type without producing compiler errors. Of course if we absolutely
      know what types we have and that a nested type exists, and these declarations
      are within our scope, we can always use an expression like T::InnerType without
      error. But this is often not the case when doing template programming since
      the type being passed to us at compile-time in a class or function template
      is chosen at instantiation time and is created by the user of a template.
    </p>
<p>
      One solution to this is afforded by the library itself. Given an enclosing
      type 'T' which we know must exist, either because it is a top-level type we
      know about or it is passed to us in some template as a 'class T' or 'typename
      T', and given an inner type named 'InnerType' whose existence we would like
      ascertain, we can use a <code class="computeroutput"><span class="identifier">BOOST_TTI_HAS_TYPE</span><span class="special">(</span><span class="identifier">InnerType</span><span class="special">)</span></code> macro and it's related <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">has_type_InnerType</span></code> metafunction to determine
      if the nested type 'InnerType' exists. This solution is perfectly valid and,
      with Boost MPL's selection metafunctions, we can do compile-time selection
      to generate the correct template code.
    </p>
<p>
      However this does not scale that well syntactically if we need to drill down
      further from a top-level enclosing type to a deeply nested type, or even to
      look for some deeply nested type's inner elements. We are going to be generating
      a great deal of <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">if_</span></code>
      and/or <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">eval_if</span></code>
      type selection statements to get to some final condition where we know we can
      generate the compile-time code which we want.
    </p>
<a name="the_type_traits_introspection_library.tti_nested_type.the_solution"></a><h4>
<a name="the_type_traits_introspection_library.tti_nested_type.the_solution-heading"></a>
      <a class="link" href="tti_nested_type.html#the_type_traits_introspection_library.tti_nested_type.the_solution">The
      solution</a>
    </h4>
<p>
      The TTI library offers a better solution in the form of constructs which work
      with nested types without producing a compiler error if the nested type does
      not exist, but still are able to do the introspecting for inner elements that
      our TTI macro metafunctions do.
    </p>
<p>
      We have already seen one of those constructs, the macro <code class="computeroutput"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span></code>,
      which generates a metafunction based on the name of an inner type. But instead
      of telling us whether that inner type exists it instead returns a typedef 'type'
      which is that inner type if it exists, else it is an unspecified type if it
      does not. In this way we have created a metafunction, very similar in functionality
      to boost::mpl::identity, but which still returns some unspecified marker 'type'
      if our nested type is invalid.
    </p>
<p>
      We can use the functionality of <code class="computeroutput"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span></code>
      to construct nested types for our other macro metafunctions, without having
      to use the T::InnerType syntax and produce a compiler error if no such type
      actually exists within our scope. We can even do this in deeply nested contexts
      by stringing together, so to speak, a series of these macro metafunction results.
    </p>
<p>
      As an example, given a type T, let us create a metafunction where there is
      a nested type FindType whose enclosing type is eventually T, as represented
      by the following structure:
    </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">T</span>
  <span class="special">{</span>
  <span class="keyword">struct</span> <span class="identifier">AType</span>
    <span class="special">{</span>
    <span class="keyword">struct</span> <span class="identifier">BType</span>
      <span class="special">{</span>
      <span class="keyword">struct</span> <span class="identifier">CType</span>
        <span class="special">{</span>
        <span class="keyword">struct</span> <span class="identifier">FindType</span>
          <span class="special">{</span>
          <span class="special">};</span>
        <span class="special">}</span>
      <span class="special">};</span>
    <span class="special">};</span>
  <span class="special">};</span>
</pre>
<p>
      In our TTI code we first create a series of member type macros for each of
      our nested types:
    </p>
<pre class="programlisting"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">FindType</span><span class="special">)</span>
<span class="identifier">BOOST_TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">AType</span><span class="special">)</span>
<span class="identifier">BOOST_TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">BType</span><span class="special">)</span>
<span class="identifier">BOOST_TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">CType</span><span class="special">)</span>
</pre>
<p>
      Next we can create a typedef to reflect a nested type called FindType which
      has the relationship as specified above by instantiating our macro metafunctions.
    </p>
<pre class="programlisting"><span class="keyword">typedef</span> <span class="keyword">typename</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_FindType</span>
  <span class="special">&lt;</span>
  <span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_CType</span>
    <span class="special">&lt;</span>
    <span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_BType</span>
      <span class="special">&lt;</span>
      <span class="keyword">typename</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_AType</span>
        <span class="special">&lt;</span>
        <span class="identifier">T</span>
        <span class="special">&gt;::</span><span class="identifier">type</span>
      <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="special">&gt;::</span><span class="identifier">type</span>
  <span class="special">&gt;::</span><span class="identifier">type</span> <span class="identifier">MyFindType</span><span class="special">;</span>
</pre>
<p>
      We can use the above typedef to pass the type as FindType to one of our macro
      metafunctions. FindType may not actually exist but we will not generate a compiler
      error when we use it.
    </p>
<p>
      As one example, let's ask whether FindType has a static member data called
      MyData of type 'int'. We add:
    </p>
<pre class="programlisting"><span class="identifier">BOOST_TTI_HAS_STATIC_MEMBER_DATA</span><span class="special">(</span><span class="identifier">MyData</span><span class="special">)</span>
</pre>
<p>
      Next we create our metafunction:
    </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">has_static_member_data_MyData</span>
  <span class="special">&lt;</span>
  <span class="identifier">MyFindType</span><span class="special">,</span>
  <span class="keyword">int</span>
  <span class="special">&gt;</span>
</pre>
<p>
      and use this in our metaprogramming code. Our metafunction now tells us whether
      the nested type FindType has a static member data called MyData of type 'int',
      even if FindType does not actually exist as we have specified it as a type.
      If we had tried to do this using normal C++ nested type notation our metafunction
      code above would be:
    </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">has_static_member_data_MyData</span>
  <span class="special">&lt;</span>
  <span class="keyword">typename</span> <span class="identifier">T</span><span class="special">::</span><span class="identifier">AType</span><span class="special">::</span><span class="identifier">BType</span><span class="special">::</span><span class="identifier">CType</span><span class="special">::</span><span class="identifier">FindType</span><span class="special">,</span>
  <span class="keyword">int</span>
  <span class="special">&gt;</span>
</pre>
<p>
      But this fails with a compiler error if there is no such nested type, and that
      is exactly what we do not want in our compile-time metaprogramming code.
    </p>
<p>
      We can also directly find out whether the deeply nested type 'FindType' actually
      exists in a similar manner. Our metafunction would be:
    </p>
<pre class="programlisting"><span class="identifier">BOOST_TTI_HAS_TYPE</span><span class="special">(</span><span class="identifier">FindType</span><span class="special">)</span>

<span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">has_type_FindType</span>
  <span class="special">&lt;</span>
  <span class="keyword">typename</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_CType</span>
    <span class="special">&lt;</span>
    <span class="keyword">typename</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_BType</span>
      <span class="special">&lt;</span>
      <span class="keyword">typename</span>
      <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_AType</span>
        <span class="special">&lt;</span>
        <span class="identifier">T</span>
        <span class="special">&gt;::</span><span class="identifier">type</span>
      <span class="special">&gt;::</span><span class="identifier">type</span>
    <span class="special">&gt;::</span><span class="identifier">type</span>
  <span class="special">&gt;</span>
</pre>
<p>
      Because this duplicates much of our code for the 'MyFindType' typedef to create
      our nested type, we can instead, and much more easily, pass our type 'MyFindType',
      since we already have it in the form of a type, to another metafunction called
      'boost::tti::valid_member_type', which returns a boolean constant which is
      'true' if our nested exists or 'false' if it does not.
    </p>
<p>
      Using this functionality with our 'MyFindType' type above we could create the
      nullary metafunction:
    </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">valid_member_type</span>
  <span class="special">&lt;</span>
  <span class="identifier">MyFindType</span>
  <span class="special">&gt;</span>
</pre>
<p>
      directly instead of replicating the same functionality with our 'boost::tti::has_type_FindType'
      metafunction.
    </p>
<p>
      The using of <code class="computeroutput"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span></code>
      to create a nested type which may or may not exist, and which can subsequently
      be used with our macro metafunctions whenever a nested type is required, without
      producing a compiler error when the type does not actually exist, is the main
      reason we have separate but similar functionality among our macro metafunctions
      to determine whether a member function or a static member function exists within
      an enclosing type.
    </p>
<p>
      In the more general case, when using <code class="computeroutput"><span class="identifier">BOOST_TTI_HAS_COMP_MEMBER_FUNCTION</span></code>
      and <code class="computeroutput"><span class="identifier">BOOST_TTI_HAS_COMP_STATIC_MEMBER_FUNCTION</span></code>,
      the signature for the member function and the static member function is a composite
      type. This makes for a syntactical notation which is easy to specify, but because
      of that composite type notation we can not use the nested type functionality
      in <code class="computeroutput"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span></code> very
      easily. But when we use <code class="computeroutput"><span class="identifier">BOOST_TTI_HAS_MEMBER_FUNCTION</span></code>
      and <code class="computeroutput"><span class="identifier">BOOST_TTI_HAS_STATIC_MEMBER_FUNCTION</span></code>
      the composite types in our signatures are broken down into their individual
      types so that using <code class="computeroutput"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span></code>,
      if necessary, for any one of the individual types is easy.
    </p>
<a name="the_type_traits_introspection_library.tti_nested_type.a_more_elegant_solution"></a><h4>
<a name="the_type_traits_introspection_library.tti_nested_type.a_more_elegant_solution-heading"></a>
      <a class="link" href="tti_nested_type.html#the_type_traits_introspection_library.tti_nested_type.a_more_elegant_solution">A
      more elegant solution</a>
    </h4>
<p>
      Although using <code class="computeroutput"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span></code>
      represents a good solution to creating a nested type without the possible compile-time
      error of the T::InnerType syntax, reaching in to specify all those ::type expressions,
      along with their repeated 'typename', does get syntactically tedious.
    </p>
<p>
      Because of this the TTI library offers a parallel set of metafunctions to the
      macro metafunctions where the 'types' specified are themselves nullary metafunctions.
      This parallel set of metafunctions, using nullary metafunctions to specify
      individual types, rather than the actual types themselves, are called 'nullary
      type metafunctions'. In this group there is also a nullary metafunction paralleling
      our <code class="computeroutput"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span></code> macro
      metafunction, and therefore a further construct making the specifying of nested
      types easy and error-free to use.
    </p>
<p>
      This group of nullary type metafunctions will be fully explained later.
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2010 Tropic Software East Inc</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="tti_detail.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="tti_usingMM.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
