<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Nullary Type Metafunctions</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.0">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;The Type Traits Introspection Library 1.4">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;The Type Traits Introspection Library 1.4">
<link rel="prev" href="tti_metaclasses.html" title="Macro Metafunctions as Metadata">
<link rel="next" href="tti_usingNTM.html" title="Using the Nullary Type Metafunctions">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="tti_metaclasses.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="tti_usingNTM.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="the_type_traits_introspection_library.tti_metafunctions"></a><a class="link" href="tti_metafunctions.html" title="Nullary Type Metafunctions">Nullary
    Type Metafunctions</a>
</h2></div></div></div>
<p>
      The macro metafunctions provide a complete set of functionality for anything
      one would like to do using the TTI library. Why then do we have another set
      of parallel functionality as nullary type metafunctions ?
    </p>
<p>
      The nullary type metafunctions parallel only those macro metafunctions in which
      types are specified individually rather than in a composite manner. The individual
      types are passed to the nullary type metafunctions as nullary metafunctions,
      hence the name of this group of metafunctions. They more easily allow a syntax
      where nested types can be specified without needing to manually reach into
      the 'type' member of <code class="computeroutput"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span></code>
      or the 'type' member of its nullary type metafunction equivalent called <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">mf_member_type</span></code>.
    </p>
<p>
      In a very real way the nullary type metafunctions exist just to provide syntactic
      improvements over the macro metafunctions and are not needed to use the library,
      since all of the library functionality is already provided with the macro metafunctions.
      Nonetheless syntactic ease of use is a goal of the TTI library and therefore
      these metafunctions are provided to allow that syntactic improvement.
    </p>
<p>
      The nullary type metafunctions reuse the metafunctions generated by the macro
      metafunctions. To do this the resulting metafunction generated by a particular
      macro metafunction needs to be passed as metadata to a corresponding nullary
      type metafunction.
    </p>
<p>
      A lambda expression, in the form of a metafunction class or a placeholder expression,
      is passed as the first parameter to our nullary type metafunctions. We have
      already seen how the TTI library supplies metafunction classes through the
      use of metafunction class macros for each of the macro metafunctions. The end-user
      can use these metafunction classes directly, or can use placeholder expressions
      with the metafunctions generated by the macro metafunctions.
    </p>
<p>
      The remaining parameters passed to the nullary type metafunctions are 'types'.
      These 'types' always consist first of the enclosing type and then possibly
      other types which make up the signature of whatever inner element we are introspecting.
      Each of these 'types' is passed as a nullary metafunction whose typedef 'type'
      is the actual type.
    </p>
<p>
      The exception to this use of nullary type metafunctions when specifying 'types'
      is when a Boost <code class="computeroutput"><span class="identifier">function_types</span></code>
      tag type, which is optional, is specified as an addition to the function signature.
      Also when dealing with a function signature and parameter types being passed,
      while the parameter 'types' themselves are in the form of nullary metafunctions,
      the MPL forward sequence which contains the parameter 'types' is a plain type
      and should not be wrapped as a nullary metafunction.
    </p>
<p>
      For a type which is in scope, we can always use boost::mpl::identity to create
      our nullary metafunction, and there can never be a compiler error for such
      known types as long as declarations for them exist or they are built-in C++
      types. For nested types, which may or may not exist, we can pass the resulting
      nullary metafunction generated by <code class="computeroutput"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span></code>,
      or its equivalent nullary type metafunction <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">mf_member_type</span></code> ( explained later ).
    </p>
<p>
      To use these metafunctions you need to include the main header file <code class="computeroutput"><span class="identifier">tti</span><span class="special">.</span><span class="identifier">hpp</span></code>,
      unless otherwise noted. Alternatively you can include a specific header as
      given in the table below,
    </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
        The header files &lt;boost/mpl/identity.hpp&gt; and &lt;boost/mpl/placeholders.hpp&gt;
        are included by the TTI header files whenever you include a general header
        file or a specific header file for a nullary type metafunction, so you need
        not manually include it in order to wrap a known type as a nullary metafunction
        or use a placeholder expression. Also the header file &lt;boost/mpl/vector.hpp&gt;
        is included by the general header file 'tti.hpp' or the specific header files
        which introspect functions, so if you use an MPL vector as your forward sequence
        wrapper for parameter types, you need not manually include the header file.
      </p></td></tr>
</table></div>
<p>
      A table of these metafunctions is given, based on the inner element whose existence
      the metaprogrammer is introspecting. A more detailed explanation can be found
      in the reference section, and examples of usage can be found in the <a class="link" href="tti_usingNTM.html#sectti_usingNTM">"Using
      the Nullary Type Metafunctions"</a> section. All of the metafunctions
      are in the top-level 'boost::tti' namespace, all have a particular name based
      on the type of its functionality, and all begin with the prefix 'mf_' so as
      not to conflict with the macro metafunction names generated by the library.
    </p>
<div class="table">
<a name="the_type_traits_introspection_library.tti_metafunctions.tbmetafunctions"></a><p class="title"><b>Table&#160;1.6.&#160;TTI Nullary Type Metafunctions</b></p>
<div class="table-contents"><table class="table" summary="TTI Nullary Type Metafunctions">
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Inner Element
              </p>
            </th>
<th>
              <p>
                Template
              </p>
            </th>
<th>
              <p>
                Parameters
              </p>
            </th>
<th>
              <p>
                Macro Equivalent
              </p>
            </th>
<th>
              <p>
                Specific Header File
              </p>
            </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                Type
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/tti/mf_has_type.html" title="Struct template mf_has_type">boost::tti::mf_has_type</a></code>
              </p>
            </td>
<td>
              <p>
                class HasType = macro metafunction as lambda expression
              </p>
              <p>
                class T = enclosing type nullary metafunction
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">BOOST_TTI_HAS_TYPE</span></code>
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../header/boost/tti/type_hpp.html" title="Header &lt;boost/tti/type.hpp&gt;">type.hpp</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Type with check
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/tti/mf_has_type.html" title="Struct template mf_has_type">boost::tti::mf_has_type</a></code>
              </p>
            </td>
<td>
              <p>
                class HasType = macro metafunction as lambda expression
              </p>
              <p>
                class T = enclosing type nullary metafunction
              </p>
              <p>
                class U = type to check against nullary metafunction
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">BOOST_TTI_HAS_TYPE</span></code>
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../header/boost/tti/type_hpp.html" title="Header &lt;boost/tti/type.hpp&gt;">type.hpp</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Class Template
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/tti/mf_has_template.html" title="Struct template mf_has_template">boost::tti::mf_has_template</a></code>
              </p>
            </td>
<td>
              <p>
                class HasTemplate = macro metafunction as lambda expression
              </p>
              <p>
                class T = enclosing type nullary metafunction
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">BOOST_TTI_HAS_TEMPLATE</span></code>
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../header/boost/tti/template_hpp.html" title="Header &lt;boost/tti/template.hpp&gt;">template.hpp</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Class Template with params
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/tti/mf_has_template_check_p_id429478.html" title="Struct template mf_has_template_check_params">boost::tti::mf_has_template_check_params</a></code>
              </p>
            </td>
<td>
              <p>
                class HasTemplateCheckParams = macro metafunction as lambda expression
              </p>
              <p>
                class T = enclosing type nullary metafunction
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">BOOST_TTI_HAS_TEMPLATE_CHECK_PARAMS</span></code>
              </p>
              <p>
                <code class="computeroutput"><span class="identifier">BOOST_TTI_VM_HAS_TEMPLATE_CHECK_PARAMS</span></code>
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../header/boost/tti/template_params_hpp.html" title="Header &lt;boost/tti/template_params.hpp&gt;">template_params.hpp</a></code>
              </p>
              <p>
                <code class="computeroutput"><a class="link" href="../header/boost/tti/vm_template_params_hpp.html" title="Header &lt;boost/tti/vm_template_params.hpp&gt;">vm_template_params.hpp</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Member data
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/tti/mf_has_member_data.html" title="Struct template mf_has_member_data">boost::tti::mf_has_member_data</a></code>
              </p>
            </td>
<td>
              <p>
                class HasMemberData = macro metafunction as lambda expression
              </p>
              <p>
                class T = enclosing type nullary metafunction
              </p>
              <p>
                class R = type of member data nullary Metafunction
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">BOOST_TTI_HAS_MEMBER_DATA</span></code>
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../header/boost/tti/mem_data_hpp.html" title="Header &lt;boost/tti/mem_data.hpp&gt;">mem_data.hpp</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Member function
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/tti/mf_has_member_function.html" title="Struct template mf_has_member_function">boost::tti::mf_has_member_function</a></code>
              </p>
            </td>
<td>
              <p>
                class HasMemberFunction = macro metafunction as lambda expression
              </p>
              <p>
                class T = enclosing type nullary metafunction
              </p>
              <p>
                class R = return value nullary metafunction
              </p>
              <p>
                class FS = (optional) a Boost MPL forward sequence of parameter types
                as nullary metafunctions. The forward sequence as a type is not presented
                as a nullary metafunction. If there are no parameters, this may be
                omitted.
              </p>
              <p>
                class TAG = (optional) a Boost <code class="computeroutput"><span class="identifier">function_types</span></code>
                tag type.
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">BOOST_TTI_HAS_MEMBER_FUNCTION</span></code>
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../header/boost/tti/mem_fun_hpp.html" title="Header &lt;boost/tti/mem_fun.hpp&gt;">mem_fun.hpp</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Static data
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/tti/mf_has_static_member_data.html" title="Struct template mf_has_static_member_data">boost::tti::mf_has_static_member_data</a></code>
              </p>
            </td>
<td>
              <p>
                class HasStaticMemberData = macro metafunction as lambda expression
              </p>
              <p>
                class T = enclosing type nullary metafunction
              </p>
              <p>
                class R = type of static data nullary metafunction
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">BOOST_TTI_HAS_STATIC_MEMBER_DATA</span></code>
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../header/boost/tti/static_mem_data_hpp.html" title="Header &lt;boost/tti/static_mem_data.hpp&gt;">static_mem_data.hpp</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                Static function
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/tti/mf_has_static_member_fu_id429381.html" title="Struct template mf_has_static_member_function">boost::tti::mf_has_static_member_function</a></code>
              </p>
            </td>
<td>
              <p>
                class HasStaticMemberFunction = macro metafunction as lambda expression
              </p>
              <p>
                class T = enclosing type nullary metafunction
              </p>
              <p>
                class R = return value nullary metafunction
              </p>
              <p>
                class FS = (optional) a Boost MPL forward sequence of parameter types
                as nullary metafunctions. The forward sequence as a type is not presented
                as a nullary metafunction. If there are no parameters, this may be
                omitted.
              </p>
              <p>
                class TAG = (optional) a Boost <code class="computeroutput"><span class="identifier">function_types</span></code>
                tag type.
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">BOOST_TTI_HAS_STATIC_MEMBER_FUNCTION</span></code>
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../header/boost/tti/static_mem_fun_hpp.html" title="Header &lt;boost/tti/static_mem_fun.hpp&gt;">static_mem_fun.hpp</a></code>
              </p>
            </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
      Other than the use of nullary metafunctions, one other difference in the nullary
      type metafunctions from their macro metafunction counterparts is that the signature
      for member functions and static member functions always involves individual
      types rather than the combined type notation which some of the macro metafunctions
      use. This allows us to specify nested types in those signatures without using
      the T::InnerType notation.
    </p>
<a name="the_type_traits_introspection_library.tti_metafunctions.nullary_type_metafunction__code__phrase_role__identifier__member_type__phrase___code__equivalent"></a><h4>
<a name="the_type_traits_introspection_library.tti_metafunctions.nullary_type_metafunction__code__phrase_role__identifier__member_type__phrase___code__equivalent-heading"></a>
      <a class="link" href="tti_metafunctions.html#the_type_traits_introspection_library.tti_metafunctions.nullary_type_metafunction__code__phrase_role__identifier__member_type__phrase___code__equivalent">Nullary
      type metafunction <code class="computeroutput"><span class="identifier">member_type</span></code>
      equivalent</a>
    </h4>
<p>
      Just as there exists the macro <code class="computeroutput"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span></code>
      for creating a macro metafunction which returns a nested type if it exists,
      else an unspecified type, there is also the equivalent nullary type metafunction.
    </p>
<div class="table">
<a name="the_type_traits_introspection_library.tti_metafunctions.tbmetanested"></a><p class="title"><b>Table&#160;1.7.&#160;TTI Nested Type Nullary Type Metafunction</b></p>
<div class="table-contents"><table class="table" summary="TTI Nested Type Nullary Type Metafunction">
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Inner Element
              </p>
            </th>
<th>
              <p>
                Template
              </p>
            </th>
<th>
              <p>
                Parameters
              </p>
            </th>
<th>
              <p>
                Macro Equivalent
              </p>
            </th>
<th>
              <p>
                Specific Header File
              </p>
            </th>
</tr></thead>
<tbody><tr>
<td>
              <p>
                Type
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/tti/mf_member_type.html" title="Struct template mf_member_type">boost::tti::mf_member_type</a></code>
              </p>
            </td>
<td>
              <p>
                class MemberType = macro metafunction as lambda expression
              </p>
              <p>
                class T = enclosing type nullary metafunction
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span></code>
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../header/boost/tti/mem_type_hpp.html" title="Header &lt;boost/tti/mem_type.hpp&gt;">mem_type.hpp</a></code>
              </p>
            </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break"><p>
      The difference between the macro metafunction <code class="computeroutput"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span></code>
      and <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">mf_member_type</span></code>
      is simply that, like the other nullary type metafunctions, the latter takes
      its enclosing type as a nullary metafunction. Both produce the exact same result.
    </p>
<p>
      The use of this metafunction allows us to created deeply nested types, which
      may or may not exist, as nullary metafunctions in much the same way that <code class="computeroutput"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span></code> can. The difference
      is the simpler syntax when using <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">mf_member_type</span></code>.
    </p>
<p>
      As an example, given the theoretical relationship of types we used before:
    </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">T</span>
  <span class="special">{</span>
  <span class="keyword">struct</span> <span class="identifier">AType</span>
    <span class="special">{</span>
    <span class="keyword">struct</span> <span class="identifier">BType</span>
      <span class="special">{</span>
      <span class="keyword">struct</span> <span class="identifier">CType</span>
        <span class="special">{</span>
        <span class="keyword">struct</span> <span class="identifier">FindType</span>
          <span class="special">{</span>
          <span class="special">};</span>
        <span class="special">}</span>
      <span class="special">};</span>
    <span class="special">};</span>
  <span class="special">};</span>
</pre>
<p>
      We can use <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">mf_member_type</span></code>
      as follows. First we create our corresponding macro metafunctions:
    </p>
<pre class="programlisting"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">FindType</span><span class="special">)</span>
<span class="identifier">BOOST_TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">AType</span><span class="special">)</span>
<span class="identifier">BOOST_TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">BType</span><span class="special">)</span>
<span class="identifier">BOOST_TTI_MEMBER_TYPE</span><span class="special">(</span><span class="identifier">CType</span><span class="special">)</span>
</pre>
<p>
      Next we will create a typedef to reflect a nested type called FindType, as
      a nullary metafunction, which has the relationship as specified above, by using
      <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">mf_member_type</span></code>.
    </p>
<pre class="programlisting"><span class="keyword">typedef</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">mf_member_type</span>
  <span class="special">&lt;</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_FindType</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;,</span>
  <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">mf_member_type</span>
    <span class="special">&lt;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_CType</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;,</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">mf_member_type</span>
      <span class="special">&lt;</span>
      <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_BType</span><span class="special">&lt;</span><span class="identifier">_</span><span class="special">&gt;,</span>
      <span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">member_type_AType</span>
        <span class="special">&lt;</span>
        <span class="identifier">T</span>
        <span class="special">&gt;</span>
      <span class="special">&gt;</span>
    <span class="special">&gt;</span>
  <span class="special">&gt;</span> <span class="identifier">MyFindType</span><span class="special">;</span>
</pre>
<p>
      The nested type created can then be used with the other nullary type metafunctions
      above since it is itself a nullary metafunction. The key information in understanding
      the code above is that the enclosing type, as in all of the nullary type metafunctions,
      is a nullary metafunction itself, which means that the enclosing type can be
      specified as the result of using <code class="computeroutput"><span class="identifier">BOOST_TTI_MEMBER_TYPE</span></code>
      as well as the result of using <code class="computeroutput"><span class="identifier">mf_member_type</span></code>
      itself.
    </p>
<p>
      Both techniques are shown in the example above, and the same technique for
      creating nested types as nullary metafunctions can be used with the other functionality
      of the nullary type metafunctions when nested types are needed as 'types'.
    </p>
<p>
      Also similar to the macro metafunctions, we have an easy way of testing whether
      or not our <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">mf_member_type</span></code>
      nested type actually exists.
    </p>
<div class="table">
<a name="the_type_traits_introspection_library.tti_metafunctions.existtbmetanested"></a><p class="title"><b>Table&#160;1.8.&#160;TTI Nested Type Nullary Type Metafunction Existence</b></p>
<div class="table-contents"><table class="table" summary="TTI Nested Type Nullary Type Metafunction Existence">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                Inner Element
              </p>
            </th>
<th>
              <p>
                Template
              </p>
            </th>
<th>
              <p>
                Parameters
              </p>
            </th>
<th>
              <p>
                Specific Header File
              </p>
            </th>
</tr></thead>
<tbody><tr>
<td>
              <p>
                Type
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/tti/mf_valid_member_type.html" title="Struct template mf_valid_member_type">boost::tti::mf_valid_member_type</a></code>
              </p>
            </td>
<td>
              <p>
                class T = a type as a nullary metafunction
              </p>
              <p>
                returns = true if the nullary metafunction's inner 'type' exists,
                false if it does not. 'Existence' is determined by whether the type
                does not equal an unspecified type.
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../header/boost/tti/mem_type_hpp.html" title="Header &lt;boost/tti/mem_type.hpp&gt;">mem_type.hpp</a></code>
              </p>
            </td>
</tr></tbody>
</table></div>
</div>
<br class="table-break"><p>
      Again note the difference here from the equivalent macro metafunction tester
      <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">tti</span><span class="special">::</span><span class="identifier">valid_member_type</span></code>.
      In the example above the type T is passed as a nullary metafunction holding
      the actual type, where for the macro metafunction equivalent the type T is
      passed as the actual type being tested.
    </p>
<p>
      In our next section we will look at examples of nullary type metafunction use.
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2010 Tropic Software East Inc</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="tti_metaclasses.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="tti_usingNTM.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
