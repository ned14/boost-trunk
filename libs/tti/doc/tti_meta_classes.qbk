[/ 
  (C) Copyright Edward Diener 2011
  Use, modification and distribution are subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:tti_metaclasses Macro Metafunctions as Metadata]

As specified in the Boost MPL library, there are two ways to pass metafunctions 
as metadata, and both ways fall under the Boost MPL terminology of 'lambda expressions':

* As a metafunction class
* As a placeholder expression

Using a placeholder expression is the easiest way and does not require the programmer to create
a metafunction class for passing the metadata. The syntax for this is fairly simple. The syntax 
for passing a macro metafunction becomes `macrometafunction<_>` etc. depending 
on how many parameters are being passed. Thus for two parameters we would have 
`macrometafunction<_,_>` etc., with another placeholder (`_`) added for each subsequent parameter.

The Boost MPL library also provides the high-level primitive 'quote' which
creates a metafunction class from any n-ary metafunction. The syntax for this 
is also fairly easy. The syntax for passing a macro metafunction as a metafunction
class becomes `boost::mpl::quote(n)<macrometafunction>' where 'n' depends on the 
actual number of template parameters the macro metafunction has.

As will be seen when we discuss the nullary type metafunctions, each nullary type 
metafunction takes as its first parameter a macro metafunction as metadata in
the form of a lambda expression. Therefore we can use either a metafunction
class generated by boost::mpl::quote(n), or a placeholder expression, to 
pass a macro metafunction as metadata to our nullary type metafunctions.
  
[endsect]
