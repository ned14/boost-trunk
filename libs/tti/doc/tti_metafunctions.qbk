[/ 
  (C) Copyright Edward Diener 2011
  Use, modification and distribution are subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:tti_metafunctions Nullary Type Metafunctions]

The macro metafunctions provide a complete set of functionality for 
anything one would like to do using the TTI library.

What is presented here is a set of named metafunctions, 
in the boost::tti namespace, which offer 
an alternative syntax for using the macro metafunctions. No new 
functionality is involved and the difference may be seen, depending on 
one's own predilection, as a valid alternative syntax for
TTI functionality, or as an unneeded syntactical complication 
which can be avoided. For those who are satisfied with the 
syntactical usage of the macro metafunctions, there is no need 
to understand the syntactical difference as presented here, and this 
entire section can be skipped.

The macro metafunctions, like all metafunctions,
pass their parameters as types. When passing the 
result of one metafunction as a parameter to another metafunction, one 
is reaching into the first metafunction to access the nested 'type' 
of its instantiated result in order 
to pass it to another metafunction as a parameter. This is common 
metafunction usage, and is the syntax of the macro metafunctions as well.

An alternative use of metafunctions is to pass the instantiated metafunction itself
as a nullary metafunction, rather than its nested 'type' member, as a parameter to 
another metafunction. This is purely a syntactical advantage of not having to 
manually specify '::type' in order to extract the nested 'type' from the resulting
nullary metafunction.

The TTI named metafunctions reuse the macro metafunctions 
but pass nearly all template parameters which are classes as nullary metafunctions. 
They are therefore called 'nullary type metafuncions' as opposed to the 
'macro metafunctions' of ordinary TTI usage.

Because the nullary type metafunctions reuse the metafunctions generated by the macro metafunctions,
the metafunction generated by a particular macro metafunction needs to 
be passed as metadata to a corresponding nullary type metafunction. As explained in Boost 
MPL, a metafunction as metadata is passed as a lambda expression, in the form of a metafunction 
class or a placeholder expression. This lambda expression is passed as the 
first parameter to each of our nullary type metafunctions. 

The remaining parameters passed to the nullary 
type metafunctions are 'types'. These 'types' always consist first of the enclosing type and then 
possibly other types which make up the signature of whatever inner element we are introspecting. 
Whenever each of these 'types' is a class it is normally passed as a nullary metafunction 
whose typedef 'type' is the actual type.

The exceptions to this use of nullary type metafunctions when specifying 'types' are:

# When a Boost `function_types` tag type, which is optional, is specified as an addition to the 
function signature it is passed as is.

# When specifying a function signature and parameter types being passed,
the MPL forward sequence which contains the parameter 'types' is passed as is.

Whenever any type is not a class, it can passed to the nullary type metafunctions as is
or it can be passed as a nullary metafunction by wrapping it with boost::mpl::identity.

For a class type which is in scope, we can always use 
boost::mpl::identity to create our nullary metafunction, and there 
can never be a compiler error for such known types as long as declarations for them exist.
For nested types, which may or may not exist, we can pass the resulting nullary 
metafunction generated by `BOOST_TTI_MEMBER_TYPE`, or its equivalent 
nullary type metafunction `boost::tti::mf_member_type` ( explained later ).

To use these metafunctions you need to include the main header file `boost/tti/tti.hpp`, 
unless otherwise noted. Alternatively you can include a specific header as given in the 
table below,

[tip 
The header files <boost/mpl/identity.hpp>, <boost/mpl/placeholders.hpp>, and 
<boost/mpl/quote.hpp> are included by 
the TTI header files whenever you include a general header file or a specific header file 
for a nullary type metafunction. So you need not 
manually include any of these header files in order to wrap a known type as a nullary 
metafunction, use a placeholder expression, or use boost::mpl::quote to pass 
a macro metafunction as a metafunction class to a nullary type metafunction. 
Also the header file <boost/mpl/vector.hpp> is 
included by the general header file 'boost/tti/tti.hpp' or the specific header files which 
introspect functions, so if you use an MPL vector as your 
forward sequence wrapper for parameter types, you need not manually include the header file.
]

A table of the nullary type metafunctions is given, based on the inner element whose 
existence the metaprogrammer is introspecting. 
More detailed explanations  
and examples for each of the nullary type metafunctions will follow this 
section in the documentation.
The actual syntax for each nullary type metafunction
can be found in the reference section,
and general examples of usage can be found in the 
[link sectti_usingNTM "Using the Nullary Type Metafunctions"] section.
All of the metafunctions are in the top-level 'boost::tti' namespace,
all have a particular name based on the type of its functionality, and all begin with 
the prefix 'mf_', representing the fact that they are metafunctions and to distinguish
them from any other constructs created by TTI in the boost::tti namespace.

[table:tbmetafunctions TTI Nullary Type Metafunctions
  [
    [Inner Element]
    [Template]
    [Parameters]
    [Macro Metafunction Passed]
    [Specific Header File]
  ]
  [
    [Type]
    [
    [classref boost::tti::mf_has_type]
    ]
    [
    class HasType = macro metafunction as lambda expression 
    
    class T = enclosing type nullary metafunction
    ]
    [`BOOST_TTI_HAS_TYPE`]
    [[headerref boost/tti/has_type.hpp `has_type.hpp`]]
  ]
  [
    [Type with check]
    [
    [classref boost::tti::mf_has_type]
    ]
    [
    class HasType = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    
    class U = type to check against nullary metafunction
    ]
    [`BOOST_TTI_HAS_TYPE`]
    [[headerref boost/tti/has_type.hpp `has_type.hpp`]]
  ]
  [
    [Class Template]
    [
    [classref boost::tti::mf_has_template]
    ]
    [
    class HasTemplate = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    ]
    [`BOOST_TTI_HAS_TEMPLATE`]
    [[headerref boost/tti/has_template.hpp `has_template.hpp`]]
  ]
  [
    [Class Template with params]
    [
    [classref boost::tti::mf_has_template_check_params]
    ]
    [
    class HasTemplateCheckParams = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    ]
    [
    `BOOST_TTI_HAS_TEMPLATE_CHECK_PARAMS`
    
    `BOOST_TTI_VM_HAS_TEMPLATE_CHECK_PARAMS`
    ]
    [
    [headerref boost/tti/has_template_check_params.hpp `has_template_check_params.hpp`]
    
    [headerref boost/tti/vm_has_template_check_params.hpp `vm_has_template_check_params.hpp`]
    ]
  ]
  [
    [Member data]
    [
    [classref boost::tti::mf_has_member_data]
    ]
    [
    class HasMemberData = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    
    class R = type of member data nullary Metafunction
    ]
    [`BOOST_TTI_HAS_MEMBER_DATA`]
    [[headerref boost/tti/has_member_data.hpp `has_member_data.hpp`]]
  ]
  [
    [Member function]
    [
    [classref boost::tti::mf_has_member_function]
    ]
    [
    class HasMemberFunction = macro metafunction as lambda expression
    
    class T   = enclosing type nullary metafunction
    
    class R   = return value nullary metafunction
    
    class FS  = (optional) a Boost MPL forward sequence of parameter types as nullary metafunctions.
                The forward sequence as a type is not presented as a nullary metafunction.
                If there are no parameters, this may be omitted.
                
    class TAG = (optional) a Boost `function_types` tag type.
    ]
    [`BOOST_TTI_HAS_MEMBER_FUNCTION`]
    [[headerref boost/tti/has_member_function.hpp `has_member_function.hpp`]]
  ]
  [
    [Static data]
    [
    [classref boost::tti::mf_has_static_member_data]
    ]
    [
    class HasStaticMemberData = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    
    class R = type of static data nullary metafunction
    ]
    [`BOOST_TTI_HAS_STATIC_MEMBER_DATA`]
    [[headerref boost/tti/has_static_member_data.hpp `has_static_member_data.hpp`]]
  ]
  [
    [Static function]
    [
    [classref boost::tti::mf_has_static_member_function]
    ]
    [
    class HasStaticMemberFunction = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    
    class R = return value nullary metafunction
    
    class FS  = (optional) a Boost MPL forward sequence of parameter types as nullary metafunctions.
                The forward sequence as a type is not presented as a nullary metafunction.
                If there are no parameters, this may be omitted.
                
    class TAG = (optional) a Boost `function_types` tag type.
    ]
    [`BOOST_TTI_HAS_STATIC_MEMBER_FUNCTION`]
    [[headerref boost/tti/has_static_member_function.hpp `has_static_member_function.hpp`]]
  ]
]

Other than the use of nullary metafunctions, one other difference
in the nullary type metafunctions from their macro metafunction counterparts is 
that the signature for member functions and static member functions 
always involves individual types rather than the combined type notation which 
some of the macro metafunctions use. This allows us to specify nested types 
in those signatures without using the T::InnerType notation.

[heading Nullary type metafunction `member_type` equivalent]

Just as there exists the macro `BOOST_TTI_MEMBER_TYPE` for creating 
a macro metafunction which returns a nested type if it exists, else an unspecified 
marker type, there is also the equivalent nullary type metafunction.

[table:tbmetanested TTI Nested Type Nullary Type Metafunction
  [
    [Inner Element]
    [Template]
    [Parameters]
    [Macro Metafunction Passed]
    [Specific Header File]
  ]
  [
    [Type]
    [
    [classref boost::tti::mf_member_type]
    ]
    [
    class MemberType = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    ]
    [`BOOST_TTI_MEMBER_TYPE`]
    [[headerref boost/tti/member_type.hpp `member_type.hpp`]]
  ]
]

The difference between the macro metafunction `BOOST_TTI_MEMBER_TYPE` and  
`boost::tti::mf_member_type` is simply that, like the other nullary type metafunctions,
the latter takes its enclosing type as a nullary metafunction. Both produce the 
exact same result.

The use of this metafunction allows us to created deeply nested types, 
which may or may not exist, as nullary metafunctions in much the same way
that `BOOST_TTI_MEMBER_TYPE` can.

As an example, given the theoretical relationship of types we used before:

 struct T
   {
   struct AType
     {
     struct BType
       {
       struct CType
         {
         struct FindType
           {
           };
         }
       };
     };
   };
  
We can use `boost::tti::mf_member_type` as follows. First we create our corresponding macro metafunctions:

 BOOST_TTI_MEMBER_TYPE(FindType)
 BOOST_TTI_MEMBER_TYPE(AType)
 BOOST_TTI_MEMBER_TYPE(BType)
 BOOST_TTI_MEMBER_TYPE(CType)

Next we will create a typedef to reflect a nested type called FindType, as a nullary metafunction, 
which has the relationship as specified above, by using `boost::tti::mf_member_type`.

 typedef
 boost::tti::mf_member_type
   <
   member_type_FindType<_>,
   boost::tti::mf_member_type
     <
     member_type_CType<_>,
     boost::tti::mf_member_type
       <
       member_type_BType<_>,
       member_type_AType
         <
         T
         >
       >
     >
   > MyFindType;
  
The nested type created can then be used with the other nullary type metafunctions above
since it is itself a nullary metafunction.
The key information in understanding the code above is that the enclosing type, 
as in all of the nullary type metafunctions, is a nullary metafunction itself, 
which means that the enclosing type can be specified as the result 
of using `BOOST_TTI_MEMBER_TYPE` as well as the 
result of using `boost::tti::mf_member_type` itself. 

Both techniques are shown in the example 
above, and the same technique for creating nested types as nullary metafunctions 
can be used with the other functionality of the nullary type metafunctions when 
nested types are needed as 'types'.

Also similar to the macro metafunctions, we have an easy way of testing whether or not 
our `boost::tti::mf_member_type` nested type actually exists.

[table:existtbmetanested TTI Nested Type Nullary Type Metafunction Existence
  [
    [Inner Element]
    [Template]
    [Parameters]
    [Specific Header File]
  ]
  [
    [Type]
    [
    [classref boost::tti::mf_valid_member_type]
    ]
    [
    class T = a type as a nullary metafunction
    
    returns = true if the nullary metafunction's inner 'type' exists, false if it does not.
              'Existence' is determined by whether the type does not equal an unspecified type.
    ]
    [[headerref boost/tti/member_type.hpp `member_type.hpp`]]
  ]
]

Again note the difference here from the equivalent macro metafunction tester `boost::tti::valid_member_type`.
In the example above the type T is passed as a nullary metafunction holding the actual type, 
where for the macro metafunction equivalent the type T is passed as the actual type being tested.

[endsect]
