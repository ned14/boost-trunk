[/ 
  (C) Copyright Edward Diener 2011
  Use, modification and distribution are subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:tti_metafunctions Nullary Type Metafunctions]

The macro metafunctions provide a complete set of functionality for 
anything one would like to do using the TTI library. Invoking the 
metafunctions allows the template metaprogrammer to discover whether
a C++ type has inner elements of a particular name.

What is presented here is a set of named metafunctions, 
in the boost::tti namespace, which offer 
an alternative syntax for using the macro metafunctions. No new 
functionality is involved.

The macro metafunctions, like all metafunctions,
pass their parameters as types. When passing the 
result of one metafunction as a parameter to another metafunction, one 
is reaching into the first metafunction to access the nested 'type' 
of its instantiated result in order 
to pass it to another metafunction as a parameter. This is common 
metafunction usage, and is the syntax of the macro metafunctions as well.

An alternative use of metafunctions is to pass the instantiated metafunction itself
as a nullary metafunction, rather than its nested 'type' member, as a parameter to 
another metafunction. This is purely a syntactical advantage of not having to 
manually specify 'typename' and '::type' in order to extract the nested 'type' from the resulting
nullary metafunction. 

This what these named metafunctions do, and therefore they are 
differentiated from the macro metafunctions by the name 'nullary type metafunctions'.
The nullary type metafunctions reuse the macro metafunctions 
but pass other parameters which are classes as nullary metafunctions. 
While the syntactical advantage over the macro metafunctions is that one does not 
have to use 'typename' and pass the actual '::type' of a resultant metafunction instantiation, the 
disadvantage is that for class types which are not metafunction results one has to 
create a nullary metafunction by wrapping the class type with boost::mpl::identity.

Because the nullary type metafunctions reuse the metafunctions generated by the macro metafunctions,
the metafunction generated by a particular macro metafunction needs to 
be passed as metadata to a corresponding nullary type metafunction. As explained in Boost 
MPL, a metafunction as metadata is passed as a lambda expression, in the form of a metafunction 
class or a placeholder expression. This lambda expression is passed as the 
first parameter to each of our nullary type metafunctions. 

The exceptions to the use of nullary type metafunctions when specifying class 'types' are:

# When a Boost `function_types` tag type, which is optional, is specified as an addition to the 
function signature it is passed as is.

# When specifying a function signature and parameter types being passed,
the MPL forward sequence which contains the parameter 'types' is passed as is.

Whenever any type is not a class, it can passed to the nullary type metafunctions as is
or it can be passed as a nullary metafunction by wrapping it with boost::mpl::identity.
The nullary type metafunctions handle both situations but clearly it is easier to pass   
a known non-class type as is than having to wrap it with boost::mpl::identity.

For nested types, which may or may not exist, we can pass the resulting nullary 
metafunction generated by `BOOST_TTI_MEMBER_TYPE`, rather than its nested ::type, or its equivalent 
nullary type metafunction `boost::tti::mf_member_type` ( explained later ).

To use these metafunctions you need to include the main header file `boost/tti/tti.hpp`, 
unless otherwise noted. Alternatively you can include a specific header as given in the 
table below,

[tip 
The header files <boost/mpl/identity.hpp>, <boost/mpl/placeholders.hpp>, and 
<boost/mpl/quote.hpp> are included by 
the TTI header files whenever you include a general header file or a specific header file 
for a nullary type metafunction. 
Also the header file <boost/mpl/vector.hpp> is 
included by the general header file 'boost/tti/tti.hpp' or the specific header files which 
introspect functions, so if you use an MPL vector as your 
forward sequence wrapper for parameter types, you need not manually include the header file.
]

A table of the nullary type metafunctions is given, based on the inner element whose 
existence the metaprogrammer is introspecting. The arguments to the nullary type 
metafunctions are the same as those of their equivalent macro metafunction, which is  
passed as the first argument in the form of a Boost MPL lambda expression.

The actual syntax for each nullary type metafunction
can be found in the reference section,
and general examples of usage can be found in the 
[link sectti_usingNTM "Using the Nullary Type Metafunctions"] section.

All of the metafunctions are in the top-level 'boost::tti' namespace,
all have a particular name based on the type of its functionality, and all begin with 
the prefix 'mf_', representing the fact that they are metafunctions and to distinguish
them from any other constructs created by TTI in the boost::tti namespace.

[table:tbmetafunctions TTI Nullary Type Metafunctions
  [
    [Inner Element]
    [Template]
    [Parameters]
    [Macro Metafunction Passed]
    [Specific Header File]
  ]
  [
    [Type]
    [
    [classref boost::tti::mf_has_type]
    ]
    [
    class HasType = macro metafunction as lambda expression 
    
    class T = enclosing type nullary metafunction
    ]
    [`BOOST_TTI_HAS_TYPE`]
    [[headerref boost/tti/mf/mf_has_type.hpp `mf_has_type.hpp`]]
  ]
  [
    [Type with check]
    [
    [classref boost::tti::mf_has_type]
    ]
    [
    class HasType = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    
    class U = type to check against nullary metafunction
    ]
    [`BOOST_TTI_HAS_TYPE`]
    [[headerref boost/tti/mf/mf_has_type.hpp `mf_has_type.hpp`]]
  ]
  [
    [Class Template]
    [
    [classref boost::tti::mf_has_template]
    ]
    [
    class HasTemplate = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    ]
    [`BOOST_TTI_HAS_TEMPLATE`]
    [[headerref boost/tti/mf/mf_has_template.hpp `mf_has_template.hpp`]]
  ]
  [
    [Class Template with params]
    [
    [classref boost::tti::mf_has_template_check_params]
    ]
    [
    class HasTemplateCheckParams = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    ]
    [
    `BOOST_TTI_HAS_TEMPLATE_CHECK_PARAMS`
    
    `BOOST_TTI_VM_HAS_TEMPLATE_CHECK_PARAMS`
    ]
    [
    [headerref boost/tti/mf/mf_has_template_check_params.hpp `mf_has_template_check_params.hpp`]
    ]
  ]
  [
    [Member data]
    [
    [classref boost::tti::mf_has_member_data]
    ]
    [
    class HasMemberData = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    
    class R = type of member data nullary Metafunction
    ]
    [`BOOST_TTI_HAS_MEMBER_DATA`]
    [[headerref boost/tti/mf/mf_has_member_data.hpp `mf_has_member_data.hpp`]]
  ]
  [
    [Member function]
    [
    [classref boost::tti::mf_has_member_function]
    ]
    [
    class HasMemberFunction = macro metafunction as lambda expression
    
    class T   = enclosing type nullary metafunction
    
    class R   = return value nullary metafunction
    
    class FS  = (optional) a Boost MPL forward sequence of parameter types as nullary metafunctions.
                The forward sequence as a type is not presented as a nullary metafunction.
                If there are no parameters, this may be omitted.
                
    class TAG = (optional) a Boost `function_types` tag type.
    ]
    [`BOOST_TTI_HAS_MEMBER_FUNCTION`]
    [[headerref boost/tti/mf/mf_has_member_function.hpp `mf_has_member_function.hpp`]]
  ]
  [
    [Static data]
    [
    [classref boost::tti::mf_has_static_member_data]
    ]
    [
    class HasStaticMemberData = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    
    class R = type of static data nullary metafunction
    ]
    [`BOOST_TTI_HAS_STATIC_MEMBER_DATA`]
    [[headerref boost/tti/mf/mf_has_static_member_data.hpp `mf_has_static_member_data.hpp`]]
  ]
  [
    [Static function]
    [
    [classref boost::tti::mf_has_static_member_function]
    ]
    [
    class HasStaticMemberFunction = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    
    class R = return value nullary metafunction
    
    class FS  = (optional) a Boost MPL forward sequence of parameter types as nullary metafunctions.
                The forward sequence as a type is not presented as a nullary metafunction.
                If there are no parameters, this may be omitted.
                
    class TAG = (optional) a Boost `function_types` tag type.
    ]
    [`BOOST_TTI_HAS_STATIC_MEMBER_FUNCTION`]
    [[headerref boost/tti/mf/mf_has_static_member_function.hpp `mf_has_static_member_function.hpp`]]
  ]
]

The nullary type metafunctions have no equivalent to the macro metafunctions
which work with function types in their composite form. These are the macro metafunctions 
generated by the BOOST_TTI_MEMBER_FUNCTION_WITH_SIG and 
BOOST_TTI_STATIC_MEMBER_FUNCTION_WITH_SIG macros. The reason for this is that the
nullary type metafunctions work with individual types, and the ability to 
pass those individual types as nullary functions when they are class types.

[heading Nullary type metafunction `member_type` equivalent]

Just as there exists the macro `BOOST_TTI_MEMBER_TYPE` for creating 
a macro metafunction which returns a nested type if it exists, else an unspecified 
marker type, there is also the equivalent nullary type metafunction.

[table:tbmetanested TTI Nested Type Nullary Type Metafunction
  [
    [Inner Element]
    [Template]
    [Parameters]
    [Macro Metafunction Passed]
    [Specific Header File]
  ]
  [
    [Type]
    [
    [classref boost::tti::mf_member_type]
    ]
    [
    class MemberType = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    ]
    [`BOOST_TTI_MEMBER_TYPE`]
    [[headerref boost/tti/mf/mf_member_type.hpp `mf_member_type.hpp`]]
  ]
]

The difference between the macro metafunction `BOOST_TTI_MEMBER_TYPE` and  
`boost::tti::mf_member_type` is simply that, like the other nullary type metafunctions,
the latter takes its enclosing type as a nullary metafunction. Both produce the 
exact same result.

[heading Nullary type metafunction `valid_member_type` equivalent]

Also similar to the macro metafunctions, we have an easy way of testing whether or not 
our `boost::tti::mf_member_type` nested type actually exists.

[table:existtbmetanested TTI Nested Type Nullary Type Metafunction Existence
  [
    [Inner Element]
    [Template]
    [Parameters]
    [Specific Header File]
  ]
  [
    [Type]
    [
    [classref boost::tti::mf_valid_member_type]
    ]
    [
    class T = a type as a nullary metafunction
    
    returns = true if the nullary metafunction's inner 'type' exists, false if it does not.
              'Existence' is determined by whether the type does not equal an unspecified type.
    ]
    [[headerref boost/tti/mf/mf_member_type.hpp `mf_member_type.hpp`]]
  ]
]

Note the difference here from the equivalent macro metafunction tester `boost::tti::valid_member_type`.
In the table above the type T is passed as a nullary metafunction holding the actual type, 
where for the macro metafunction equivalent the type T is passed as the actual type being tested.

[endsect]
