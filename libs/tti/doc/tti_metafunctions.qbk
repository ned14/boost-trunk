[/ 
  (C) Copyright Edward Diener 2011
  Use, modification and distribution are subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:tti_metafunctions Nullary Type Metafunctions]

The macro metafunctions provide a complete set of functionality for 
anything one would like to do using the TTI library. Why then do we 
have another set of parallel functionality as nullary type metafunctions ?

The nullary type metafunctions parallel only those macro metafunctions in which types are specified
individually rather than in a composite manner. The individual types are passed to the nullary 
type metafunctions as nullary metafunctions, hence the name of this group of metafunctions.
They more easily allow a syntax where nested types can be specified without needing to manually 
reach into the 'type' member of `BOOST_TTI_MEMBER_TYPE` or the 'type' member of its nullary type 
metafunction equivalent called `boost::tti::mf_member_type`.

In a very real way the nullary type metafunctions exist just to provide syntactic improvements
over the macro metafunctions and are not needed to use the library, since all of the library 
functionality is already provided with the macro metafunctions. Nonetheless syntactic ease of use 
is a goal of the TTI library and therefore these metafunctions are provided to allow 
that syntactic improvement.

The nullary type metafunctions reuse the metafunctions generated by the macro metafunctions.
To do this the resulting metafunction generated by a particular macro metafunction needs to 
be passed as metadata to a corresponding nullary type metafunction.
  
A lambda expression, in the form of a metafunction class or a placeholder expression, is passed as the 
first parameter to our nullary type metafunctions. We have already seen how the TTI library supplies
metafunction classes through the use of metafunction class macros for each of the macro metafunctions. 
The end-user can use these metafunction classes directly, or can use placeholder expressions with the 
metafunctions generated by the macro metafunctions.

The remaining parameters passed to the nullary type metafunctions are 'types'. These 'types' always consist 
first of the enclosing type and then 
possibly other types which make up the signature of whatever inner element we are introspecting. Each of these
'types' is passed as a nullary metafunction whose typedef 'type' is the actual type.

The exception to this use of nullary type metafunctions when specifying 'types' is when a Boost 
`function_types` tag type, which is optional, is specified as an addition to the function signature. 
Also when dealing with a function signature and parameter types being passed, while the 
parameter 'types' themselves are in the form of nullary metafunctions, the MPL forward sequence 
which contains the parameter 'types' is a plain type and should not be wrapped as a nullary metafunction.

For a type which is in scope, we can always use 
boost::mpl::identity to create our nullary metafunction, and there can never be a compiler error for
such known types as long as declarations for them exist or they are built-in C++ types.
For nested types, which may or may not exist, we can pass the resulting nullary metafunction generated by 
`BOOST_TTI_MEMBER_TYPE`, or its equivalent nullary type metafunction 
`boost::tti::mf_member_type` ( explained later ).

To use these metafunctions you need to include the main header file `tti.hpp`, unless otherwise noted.
Alternatively you can include a specific header as given in the table below,

[tip 
The header files <boost/mpl/identity.hpp> and <boost/mpl/placeholders.hpp> are included by 
the TTI header files whenever you include a general header file or a specific header file 
for a nullary type metafunction, so you need not 
manually include it in order to wrap a known type as a nullary 
metafunction or use a placeholder expression. Also the header file <boost/mpl/vector.hpp> is 
included by the general header file 'tti.hpp' or the specific header files which introspect functions, 
so if you use an MPL vector as your 
forward sequence wrapper for parameter types, you need not manually include the header file.
]

A table of these metafunctions is given, based on the inner element whose 
existence the metaprogrammer is introspecting. A more detailed explanation can be found 
in the reference section, and examples of usage can be found in the 
[link sectti_usingNTM "Using the Nullary Type Metafunctions"] section.
All of the metafunctions are in the top-level 'boost::tti' namespace,
all have a particular name based on the type of its functionality, and all begin with the prefix 
'mf_' so as not to conflict with the macro metafunction names generated by the library.

[table:tbmetafunctions TTI Nullary Type Metafunctions
  [
    [Inner Element]
    [Template]
    [Parameters]
    [Macro Equivalent]
    [Specific Header File]
  ]
  [
    [Type]
    [
    [classref boost::tti::mf_has_type]
    ]
    [
    class HasType = macro metafunction as lambda expression 
    
    class T = enclosing type nullary metafunction
    ]
    [`BOOST_TTI_HAS_TYPE`]
    [[headerref boost/tti/type.hpp `type.hpp`]]
  ]
  [
    [Type with check]
    [
    [classref boost::tti::mf_has_type]
    ]
    [
    class HasType = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    
    class U = type to check against nullary metafunction
    ]
    [`BOOST_TTI_HAS_TYPE`]
    [[headerref boost/tti/type.hpp `type.hpp`]]
  ]
  [
    [Class Template]
    [
    [classref boost::tti::mf_has_template]
    ]
    [
    class HasTemplate = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    ]
    [`BOOST_TTI_HAS_TEMPLATE`]
    [[headerref boost/tti/template.hpp `template.hpp`]]
  ]
  [
    [Class Template with params]
    [
    [classref boost::tti::mf_has_template_check_params]
    ]
    [
    class HasTemplateCheckParams = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    ]
    [
    `BOOST_TTI_HAS_TEMPLATE_CHECK_PARAMS`
    
    `BOOST_TTI_VM_HAS_TEMPLATE_CHECK_PARAMS`
    ]
    [
    [headerref boost/tti/template_params.hpp `template_params.hpp`]
    
    [headerref boost/tti/vm_template_params.hpp `vm_template_params.hpp`]
    ]
  ]
  [
    [Member data]
    [
    [classref boost::tti::mf_has_member_data]
    ]
    [
    class HasMemberData = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    
    class R = type of member data nullary Metafunction
    ]
    [`BOOST_TTI_HAS_MEMBER_DATA`]
    [[headerref boost/tti/mem_data.hpp `mem_data.hpp`]]
  ]
  [
    [Member function]
    [
    [classref boost::tti::mf_has_member_function]
    ]
    [
    class HasMemberFunction = macro metafunction as lambda expression
    
    class T   = enclosing type nullary metafunction
    
    class R   = return value nullary metafunction
    
    class FS  = (optional) a Boost MPL forward sequence of parameter types as nullary metafunctions.
                The forward sequence as a type is not presented as a nullary metafunction.
                If there are no parameters, this may be omitted.
                
    class TAG = (optional) a Boost `function_types` tag type.
    ]
    [`BOOST_TTI_HAS_MEMBER_FUNCTION`]
    [[headerref boost/tti/mem_fun.hpp `mem_fun.hpp`]]
  ]
  [
    [Static data]
    [
    [classref boost::tti::mf_has_static_member_data]
    ]
    [
    class HasStaticMemberData = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    
    class R = type of static data nullary metafunction
    ]
    [`BOOST_TTI_HAS_STATIC_MEMBER_DATA`]
    [[headerref boost/tti/static_mem_data.hpp `static_mem_data.hpp`]]
  ]
  [
    [Static function]
    [
    [classref boost::tti::mf_has_static_member_function]
    ]
    [
    class HasStaticMemberFunction = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    
    class R = return value nullary metafunction
    
    class FS  = (optional) a Boost MPL forward sequence of parameter types as nullary metafunctions.
                The forward sequence as a type is not presented as a nullary metafunction.
                If there are no parameters, this may be omitted.
                
    class TAG = (optional) a Boost `function_types` tag type.
    ]
    [`BOOST_TTI_HAS_STATIC_MEMBER_FUNCTION`]
    [[headerref boost/tti/static_mem_fun.hpp `static_mem_fun.hpp`]]
  ]
]

Other than the use of nullary metafunctions, one other difference
in the nullary type metafunctions from their macro metafunction counterparts is 
that the signature for member functions and static member functions 
always involves individual types rather than the combined type notation which 
some of the macro metafunctions use. This allows us to specify nested types 
in those signatures without using the T::InnerType notation.

[heading Nullary type metafunction `member_type` equivalent]

Just as there exists the macro `BOOST_TTI_MEMBER_TYPE` for creating 
a macro metafunction which returns a nested type if it exists, else an unspecified 
type, there is also the equivalent nullary type metafunction.

[table:tbmetanested TTI Nested Type Nullary Type Metafunction
  [
    [Inner Element]
    [Template]
    [Parameters]
    [Macro Equivalent]
    [Specific Header File]
  ]
  [
    [Type]
    [
    [classref boost::tti::mf_member_type]
    ]
    [
    class MemberType = macro metafunction as lambda expression
    
    class T = enclosing type nullary metafunction
    ]
    [`BOOST_TTI_MEMBER_TYPE`]
    [[headerref boost/tti/mem_type.hpp `mem_type.hpp`]]
  ]
]

The difference between the macro metafunction `BOOST_TTI_MEMBER_TYPE` and  
`boost::tti::mf_member_type` is simply that, like the other nullary type metafunctions,
the latter takes its enclosing type as a nullary metafunction. Both produce the 
exact same result.

The use of this metafunction allows us to created deeply nested types, 
which may or may not exist, as nullary metafunctions in much the same way
that `BOOST_TTI_MEMBER_TYPE` can. The difference is 
the simpler syntax when using `boost::tti::mf_member_type`.

As an example, given the theoretical relationship of types we used before:

 struct T
   {
   struct AType
     {
     struct BType
       {
       struct CType
         {
         struct FindType
           {
           };
         }
       };
     };
   };
  
We can use `boost::tti::mf_member_type` as follows. First we create our corresponding macro metafunctions:

 BOOST_TTI_MEMBER_TYPE(FindType)
 BOOST_TTI_MEMBER_TYPE(AType)
 BOOST_TTI_MEMBER_TYPE(BType)
 BOOST_TTI_MEMBER_TYPE(CType)

Next we will create a typedef to reflect a nested type called FindType, as a nullary metafunction, 
which has the relationship as specified above, by using `boost::tti::mf_member_type`.

 typedef
 boost::tti::mf_member_type
   <
   boost::tti::member_type_FindType<_>,
   boost::tti::mf_member_type
     <
     boost::tti::member_type_CType<_>,
     boost::tti::mf_member_type
       <
       boost::tti::member_type_BType<_>,
       boost::tti::member_type_AType
         <
         T
         >
       >
     >
   > MyFindType;
  
The nested type created can then be used with the other nullary type metafunctions above
since it is itself a nullary metafunction.
The key information in understanding the code above is that the enclosing type, 
as in all of the nullary type metafunctions, is a nullary metafunction itself, 
which means that the enclosing type can be specified as the result 
of using `BOOST_TTI_MEMBER_TYPE` as well as the 
result of using `mf_member_type` itself. 

Both techniques are shown in the example 
above, and the same technique for creating nested types as nullary metafunctions 
can be used with the other functionality of the nullary type metafunctions when 
nested types are needed as 'types'.

Also similar to the macro metafunctions, we have an easy way of testing whether or not 
our `boost::tti::mf_member_type` nested type actually exists.

[table:existtbmetanested TTI Nested Type Nullary Type Metafunction Existence
  [
    [Inner Element]
    [Template]
    [Parameters]
    [Specific Header File]
  ]
  [
    [Type]
    [
    [classref boost::tti::mf_valid_member_type]
    ]
    [
    class T = a type as a nullary metafunction
    
    returns = true if the nullary metafunction's inner 'type' exists, false if it does not.
              'Existence' is determined by whether the type does not equal an unspecified type.
    ]
    [[headerref boost/tti/mem_type.hpp `mem_type.hpp`]]
  ]
]

Again note the difference here from the equivalent macro metafunction tester `boost::tti::valid_member_type`.
In the example above the type T is passed as a nullary metafunction holding the actual type, 
where for the macro metafunction equivalent the type T is passed as the actual type being tested.

In our next section we will look at examples of nullary type metafunction use.

[endsect]
