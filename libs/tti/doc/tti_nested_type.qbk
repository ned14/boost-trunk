[/ 
  (C) Copyright Edward Diener 2011,2012
  Use, modification and distribution are subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:tti_nested_type Nested Types]

[heading The problem]

One of the goals of the TTI library is never to produce a compiler error by just 
using the functionality in the library, whether it is invoking its function-like macros 
or instantiating the macro metafunctions created by them, and whether the inner element exists 
or not. In this sense The TTI library macros for introspecting an enclosing type for 
an inner element work well. But there is one exception to this general case.
That exception is the crux of the discussion regarding nested types which follows.

The metafunctions generated by the TTI macros all work with types, whether in specifying
an enclosing type or in specifying the type of some inner element, which may also involve 
types in the signature of that element, such as a parameter or return type of a function. 
The C++ notation for a nested type, given an enclosing type 'T' and an inner type 'InnerType', 
is 'T::InnerType'. If either the enclosing type 'T' does not exist, or the inner type 'InnerType' 
does not exist within 'T', the expression 'T::InnerType' will give a compiler error if we attempt 
to use it in our template instantiation of one of TTI's macro metafunctions.

This is a problem if we want to be able to introspect for the existence of inner elements 
to an enclosing type without producing compiler errors. Of course if we absolutely know what 
types we have and that a nested type exists, and these declarations are within our scope, we can 
always use an expression like 'T::InnerType' without compiler error. But this is often not the 
case when doing template programming since the type being passed to us at compile-time in a class 
or function template is chosen at instantiation time and is created by the user of a template.

One solution to this is afforded by the library itself. Given an enclosing type 'T' 
which we know must exist, either because it is a top-level type we know about or 
it is passed to us in some template as a 'class T' or 'typename T', and given an inner type 
named 'InnerType' whose existence we would like ascertain, we can use a `BOOST_TTI_HAS_TYPE(InnerType)` 
macro and it's related `has_type_InnerType` metafunction to determine if the nested type 'InnerType' 
exists. This solution is perfectly valid, and in conjunction with Boost MPL's selection metafunctions, 
we can do compile-time selection to generate the correct template code.

However this does not scale that well syntactically if we need to drill down further 
from a top-level enclosing type to a deeply nested type, or even to look for some deeply nested 
type's inner elements. We are going to be generating a great deal of `boost::mpl::if_` and/or 
`boost::mpl::eval_if` type selection statements to get to some final condition where we know we 
can generate the compile-time code which we want.

[heading The solution]

The TTI library offers a solution in the form of a construct which works with a 
nested type without producing a compiler error if the nested type does not exist, while still 
allowing us to introspect inner elements using such a potentially non-existing nested type.

This is a metafunction created by the macro [macroref BOOST_TTI_MEMBER_TYPE]. The macro takes
a single parameter, which is the name of a type. We will call this our 'named type'. 
The macro generates a metafunction called `member_type_'named_type'` which, passed an enclosing type, 
returns the named type if it exists, else an unspecified marker type internal to the TTI library 
if it does not.

Its general explanation is given as:

[table:tbmacronested TTI Nested Type Macro Metafunction
  [
    [Inner Element]
    [Macro]
    [Template]
    [Specific Header File]
  ]
  [
    [Type]
    [
    [macroref BOOST_TTI_MEMBER_TYPE](name)
    ]
    [
    `member_type_'name'`
    
    class T = enclosing type
    
    returns = the type of 'name' if it exists, else an unspecified type, as the typedef 'type'.
    ]
    [[headerref boost/tti/member_type.hpp `member_type.hpp`]]
  ]
]

A simple example:

 #include <boost/tti/member_type.hpp>
 
 BOOST_TTI_MEMBER_TYPE(ANamedType)
 
 typedef typename member_type_ANamedType<EnclosingType>::type AType;
 
If type 'ANamedType' is a nested type of 'EnclosingType' then
AType is the same type as 'ANamedType', otherwise AType is a  
type internal to the TTI library. In either case AType could   
further be used as a type in template programming, even if 
'EnclosingType::ANamedType' did not exist.

If, on the other hand, we had to specify Atype as 'EnclosingType::ANamedType'
in template programming, this would lead to a compiler error if this type
did not exist at the point of instantiation.

[heading A nested type example]

We can use the functionality of `BOOST_TTI_MEMBER_TYPE` to construct nested types
for our other macro metafunctions, without having to use the T::InnerType syntax and produce a compiler 
error if no such type actually exists within our scope. We can even do this in deeply nested contexts 
by stringing together, so to speak, a series of these macro metafunction results.

As an example, given a type T, let us create a metafunction where there is a nested type FindType
whose enclosing type is eventually T, as represented by the following structure:

 struct T
   {
   struct AType
     {
     struct BType
       {
       struct CType
         {
         struct FindType
           {
           };
         }
       };
     };
   };

In our TTI code we first create a series of member type macros for each of our nested 
types:

 BOOST_TTI_MEMBER_TYPE(FindType)
 BOOST_TTI_MEMBER_TYPE(AType)
 BOOST_TTI_MEMBER_TYPE(BType)
 BOOST_TTI_MEMBER_TYPE(CType)

Next we can create a typedef to reflect a nested type called FindType which has the relationship
as specified above by instantiating our macro metafunctions. We have to do this in the reverse
order of our hypothetical 'struct T' above since the metafunction `BOOST_TTI_MEMBER_TYPE` takes
its enclosing type as its template parameter.

 typedef typename
 member_type_FindType
   <
   typename member_type_CType
     <
     typename member_type_BType
       <
       typename member_type_AType
         <
         T
         >::type
       >::type
     >::type
   >::type MyFindType;
  
We can use the above typedef to pass the type as FindType 
to one of our macro metafunctions. FindType may not actually exist but we will not generate 
a compiler error when we use it. It will only generate, if it does not exist, an eventual 
failure by having whatever metafunction uses such a type return a false value at compile-time.

As one example, let's ask whether FindType has a static member data called MyData of type 'int'. 
We add:

 BOOST_TTI_HAS_STATIC_MEMBER_DATA(MyData)

Next we create our metafunction:

 has_static_member_data_MyData
   <
   MyFindType,
   int
   >
  
and use this in our metaprogramming code. Our metafunction now tells us whether the nested type 
FindType has a static member data called MyData of type 'int', even if FindType does not actually 
exist as we have specified it as a type. If we had tried to do this using normal C++ nested type
notation our metafunction code above would be:

 boost::tti::has_static_member_data_MyData
   <
   typename T::AType::BType::CType::FindType,
   int
   >
   
But this fails with a compiler error if there is no such nested type, and 
that is exactly what we do not want in our compile-time metaprogramming code.

in the above metafunction we are asking whether or not FindType has a static 
member data element called 'MyData', and the result will be 'false' if either 
FindType does not exist or if it does exist but does not have a static member data 
of type 'int' called 'MyData'. In neither situation will we produce a compiler error.

[heading Existence of nested type]

In some situations we may also be interested in ascertaining whether the deeply nested 
type 'FindType' actually exists. Our metafunction, using BOOST_TTI_MEMBER_TYPE 
and repeating our macros from above, would be:

 BOOST_TTI_MEMBER_TYPE(FindType)
 BOOST_TTI_MEMBER_TYPE(AType)
 BOOST_TTI_MEMBER_TYPE(BType)
 BOOST_TTI_MEMBER_TYPE(CType)

 BOOST_TTI_HAS_TYPE(FindType)

 has_type_FindType
   <
   typename
   member_type_CType
     <
     typename
     member_type_BType
       <
       typename
       member_type_AType
         <
         T
         >::type
       >::type
     >::type
   >
  
But this duplicates much of our code when we generated the 'MyFindType' typedef, so
it would be much better if we could simply pass our originally typedefed
'MyFindType' type to some other metafunction which would tell us directly if 'MyFindType' 
actually exists. 

And so we can ! 

The TTI library has a specifically named metafunction,
called 'boost::tti::valid_member_type', which takes a type and determines 
if it 'actually exists', returning the compile-time boolean constant called 'value' 
of 'true' if it does or 'false' if it does not. The meaning of 'actually exists',
as far as 'boost::tti::valid_member_type' is concerned, is that the type does not
equal the unspecified type which BOOST_TTI_MEMBER_TYPE returns when its nested type 
does not exist. Therefore 'boost::tti::valid_member_type' is meant to be used 
with the return 'type' of BOOST_TTI_MEMBER_TYPE, which is what 'MyFindType' represents.

The general explanation of 'boost::tti::valid_member_type' is given as:

[table:existtbmacronested TTI Nested Type Macro Metafunction Existence
  [
    [Inner Element]
    [Macro]
    [Template]
    [Specific Header File]
  ]
  [
    [Type]
    [None]
    [
    [classref boost::tti::valid_member_type]
    
    class T = a type
    
    returns = true if the type exists, false if it does not.
              'Existence' is determined by whether the type 
              does not equal the unspecified type of BOOST_TTI_MEMBER_TYPE
              when the type does not exist.
    ]
    [[headerref boost/tti/member_type.hpp `member_type.hpp`]]
  ]
]

Using this functionality with our 'MyFindType' type above 
we could create the nullary metafunction:

 boost::tti::valid_member_type
   <
   MyFindType
   >
 
directly instead of replicating the same functionality with our 'boost::tti::has_type_FindType' 
metafunction.

[endsect]
