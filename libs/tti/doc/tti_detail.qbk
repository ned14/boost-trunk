[/ 
  (C) Copyright Edward Diener 2011
  Use, modification and distribution are subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt).
]

[section:tti_detail Macro Metafunctions]

The TTI library uses macros to create metafunctions, in the boost::tti namespace, 
for introspecting an inner element by name. Each macro for a particular type of inner 
element has two forms, the simple one where the first macro parameter designating the 
'name' of the inner element is used to create the name of the metafunction, and the 
complex one where the first macro parameter, called 'trait', designates 
the name of the metafunction and the second macro parameter designates the 'name' to be 
introspected. Other than that difference, the two forms of the macro produce the exact same 
results.

To use these metafunctions you can include the main general header file 'tti.hpp',
unless otherwise noted. Alternatively you can include a specific header file as 
given in the table below.

A table of these macros is given, based on the inner element whose 
existence the metaprogrammer is introspecting. A more detailed explanation can be found 
in the reference section, and examples of usage can be found in the 
[link sectti_usingMM "Using the Macro Metafunctions"] section.
In the Template column only the name generated by the simple form 
of the template is given since the name generated by the complex form is always boost::tti::trait 
where 'trait' is the first parameter to the corresponding complex form macro. All of the 
introspecting metafunctions in the table below return a boolean constant called 'value', which 
specifies whether or not the inner element exists.

[table:tbmacros TTI Macro Metafunctions
  [
    [Inner Element]
    [Macro]
    [Template]
    [Specific Header File]
  ]
  [
    [Type]
    [
    [macroref BOOST_TTI_HAS_TYPE](name)
    ]
    [
    `boost::tti::has_type_'name'`
    
    class T = enclosing type
    ]
    [[headerref boost/tti/type.hpp `type.hpp`]]
  ]
  [
    [Type with check]
    [
    [macroref BOOST_TTI_HAS_TYPE](name)
    ]
    [
    `boost::tti::has_type_'name'`
    
    class T = enclosing type
    
    class U = type to check against
    ]
    [[headerref boost/tti/type.hpp `type.hpp`]]
  ]
  [
    [Class Template]
    [
    [macroref BOOST_TTI_HAS_TEMPLATE](name)
    ]
    [
    `boost::tti::has_template_'name'`
    
    class T = enclosing type
    
    All of the template parameters must be 'class' ( or 'typename' ) parameters
    ]
    [[headerref boost/tti/template.hpp `template.hpp`]]
  ]
  [
    [Class Template with params]
    [
    [macroref BOOST_TTI_HAS_TEMPLATE_CHECK_PARAMS](name,ppSeq[footnote A Boost PP data sequence with each comma separated portion of the template parameters as its own sequence element.])
    ]
    [
    `boost::tti::has_template_check_params_'name'`
    
    class T = enclosing type
    ]
    [[headerref boost/tti/template_params.hpp `template_params.hpp`]]
  ]
  [
    [Class Template with params using variadic macros[footnote General header file is `tti_vm.hpp`.]]
    [
    [macroref BOOST_TTI_VM_HAS_TEMPLATE_CHECK_PARAMS](name,...[footnote The template parameters as variadic data.])
    ]
    [
    `boost::tti::has_template_check_params_'name'`
    
    class T = enclosing type
    ]
    [[headerref boost/tti/vm_template_params.hpp `vm_template_params.hpp`]]
  ]
  [
    [Member data]
    [
    [macroref BOOST_TTI_HAS_MEMBER_DATA](name)
    ]
    [
    `boost::tti::has_member_data_'name'`
    
    class T = enclosing type
    
    class R = data type
    ]
    [[headerref boost/tti/mem_data.hpp `mem_data.hpp`]]
  ]
  [
    [Member function as individual types]
    [
    [macroref BOOST_TTI_HAS_MEMBER_FUNCTION](name)
    ]
    [
    `boost::tti::has_member_function_'name'`
    
    class T   = enclosing type
    
    class R   = return type
    
    class FS  = (optional) function parameter types as a Boost MPL forward sequence.
                If there are no function parameters this does not have to be specified.
                Defaults to boost::mpl::vector<>.
    
    class TAG = (optional) Boost `function_types` tag type.
                Defaults to `boost::function_types::null_tag`.
    ]
    [[headerref boost/tti/mem_fun.hpp `mem_fun.hpp`]]
  ]
  [
    [Member function as a composite type]
    [
    [macroref BOOST_TTI_HAS_COMP_MEMBER_FUNCTION](name)
    ]
    [
    `boost::tti::has_comp_member_function_'name'`
    
    class T = pointer to member function
    
    The form for T is 'ReturnType (Class::*)(Zero or more comma-separated parameter types)'
    ]
    [[headerref boost/tti/comp_mem_fun.hpp `comp_mem_fun.hpp`]]
  ]
  [
    [Static member data]
    [
    [macroref BOOST_TTI_HAS_STATIC_MEMBER_DATA](name)
    ]
    [
    `boost::tti::has_static_member_data_'name'`
    
    class T = enclosing type
    
    class Type = data type
    ]
    [[headerref boost/tti/static_mem_data.hpp `static_mem_data.hpp`]]
  ]
  [
    [Static member function as individual types]
    [
    [macroref BOOST_TTI_HAS_STATIC_MEMBER_FUNCTION](name)
    ]
    [
    `boost::tti::has_static_member_function_'name'`
    
    class T   = enclosing type
    
    class R   = return type
    
    class FS  = (optional) function parameter types as a Boost MPL forward sequence.
                If there are no function parameters this does not have to be specified.
                Defaults to boost::mpl::vector<>.
    
    class TAG = (optional) Boost `function_types` tag type.
                Defaults to `boost::function_types::null_tag`.
    ]
    [[headerref boost/tti/static_mem_fun.hpp `static_mem_fun.hpp`]]
  ]
  [
    [Static member function as a composite type]
    [
    [macroref BOOST_TTI_HAS_COMP_STATIC_MEMBER_FUNCTION](name)
    ]
    [
    `boost::tti::has_comp_static_member_function_'name'`
    
    class T = enclosing type
    
    class Type = function type
    
    The form for Type is 'ReturnType (Zero or more comma-separated parameter types)'
    ]
    [[headerref boost/tti/comp_static_mem_fun.hpp `comp_static_mem_fun.hpp`]]
  ]
]

There is one other macro which creates a metafunction which does not introspect
for the existence of an inner element type, but is very useful nonetheless. 
Instead the macro metafunction created returns the nested type if it exists, else 
it returns an unspecified type.

[table:tbmacronested TTI Nested Type Macro Metafunction
  [
    [Inner Element]
    [Macro]
    [Template]
    [Specific Header File]
  ]
  [
    [Type]
    [
    [macroref BOOST_TTI_MEMBER_TYPE](name)
    ]
    [
    `boost::tti::member_type_'name'`
    
    class T = enclosing type
    
    returns = the type of 'name' if it exists, else an unspecified type, as a typedef 'type'.
    ]
    [[headerref boost/tti/mem_type.hpp `mem_type.hpp`]]
  ]
]

Along with this macro metafunction we have another metafunction which, when passed a 'type',
which can be any type but which will generally be used with the type returned by
invoking the metafunction generated by `BOOST_TTI_MEMBER_TYPE`, will tell us whether the type exists
or not as a boolean constant.

[table:existtbmacronested TTI Nested Type Macro Metafunction Existence
  [
    [Inner Element]
    [Macro]
    [Template]
    [Specific Header File]
  ]
  [
    [Type]
    [None]
    [
    [classref boost::tti::valid_member_type]
    
    class T = a type
    
    returns = true if the type exists, false if it does not.
              'Existence' is determined by whether the type does not equal an unspecified type.
    ]
    [[headerref boost/tti/mem_type.hpp `mem_type.hpp`]]
  ]
]

The usefulness of the `BOOST_TTI_MEMBER_TYPE` macro metafunction will be shown 
in the next topic when I explain the problem of specifying nested types and how TTI solves 
it.

[endsect]
