[/============================================================================
  Boost.odeint

  Copyright (c) 2009-2012 Karsten Ahnert
  Copyright (c) 2009-2012 Mario Mulansky

  Use, modification and distribution is subject to the Boost Software License,
  Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
  http://www.boost.org/LICENSE_1_0.txt)
=============================================================================/]


[section Iterators and Ranges]



odeint supports iterators for iterating through an ordinary differential equation. They offer you an alternative to the integrate functions. Furthermore, many of the standard algorithms in the C++ standard library and Boost.Range can be used with the odeint's iterators.

[import ../examples/const_step_iterator.cpp]

Four iterators are provided. They are all single pass iterators. The first one is a iterator which solves the odeint with constant step size. An example is 

[const_step_iterator_accumulate]

In this example all x-values of the solution are accumulated. The iterator itself does not occur directly in this example but it is generated by the factory functions `make_const_step_iterator_begin` and `make_const_step_iterator_end`. odeint also supports Boost.Range, that is you write the above example in a more succinct form with the factory function `make_const_step_range`

[const_step_iterator_accumulate_range]

The second iterator type is also a iterator with const step size. But the value type of this iterator consists here of a pair of the time and the state of the solution of the ODE. An example is

[const_step_time_iterator_accumulate_range]

The factory functions are now `make_const_step_time_iterator_begin`, `make_const_step_time_iterator_end` and `make_const_step_time_range`.


[import ../examples/adaptive_iterator.cpp]

The other two iterator types adaptive iterators which are completely analogous to the const step iterators. Examples are

[adaptive_iterator_accumulate_range]

[adaptive_time_iterator_accumulate_range]


[section const_step_iterator]

* Definition: `const_step_iterator< Stepper , System >`
* `value_type` is `Stepper::state_type`
* Factory functions
  * `make_const_step_iterator_begin( stepper , system , state , t_start , t_end , dt )`
  * `make_const_step_iterator_end( stepper , system , state )`
  * `make_const_step_range( stepper , system , state , t_start , t_end , dt )`
* This stepper works with all steppers fulfilling the Stepper concept or the DenseOutputStepper concept.
* This stepper updates the value of `state`. The value of `state` is the current state of the ODE during the iteration.

[endsect]

[section const_step_time_iterator]

* Definition: `const_step_iterator< Stepper , System >`
* `value_type` is `std::pair< Stepper::state_type& , Stepper::time_type >`
* Factory functions
  * `make_const_step_time_iterator_begin( stepper , system , state , t_start , t_end , dt )`
  * `make_const_step_time_iterator_end( stepper , system , state )`
  * `make_const_step_time_range( stepper , system , state , t_start , t_end , dt )`
* This stepper works with all steppers fulfilling the Stepper concept or the DenseOutputStepper concept.
* This stepper updates the value of `state`. The value of `state` is the current state of the ODE during the iteration.


[endsect]


[section adaptive_step_iterator]

* Definition: `adaptive_iterator< Stepper , System >`
* `value_type` is `Stepper::state_type`
* Factory functions
  * `make_adaptive_iterator_begin( stepper , system , state , t_start , t_end , dt )`
  * `make_adaptive_iterator_end( stepper , system , state )`
  * `make_adaptive_range( stepper , system , state , t_start , t_end , dt )`
* This stepper works with all steppers fulfilling the ControlledStepper concept or the DenseOutputStepper concept.
* For steppers fulfilling the ControlledStepper concept `state` is modified according to the current state of the ODE. For DenseOutputStepper the state is not modified due to performance optimizations.


[endsect]

[section adaptive_step_time_iterator]

* Definition: `adaptive_iterator< Stepper , System >`
* `value_type` is `std::pair< Stepper::state_type& , Stepper::time_type >`
* Factory functions
  * `make_adaptive_time_iterator_begin( stepper , system , state , t_start , t_end , dt )`
  * `make_adaptive_time_iterator_end( stepper , system , state )`
  * `make_adaptive_time_range( stepper , system , state , t_start , t_end , dt )`
* This stepper works with all steppers fulfilling the ControlledStepper concept or the DenseOutputStepper concept.
* This stepper updates the value of `state`. The value of `state` is the current state of the ODE during the iteration.


[endsect]






[endsect]
