<?xml version="1.0" encoding="utf-8"?>
<header name="boost/proto/transform/let.hpp">
  <para>
    Contains definition of the
    <computeroutput><classname alt="boost::proto::let">proto::let&lt;&gt;</classname></computeroutput>
    transform and the
    <computeroutput><classname alt="boost::proto::local">proto::local&lt;&gt;</classname></computeroutput>
    placeholder.
  </para>
  <namespace name="boost">
    <namespace name="proto">
      <struct name="local">
        <template>
          <template-type-parameter name="T"/>
        </template>
        <purpose>
          A placeholder for a local variable in a
          <computeroutput><classname>proto::let</classname>&lt;&gt;</computeroutput>
          transform.
        </purpose>
      </struct>

      <struct name="let">
        <template>
          <template-type-parameter name="T" pack="1"/>
        </template>
        
        <inherit><classname>proto::transform</classname>&lt; let&lt;T...&gt; &gt;</inherit>
        
        <purpose>A <conceptname>PrimitiveTransform</conceptname> that has the effect of saving
        the results of transforms in local variables so they can be referred to from other
        transforms.</purpose>
        
        <description>
          <para>
            The purpose of <computeroutput>proto::let&lt;&gt;</computeroutput> is to make it
            possible to save the results of transforms in local variables so they can be referred
            to from other transforms.
          </para>

          <para>
            Take as an example a transform that computes a <computeroutput>std::pair&lt;&gt;</computeroutput>
            and saves the result into a temporary object. Then, it increments the value stored in
            <computeroutput>second</computeroutput> and returns a new pair. It might look like this:
          </para>
          
          <para>
            <programlisting>using proto::_a;
using proto::functional::make_pair;
using proto::functional::first;
using proto::functional::second;

struct inc_second
  : proto::let&lt;
        // make a pair and initialize _a with it.
        _a(make_pair(proto::_value, proto::_state))
        // use _a to make a new pair with the first element
        // of _a and the incremented second element.
      , make_pair(first(_a), mpl::next&lt;second(_a)&gt;())
    &gt;
{};

int main()
{
    proto::literal&lt;char const *&gt; hello("hello");
    std::pair&lt;char const *, mpl::int_&lt;1&gt; &gt; p =
        inc_second()(hello, mpl::int_&lt;0&gt;());
}</programlisting>
          </para>

          <para>
            <computeroutput>proto::let&lt;&gt;</computeroutput> requires that the first
            (N-1) template parameters are of the form <computeroutput><replaceable>_x</replaceable>(<conceptname>Transform</conceptname>)</computeroutput>,
            where <computeroutput><replaceable>_x</replaceable></computeroutput> is an instance of
            <computeroutput><classname>proto::local</classname>&lt;&gt;</computeroutput>
            like <computeroutput>proto::_a</computeroutput>. Also, the <replaceable>N</replaceable>th
            parameter must be a <conceptname>Transform</conceptname>.
          </para>

          <para>
            For the full description of the behavior of the
            <computeroutput>proto::let&lt;&gt;</computeroutput>
            transform, see the documentation for the nested
            <computeroutput><classname alt="proto::let::impl">proto::let::impl&lt;&gt;</classname></computeroutput>
            class template.
          </para>
        </description>

        <struct name="impl">
          <template>
            <template-type-parameter name="Expr"/>
            <template-type-parameter name="State"/>
            <template-type-parameter name="Data"/>
          </template>
          <inherit><classname>proto::transform_impl</classname>&lt; Expr, State, Data &gt;</inherit>
          <typedef name="result_type">
            <type><emphasis>see-below</emphasis></type>
            <description>
              <para>
                <computeroutput><classname>proto::let</classname>&lt;L<subscript>0</subscript>(I<subscript>0</subscript>),...L<subscript>n</subscript>(I<subscript>n</subscript>), T&gt;::impl&lt;Expr, State, Data&gt;::result_type</computeroutput> is
                computed as follows:
              </para>
              <para>
                Let <computeroutput>T<superscript>'</superscript></computeroutput> be a new transform such that
                every <computeroutput>L<subscript>i</subscript></computeroutput> in <computeroutput>T</computeroutput>
                is lexically replaced with
                <computeroutput><classname>proto::when</classname>&lt;<classname>_</classname>, I<subscript>i</subscript>&gt;</computeroutput>,
                with the exception noted below.
              </para>
              <para>
                In the case of nested <computeroutput><classname>proto::let</classname>&lt;&gt;</computeroutput> transforms,
                lexical substitution proceeds inside-out; that is, substitution of the innermost <computeroutput>let&lt;&gt;</computeroutput>
                is done first. This is to ensure that local variables are found in the innermost lexical scope in which they appear.
              </para>
              <para>
                <computeroutput>result_type</computeroutput> is
                <computeroutput><classname>proto::when</classname>&lt;<classname>_</classname>,
                    T<superscript>'</superscript>&gt;::impl&lt;Expr, State, Data&gt;::result_type</computeroutput>.
              </para>
              <para>
                Note: local variables have no visibility outside of the transform <computeroutput>T</computeroutput>.
                That is, one local variable cannot participate in the initialization of another in the same
                <computeroutput>let&lt;&gt;</computeroutput> transform.
              </para>
            </description>
          </typedef>
          <method-group name="public member functions">
            <method name="operator()" cv="const">
              <type>result_type</type>
              <parameter name="expr">
                <paramtype>typename impl::expr_param</paramtype>
              </parameter>
              <parameter name="state">
                <paramtype>typename impl::state_param</paramtype>
              </parameter>
              <parameter name="data">
                <paramtype>typename impl::data_param</paramtype>
              </parameter>
              <description>
                <para>
                  <computeroutput><classname>proto::let</classname>&lt;L<subscript>0</subscript>(I<subscript>0</subscript>),...L<subscript>n</subscript>(I<subscript>n</subscript>), T&gt;::impl&lt;Expr,State,Data&gt;::operator()</computeroutput>
                  behaves as follows:
                </para>
                <para>
                  For each <computeroutput>i</computeroutput> in <computeroutput>[0,n]</computeroutput>, let
                  <computeroutput>X<subscript>i</subscript></computeroutput> be a hidden temporary object initialized with
                  <computeroutput><classname>proto::when</classname>&lt;<classname>_</classname>, I<subscript>i</subscript>&gt;::impl&lt;Expr, State, Data&gt;()(expr, state, data)</computeroutput>.
                  The temporary objects <computeroutput>X<subscript>i</subscript></computeroutput> belong to the
                  lexical scope of the current <computeroutput>let&lt;&gt;</computeroutput> transform. (Nested
                  <computeroutput>let&lt;&gt;</computeroutput> transforms have their own lexical scopes with
                  their own hidden temporary objects.)
                </para>
                <para>
                  For each <computeroutput>i</computeroutput> in <computeroutput>[0,n]</computeroutput>, 
                  define a <conceptname>PrimitiveTransform</conceptname> <computeroutput>GetLocal<subscript>i</subscript></computeroutput>
                  that returns the nearest lexically scoped hidden temporary object <computeroutput>X<subscript>i</subscript></computeroutput>.
                </para>
                <para>
                  Let <computeroutput>T<superscript>'</superscript></computeroutput> be a new transform such that
                  every <computeroutput>L<subscript>i</subscript></computeroutput> in <computeroutput>T</computeroutput>
                  is lexically replaced with <computeroutput>GetLocal<subscript>i</subscript></computeroutput>.
                </para>
                <para>
                  Note: local variables have no visibility outside of the transform <computeroutput>T</computeroutput>.
                  That is, one local variable cannot participate in the initialization of another in the same
                  <computeroutput>let&lt;&gt;</computeroutput> transform.
                </para>
              </description>
              <returns><computeroutput><classname>proto::when</classname>&lt;<classname>_</classname>,
                  T<superscript>'</superscript>&gt;::impl&lt;Expr, State, Data&gt;()(expr, state, data)</computeroutput>
              </returns>
            </method>
          </method-group>
        </struct>
      </struct>
    </namespace>
  </namespace>
</header>
