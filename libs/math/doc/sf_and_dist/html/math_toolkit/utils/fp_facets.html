<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Facets for Floating-Point Infinities and NaNs</title>
<link rel="stylesheet" href="../../../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.74.0">
<link rel="home" href="../../index.html" title="Math Toolkit">
<link rel="up" href="../utils.html" title="Floating Point Utilities">
<link rel="prev" href="sign_functions.html" title="Sign Manipulation Functions">
<link rel="next" href="next_float.html" title="Floating-Point Representation Distance (ULP), and Finding Adjacent Floating-Point Values">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../../../boost.png"></td>
<td align="center"><a href="../../../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="sign_functions.html"><img src="../../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../utils.html"><img src="../../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="next_float.html"><img src="../../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section" lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a name="math_toolkit.utils.fp_facets"></a><a class="link" href="fp_facets.html" title="Facets for Floating-Point Infinities and NaNs">Facets for Floating-Point
      Infinities and NaNs</a>
</h3></div></div></div>
<a name="math_toolkit.utils.fp_facets.synopsis"></a><h5>
<a name="id1123356"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.synopsis">Synopsis</a>
      </h5>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">math</span>
<span class="special">{</span>
  <span class="comment">// Values for flags. 
</span>  <span class="keyword">const</span> <span class="keyword">int</span> <span class="identifier">legacy</span><span class="special">;</span>
  <span class="keyword">const</span> <span class="keyword">int</span> <span class="identifier">signed_zero</span><span class="special">;</span>
  <span class="keyword">const</span> <span class="keyword">int</span> <span class="identifier">trap_infinity</span><span class="special">;</span>
  <span class="keyword">const</span> <span class="keyword">int</span> <span class="identifier">trap_nan</span><span class="special">;</span>

  <span class="keyword">template</span><span class="special">&lt;</span>
      <span class="keyword">class</span> <span class="identifier">CharType</span><span class="special">,</span>
      <span class="keyword">class</span> <span class="identifier">OutputIterator</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostreambuf_iterator</span><span class="special">&lt;</span><span class="identifier">CharType</span><span class="special">&gt;</span> 
  <span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">nonfinite_num_put</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">num_put</span><span class="special">&lt;</span><span class="identifier">CharType</span><span class="special">,</span> <span class="identifier">OutputIterator</span><span class="special">&gt;</span>
  <span class="special">{</span> 
  <span class="keyword">public</span><span class="special">:</span>
      <span class="keyword">explicit</span> <span class="identifier">nonfinite_num_put</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="number">0</span><span class="special">);</span>
  <span class="special">};</span>

  <span class="keyword">template</span><span class="special">&lt;</span>
      <span class="keyword">class</span> <span class="identifier">CharType</span><span class="special">,</span>
      <span class="keyword">class</span> <span class="identifier">InputIterator</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">istreambuf_iterator</span><span class="special">&lt;</span><span class="identifier">CharType</span><span class="special">&gt;</span>
  <span class="special">&gt;</span>
  <span class="keyword">class</span> <span class="identifier">nonfinite_num_get</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">num_get</span><span class="special">&lt;</span><span class="identifier">CharType</span><span class="special">,</span> <span class="identifier">InputIterator</span><span class="special">&gt;</span>
  <span class="special">{</span>
  <span class="keyword">public</span><span class="special">:</span>
      <span class="keyword">explicit</span> <span class="identifier">nonfinite_num_get</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="number">0</span><span class="special">);</span>  <span class="comment">// legacy, sign_zero ...
</span>  <span class="special">};</span> 
<span class="special">}}</span> <span class="comment">// namespace boost namespace math
</span></pre>
<p>
        To use these facets
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">\</span><span class="identifier">math</span><span class="special">\</span><span class="identifier">special_functions</span><span class="special">\</span><span class="identifier">nonfinite_num_facets</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
</pre>
<a name="math_toolkit.utils.fp_facets.introduction"></a><h5>
<a name="id1123877"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.introduction">Introduction</a>
      </h5>
<a name="math_toolkit.utils.fp_facets.the_problem"></a><h6>
<a name="id1123890"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.the_problem">The Problem</a>
      </h6>
<p>
        The C++98 standard does not specify how infinity and NaN are represented
        in text streams. As a result, different platforms use different string representations.
        This can cause undefined behavior when text files are moved between different
        platforms. Some platforms cannot even input parse their own output! So 'route-tripping'
        or loopback of output to input is not possible. For instance, the following
        test fails with MSVC:
      </p>
<pre class="programlisting"><span class="identifier">stringstream</span> <span class="identifier">ss</span><span class="special">;</span>
<span class="keyword">double</span> <span class="identifier">inf</span> <span class="special">=</span> <span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;::</span><span class="identifier">infinity</span><span class="special">();</span>
<span class="keyword">double</span> <span class="identifier">r</span><span class="special">;</span>
<span class="identifier">ss</span> <span class="special">&lt;&lt;</span> <span class="identifier">inf</span><span class="special">;</span> <span class="comment">// Write out.
</span><span class="identifier">ss</span> <span class="special">&gt;&gt;</span> <span class="identifier">r</span><span class="special">;</span> <span class="comment">// Read back in.
</span>
<span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"infinity output was "</span> <span class="special">&lt;&lt;</span> <span class="identifier">inf</span> <span class="special">&lt;&lt;</span> <span class="identifier">endl</span><span class="special">;</span> <span class="comment">// 1.#INF
</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"infinity input was "</span> <span class="special">&lt;&lt;</span> <span class="identifier">r</span> <span class="special">&lt;&lt;</span> <span class="identifier">endl</span><span class="special">;</span> <span class="comment">// 1
</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">inf</span> <span class="special">==</span> <span class="identifier">y</span><span class="special">);</span> <span class="comment">// Fails!
</span></pre>
<a name="math_toolkit.utils.fp_facets.the_solution"></a><h6>
<a name="id1124130"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.the_solution">The Solution</a>
      </h6>
<p>
        The facets <code class="computeroutput"><span class="identifier">nonfinite_num_put</span></code>
        and <code class="computeroutput"><span class="identifier">nonfinite_num_get</span></code> format
        and parse all floating-point numbers, including <code class="computeroutput"><span class="identifier">infinity</span></code>
        and <code class="computeroutput"><span class="identifier">NaN</span></code>, in a consistent
        and portable manner.
      </p>
<p>
        The following test succeeds with MSVC.
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="identifier">locale</span> <span class="identifier">old_locale</span><span class="special">;</span>
<span class="identifier">locale</span> <span class="identifier">tmp_locale</span><span class="special">(</span><span class="identifier">old_locale</span><span class="special">,</span> <span class="keyword">new</span> <span class="identifier">nonfinite_num_put</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;);</span>
<span class="identifier">locale</span> <span class="identifier">new_locale</span><span class="special">(</span><span class="identifier">tmp_locale</span><span class="special">,</span> <span class="keyword">new</span> <span class="identifier">nonfinite_num_get</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;);</span>
</pre>
<p>
      </p>
<div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../../../../../../../doc/src/images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
          To add two facets, <code class="computeroutput"><span class="identifier">nonfinite_num_put</span></code>
          and <code class="computeroutput"><span class="identifier">nonfinite_num_get</span></code>,
          you have to add one at a time, using a temporary locale.
        </p></td></tr>
</table></div>
<p>
        
</p>
<pre class="programlisting"><span class="identifier">stringstream</span> <span class="identifier">ss</span><span class="special">;</span>
<span class="identifier">ss</span><span class="special">.</span><span class="identifier">imbue</span><span class="special">(</span><span class="identifier">new_locale</span><span class="special">);</span>
<span class="keyword">double</span> <span class="identifier">inf</span> <span class="special">=</span> <span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;::</span><span class="identifier">infinity</span><span class="special">();</span>
<span class="identifier">ss</span> <span class="special">&lt;&lt;</span> <span class="identifier">inf</span><span class="special">;</span> <span class="comment">// Write out.
</span><span class="identifier">assert</span><span class="special">(</span><span class="identifier">ss</span><span class="special">.</span><span class="identifier">str</span><span class="special">()</span> <span class="special">==</span> <span class="string">"inf"</span><span class="special">);</span>
    <span class="keyword">double</span> <span class="identifier">r</span><span class="special">;</span>
<span class="identifier">ss</span> <span class="special">&gt;&gt;</span> <span class="identifier">r</span><span class="special">;</span> <span class="comment">// Read back in.
</span><span class="identifier">assert</span><span class="special">(</span><span class="identifier">inf</span> <span class="special">==</span> <span class="identifier">r</span><span class="special">);</span> <span class="comment">// Confirms that the double values really are identical.
</span>
<span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"infinity output was "</span> <span class="special">&lt;&lt;</span> <span class="identifier">ss</span><span class="special">.</span><span class="identifier">str</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">endl</span><span class="special">;</span>
<span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"infinity input was "</span> <span class="special">&lt;&lt;</span> <span class="identifier">r</span> <span class="special">&lt;&lt;</span> <span class="identifier">endl</span><span class="special">;</span>
<span class="comment">// But the string representation of r displayed will be the native type
</span><span class="comment">// because, when it was constructed, cout had NOT been imbued 
</span><span class="comment">// with the new locale containing the nonfinite_numput facet.
</span><span class="comment">// So the cout output will be "1.#INF on MS platforms
</span><span class="comment">// and may be "inf" or other string representation on other platforms.
</span>
</pre>
<p>
      </p>
<a name="math_toolkit.utils.fp_facets.c__0x_standard_for_output_of_infinity_and_nan"></a><h5>
<a name="id1124613"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.c__0x_standard_for_output_of_infinity_and_nan">C++0X
        standard for output of infinity and NaN</a>
      </h5>
<p>
        <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf" target="_top">C++0X
        (final) draft standard</a> does not explicitly specify the representation
        (and input) of nonfinite values, leaving it implementation-defined. So without
        some specific action, input and output of nonfinite values is not portable.
      </p>
<a name="math_toolkit.utils.fp_facets.c99_standard_for_output_of_infinity_and_nan"></a><h5>
<a name="id1124635"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.c99_standard_for_output_of_infinity_and_nan">C99
        standard for output of infinity and NaN</a>
      </h5>
<p>
        The <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf" target="_top">C99
        standard</a> <span class="bold"><strong>does</strong></span> specify how infinity
        and NaN are formatted by printf and similar output functions, and parsed
        by scanf and similar input functions.
      </p>
<p>
        The following string representations are used:
      </p>
<div class="table">
<a name="math_toolkit.utils.fp_facets.c99_representation_of_infinity_and_nan"></a><p class="title"><b>Table&#160;50.&#160;C99 Representation of Infinity and NaN</b></p>
<div class="table-contents"><table class="table" summary="C99 Representation of Infinity and NaN">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  number
                </p>
              </th>
<th>
                <p>
                  string
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  Positive infinity
                </p>
              </td>
<td>
                <p>
                  "inf" or "infinity"
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  Positive NaN
                </p>
              </td>
<td>
                <p>
                  "nan" or "nan(...)"
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  Negative infinity
                </p>
              </td>
<td>
                <p>
                  "-inf" or "-infinity"
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  Negative NaN
                </p>
              </td>
<td>
                <p>
                  "-nan" or "-nan(...)"
                </p>
              </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><p>
        So following C99 provides a sensible 'standard' way of handling input and
        output of nonfinites in C++, and this implementation follows most of these
        formats.
      </p>
<a name="math_toolkit.utils.fp_facets.signaling_nans"></a><h6>
<a name="id1124785"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.signaling_nans">Signaling NaNs</a>
      </h6>
<p>
        A particular type of NaN is the signaling NaN. The usual mechanism of signaling
        is by raising a floating-point exception. Signaling NaNs are defined by
        <a href="http://en.wikipedia.org/wiki/IEEE_floating-point_standard" target="_top">IEEE
        754-2008</a>.
      </p>
<p>
        Floating-point values with layout <span class="emphasis"><em>s</em></span>111 1111 1<span class="emphasis"><em>a</em></span>xx
        xxxx xxxx xxxx xxxx xxxx where <span class="emphasis"><em>s</em></span> is the sign, <span class="emphasis"><em>x</em></span>
        is the payload, and bit <span class="emphasis"><em>a</em></span> determines the type of NaN.
      </p>
<p>
        If bit <span class="emphasis"><em>a</em></span> = 1, it is a quiet NaN.
      </p>
<p>
        If bit <span class="emphasis"><em>a</em></span> is zero and the payload <span class="emphasis"><em>x</em></span>
        is nonzero, then it is a signaling NaN.
      </p>
<p>
        Although there has been theoretical interest in the ability of a signaling
        NaN to raise an exception, for example to prevent use of an uninitialised
        variable, in practice there appears to be no useful application of signaling
        NaNs for most current processors. <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf" target="_top">C++0X
        18.3.2.2</a> still specifies a (implementation-defined) representation
        for signaling NaN, and <code class="computeroutput"><span class="keyword">static</span> <span class="identifier">constexpr</span> <span class="keyword">bool</span>
        <span class="identifier">has_signaling_NaN</span></code> a method of checking
        if a floating-point type has a representation for signaling NaN.
      </p>
<p>
        But in practice, most platforms treat signaling NaNs in the same as quiet
        NaNs. So, for example, they are represented by "nan" on output
        in <a href="http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf" target="_top">C99</a>
        format, and output as <code class="computeroutput"><span class="number">1.</span><span class="preprocessor">#QNAN</span></code>
        by Microsoft compilers.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>
          The C99 standard does not distinguish between the quiet NaN and signaling
          NaN values. A quiet NaN propagates through almost every arithmetic operation
          without raising a floating-point exception; a signaling NaN generally raises
          a floating-point exception when occurring as an arithmetic operand.
        </p>
<p>
          C99 specification does not define the behavior of signaling NaNs. NaNs
          created by IEC 60559 operations are always quiet. Therefore this implementation
          follows C99, and treats the signaling NaN bit as just a part of the NaN
          payload field. So this implementation does not distinguish between the
          two classes of NaN.
        </p>
</td></tr>
</table></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>
          An implementation may give zero and non-numeric values (such as infinities
          and NaNs) a sign or may leave them unsigned. Wherever such values are unsigned,
          any requirement in the C99 Standard to retrieve the sign shall produce
          an unspecified sign, and any requirement to set the sign shall be ignored.
        </p>
<p>
          This might apply to user-defined types, but in practice built-in floating-point
          types <code class="computeroutput"><span class="keyword">float</span></code>, <code class="computeroutput"><span class="keyword">double</span></code> and <code class="computeroutput"><span class="keyword">long</span>
          <span class="keyword">double</span></code> have well-behaved signs.
        </p>
</td></tr>
</table></div>
<p>
        The numbers can be of type <code class="computeroutput"><span class="keyword">float</span></code>,
        <code class="computeroutput"><span class="keyword">double</span></code> and <code class="computeroutput"><span class="keyword">long</span>
        <span class="keyword">double</span></code>. An optional + sign can be
        used with positive numbers (controlled by ios manipulator <code class="computeroutput"><span class="identifier">showpos</span></code>).
        The function <code class="computeroutput"><span class="identifier">printf</span></code> and similar
        C++ functions use standard formatting flags to put all lower or all upper
        case (controlled by <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ios</span></code> manipulator <code class="computeroutput"><span class="identifier">uppercase</span></code>
        and <code class="computeroutput"><span class="identifier">lowercase</span></code>).
      </p>
<p>
        The function <code class="computeroutput"><span class="identifier">scanf</span></code> and similar
        input functions are case-insensitive.
      </p>
<p>
        The dots in <code class="computeroutput"><span class="identifier">nan</span><span class="special">(...)</span></code>
        stand for an arbitrary string. The meaning of that string is implementation
        dependent. It can be used to convey extra information about the NaN, from
        the 'payload'. A particular value of the payload might be used to indicate
        a <span class="emphasis"><em>missing value</em></span>, for example.
      </p>
<p>
        This library uses the string representations specified by the C99 standard.
      </p>
<p>
        An example of an implementation that optionally includes the NaN payload
        information is at <a href="http://publib.boulder.ibm.com/infocenter/zos/v1r10/index.jsp?topic=/com.ibm.zos.r10.bpxbd00/fprints.htm" target="_top">AIX
        NaN fprintf</a>. That implementation specifies for Binary Floating Point
        NANs:
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
            A NaN ordinal sequence is a left-parenthesis character '(', followed
            by a digit sequence representing an integer n, where 1 &lt;= n &lt;=
            INT_MAX-1, followed by a right-parenthesis character ')'.
          </li>
<li>
            The integer value, n, is determined by the fraction bits of the NaN argument
            value as follows:
          </li>
<li>
            For a signalling NaN value, NaN fraction bits are reversed (left to right)
            to produce bits (right to left) of an even integer value, 2*n. Then formatted
            output functions produce a (signalling) NaN ordinal sequence corresponding
            to the integer value n.
          </li>
<li>
            For a quiet NaN value, NaN fraction bits are reversed (left to right)
            to produce bits (right to left) of an odd integer value, 2*n-1. Then
            formatted output functions produce a (quiet) NaN ordinal sequence corresponding
            to the integer value n.
          </li>
</ul></div>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../../../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
          This implementation does not (yet) provide output of, or access to, the
          NaN payload.
        </p></td></tr>
</table></div>
<a name="math_toolkit.utils.fp_facets.reference"></a><h5>
<a name="id1126220"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.reference">Reference</a>
      </h5>
<a name="math_toolkit.utils.fp_facets.the_facet__code__phrase_role__identifier__nonfinite_num_put__phrase___code_"></a><h6>
<a name="id1126233"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.the_facet__code__phrase_role__identifier__nonfinite_num_put__phrase___code_">The
        Facet <code class="computeroutput"><span class="identifier">nonfinite_num_put</span></code></a>
      </h6>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span>
  <span class="keyword">class</span> <span class="identifier">CharType</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">OutputIterator</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostreambuf_iterator</span><span class="special">&lt;</span><span class="identifier">CharType</span><span class="special">&gt;</span>
        <span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">nonfinite_num_put</span><span class="special">;</span>
</pre>
<p>
        The <code class="computeroutput"><span class="keyword">class</span> <span class="identifier">nonfinite_num_put</span><span class="special">&lt;</span><span class="identifier">CharType</span><span class="special">,</span> <span class="identifier">OutputIterator</span><span class="special">&gt;</span></code> is derived from <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">num_put</span><span class="special">&lt;</span><span class="identifier">CharType</span><span class="special">,</span> <span class="identifier">OutputIterator</span><span class="special">&gt;</span></code>. Thus it is a facet that formats numbers.
        The first template argument is the character type of the formatted strings,
        usually <code class="computeroutput"><span class="keyword">char</span></code> or <code class="computeroutput"><span class="keyword">wchar_t</span></code>. The second template argument is the
        type of iterator used to write the strings. It is required to be an output
        iterator. Usually the default <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostreambuf_iterator</span></code>
        is used. The public interface of the class consists of a single constructor
        only:
      </p>
<pre class="programlisting"><span class="identifier">nonfinite_num_put</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="number">0</span><span class="special">);</span>
</pre>
<p>
        The flags argument (effectively optional because a default of <code class="computeroutput"> <span class="identifier">no_flags</span></code> is provided) is discussed below.
        The class template <code class="computeroutput"><span class="identifier">nonfinite_num_put</span></code>
        is defined in the header <code class="computeroutput"><span class="identifier">boost</span><span class="special">/</span><span class="identifier">math</span><span class="special">/</span><span class="identifier">nonfinite_num_facets</span><span class="special">.</span><span class="identifier">hpp</span></code> and lives in the namespace <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">math</span></code>.
      </p>
<p>
        Unlike the C++ Standard facet <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">num_put</span></code>,
        the facet <code class="computeroutput"><span class="identifier">nonfinite_num_put</span></code>
        formats <code class="computeroutput"><span class="identifier">infinity</span></code> and <code class="computeroutput"><span class="identifier">NaN</span></code> in a consistent and portable manner.
        It uses the following string representations:
      </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Number
                </p>
              </th>
<th>
                <p>
                  String
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  Positive infinity
                </p>
              </td>
<td>
                <p>
                  inf
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  Positive NaN
                </p>
              </td>
<td>
                <p>
                  nan
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  Negative infinity
                </p>
              </td>
<td>
                <p>
                  -inf
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  Negative NaN
                </p>
              </td>
<td>
                <p>
                  -nan
                </p>
              </td>
</tr>
</tbody>
</table></div>
<p>
        The numbers can be of type <code class="computeroutput"><span class="keyword">float</span></code>,
        <code class="computeroutput"><span class="keyword">double</span></code> and <code class="computeroutput"><span class="keyword">long</span>
        <span class="keyword">double</span></code>. The strings can be in all
        lower case or all upper case. An optional + sign can be used with positive
        numbers. This can be controlled with the <code class="computeroutput"><span class="identifier">uppercase</span></code>,
        <code class="computeroutput"><span class="identifier">lowercase</span></code>, <code class="computeroutput"><span class="identifier">showpos</span></code> and <code class="computeroutput"><span class="identifier">noshowpos</span></code>
        manipulators. Formatting of integers, boolean values and finite floating-point
        numbers is simply delegated to the normal <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">num_put</span></code>.
      </p>
<a name="math_toolkit.utils.fp_facets.facet__code__phrase_role__identifier__nonfinite_num_get__phrase___code_"></a><h6>
<a name="id1126746"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.facet__code__phrase_role__identifier__nonfinite_num_get__phrase___code_">Facet
        <code class="computeroutput"><span class="identifier">nonfinite_num_get</span></code></a>
      </h6>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">CharType</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">InputIterator</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">istreambuf_iterator</span><span class="special">&lt;</span><span class="identifier">CharType</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="keyword">class</span> <span class="identifier">nonfinite_num_get</span><span class="special">;</span>
</pre>
<p>
        The class <code class="computeroutput"><span class="identifier">nonfinite_num_get</span><span class="special">&lt;</span><span class="identifier">CharType</span><span class="special">,</span> <span class="identifier">InputIterator</span><span class="special">&gt;</span></code> is derived from <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">num_get</span><span class="special">&lt;</span><span class="identifier">CharType</span><span class="special">,</span> <span class="identifier">IntputIterator</span><span class="special">&gt;</span></code>. Thus it is a facet that parses strings
        that represent numbers. The first template argument is the character type
        of the strings, usually <code class="computeroutput"><span class="keyword">char</span></code>
        or <code class="computeroutput"><span class="keyword">wchar_t</span></code>. The second template
        argument is the type of iterator used to read the strings. It is required
        to be an input iterator. Usually the default is used. The public interface
        of the class consists of a single constructor only:
      </p>
<pre class="programlisting"><span class="identifier">nonfinite_num_get</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">flags</span> <span class="special">=</span> <span class="number">0</span><span class="special">);</span>
</pre>
<p>
        The flags argument is discussed below. The <code class="computeroutput"><span class="keyword">class</span>
        <span class="keyword">template</span> <span class="identifier">nonfinite_num_get</span></code>
        is defined in the header <code class="computeroutput"><span class="identifier">boost</span><span class="special">/</span><span class="identifier">math</span><span class="special">/</span><span class="identifier">nonfinite_num_facets</span><span class="special">.</span><span class="identifier">hpp</span></code> and lives in the <code class="computeroutput"><span class="keyword">namespace</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">math</span></code>.
      </p>
<p>
        Unlike the facet <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">num_get</span></code>, the facet <code class="computeroutput"><span class="identifier">nonfinite_num_get</span></code>
        parses strings that represent <code class="computeroutput"><span class="identifier">infinity</span></code>
        and <code class="computeroutput"><span class="identifier">NaN</span></code> in a consistent and
        portable manner. It recognizes precisely the string representations specified
        by the C99 standard:
      </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Number
                </p>
              </th>
<th>
                <p>
                  String
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  Positive infinity
                </p>
              </td>
<td>
                <p>
                  inf, infinity
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  Positive NaN
                </p>
              </td>
<td>
                <p>
                  nan, nan(...)
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  Negative infinity
                </p>
              </td>
<td>
                <p>
                  -inf, -infinity
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  Negative NaN
                </p>
              </td>
<td>
                <p>
                  -nan, -nan(...)
                </p>
              </td>
</tr>
</tbody>
</table></div>
<p>
        The numbers can be of type <code class="computeroutput"><span class="keyword">float</span></code>,
        <code class="computeroutput"><span class="keyword">double</span></code> and <code class="computeroutput"><span class="keyword">long</span>
        <span class="keyword">double</span></code>. The facet is case-insensitive.
        An optional + sign can be used with positive numbers. The dots in nan(...)
        stand for an arbitrary string usually containing the <span class="emphasis"><em>NaN payload</em></span>.
        Parsing of strings that represent integers, boolean values and finite floating-point
        numbers is delegated to <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">num_get</span></code>.
      </p>
<p>
        When the facet parses a string that represents <code class="computeroutput"><span class="identifier">infinity</span></code>
        on a platform that lacks infinity, then the fail bit of the stream is set.
      </p>
<p>
        When the facet parses a string that represents <code class="computeroutput"><span class="identifier">NaN</span></code>
        on a platform that lacks NaN, then the fail bit of the stream is set.
      </p>
<a name="math_toolkit.utils.fp_facets.flags"></a><h5>
<a name="id1127243"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.flags">Flags</a>
      </h5>
<p>
        The constructors for <code class="computeroutput"><span class="identifier">nonfinite_num_put</span></code>
        and <code class="computeroutput"><span class="identifier">nonfinite_num_get</span></code> take
        an optional bit flags argument. There are four different bit flags:
      </p>
<div class="itemizedlist"><ul type="disc">
<li>
            legacy
          </li>
<li>
            signed_zero
          </li>
<li>
            trap_infinity
          </li>
<li>
            trap_nan
          </li>
</ul></div>
<p>
        The flags can be combined with the OR <code class="computeroutput"><span class="keyword">operator</span><span class="special">|</span></code>.
      </p>
<p>
        The flags are defined in the header <code class="computeroutput"><span class="identifier">boost</span><span class="special">/</span><span class="identifier">math</span><span class="special">/</span><span class="identifier">nonfinite_num_facets</span><span class="special">.</span><span class="identifier">hpp</span></code> and live in the <code class="computeroutput"><span class="keyword">namespace</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">math</span></code>.
      </p>
<a name="math_toolkit.utils.fp_facets.legacy"></a><h6>
<a name="id1127373"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.legacy">legacy</a>
      </h6>
<p>
        The legacy flag has no effect with the output facet <code class="computeroutput"><span class="identifier">nonfinite_num_put</span></code>.
      </p>
<p>
        If the legacy flag is used with the <code class="computeroutput"><span class="identifier">nonfinite_num_get</span></code>
        input facet, then the facet will recognize all the following string representations
        of <code class="computeroutput"><span class="identifier">infinity</span></code> and <code class="computeroutput"><span class="identifier">NaN</span></code>:
      </p>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                <p>
                  Number
                </p>
              </th>
<th>
                <p>
                  String
                </p>
              </th>
</tr></thead>
<tbody>
<tr>
<td>
                <p>
                  Positive infinity
                </p>
              </td>
<td>
                <p>
                  inf, infinity, one#inf
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  Positive NaN
                </p>
              </td>
<td>
                <p>
                  nan, nan(...), nanq, nans, qnan, snan, one#ind, one#qnan, one#snan
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  Negative infinity
                </p>
              </td>
<td>
                <p>
                  -inf, -infinity, -one#inf
                </p>
              </td>
</tr>
<tr>
<td>
                <p>
                  Negative NaN
                </p>
              </td>
<td>
                <p>
                  -nan, -nan(...), -nanq, -nans, -qnan, -snan, -one#ind, - one#qnan,
                  -one#snan
                </p>
              </td>
</tr>
</tbody>
</table></div>
<p>
        The numbers can be of type <code class="computeroutput"><span class="keyword">float</span></code>,
        <code class="computeroutput"><span class="keyword">double</span></code> and <code class="computeroutput"><span class="keyword">long</span>
        <span class="keyword">double</span></code>. The facet is case-insensitive.
        An optional <code class="computeroutput"><span class="special">+</span></code> sign can be used
        with the positive values. The dots in <code class="computeroutput"><span class="identifier">nan</span><span class="special">(...)</span></code> stand for an arbitrary string. <code class="computeroutput"><span class="identifier">one</span></code> stands for any string that <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">num_get</span></code>
        parses as the number <code class="computeroutput"><span class="number">1.</span></code>.
      </p>
<p>
        The list includes a number of non-standard string representations of infinity
        and NaN that are used by various existing implementations of the C++ standard
        library, and also string representations used by other programming languages.
      </p>
<a name="math_toolkit.utils.fp_facets.signed_zero"></a><h6>
<a name="id1127613"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.signed_zero">signed_zero</a>
      </h6>
<p>
        If the <code class="computeroutput"><span class="identifier">signed_zero</span></code> flag is
        used with <code class="computeroutput"><span class="identifier">nonfinite_num_put</span></code>,
        then the facet will distinguish between positive and negative zero. It will
        format positive zero as "0" or "+0" and negative zero
        as "-0". The string representation of positive zero can be controlled
        with the <code class="computeroutput"><span class="identifier">showpos</span></code> and <code class="computeroutput"><span class="identifier">noshowpos</span></code> manipulators.
      </p>
<p>
        The <code class="computeroutput"><span class="identifier">signed_zero</span> <span class="identifier">flag</span></code>
        has no effect with the input facet <code class="computeroutput"><span class="identifier">nonfinite_num_get</span></code>.
        The input facet <code class="computeroutput"><span class="identifier">nonfinite_num_get</span></code>
        always parses "0" and "+0" as positive zero and "-0"
        as negative zero, as do most implementations of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">num_get</span></code>.
      </p>
<a name="math_toolkit.utils.fp_facets.trap_infinity"></a><h6>
<a name="id1127703"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.trap_infinity">trap_infinity</a>
      </h6>
<p>
        If the <code class="computeroutput"><span class="identifier">trap_infinity</span></code> flag
        is used with <code class="computeroutput"><span class="identifier">nonfinite_num_put</span></code>,
        then the facet will throw an exception of type <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">failure</span></code>
        when an attempt is made to format positive or negative infinity. If the facet
        is called from a stream insertion operator, then the stream will catch that
        exception and set either its <code class="computeroutput"><span class="identifier">fail</span>
        <span class="identifier">bit</span></code> or its <code class="computeroutput"><span class="identifier">bad</span>
        <span class="identifier">bit</span></code>. Which bit is set is platform
        dependent.
      </p>
<p>
        If the <code class="computeroutput"><span class="identifier">trap_infinity</span></code> flag
        is used with <code class="computeroutput"><span class="identifier">nonfinite_num_get</span></code>,
        then the facet will set the <code class="computeroutput"><span class="identifier">fail</span>
        <span class="identifier">bit</span></code> of the stream when an attempt
        is made to parse a string that represents positive or negative infinity.
      </p>
<p>
        (See Design Rationale below for a discussion of this inconsistency.)
      </p>
<a name="math_toolkit.utils.fp_facets.trap_nan"></a><h6>
<a name="id1127816"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.trap_nan">trap_nan</a>
      </h6>
<p>
        Same as <code class="computeroutput"><span class="identifier">trap_infinity</span></code>, but
        positive and negative NaN are trapped instead.
      </p>
<a name="math_toolkit.utils.fp_facets.examples"></a><h4>
<a name="id1127840"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.examples">Examples</a>
      </h4>
<a name="math_toolkit.utils.fp_facets.simple_example_with_std__stringstreams"></a><h6>
<a name="id1127853"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.simple_example_with_std__stringstreams">Simple
        example with std::stringstreams</a>
      </h6>
<p>
        
</p>
<pre class="programlisting"><span class="identifier">locale</span> <span class="identifier">old_locale</span><span class="special">;</span>
<span class="identifier">locale</span> <span class="identifier">tmp_locale</span><span class="special">(</span><span class="identifier">old_locale</span><span class="special">,</span> <span class="keyword">new</span> <span class="identifier">nonfinite_num_put</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;);</span>
<span class="identifier">locale</span> <span class="identifier">new_locale</span><span class="special">(</span><span class="identifier">tmp_locale</span><span class="special">,</span> <span class="keyword">new</span> <span class="identifier">nonfinite_num_get</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;);</span>
</pre>
<p>
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="identifier">stringstream</span> <span class="identifier">ss</span><span class="special">;</span>
<span class="identifier">ss</span><span class="special">.</span><span class="identifier">imbue</span><span class="special">(</span><span class="identifier">new_locale</span><span class="special">);</span>
<span class="keyword">double</span> <span class="identifier">inf</span> <span class="special">=</span> <span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;::</span><span class="identifier">infinity</span><span class="special">();</span>
<span class="identifier">ss</span> <span class="special">&lt;&lt;</span> <span class="identifier">inf</span><span class="special">;</span> <span class="comment">// Write out.
</span><span class="identifier">assert</span><span class="special">(</span><span class="identifier">ss</span><span class="special">.</span><span class="identifier">str</span><span class="special">()</span> <span class="special">==</span> <span class="string">"inf"</span><span class="special">);</span>
    <span class="keyword">double</span> <span class="identifier">r</span><span class="special">;</span>
<span class="identifier">ss</span> <span class="special">&gt;&gt;</span> <span class="identifier">r</span><span class="special">;</span> <span class="comment">// Read back in.
</span><span class="identifier">assert</span><span class="special">(</span><span class="identifier">inf</span> <span class="special">==</span> <span class="identifier">r</span><span class="special">);</span> <span class="comment">// Confirms that the double values really are identical.
</span>
<span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"infinity output was "</span> <span class="special">&lt;&lt;</span> <span class="identifier">ss</span><span class="special">.</span><span class="identifier">str</span><span class="special">()</span> <span class="special">&lt;&lt;</span> <span class="identifier">endl</span><span class="special">;</span>
<span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="string">"infinity input was "</span> <span class="special">&lt;&lt;</span> <span class="identifier">r</span> <span class="special">&lt;&lt;</span> <span class="identifier">endl</span><span class="special">;</span>
<span class="comment">// But the string representation of r displayed will be the native type
</span><span class="comment">// because, when it was constructed, cout had NOT been imbued 
</span><span class="comment">// with the new locale containing the nonfinite_numput facet.
</span><span class="comment">// So the cout output will be "1.#INF on MS platforms
</span><span class="comment">// and may be "inf" or other string representation on other platforms.
</span>
</pre>
<p>
      </p>
<a name="math_toolkit.utils.fp_facets.use_with_lexical_cast"></a><h6>
<a name="id1129645"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.use_with_lexical_cast">Use with
        lexical_cast</a>
      </h6>
<p>
        Without using a new locale that contains the nonfinite facets, <code class="computeroutput"><span class="identifier">lexical_cast</span></code> is not portable (and often
        fails) if nonfinite values are found.
      </p>
<p>
        
</p>
<pre class="programlisting"><span class="identifier">locale</span> <span class="identifier">old_locale</span><span class="special">;</span>
<span class="identifier">locale</span> <span class="identifier">tmp_locale</span><span class="special">(</span><span class="identifier">old_locale</span><span class="special">,</span> <span class="keyword">new</span> <span class="identifier">nonfinite_num_put</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;);</span>
<span class="identifier">locale</span> <span class="identifier">new_locale</span><span class="special">(</span><span class="identifier">tmp_locale</span><span class="special">,</span> <span class="keyword">new</span> <span class="identifier">nonfinite_num_get</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;);</span>
</pre>
<p>
      </p>
<p>
        Although other examples imbue individual streams with the new locale, for
        the streams constructed inside lexical_cast, it is necesary to assign to
        a global locale.
      </p>
<pre class="programlisting"><span class="identifier">locale</span><span class="special">::</span><span class="identifier">global</span><span class="special">(</span><span class="identifier">new_locale</span><span class="special">);</span>
</pre>
<p>
        <code class="computeroutput"><span class="identifier">lexical_cast</span></code> then works as
        expected, even with infinity and NaNs.
      </p>
<pre class="programlisting"><span class="keyword">double</span> <span class="identifier">x</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lexical_cast</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;(</span><span class="string">"inf"</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">x</span> <span class="special">==</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric</span><span class="special">:</span><span class="identifier">limits</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;::</span><span class="identifier">infinity</span><span class="special">());</span>

<span class="identifier">string</span> <span class="identifier">s</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">lexical_cast</span><span class="special">&lt;</span><span class="identifier">string</span><span class="special">&gt;(</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;::</span><span class="identifier">infinity</span><span class="special">());</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">s</span> <span class="special">==</span> <span class="string">"inf"</span><span class="special">);</span>
</pre>
<div class="warning"><table border="0" summary="Warning">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../../../../../../../doc/src/images/warning.png"></td>
<th align="left">Warning</th>
</tr>
<tr><td align="left" valign="top"><p>
          You should be aware that the C++ specification does not explicitly require
          that input from decimal digits strings converts with rounding to the nearest
          representable floating-point binary value. (In contrast, decimal digits
          read by the compiler, for example by an assignment like <code class="computeroutput"><span class="keyword">double</span>
          <span class="identifier">d</span> <span class="special">=</span>
          <span class="number">1.234567890123456789</span></code>, are guaranteed
          to assign the nearest representable value to double d). This implies that,
          no matter how many decimal digits you provide, there is a potential uncertainty
          of 1 least significant bit in the resulting binary value.
        </p></td></tr>
</table></div>
<p>
        See <a href="http://en.wikipedia.org/wiki/Floating_point#Representable_numbers.2C_conversion_and_rounding" target="_top">for
        more information on <span class="emphasis"><em>nearest representable</em></span> and <span class="emphasis"><em>rounding</em></span></a>.
      </p>
<p>
        Most iostream libraries do in fact achieve the desirable <span class="emphasis"><em>nearest
        representable floating-point binary value</em></span> for all values of input.
        However one popular STL library does not quite achieve this for 64-bit doubles.
        See <a href="http://connect.microsoft.com/VisualStudio/feedback/details/98770/decimal-digit-string-input-to-double-may-be-1-bit-wrong" target="_top">Decimal
        digit string input to double may be 1 bit wrong</a> for the bizarre full
        details.
      </p>
<p>
        If you are expecting to 'round-trip' <code class="computeroutput"><span class="identifier">lexical_cast</span></code>
        or <code class="computeroutput"><span class="identifier">serialization</span></code>, for example
        archiving and loading, and want to be <span class="bold"><strong>absolutely certain
        that you will always get an exactly identical double value binary pattern</strong></span>,
        you should use the suggested 'workaround' below that is believed to work
        on all platforms.
      </p>
<p>
        You should output using all potentially significant decimal digits, by setting
        stream precision to <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;::</span><span class="identifier">max_digits10</span></code>, (or for the appropriate floating-point
        type, if not double) and crucially, <span class="bold"><strong>require <code class="computeroutput"><span class="identifier">scientific</span></code> format</strong></span>, not <code class="computeroutput"><span class="identifier">fixed</span></code> or automatic (default), for example:
      </p>
<pre class="programlisting"><span class="keyword">double</span> <span class="identifier">output_value</span> <span class="special">=</span> <span class="identifier">any</span> <span class="identifier">value</span><span class="special">;</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">stringstream</span> <span class="identifier">s</span><span class="special">;</span>
<span class="identifier">s</span> <span class="special">&lt;&lt;</span> <span class="identifier">setprecison</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;::</span><span class="identifier">max_digits10</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">scientific</span> <span class="special">&lt;&lt;</span> <span class="identifier">output_value</span><span class="special">;</span>
<span class="identifier">s</span> <span class="special">&gt;&gt;</span> <span class="identifier">input_value</span><span class="special">;</span>
</pre>
<a name="math_toolkit.utils.fp_facets.use_with_serialization_archives"></a><h5>
<a name="id1130272"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.use_with_serialization_archives">Use
        with serialization archives</a>
      </h5>
<p>
        It is vital that the same locale is used when an archive is saved and when
        it is loaded. Otherwise, loading the archive may fail. By default, archives
        are saved and loaded with a classic C locale with a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">archive</span><span class="special">::</span><span class="identifier">codecvt_null</span></code>
        facet added. Normally you do not have to worry about that.
      </p>
<p>
        The constructors for the archive classes, as a side-effect, imbue the stream
        with such a locale. However, if you want to use the facets <code class="computeroutput"><span class="identifier">nonfinite_num_put</span></code> and <code class="computeroutput"><span class="identifier">nonfinite_num_get</span></code>
        with archives, then you have to manage the locale manually. That is done
        by calling the archive constructor with the flag <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">archive</span><span class="special">::</span><span class="identifier">no_codecvt</span></code>,
        thereby ensuring that the archive constructor will <span class="bold"><strong>not
        imbue the stream with a new locale</strong></span>.
      </p>
<p>
        The following code shows how to use <code class="computeroutput"><span class="identifier">nonfinite_num_put</span></code>
        with a <code class="computeroutput"><span class="identifier">text_oarchive</span></code>.
      </p>
<pre class="programlisting"><span class="identifier">locale</span> <span class="identifier">default_locale</span><span class="special">(</span><span class="identifier">locale</span><span class="special">::</span><span class="identifier">classic</span><span class="special">(),</span> <span class="keyword">new</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">archive</span><span class="special">::</span><span class="identifier">codecvt_null</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;);</span>
<span class="identifier">locale</span> <span class="identifier">my_locale</span><span class="special">(</span><span class="identifier">default_locale</span><span class="special">,</span> <span class="keyword">new</span> <span class="identifier">nonfinite_num_put</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;);</span>

<span class="identifier">ofstream</span> <span class="identifier">ofs</span><span class="special">(</span><span class="string">"test.txt"</span><span class="special">);</span>
<span class="identifier">ofs</span><span class="special">.</span><span class="identifier">imbue</span><span class="special">(</span><span class="identifier">my_locale</span><span class="special">);</span>

<span class="identifier">boost</span><span class="special">::</span><span class="identifier">archive</span><span class="special">::</span><span class="identifier">text_oarchive</span> <span class="identifier">oa</span><span class="special">(</span><span class="identifier">ofs</span><span class="special">,</span> <span class="identifier">no_codecvt</span><span class="special">);</span>

<span class="keyword">double</span> <span class="identifier">x</span> <span class="special">=</span> <span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;::</span><span class="identifier">infinity</span><span class="special">();</span>
<span class="identifier">oa</span> <span class="special">&amp;</span> <span class="identifier">x</span><span class="special">;</span>
</pre>
<p>
        The same method works with <code class="computeroutput"><span class="identifier">nonfinite_num_get</span></code>
        and <code class="computeroutput"><span class="identifier">text_iarchive</span></code>.
      </p>
<p>
        If you use the <code class="computeroutput"><span class="identifier">nonfinite_num_put</span></code>
        with <code class="computeroutput"><span class="identifier">trap_infinity</span></code> and/or
        <code class="computeroutput"><span class="identifier">trap_nan</span></code> flag with a serialization
        archive, then you must set the exception mask of the stream. Serialization
        archives do not check the stream state.
      </p>
<a name="math_toolkit.utils.fp_facets.other_examples"></a><h6>
<a name="id1130668"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.other_examples">Other examples</a>
      </h6>
<p>
        <a href="../../../../../example/nonfinite_facet_simple.cpp" target="_top">nonfinite_facet_simple.cpp</a>
        give some more simple demonstrations of the difference between using classic
        C locale and constructing a C99 infinty and NaN compliant locale for input
        and output.
      </p>
<p>
        See <a href="../../../../../example/nonfinite_facet_sstream.cpp" target="_top">nonfinite_facet_sstream.cpp</a>
        for this example of use with <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">stringstream</span></code>s.
      </p>
<p>
        For an example of how to enforce the MSVC 'legacy' "1.#INF" and
        "1.#QNAN" representations of infinity and NaNs, for input and output,
        see <a href="../../../../../example/nonfinite_legacy.cpp" target="_top">nonfinite_legacy.cpp</a>.
      </p>
<p>
        Treatment of signaling NaN is demonstrated at <a href="../../../../../example/nonfinite_signaling_NaN.cpp" target="_top">../../../example/nonfinite_signaling_NaN.cpp</a>
      </p>
<p>
        Example <a href="../../../../../example/nonfinite_loopback_ok.cpp" target="_top">../../../example/nonfinite_loopback_ok.cpp</a>
        shows loopback works OK.
      </p>
<p>
        Example <a href="../../../../../example/nonfinite_num_facet.cpp" target="_top">../../../example/nonfinite_num_facet.cpp</a>
        shows output and re-input of various finite and nonfinite values.
      </p>
<p>
        A very basic example of using Boost.Archive is at <a href="../../../../../example/nonfinite_serialization_archives.cpp" target="_top">../../../example/nonfinite_serialization_archives.cpp</a>.
      </p>
<p>
        A full demonstration of serialization by Francois Mauger is at <a href="../../../../../example/nonfinite_num_facet_serialization.cpp" target="_top">../../../example/nonfinite_num_facet_serialization.cpp</a>
      </p>
<a name="math_toolkit.utils.fp_facets.portability"></a><h5>
<a name="id1130764"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.portability">Portability</a>
      </h5>
<p>
        This library uses the floating-point number classification and sign-bit from
        Boost.Math library, and should work on all platforms where that library works.
        See the portability information for that library.
      </p>
<a name="math_toolkit.utils.fp_facets.design_rationale"></a><h5>
<a name="id1130781"></a>
        <a class="link" href="fp_facets.html#math_toolkit.utils.fp_facets.design_rationale">Design Rationale</a>
      </h5>
<div class="itemizedlist"><ul type="disc">
<li>
            The flags are implemented as a const data member of the facet. Facets
            are reference counted, and locales can share facets. Therefore changing
            the flags of a facet would have effects that are hard to predict. An
            alternative design would be to implement the flags using <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">xalloc</span></code> and <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ios_base</span><span class="special">::</span><span class="identifier">iword</span></code>.
            Then one could safely modify the flags, and one could define manipulators
            that do so. However, for that to work with dynamically linked libraries,
            a <code class="computeroutput"><span class="special">.</span><span class="identifier">cpp</span></code>
            file would have to be added to the library. It was judged be more desirable
            to have a headers only library, than to have mutable flags and manipulators.
          </li>
<li>
            The facet <code class="computeroutput"><span class="identifier">nonfinite_num_put</span></code>
            throws an exception when the <code class="computeroutput"><span class="identifier">trap_infinity</span></code>
            or <code class="computeroutput"><span class="identifier">trap_nan</span></code> flag is set
            and an attempt is made to format infinity or NaN. It would be better
            if the facet set the fail bit of the stream. However, facets derived
            from <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">num_put</span></code> do not have access to the stream
            state.
          </li>
</ul></div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2006 , 2007, 2008, 2009, 2010 John Maddock, Paul A. Bristow,
      Hubert Holin, Xiaogang Zhang, Bruno Lalande, Johan R&#229;de, Gautam Sewani and
      Thijs van den Berg<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="sign_functions.html"><img src="../../../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../utils.html"><img src="../../../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="next_float.html"><img src="../../../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
