<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
    <title>Boost.Range Range Adaptors </title>
    <link rel="stylesheet" href="../style.css" type="text/css">
</head>

    <body>

    <table border="0" >
        <tr>
            <td ><img src="../../../boost.png" border="0" /></td>
            <td ><h1 align="center">Boost.Range </h1></td>
        </tr>
    </table>

    <h2> Range Adaptors </h2>
    
    <hr />
    <a name="indexed"></a>
    <h4><code>indexed</code></h4>
    <blockquote>
        <pre>rng | boost::adaptors::indexed</pre>
        <pre>boost::make_indexed_range( rng )</pre>
    </blockquote>
    <ul>
        <li>
            <b>Returns:</b>
            A range adapted to return both the element and the associated
            index.
            The returned range consists of iterators that have in addition
            to the usual iterator member functions an
            <code>index()</code> member function that returns the appropriate
            index for the element in the sequence corresponding with the
            iterator.
        </li>
        <li>
            <b>Range Category:</b>
            SinglePassRange
        </li>
    </ul>
    <hr />
    <h3>Example</h3>
    <pre>
        <span class="keyword">#include</span> &lt;boost/range/adaptor/indexed.hpp&gt;
        <span class="keyword">#include</span> &lt;boost/range/algorithm/copy.hpp&gt;
        <span class="keyword">#include</span> &lt;boost/assign.hpp&gt;
        <span class="keyword">#include</span> &lt;algorithm&gt;
        <span class="keyword">#include</span> &lt;iostream&gt;
        <span class="keyword">#include</span> &lt;vector&gt;
        
        <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
        void display_element_and_index(Iterator first, Iterator last)
        {
            <span class="keyword">for</span> (Iterator it = first; it != last; ++it)
            {
                std::cout << "Element = " << *it
                          << " Index = " << it.index() << std::endl;
            }
        }
        
        <span class="keyword">template</span>&lt;<span class="keyword">class</span> SinglePassRange&gt;
        void display_element_and_index(<span class="keyword">const</span> SinglePassRange& rng)
        {
            display_element_and_index(boost::begin(rng), boost::end(rng));
        }
        
        <span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const char</span>* argv[])
        {
            <span class="keyword">using namespace</span> boost::assign;
            <span class="keyword">using namespace</span> boost::adaptors;
            
            std::vector&lt;<span class="keyword">int</span>&gt; input;
            input += 10,20,30,40,50,60,70,80,90;
            
            display_element_and_index( input | indexed(0) );
            
            <span class="keyword">return</span> 0;
        }
    </pre>
    <p>
        This produces the output: <br />
        <code>
        Element = 10 Index = 0 <br />
        Element = 20 Index = 1 <br />
        Element = 30 Index = 2 <br />
        Element = 40 Index = 3 <br />
        Element = 50 Index = 4 <br />
        Element = 60 Index = 5 <br />
        Element = 70 Index = 6 <br />
        Element = 80 Index = 7 <br />
        Element = 90 Index = 8 <br />
        </code>
    </p>
    <hr />
    <p>
    (C) Copyright Neil Groves 2009
    (C) Copyright Thorsten Ottosen 2003-2004
    </p>

    <br />
    <br />
    <br />
    <br />
    <br />
    <br />
    <br />
    <br />
    <br />
    <br />
    <br />
    <br />
    </body>
</html>

