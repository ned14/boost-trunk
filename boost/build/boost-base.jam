#  (C) Copyright David Abrahams and Carlos Pinto Coelho 2001. Permission to
#  copy, use, modify, sell and distribute this software is granted provided this
#  copyright notice appears in all copies. This software is provided "as is"
#  without express or implied warranty, and with no claim as to its suitability
#  for any purpose.
#
# Jamrules file by David Abrahams (abrahams@mediaone.net) and Carlos Pinto
# Coelho (cfspc@altrabroadband.com).

# Notes on the design of the system:
#
# This system is designed to support building the "same" targets with multiple
# build tool suites (e.g. msvc, gcc,...)  and build variants (e.g. debug,
# release...). Although it currently varies across two dimensions, it should
# trivially support extension to three or more, e.g. in case of cross-platform
# builds. The word "same" is written in quotes above because internally,
# separate targets are generated for each unique toolset/build-variant
# combination.
#
# Specifics of build tool suites are specified in files with names of the form
# "<name>-tools.jam", where <name> is the name used to identify the tool suite.

# Workarounds for Jam limitations:
#
# 1. Jam supports something like the setting of attributes on targets using the
#    syntax:
#       <name> on <target> = <expression>
#
#    This facility is used to control build actions for individual targets
#    (target-specific variables take precedence over global ones when build
#    actions # are executed). An obvious approach would be to use target
#    attributes to hold # properties of build tools (e.g. where to find the
#    standard includes).  # Unfortunately, although you can write target
#    attributes, there is no way to # read them. Instead, we take advantage of
#    two properties of Jam:
#
#    a. A variable name can be formed by evaluating an expression. For example,
#       the following rule, appends FOOBAR to its first argument to form the
#       name of a new variable, which is given the value "baz"
#
#          rule X { $(1)FOOBAR = baz ; }
#
#    b. Any character is allowed in a variable name. So, although they are
#       actually global variables, we can form names like <name>.c++-flags thus:
#       
#          C++FLAGS = $($(1).c++-flags) # Get the c++-flags "attribute" from $(1)
#
# 2. There is no way to call a rule based on the value of a variable
#    other than by using a switch statement. Because that approach requires
#    intrusive changes to rules when the system is extended, we have avoided
#    it. Instead, we have taken advantage of two "features" of Jam:
#
#    a. The name of a file to be included can be computed from an
#       expression. For example, the following includes a file whose name is
#       formed by concatenating $(1) and "-tools.jam":
#
#           include $(1)-tools.jam 
#
#    b. A rule can be redefined any number of times. Its latest definition is
#       the one invoked. For example, the following prints "#2".
#
#           rule X { ECHO #1 ; }
#           rule X { ECHO #2 ; }
#           X ;
#
#    Together, these facts allow us to select tool-suite-specific actions for
#    building specific target types by repeatedly redefining the generalized
#    build actions in the various <build-tools>-tools.jam files

TOOLS ?= borland gcc metrowerks msvc ;

# detect-build-tools <tools-name> : <detection-command>
#
# Declares a pseudotarget for the specified build tools which is built by
# the given <detection-command>. 
#
# Although not currently implemented, the plan is to make compilation of
# tool-specific targets dependent on this pseudotarget. That way, we will never
# even attempt to build targets for tools that don't exist.
rule detect-build-tools
{
    detection-command on $(<) = $($(<).bin-directory)$(>) ;
}

actions build-tools
{
    $(detection-command)
}

rule library-file
{
    LibraryFromObjects $(<) : [ Objects $(>) ] ;
}

rule executable-file
{
    type-DEPENDS exe : $(<) ;
    main-from-objects $(<) : [ Objects $(>) ] : EXE ;

    # Setting RUN_ALL causes all executable targets to be run.
    if $(RUN_ALL)
    {
        Run $(<) ;
    }
}

rule dll-file
{
    type-DEPENDS dll : $(<) ;
    
    # Set up the import library dependency on Windows
    if $(gEXPORT_SUFFIX(DLL))
    {
        INCLUDES $(<) : $(<:S=)$(gEXPORT_SUFFIX(DLL)) ;
        INCLUDES $(<:S=)$(gEXPORT_SUFFIX(DLL)) : $(<) ;
    }
    
    main-from-objects $(<) $(<:S=)$(gEXPORT_SUFFIX(DLL)) : [ Objects $(>) ] : DLL ;
}

# main-from-objects exe-target : obj-target... : ("EXE"|"DLL")
#
# generate instructions to build the given "main" target from the given object
# files given in the 2nd parameter. The 3rd parameter should be EXE for an
# executable, or DLL for a shared library.
rule main-from-objects
{
    # make compiled sources a dependency of target

    DEPENDS $(<) : $(>) ;

	MakeLocate $(<) : $(LOCATE_TARGET) ;

    Clean clean : $(<) ;

    switch $(3)
    {
      case EXE : Link $(<) : $(>) : $(3) ;
      case DLL : Link-DLL $(<) : $(>) : $(3) ;
      case * : EXIT "unknown main target type $(3)" ;
    }
}

rule Link-DLL
{
    MODE on $(<[1]) = $(DLLMODE) ;
    
    if $(<[2])
    {
      MODE on $(<[2]) = $(IMPMODE) ;
      Chmod $(<[2]) ;
    }
    Link-DLL-action $(<) : $(>) : $(3) ;
    
    Chmod $(<[1]) ;
}

# A simple action to run an executable target
actions Run
{
    $(<)
}

# bubble variable-name
#
# Helper function for sort, below
# Removes the greatest element from $(variable-name) and returns it.
rule bubble # 
{
    local result = ;
    local last = $($(<)[1]) ;
    for x in $($(<)[2-])
    {
        if $(last) <= $(x)
        {
            result += $(last) ;
            last = $(x) ;
        }
        else
        {
            result += $(x) ;
        }
    }
    $(<) = $(result) ;
    return $(last) ;
}

# sort args
#
# return args sorted in lexicographic order.
rule sort
{
    local _all = $(<) ;
    local _result = ;
    local _count ;
    for _count in $(<)
    {
        _result = [ bubble _all ] $(_result) ;
    }
    return $(_result) ;
}

# min args
#
# return the lexicographic minimum element of args
rule min
{
    local result = ;
    local x ;
    for x in $(<)
    {
        if ! $(result) || ( $(x) < $(result) )
        {
            result = $(x) ;
        }
    }
    return $(result) ;
}

# difference listB : listA
# returns the elements of B that are not in A
rule difference
{
    local result = ;
    local element ;
    for element in $(<)
    {
        if ! ( $(element) in $(>) )
        {
            result += $(element) ;
        }
    }
    return $(result) ;
}

# replace list : old-value new-value
#
# returns list with occurrences of old-value replaced by new-value
rule replace
{
    local result = ;
    local x ;
    for x in $(<)
    {
        if $(x) = $(>[1])
        {
            result += $(>[2]) ;
        }
        else
        {
            result += $(x) ;
        }
    }
    return $(result) ;
}

# select-ungristed list...
#
# Returns the elements of list that have no grist
rule select-ungristed
{
    local result x ;
    for x in $(<)
    {
        if ! $(x:G)
        {
            result += $(x) ;
        }
    }
    return $(result) ;
}

# Split a qualified property into 3 elements. 
#
# Grammar description of qualified-property :
#   [[<toolset>]<variant>]property
#
# returns <toolset> <variant> property
# missing <toolset> or <variant> are treated as <*>
rule split-qualified-property
{
    local grist1 = $(<:G) ;
    local ungrist1 = $(<:G=) ;
    local grist2 = $(ungrist1:G) ;
    local ungrist2 = $(ungrist1:G=) ;
    local grist3 = $(ungrist2:G) ;
    local ungrist3 = $(ungrist2:G=) ;
    if $(grist3)
    {
        return $(grist1) $(grist2) $(grist3)$(ungrist3) ;
    }
    else if $(grist2)
    {
        return <*> $(grist1) $(grist2)$(ungrist2) ;
    }
    else
    {
        return <*> <*> $(<) ;
    }
}

rule unique # list
{
    local result = ;
    local f ;
    for f in $(<)
    {
        if ! $(f) in $(result)
        {
            result += $(f) ;
        }
    }
    return $(result) ;
}

# get-properties features : properties
#
# Given a list of gristed features and a list of properties, returns the
# properties matching the given features.
rule get-properties 
{
    local result = ;
    local property ;
    for property in $(>)
    {
        if $(property:G) in $(<)
        {
            result += $(property) ;
        }
    }
    return $(result) ;
}
    
# get-values feature : properties
#
# Given a single gristed feature name and a list of properties, returns the
# value(s) of that feature.
rule get-values
{
    if $(<[2])
    {
        EXIT "Error: Expecting a single gristed feature name for $1 in get-values, got" "$(<)" ;
    }
    else
    {
        local _properties = [ get-properties $(<) : $(>) ] ;
        return $(_properties:G=) ;
    }
}

# normalize-properties properties
#
# Normalizes a set of (possibly qualified) properties by prepending <*> as many
# times as neccessary to ensure that each property has at least 3 gristed elements.
rule normalize-properties
{
    local property ;
    local result ;
    for property in $(<)
    {
        result += [ join [ split-qualified-property $(property) ] ] ;
    }
    return $(result) ;
}

# intersection set1 : set2
#
# Removes from set1 any items which don't appear in set2 and returns the result.
rule intersection 
{
    local result v ;
    for v in $(<)
    {
        if $(v) in $(>)
        {
            result += $(v) ;
        }
    }
    return $(result) ;
}

# subset sub : super
#
# Returns true iff sub is a subset of super, empty otherwise
rule is-subset
{
    if [ intersection $(<) : $(>) ] = $(<)
    {
        return true ;
    }
}

# distribute-feature <feature>value1[/value2...]
#
# Distribute the given feature across the slash-separated set of values, i.e.
# returns <feature>value1[ <feature>/value2...]
rule distribute-feature
{
    local g = $(<:G) ;
    local result = [ split-path $(<:G=) ] ;
    return $(g)$(result) ;
}

# set-insert variable-name : value... ;
#
# Appends the given values to the list designated by variable-name if they are
# not already present.
rule set-insert
{
    local v ;
    for v in $(>)
    {
        if ! ( $(v) in $($(<)) )
        {
            $(<) += $(v) ;
        }
    }
}

# equal-sets set1 : set2
#
# Returns true iff set1 contains the same elements as set2.
# Not sensitive to the same element appearing multiple times
rule equal-sets
{
    if ( ! [ difference $(<) : $(>) ] ) && ( ! [ difference $(>) : $(<) ] )
    {
        return true ;
    }
}

# feature name : [values...] : [ PATH ]
#
# Declares a feature with the given name. If values is empty, declares a free
# feature; declares a simple feature otherwise. "PATH" should be supplied for a
# free feature whose values might be paths specified relative to the
# (sub)project directory.
rule feature
{
    gUNGRISTED(<$(<)>) = $(<) ;
    gFEATURE_VALUES(<$(<)>) = $(>) ;
    
    if ( ! $(>) ) && ! ( <$(<)> in $(gFREE_FEATURES) )
    {
        gFREE_FEATURES += <$(<)> ;
        if PATH in $(3)
        {
            gPATH_FEATURES += <$(<)> ;
        }
    }
    else
    {
        if PATH in $(3)
        {
            ECHO "Simple feature" <$(<)> "qualified with PATH in 3rd"
                  "argument. PATH ignored." ;
        }
    }
}

# feature-default <feature>...
#
# return the default properties corresponding to the given feature(s)
rule feature-default
{
    local result f ;
    for f in $(<)
    {
        result += $(f)$(gFEATURE_VALUES($(f))[1]) ;
    }
    return $(result) ;
}

# flags tools-name variable-name condition [: value(s)]
#
# Declare command-line settings for a given toolset.
#   toolset:         the name of the toolset
#   variable-name:   the name of a global variable which can be used to carry
#                    information to a command-line
#   condition:       one of the following:
#                    1. zero or more <simple-feature>value[/<simple-feature>value...]
#                    2. <free-feature>
#   values:          non-empty in case 1 above, empty in case 2.
#
# Semantics only affect targets built with the specified toolset, and depend on
# the form of condition:
#
# 1. For targets whose build-properties are a superset of any element of condition
# (or, when condition is empty, for all targets), values will be appended to
# $(variable-name).
#
# 2. for each free property of a built target whose feature is specified by
# condition, the property's value will be appended to $(variable-name)
#
# In either case, the variable will be set "on" the target so it may be  used in
# the build actions. 
rule flags
{
    local toolset = $(<[1]) ;
    local variable = $(<[2]) ;
    local condition = $(<[3-]) ;

    # record the names of all variables used so they can be set on targets
    if ! ( $(variable) in $(gTARGET_VARIABLES) )
    {
        gTARGET_VARIABLES += $(variable) ;
        $(variable) = ;
    }

    if $(>)
    {
        # values is non-empty: specifying simple properties
        if ! $(condition) 
        {
             $(variable) += $(>) ; # condition is empty: unconditionally add values
        }
        else
        {
            local found = ;
            
            local property_set ;
            for property_set in $(condition)
            {
                local properties = [ split-path $(property_set) ] ;
                
                # Add each feature to the set of features relevant to the toolset
                gRELEVANT_FEATURES($(toolset)) += $(properties:G) ;

                # if this property_set is a subset of the current build-properties
                if ( ! $(found) ) && [ is-subset $(properties) : $(gBUILD_PROPERTIES) ]
                {
                    found = true ;
                    $(variable) += $(>) ;
                }
            }
        }
    }
    else
    {
        
        if $(condition[2])
            || $(condition[1]:G=)
            || ! ( $(condition[1]) in $(gFREE_FEATURES) )
        {
            EXIT "Error: rule flags expects only a single free feature"
            " name when no values are supplied. "
            "got (" $(condition) ") instead." ;
        }
        # Add the values of the free feature specified by condition to $(variable)
        $(variable) += [ get-values $(condition) : $(gBUILD_PROPERTIES) ] ;
        # Record that the feature is relevant to the toolset
        gRELEVANT_FEATURES($(toolset)) += $(condition) ;
    }
}

# include-tools toolset
#
# Unconditionally process the specification file for the given toolset. It is
# neccessary to do this for each target built with that toolset, since the
# toolset will invoke the flags rule to set global variables based on the build
# properties of the target.
rule include-tools 
{
    gCURRENT_TOOLSET = $(<) ;

    gTARGET_VARIABLES = ;
    gRELEVANT_FEATURES($(<)) = ; # clear relevant feature set
    
    include $(BOOST_BUILD_INSTALLATION)$(SLASH)$(<)-tools.jam ;

    # Always maintain the list of relevant features as unique
    gRELEVANT_FEATURES($(<)) = [ unique $(gRELEVANT_FEATURES($(<))) ] ;
    
    gINCLUDED($(BOOST_BUILD_INSTALLATION)$(SLASH)$(<)-tools.jam) = true ;
}

# relevant-features toolset
#
# Returns the set of unique features relevant to the given toolset; includes the
# toolset description file as a side-effect if neccessary.
rule relevant-features # name
{
    if ! $(gRELEVANT_FEATURES($(<)))
    {
        include-tools $(<) ;
    }
    return $(gRELEVANT_FEATURES($(<))) ;
}

# variant name : [<toolset>]<feature>value...
#
# Delcare a build variant, whose configuration is given by the given (optionally
# toolset-qualified) properties.
rule variant
{
    local toolset ;
    for toolset in $(TOOLS)
    {
        # We hijack select-properties to do our dirty work here.
        # Because properties in a variant declaration are only qualified with
        # toolset and not variant, we specify the toolset where
        # select-properties expects a variant name. The first toolset parameter
        # is neccessary to get the relevant-features correctly set. We supply
        # the variant name as the target name, so that error messages will look
        # coherent.
        gBASE_PROPERTIES($(toolset),$(<))
            = [ sort [ select-properties $(toolset) $(toolset) $(<) : $(>) ] ] ;
    }
}

# select-properties toolset variant target-name : qualified-properties...
#
# Returns
rule select-properties
{
    local relevant_features = [ relevant-features $(<[1]) ] ;
    local normalized = [ normalize-properties $(>) ] ;

    # Classify properties by the specificity of their qualification.
    # First, grab those that apply to this toolset, or all toolsets
    local this_toolset = [ get-values <$(<[1])> : $(normalized) ] ;
    local all_toolsets = [ get-values <*> : $(normalized) ] ;
    
    local 0-stars = [ get-values <$(<[2])> : $(this_toolset) ] ;
    local 1-stars = [ get-values <*> : $(this_toolset) ] [ get-values <$(<[2])> : $(all_toolsets) ] ;
    local 2-stars = [ get-values <*> : $(all_toolsets) ] ;

    # Select feature names from the features relevant to the toolset.
    local features = [ intersection $(relevant_features)
        : $(0-stars:G) $(1-stars:G) $(2-stars:G) ] ;

    local result f ;
    for f in $(features)
    {
        local is_free = [ intersection $(f) : $(gFREE_FEATURES) ] ;
        
        # Go through the $(n-stars) lists from most- to least- specific;
        # collect the best set of values of a simple feature, and /all/
        # values of a free feature.
        local r n ;
        for n in 0 1 2
        {
            if ! $(r) || $(is_free)
            {
                r += [ get-values $(f) : $($(n)-stars) ] ;
            }
        }

        r = [ unique $(r) ] ;
        if $(r[2]) && ! $(is_free) # Check for conflicting simple-feature requests
        {
            EXIT "Error: Ambiguous properties requested for"
            $(<[3]) <$(<[1])><$(<[2])> ":" $(f)$(r) ;
        }
        result += $(f)$(r) ;
    }
    return $(result) ;
}
# get toolset features
include $(BOOST_BUILD_INSTALLATION)$(SLASH)features.jam ;

# ungrist-properties properties...
#
# Transforms a list of properties of the form:
#   <feature1>value1 [<feature2>value2... ]
# into a list of the form:
#   feature1-value1 feature2-value2
# suitable for use as directory path elements
rule ungrist-properties
{
    local property ;
    local result = ;
    for property in $(<)
    {
        # local f = [ ungrist-feature $(property:G) ] ;
        local f =  ;
        result += $(gUNGRISTED($(property:G)))-$(property:G=) ;
    }
    return $(result) ;
}

# set-target-variables target
#
# attach global build tool settings to the given file-target, so that they can be
# used in build actions.
rule set-target-variables # file-target
{
    local s ;
    for s in $(gTARGET_VARIABLES)
    {
        $(s) on $(<) = $($(s)) ;
    }
}

# fixup-path-properties properties...
#
# For free properties that have been declared with "PATH", add a relative path
# prefix to the value as neccessary to locate the path relative to the current
# subproject. 
rule fixup-path-properties
{
    local path-properties = [ get-properties $(gPATH_FEATURES) : $(<) ] ;
    local non-path = [ difference $(<) : $(path-properties) ] ;    
    if $(RELATIVE_SUBDIR) && ! $(path-properties:R)
    {
        path-properties = $(path-properties:R=$(RELATIVE_SUBDIR)) ;
    }
    return $(path-properties) $(non-path) ;
}

# report-any-incompatible-properties requirements... : build-request... : target-name
#
# If any element of requirements has the same grist but a different ungristed
# part as any element of build-request, exits with an error report about target-name
rule report-any-incompatible-properties
{
    local all-properties = [ unique $(<) $(>) ] ;
    local all-features = $(all-properties:G) ;
    local unique-features = [ unique $(all-features) ] ;
    if $(all-features) != $(unique-features)
    {
        EXIT "Error:" "$(3):" "target requirements conflict for requested build {" $(<) $(>) "}" ;
    }
}
if report-any-incompatible-properties in $(TEST)
{
    report-any-incompatible-properties <foo>bar <baz>mumble : <b>c <foo>bar : my-target ;
    report-any-incompatible-properties <foo>bat <baz>mumble <baz>buz <d>f : <b>c <foo>bar : my-target ;
}

# multiply-property-sets [<feature>value1[/value2...] ]...
#
# Expands a set of (possibly multi-valued) properties into all the combinations
# that include every feature in the set. Each combination is given as a path,
# with the slash separating the properties, sorted in feature order.
rule multiply-property-sets
{
    local result p ;
    for p in [ sort $(<) ]
    {
        # expand any multi-valued simple features from the default build
        local multiple = [ distribute-feature $(p) ] ;

        # concatenation produces a product, so the tree branches for each
        # multi-valued simple feature.
        result = $(result)/$(multiple) ;
        result ?= $(multiple) ; # this trick allows us to get started 
    }
    return $(result) ;
}

# make-path-property-sets base-path : common-properties : property-sets
#
# Returns a list of paths where the initial ungristed part of each element is a
# relative path to a subvariant directory from a target's build root and the
# rest of the element is a slash-separated property set describing the
# properties of the target to be built.
#
# Each path returned is base-path extended by one of the ungristed property-sets
# (or just the base-path if no property-sets are supplied). Each property set
# returned is formed by extending common-properties with one of the property-sets.
#
# For example,
#
#   make-path-property-sets gcc/release : <p1>v1 : <p2>v2/<p3>v3
#
# returns this single-element list:
#
#      gcc/release/p2-v2/p3-v3/<p1>v1/<p2>v2/<p3>v3
#     |<-- subvariant path -->|<-- property-set -->|
rule make-path-property-sets
{
    local result ;
    local s ;
    for s in $(3)
    {
        result += [ join
                    $(<) [ ungrist-properties [ split-path $(s) ] ] # directory components
                    $(>) $(s) : $(SLASH) ] ; # common properties + property set
    }

    # if there were no overrides, just add the base variant and properties
    if ! $(result)
    {
        result = [ join $(<) $(>) : $(SLASH) ] ;
    }
    return $(result) ;
}

# expand-build-request
#      toolset variant target-name : requirements : build-request
#
# Returns a list of path-property-sets (see make-path-property-sets above) for
# all build configurations based on the given toolset, requirements, and
# build-request. Target-name is just used for error reporting.
rule expand-build-request 
{
    local toolset = $(<[1]) ;
    local variant = $(<[2]) ;

    # grab the requirements and BUILD-request relevant to this toolset and variant
    local requirements = [ select-properties $(toolset) $(variant) : $(>) ] ;
    local build-request = [ select-properties $(toolset) $(variant) : $(3) ] ;

    # Separate the free features (e.g. <define>, <undef>, <include>) from the others
    local free-properties = [ get-properties $(gFREE_FEATURES) : $(requirements) $(build-request) ] ;
    requirements = [ difference $(requirements) : $(free-properties) ] ;
    build-request = [ difference $(build-request) : $(free-properties) ] ;

    # Check for conflicts
    report-any-incompatible-properties $(requirements) : $(build-request) : $(<[3]) ;

    # Get  the base variant for the toolset. Includes free features
    local base-properties = $(gBASE_PROPERTIES($(toolset),$(variant))) ;

    # Which properties will override settings in the base variant?
    local override-properties = [ unique $(requirements) $(build-request) ] ;
    override-properties = [ difference $(override-properties) : $(base-properties) ] ;

    # Which features, and thus properties, of the base variant are we keeping?
    local kept-features = [ difference $(base-properties:G) : $(override-properties:G) ] ;
    local kept-properties = [ get-properties $(kept-features) : $(base-properties) ] ;

    # Which features will pick up a default value because they are not in
    # the base variant or in the overrides?
    local relevant_features = [ relevant-features $(toolset) ] ;
    local defaulted-features = [ difference $(relevant_features)
                                : $(override-properties:G) $(kept-features) ] ;
    local defaulted-properties = [ feature-default $(defaulted-features) ] ;

    # form override property sets of the form (property1[/property2...] )+,
    # sorted in feature order. These represent the properties of subvariants
    # that differ from the base variant 
    local override-sets
        = [ multiply-property-sets $(override-properties) $(defaulted-properties) ] ;

    # return path-property-sets corresponding to each (sub)variant build
    # described.
    return [ make-path-property-sets $(toolset)$(SLASH)$(variant)
                : $(kept-properties) [ fixup-path-properties $(free-properties) ]
                : $(override-sets) ] ;
}

# split-path-at-grist path
#
# Breaks path at each $(SLASH) that is followed by grist. This can be used to
# break apart property sets, particularly where the <include> feature is used,
# since its value is typically a path.
rule split-path-at-grist
{
    local full-split = [ split-path $(<) ] ;
    local last ;
    local result x ;
    for x in $(full-split)
    {
        if $(x:G)
        {
            result += $(last) ;
            last = $(x) ;
        }
        else
        {
            last = $(last)$(SLASH)$(x) ;
            last ?= $(x) ;
        }
    }
    return $(result) $(last) ;
}
 
# declare-local-target name : sources : requirements : local-BUILD : target-type
#
# declares a subproject-local target of the given name and target-type. This is
# all top-level rules which declare targets should eventually go through here.
rule declare-local-target 
{

    # We grist the base target name here because we're referring the abstract
    # target which generates all of the actual builds. We need a way to
    # distinguish targets of the same name from different subprojects.
    local base-target = [ FGristFiles $(<) ] ;

    gTARGET_SOURCES($(base-target)) = $(2) ;
    gTARGET_REQUIREMENTS($(base-target)) = $(3) ;
    gTARGET_BUILD($(base-target)) = $(4) ;
    gTARGET_TYPE($(base-target)) = $(5) ;

    # Check to avoid infinite recursion when subprojects contain mutual
    # dependencies. 
    if ! $(gCURRENTLY_DECLARING($(base-target)))
    {
        local gCURRENTLY_DECLARING($(base-target)) = true ;
        declare-target $(1) : $(2) : $(3) : $(4) : $(5) ;
    }
}

# directory-of files...
#
# Returns a list of the directories containing each element of files
rule directory-of
{
    local result d ;
    for d in $(<:D)
    {
        if $(d) = ""
        {
            result += $(DOT) ;
        }
        else
        {
            result += $(d) ;
        }
    }
    return $(result) ;
}

# top-relative-tokens path
#
# Returns a list of path elements which form the relative path from TOP to path,
# which is expected to be given relative to the current subproject.
rule top-relative-tokens
{
    return [ simplify-path-tokens $(SUBDIR_TOKENS) [ split-path $(<) ] ] ;
}

# dependent-include target-path...
#
# For each target-path, ensure that the appropriate Jamfile has been
# included. Used when a target declares its dependency on another target.

rule dependent-include
{
    local target ;
    for target in $(<)
    {
        # compute the path to the Jamfile containing target. This path must be
        # relative to the directory of Jam's invocation in order for the include
        # rule to find it.
        
        local jamfile-path
            = [ join-path
                [ simplify-path-tokens
                  $(RELATIVE_SUBDIR_TOKENS) [ directory-of $(target) ] $(JAMFILE) ] ] ;
                  
        if ! $(gINCLUDED($(jamfile-path)))
        {
            # protect variables from being permanently set by SubDir invocations
            # in included files.
            local SUBDIR SUBDIR_TOKENS SEARCH_SOURCE LOCATE_SOURCE LOCATE_TARGET ;
            local SOURCE_GRIST ;
            local RELATIVE_SUBDIR RELATIVE_SUBDIR_TOKENS ;

            # this stack allows us to avoid making dependee libraries part of
            # the "type" targets, e.g. all, exe, obj. See rule type-DEPENDS.
            local gIN_LIB_INCLUDE = 1 ;
            
            include $(jamfile-path) ;
            gINCLUDED($(jamfile-path)) = true ;
        }
    }
}

# link-libraries dependent : libs... : subvariant-id
#
# Used to make the given dependent target depend on the file result of building
# the given libs. The 3rd argument should be the relative path from the target
# build root to the requested subvariant.
rule link-libraries
{
  local lib-path ;
  for lib-path in $(>)
  {
    local new-subdir = TOP [ top-relative-tokens [ directory-of $(lib-path) ] ] ;
    
    # protect global variables from being permanently set by SubDir
    local SUBDIR SUBDIR_TOKENS SEARCH_SOURCE LOCATE_SOURCE LOCATE_TARGET ;
    local SOURCE_GRIST ;
    local RELATIVE_SUBDIR RELATIVE_SUBDIR_TOKENS ;

    # Enter the dependee subproject
    SubDir $(new-subdir) ;

    local lib-target = [ FGristFiles $(lib-path:D=) ] ;
    local lib-target-type = $(gTARGET_TYPE($(lib-target))) ;

    local lib-grist = [ join-path $(SOURCE_GRIST) $(lib-path:D=) $(3) ] ;
    local build-target = $(lib-target:G=$(lib-grist)) ;
    
    # if build instructions for the given target have not been given, do that now.
    if ! $(lib-grist) in $(gDECLARED_TARGETS)
    {
        declare-target $(lib-target)
            : $(gTARGET_SOURCES($(lib-target)))
            : $(gTARGET_REQUIREMENTS($(lib-target)))
            : $(BUILD) : $(lib-target-type) ;
    }

    # Get the name of the built target file
    local target-file = [ FAppendSuffix $(build-target) : $(gIMPORT_SUFFIX($(lib-target-type))) ] ;

    # Set up dependencies and link instructions
    DEPENDS $(<) : $(target-file) ;
    NEEDLIBS on $(<) += $(target-file) ;
  }
}

# Which configuration(s) to build if nothing is explicitly specified
DEFAULT_BUILD ?= debug ;

# get-BUILD [target-default-build]
#
# If BUILD is set, return it. Otherwise if target-default-build is non-empty,
# return it. Otherwise, return $(DEFAULT_BUILD)
rule get-BUILD
{
  local build = $(BUILD) ;
  build ?= $(<) ;
  build ?= $(DEFAULT_BUILD) ;
  return $(build) ;
}

BIN_DIRECTORY ?= bin ;

# declare-fake-targets abstract-target : target-file
#
# 
rule declare-fake-targets
{
    # make a fake target so that it can be built without knowing the suffix
    # Since executables under *NIX have no suffix, we'd better check
    if $(>) != $(<)
    {
        DEPENDS $(<) : $(>) ;
        NOTFILE $(<) ;
    }
    
    # The following checks that we're in the subdirectory of Jam's invocation
    # so that we can arrange for ungristed target names to be built from the
    # command-line.
    if ( $(SUBDIR) = $(gINVOCATION_SUBDIR) )
    {
        DEPENDS $(<:G=) : $(<) ; # allows $(<:G=) to be used to build all variants
        NOTFILE $(<:G=) ;
    }
}

# declare-target-type TYPE : [[<compiler>]<variant>]<feature>value...
rule declare-target-type
{
    gTARGET_TYPE_REQUIREMENTS($(<)) = $(>) ;
}

declare-target-type DLL : <shared-linkable>true ;

if $(NT)
{
  gIMPORT_SUFFIX(DLL) = .lib ;
  gIMPORT_SUFFIX(LIB) = .lib ;
  gEXPORT_SUFFIX(DLL) = .lib ;
}
else
{
  gIMPORT_SUFFIX(DLL) = .so ;
  gIMPORT_SUFFIX(LIB) = .a ;
}

rule declare-target # target : sources : requirements : local-build : target-type
{
  local target-type = $(5) ;
  local requirements = $(3) ;
  local BUILD = [ get-BUILD $(4) ] ;
  local variants = [ select-ungristed $(BUILD) ] ;
  local build-request = [ difference $(BUILD) : $(variants) ] ;

  # extract and remove <lib> targets from $(>)
  local libs = [ get-values <lib> : $(>) ] ;
  local sources = [ FGristFiles [ difference $(>:G=) : $(libs) ] ] ;

  # include each jamfile describing a dependee target.
  dependent-include $(libs) ;
  
  local toolset ;
  for toolset in $(TOOLS)
  {
    local v ;
    for v in $(variants)
    {
      local type-requirements =
        $(gTARGET_TYPE_REQUIREMENTS($(target-type))) <target-type>$(target-type) ;

      local expanded
          = [ expand-build-request $(toolset) $(v) $(<)
              : $(requirements) $(type-requirements) : $(build-request) ] ;

      local x ;
      for x in $(expanded)
      {
          # extract the elements of x
          local x-split = [ split-path-at-grist $(x) ] ;

          # this is the path from the target's build root to the subvariant directory
          local subvariant-id = $(x-split[1]) ;

          # SOURCE_GRIST identifies the subproject directory; TARGET_GRIST
          # will identify the target and subvariant, since unique versions of
          # files will be built for that combination. 
          local TARGET_GRIST = [ join-path $(SOURCE_GRIST) $(<) $(subvariant-id) ] ;
          local HDRGRIST = $(TARGET_GRIST) ;

          # Do nothing if build instructions and dependencies for this target
          # have already been generated.
          if ! $(TARGET_GRIST) in $(gDECLARED_TARGETS)
          {
            gDECLARED_TARGETS += $(TARGET_GRIST) ;

            # LOCATE_TARGET affects where built targets are generated. We move
            # it relative to the default location based on the subvariant
            local LOCATE_TARGET
              = [ join-path $(LOCATE_TARGET) $(BIN_DIRECTORY) $(<) $(subvariant-id) ] ;

            local main-target = $(<:G=$(TARGET_GRIST)) ;
            local target-file = [ FAppendSuffix $(main-target) : $(SUF$(target-type)) ] ;
            declare-fake-targets $(main-target) : $(target-file) ;
            
            # set up gBUILD_PROPERTIES for include-tools (below)
            local gBUILD_PROPERTIES = $(x-split[2-]) ;

            # Include the toolset specification. This will set up the global
            # flags variables in a way appropriate to this build.
            include-tools $(toolset) ;
            
            # transfer target variables to the target file.
            set-target-variables $(target-file) ;

            # dispatch to the appropriate declaration function. It would be much
            # better to be able to do this with some sort of indirection, but
            # Jam doesn't yet support it.
            switch $(target-type)
            {
              case EXE : executable-file $(target-file) : $(sources) ;
              case LIB : library-file $(target-file) : $(sources) ;
              case DLL : dll-file $(target-file) : $(sources) ;
              case * : EXIT "unknown target type:" $(target-type) ;
            }

            # generate build instructions
            link-libraries $(target-file) : $(libs) : $(subvariant-id) ;
          }

          # peel the first pair off the front
          build = $(build[3-]) ;
      }
    }
  }
}

# exe target : sources : requirements : local-build
#
# Declare an executable target.
rule exe
{
    declare-local-target $(<) : $(2) : $(3) : $(4) : EXE ;
}

# dll target : sources : requirements : local-build
#
# Declare a shared library target.
rule dll
{
    declare-local-target $(<) : $(2) : $(3) : $(4) : DLL ;
}

# lib target : sources : requirements : local-build
#
# Declare a statically-linked library target.
rule lib
{
    declare-local-target $(<) : $(2) : $(3) : $(4) : LIB ;
}


if ! ( NDEBUG in $(TEST) )
{
    include $(BOOST_BASE_DIR)$(SLASH)unit-tests.jam ;
}