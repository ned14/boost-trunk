# Borland tool definitions.
#
# Please note that wide-character support is currently disabled for Borland in
# features.jam, pending someone taking the time to figure out how to get the
# appropriate libraries into the link command line.

# compute Borland tool path
# You can either put the borland bin directory in your PATH, or you can set
# BCCROOT to point at the borland installation directory
BCC_TOOL_PATH = $(BCCROOT)$(SLASH)bin$(SLASH) ;
BCC_TOOL_PATH ?= "" ; # Don't clobber adjoining text if BCCROOT isn't set

# specify compilation and link flags
flags borland CFLAGS <debug-symbols>on : -v ;
flags borland LINKFLAGS <debug-symbols>on : -v ;
flags borland CFLAGS <optimization>off : -Od ;
flags borland CFLAGS <optimization>speed : -O2 ;
flags borland CFLAGS <optimization>space : -O1 ;
flags borland CFLAGS <inlining>off : -vi- ;
flags borland CFLAGS <inlining>on : -vi -w-inl ;
flags borland CFLAGS <inlining>full : -vi -w-inl ;

flags borland LINKFLAGS <threading>multi : -tWM ;
flags borland LINKFLAGS <runtime-link>dynamic : -tWR ;
flags borland LINKFLAGS <user-interface>gui/<target-type>EXE : -tW ;
flags borland LINKFLAGS <user-interface>console/<target-type>EXE : -tWC ;
flags borland LINKFLAGS <wide-character-support>on : -WU ;

flags msvc LINKFLAGS <target-type>DLL : -tWD ;

# C0D32.OBJ - 32-bit DLL startup module (cod32w: wide-char version; cod32x: no
# exception handling)
flags borland CFLAGS <threading>multi : -tWM ;
# flags borland CFLAGS <user-interface>gui/<target-type>EXE : -tW ;
flags borland CFLAGS <runtime-link>dynamic : -tWR ;
# flags borland CFLAGS <user-interface>console/<target-type>EXE : -tWC ;
flags borland CFLAGS <wide-character-support>on : -WU ;

# Apparently not needed when invoking the linker through bcc32
# flags borland BCC_STDLIBS <runtime-link>static/<threading>single :  CW32.LIB ;
# flags borland BCC_STDLIBS <runtime-link>dynamic/<threading>single :  CW32I.LIB ;
# flags borland BCC_STDLIBS <runtime-link>static/<threading>multi : CW32MT.LIB ;
# flags borland BCC_STDLIBS <runtime-link>dynamic/<threading>multi :  CW32MTI.LIB ;

flags borland DEFINES <define> ;
flags borland UNDEFS <undef> ;
flags borland HDRS <include> ;

flags borland STDHDRS : $(BCCROOT)$(SLASH)include ;
flags borland STDLIBPATH : $(BCCROOT)$(SLASH)lib ;

# IMPORT32.LIB - 32-bit import library 

# For detailed information about borland tools and their command-line switches,
# see http://www.objectcentral.com/vide/help/videdoc/bcc32.html

rule use-tool
{
    $(>) on $(<) = $(3:G=borland-tools:S=.exe) ;
    DEPENDS $(<) : $(3:G=borland-tools:S=.exe) ;
    SEARCH on $(3:G=borland-tools:S=.exe) = $(BCCROOT)$(SLASH)bin $(PATH) ;
}

#### Link ####

rule Link-action
{
    use-tool $(<) : LINKER : bcc32 ;
    borland-Link-action $(<) : $(>) ;
    if $(3) = DLL
    {
        use-tool $(<) : IMPLIB : implib ;
        borland-IMPLIB-action $(<) : $(>) ;
    }
}

# bcc32 needs to have ilink32 in the path in order to invoke it, so explicitly
# specifying $(BCC_TOOL_PATH)bcc32 doesn't help. You need to add
# $(BCC_TOOL_PATH) to the path
actions borland-Link-action bind NEEDLIBS LINKER
{
    set PATH=$(BCC_TOOL_PATH);%PATH%
    $(LINKER) -q $(LINKFLAGS) -L"$(BCCROOT)$(SLASH)lib" -e"$(<[1])" "$(>)" "$(NEEDLIBS)" 
}

actions borland-IMPLIB-action bind IMPLIB
{
    $(IMPLIB) $(<[2]) $(<[1])
}

#### Cc #####

rule Cc-action
{
    use-tool $(<) : CC : bcc32 ;
    borland-Cc-action $(<) : $(>) ;
}

actions borland-Cc-action bind CC
{
    $(CC) -q -c -w- -U$(UNDEFS) -D$(DEFINES) $(CFLAGS) -I"$(HDRS)" -I"$(BCCROOT)$(SLASH)include" -o"$(<)" "$(>)"
}

#### C++ ####
rule C++-action
{
    use-tool $(<) : C++ : bcc32 ;
    borland-C++-action $(<) : $(>) ;
}

actions borland-C++-action bind C++
{
    $(C++) -q -c -P -w- -U$(UNDEFS) -D$(DEFINES) $(CFLAGS) $(C++FLAGS) -I"$(HDRS)" -I"$(BCCROOT)$(SLASH)include" -o"$(<)" "$(>)"
}

#### Archive ####
rule Archive-action
{
    use-tool $(<) : LD : tlib ;
    borland-Archive-action $(<) : $(>) ;
}

actions updated together piecemeal borland-Archive-action bind LD
{
    $(LD) /P32 /u /a /C "$(<)" +"$(>)"
}
