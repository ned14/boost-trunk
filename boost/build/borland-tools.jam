borland.bin-directory = [ conditional $(BCCROOT) : $(BCCROOT)$(SLASH)bin$(SLASH) : " " ] ;
detect-build-tools borland : bcc32 ;

flags borland CFLAGS <debug-symbols>on : -v ;
flags borland LINKFLAGS <debug-symbols>on : -v ;
flags borland CFLAGS <optimization>off : -Od ;
flags borland CFLAGS <optimization>speed : -O2 ;
flags borland CFLAGS <optimization>space : -O1 ;
flags borland CFLAGS <inlining>off : -vi- ;
flags borland CFLAGS <inlining>on : -vi -w-inl ;
flags borland CFLAGS <inlining>full : -vi -w-inl ;


flags borland CFLAGS <threading>multi : -tWM ;
flags borland CFLAGS <user-interface>gui : -tW ;
flags borland CFLAGS <user-interface>console : -tWC ;

flags borland LINKFLAGS <threading>multi : -tWM ;
flags borland LINKFLAGS <user-interface>gui/<runtime-link>static : -tW ;
flags borland LINKFLAGS <user-interface>gui/<runtime-link>dynamic : -tWR ;
flags borland LINKFLAGS <user-interface>console/<runtime-link>static : -tWC ;
flags borland LINKFLAGS <user-interface>console/<runtime-link>dynamic : -tWCR ;

# -tWD Make the target a Windows .DLL with all functions exportable. 

# C0D32.OBJ - 32-bit DLL startup module (cod32w: wide-char version; cod32x: no
# exception handling)
flags borland CFLAGS <runtime-link>dynamic/<user-interface>gui : -tWR ;
flags borland CFLAGS <runtime-link>dynamic/<user-interface>console : -tWCR ;


#  flags borland STDOBJS <user-interface>gui/<wide-character-support>off : c0W32.OBJ ;
#  flags borland STDOBJS <user-interface>gui/<wide-character-support>on : c0W32w.OBJ ;

#  flags borland STDOBJS <user-interface>console/<wide-character-support>off : c0X32.OBJ ;
#  flags borland STDOBJS <user-interface>console/<wide-character-support>on : c0X32w.OBJ ;

flags borland STDLIBS <runtime-link>static/<threading>single :  CW32.LIB ;
flags borland STDLIBS <runtime-link>dynamic/<threading>single :  CW32I.LIB ;

flags borland STDLIBS <runtime-link>static/<threading>multi : CW32MT.LIB ;
flags borland STDLIBS <runtime-link>dynamic/<threading>multi :  CW32MTI.LIB ;

flags borland DEFINES <define> ;
flags borland UNDEFS <undef> ;
flags borland HDRS <include> ;

flags borland STDHDRS : $(BCCROOT)$(SLASH)include ;
flags borland STDLIBPATH : $(BCCROOT)$(SLASH)lib ;

# IMPORT32.LIB - 32-bit import library 

# For detailed information about borland tools and their command-line switches,
# see http://www.objectcentral.com/vide/help/videdoc/bcc32.html

#### Link ####

rule Link-action
{
    borland-Link-action $(<) : $(>) ;
}

# bcc32 needs to have ilink32 in the path in order to invoke it, so explicitly
# specifying borland.bin-directory doesn't help, and I can't figure out the
# right way to explicitly invoke ilink32. Maybe somebody else can fill in the
# details...
actions borland-Link-action bind NEEDLIBS
{
    set PATH="$(borland.bin-directory)";%PATH% ;
    bcc32 -q $(LINKFLAGS) -L"$(BCCROOT)$(SLASH)lib" -e"$(<)" "$(>)"  "$(STDLIBS)" "$(NEEDLIBS)" 
}

#### Cc #####

rule Cc-action
{
    borland-Cc-action $(<) : $(>) ;
}

actions borland-Cc-action
{
    $(borland.bin-directory)bcc32 -q -c -w- -U$(UNDEFS) -D$(DEFINES) $(CFLAGS) $(CCFLAGS) $(OPTIM) -I"$(HDRS)" -I"$(BCCROOT)$(SLASH)include" -o"$(<)" "$(>)"
}
#### C++ ####
rule C++-action
{
    borland-C++-action $(<) : $(>) ;
}

actions borland-C++-action
{
    $(borland.bin-directory)bcc32 -q -c -P -w- -U$(UNDEFS) -D$(DEFINES) $(CFLAGS) $(C++FLAGS) $(OPTIM)  -I"$(HDRS)" -I"$(BCCROOT)$(SLASH)include" -o"$(<)" "$(>)"
}

#### Archive ####
rule Archive-action
{
    borland-Archive-action $(<) : $(>) ;
}

actions updated together piecemeal borland-Archive-action
{
    $(borland.bin-directory)tlib /P32 /u /a /C "$(<)" +"$(>)"
}


# FILEINFO.OBJ - Passes open file-handle information to child processes. Include
# this file in your link to pass full information about open files to child
# processes created with exec and spawn. Works with the C++ runtime library to
# inherit this information.

# WILDARGS.OBJ - If you want wild-card expansion for you console-mode
# applications, then you should also link in this file when you link your
# console-mode application. It apparently doesn t work for GUI apps. It does the
# normal DOS-like wild card expansion and passes them to argv and argc of your
# main.

# C0S32.OBJ  - Unknown

# dxextra.lib - DirectX static library 

# inet.lib - Import lib for MS Internet DLLs 
# noeh32.lib - No exception handling support lib 
# ole2w32.lib - Import lib for 32-bit OLE 2.0 API 
# oleaut32.lib - Unknown

# uuid.lib - GUID static lib for Direct3d, DirectDraw, DirectSound, Shell
# extensions, DAO, Active Scripting, etc.

# wininet.lib - Unknown 
# ws2_32.lib - Import lib for WinSock 2.0 API 
# GP.OBJ - Prints register-dump information when an exception occurs.
