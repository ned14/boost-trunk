#ifndef BOOST_SERIALIZATION_VARIANT_HPP
#define BOOST_SERIALIZATION_VARIANT_HPP

// MS compatible compilers support #pragma once
#if defined(_MSC_VER) && (_MSC_VER >= 1020)
# pragma once
#endif

#if defined(_MSC_VER) && (_MSC_VER <= 1020)
#  pragma warning (disable : 4786) // too long name, harmless warning
#endif

/////////1/////////2/////////3/////////4/////////5/////////6/////////7/////////8
// variant.hpp - non-intrusive serialization of variant types
//
// copyright (c) 2005   
// troy d. straszheim <troy@resophonic.com>
// http://www.resophonic.com
//
// Use, modification and distribution is subject to the Boost Software
// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
// See http://www.boost.org for updates, documentation, and revision history.
//
// thanks to Robert Ramey, Peter Dimov, and Richard Crossley.
//

#include <boost/config.hpp>
#include <boost/mpl/fold.hpp>

#include <boost/throw_exception.hpp>

#include <boost/variant.hpp>

#include <boost/archive/archive_exception.hpp>

#include <boost/serialization/split_free.hpp>
#include <boost/serialization/serialization.hpp>
#include <boost/serialization/split_free.hpp>

namespace boost {
namespace serialization {
namespace variant_impl { // msvc chokes on the name "variant"

struct stop_tag { };

template <typename Value, typename Base>
struct variant_in : Base
{
    BOOST_STATIC_CONSTANT(int, index = 1 + Base::index);
    template <typename Archive, typename Variant>
    static void exec(Archive& ar, int discriminator, Variant& var){
        if (discriminator == index) {
            Value value;
            ar >> BOOST_SERIALIZATION_NVP(value);
            var = value;
            return;
        }
        Base::exec(ar,discriminator,var);
    }
};

template <>
struct variant_in<mpl::void_, stop_tag> {
    BOOST_STATIC_CONSTANT(int, index = -1);
    template <typename Archive,typename V>
    static void exec(Archive& ar,int discriminator,V& v){
        boost::throw_exception(
            boost::archive::archive_exception(
                boost::archive::archive_exception::stream_error
            )
        );
    }
};

template<class Archive>
struct save_visitor : boost::static_visitor<> {
    save_visitor(Archive& ar) :
        m_ar(ar)
    {}
    template<class T>
    void operator()(T const & value) const
    {
        m_ar << BOOST_SERIALIZATION_NVP(value);
    }
private:
    Archive & m_ar;
};

} // namespace variant_impl

template<class Archive,BOOST_VARIANT_ENUM_PARAMS(typename T)>
void load(
    Archive & ar, 
    boost::variant<BOOST_VARIANT_ENUM_PARAMS(T)>& v,
    unsigned int version
){
    typedef BOOST_DEDUCED_TYPENAME boost::variant<BOOST_VARIANT_ENUM_PARAMS(T)>::types types;
    int which;
    ar >> BOOST_SERIALIZATION_NVP(which);

    // fold<> from Richard Crossley.  Wicked.  The call to exec
    // starts in the most-derived part of the composite class
    // generated by fold and recursively works its way down.
    mpl::fold<
        types, 
        variant_impl::variant_in<mpl::void_, variant_impl::stop_tag>, 
        variant_impl::variant_in<mpl::_2, mpl::_1> 
    >::type::exec(ar,which,v);
}

template<class Archive,BOOST_VARIANT_ENUM_PARAMS(typename T)>
void save(
    Archive & ar,
    boost::variant<BOOST_VARIANT_ENUM_PARAMS(T)> const & v,
    unsigned int version
){
    int which = v.which();
    ar << BOOST_SERIALIZATION_NVP(which);
    variant_impl::save_visitor<Archive> visitor(ar);
    v.apply_visitor(visitor);
}

template<class Archive,BOOST_VARIANT_ENUM_PARAMS(typename T)>
inline void serialize(
    Archive & ar,
    boost::variant<BOOST_VARIANT_ENUM_PARAMS(T)> & v,
    unsigned int file_version
){
    split_free(ar,v,file_version);
}

} // namespace serialization
} // namespace boost

#endif //BOOST_SERIALIZATION_VARIANT_HPP

