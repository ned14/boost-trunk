<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN"
"http://www.w3.org/TR/REC-html40/strict.dtd">
    <title>
      Function Overloading
    </title>
    <div>
      <h1>
         <img width="277" height="86" id="_x0000_i1025" align="center"
        src="c++boost.gif" alt= "c++boost.gif (8819 bytes)">Function Overloading
      </h1>

<h2>An Example</h2>
      <p>
        To expose overloaded functions in Python, simply <code>def()</code> each
        one with the same Python name:
<blockquote>
<pre>
inline int f1() { return 3; }
inline int f2(int x) { return x + 1; }

class X {
public:
    X() : m_value(0) {}
    X(int n) : m_value(n) {}
    int value() const { return m_value; }
    void value(int v) { m_value = v; }
private:
    int m_value;
};
  ...

void initoverload_demo()
{
    try
    {
        py::Module overload_demo("overload_demo");
        // Overloaded functions at module scope
        overload_demo.def(f1, "f");
        overload_demo.def(f2, "f");

        py::ClassWrapper&lt;X&gt; x_class(overload_demo, "X");
        // Overloaded constructors
        x_class.def(py::Constructor&lt;&gt;());
        x_class.def(py::Constructor&lt;int&gt;());

        // Overloaded member functions
        x_class.def((int (X::*)() const)&amp;X::value, "value");
        x_class.def((void (X::*)(int))&amp;X::value, "value");
  ...
</pre>
</blockquote>

      <p>
        Now in Python:
<blockquote>
<pre>
>>> from overload_demo import *
>>> x0 = X()
>>> x1 = X(1)
>>> x0.value()
0
>>> x1.value()
1
>>> x0.value(3)
>>> x0.value()
3
>>> X('hello')
TypeError: No overloaded functions match (X, string). Candidates are:
void (*)()
void (*)(int)
>>> f()
3
>>> f(4)
5
</pre>
</blockquote>

<h2>Discussion</h2>
      <p>
        Notice that overloading in the Python module was produced three ways:<ol>
        <li>by combining the non-overloaded C++ functions <code>int f1()</code>
        and <code>int f2(int)</code> and exposing them as <code>f</code> in Python.
        <li>by exposing the overloaded constructors of <code>class X</code>
        <li>by exposing the overloaded member functions <code>X::value</code>.
        </ol>
      <p>
        Techniques 1. and 3. above are really alternatives. In case 3, you need
        to form a pointer to each of the overloaded functions. The casting
        syntax shown above is one way to do that in C++. Case 1 does not require
        complicated-looking casts, but may not be viable if you can't change
        your C++ interface. N.B. There's really nothing unsafe about casting an
        overloaded (member) function address this way: the compiler won't let
        you write it at all unless you get it right.

<h2>An Alternative to Casting</h2>
      <p>
        This approach is not neccessarily better, but may be preferable for some
        people who have trouble writing out the types of (member) function
        pointers or simply prefer to avoid all casts as a matter of principle:
<blockquote>
<pre>
// Forwarding functions for X::value
inline void set_x_value(X&amp; self, int v) { self.value(v); }
inline int get_x_value(X&amp; self) { return self.value(); }
   ...
        // Overloaded member functions
        x_class.def(set_x_value, "value");
        x_class.def(get_x_value, "value");
</pre>
</blockquote>
<p>Here we are taking advantage of the ability to expose C++ functions at
namespace scope functions as Python member functions.

<h2>Overload Resolution</h2>
      <p>
        The function overload resolution mechanism in py_cpp works as
        follows:<ul>
        <li>Attribute lookup for extension classes proceeds in the usual way. When a
        class is found which has a matching attribute, only functions overloaded
        in the context of that class are candidates for overload resolution.
        <li>Within a name-space context (extension class or module), overloaded
        functions are tried in the same order they were
        <code>def()</code>ed. The first function whose signature can be made to
        match each argument passed is the one which is ultimately called.
        </ul>
      <p>
         Prev: <a href="overloading.html">Function Overloading</a>
         Next: <a href="under-the-hoold.html">A Peek Under the Hood</a>
         Up: <a href="py_cpp.html">Top</a>
      <p>
         &copy; Copyright David Abrahams 2000. Permission to copy, use, modify,
        sell and distribute this document is granted provided this copyright
        notice appears in all copies. This document is provided "as is" without
        express or implied warranty, and with no claim as to its suitability
        for any purpose.
      <p>
         Updated: Oct 15, 2000
    </div>

