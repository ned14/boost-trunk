<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN"
"http://www.w3.org/TR/REC-html40/strict.dtd">
    <title>
      Wrapping enums
    </title>
    <div>
      <h1>
         <img width="277" height="86" id="_x0000_i1025" align="center"
        src="c++boost.gif" alt= "c++boost.gif (8819 bytes)">Wrapping enums
      </h1>
<p>Because there is in general no way to deduce that a value of arbitrary type T
is an enumeration constant, py_cpp cannot automatically convert enum values to
and from Python. To handle this case, you need to decide how you want the enum
to show up in Python (since Python doesn't have enums). Once you have done that,
you can write some simple <code>from_python()</code> and
<code>to_python()</code> functions.

<p>If you are satisfied with a Python int as a way to represent your enum
values, py_cpp provides a shorthand for these functions. You just need to
instantiate <code>python::enum_as_int_converters&lt;EnumType&gt;</code> where
<code>EnumType</code> is your enumerated type. There are two convenient ways to do this:

<ol>
<li><blockquote>
<pre>
// drop into namespace python and explicitly instantiate
BOOST_PYTHON_BEGIN_CONVERSION_NAMESPACE // this is a gcc 2.95.2 bug workaround
  template class enum_as_int_converters<extclass_demo::EnumOwner::enum_type>;
BOOST_PYTHON_END_CONVERSION_NAMESPACE
</pre>
</blockquote>
<li><blockquote><pre>
// instantiate as base class in any namespace
struct EnumTypeConverters
    : python::py_enum_as_int_converters<EnumType>
{
};
</blockquote></pre>
</ol>

<p>Either of the above is equivalent to the following declarations:
<blockquote><pre>
BOOST_PYTHON_BEGIN_CONVERSION_NAMESPACE // this is a gcc 2.95.2 bug workaround

  MyEnumType from_python(PyObject* x, python::type&lt;MyEnumType&gt;)
  {
      return static_cast&lt;MyEnum&gt;(
        from_python(x, python::type&lt;long&gt;()));
  }

  MyEnumType from_python(PyObject* x, python::type&lt;const MyEnumType&amp;&gt;)
  {
      return static_cast&lt;MyEnum&gt;(
        from_python(x, python::type&lt;long&gt;()));
  }

  PyObject* to_python(MyEnumType x)
  {
      return to_python(static_cast&lt;long&gt;(x));
  }
BOOST_PYTHON_END_CONVERSION_NAMESPACE
</pre></blockquote>

<p>This technique defines the conversions of
<code>MyEnumType</code> in terms of the conversions for the built-in
 <code>long</code> type.

You may also want to add a bunch of lines like this to your module
initialization:

<blockquote><pre>
mymodule.add(python::to_python(enum_value_1), "enum_value_1");
mymodule.add(python::to_python(enum_value_2), "enum_value_2");
...
</pre></blockquote>

You can also add these to an extension class definition, if your enum happens to
be local to a class and you want the analogous interface in Python:

<blockquote><pre>
my_class.add(python::to_python(enum_value_1), "enum_value_1");
my_class.add(python::to_python(enum_value_2), "enum_value_2");
...
</pre></blockquote>
      <p>
         &copy; Copyright David Abrahams 2000. Permission to copy, use, modify,
        sell and distribute this document is granted provided this copyright
        notice appears in all copies. This document is provided &ldquo;as
        is&rdquo; without express or implied warranty, and with no claim as to
        its suitability for any purpose.
      <p>
         Updated: Nov 12, 2000
    </div>

