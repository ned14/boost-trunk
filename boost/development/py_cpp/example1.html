<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN"
"http://www.w3.org/TR/REC-html40/strict.dtd">
    <title>
      A Simple Example Using py_cpp
    </title>
    <div>
      <h1>
         <img width="277" height="86" id="_x0000_i1025" src="c++boost.gif" alt=
        "c++boost.gif (8819 bytes)">
      </h1>
      <h1>
         A Simple Example Using py_cpp
      </h1>
      <p>
         Suppose we have the following C++ API which we want to expose in
        Python:
      <blockquote>
<pre>
#include &lt;string&gt;

namespace hello {
  class world
  {
   public:
      world(int);
      ~world();
      std::string get() const { return "hi, world"; }
    ...
  };
  std::size_t length(const world&amp; x) { return std::strlen(x.get()); }
}

</pre>
      </blockquote>
      <p>
         Here is the C++ code for a python module called <code>hello</code>
        which exposes the API using py_cpp:
      <blockquote>
<pre>
#include &lt;py_cpp/class_wrapper.h&gt;
// Python requires an exported function called init&lt;module-name&gt; in every
// extension module. This is where we build the module contents.
extern "C"
#ifdef _WIN32
__declspec(dllexport)
#endif
void inithello()
{
    try
    {
       // create an object representing this extension module
       python::module_builder hello("hello");
       // Create the Python type object for our extension class
       python::class_builder&lt;hello::world&gt; world_class(hello, "world");
       // Add the __init__ function
       world_class.def(python::constructor&lt;int&gt;());
       // Add a regular member function
       world_class.def(&amp;hello::world::get, "get");
       // Add a regular function to the module
       hello.def(hello::length, "length");
    }
    catch(...)
    {
       python::handle_exception();    // Deal with the exception for Python
    }
}
// Win32 DLL boilerplate
#if defined(_WIN32)
#include &lt;windows.h&gt;
extern "C" BOOL WINAPI DllMain(HINSTANCE, DWORD, LPVOID)
{
    return 1;
}
#endif // _WIN32
</pre>
      </blockquote>
      <p>
         That's it! If we build this shared library and put it on our <code>
        PYTHONPATH</code> we can now access our C++ class and function from
        Python.
      <blockquote>
<pre>
&gt;&gt;&gt; import hello
&gt;&gt;&gt; hi_world = hello.world(3)
&gt;&gt;&gt; hi_world.get()
'hi, world'
&gt;&gt;&gt; hello.length(hi_world)
9
</pre>
      </blockquote>
      <p>
         We can even make a subclass of <code>hello.world</code>:
      <blockquote>
<pre>
&gt;&gt;&gt; class my_subclass(hello.world):
...     def get(self):
...         return 'hello, world'
...
&gt;&gt;&gt; y = my_subclass(4)
&gt;&gt;&gt; y.get()
'hello, world'
</pre>
      </blockquote>
      <p>
         Pretty cool! You can't do that with an ordinary Python extension type!
      <blockquote>
<pre>
&gt;&gt;&gt; hello.length(y)
9
</pre>
      </blockquote>
      <p>
         Of course, you may now have a slightly empty feeling in the pit of
        your little pythonic stomach. Perhaps you feel your subclass deserves
        to have a <code>length()</code> of <code>12</code>? If so, <a href= 
        "overriding.html">read on</a>...
      <p>
         Previous: <a href="comparisons.html">Comparisons with other systems</a> Next: <a href="overriding.html">Overridable virtual functions</a> Up:
        <a href="py_cpp.html">Top</a>
      <p>
         &copy; Copyright David Abrahams 2000. Permission to copy, use, modify,
        sell and distribute this document is granted provided this copyright
        notice appears in all copies. This document is provided "as is" without
        express or implied warranty, and with no claim as to its suitability
        for any purpose.
      <p>
         Updated: Oct 30, 2000
    </div>

