<HTML>
<!--
  -- Copyright (c) Jeremy Siek 2000
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  I make no representations about the
  -- suitability of this software for any purpose.  It is provided "as is"
  -- without express or implied warranty.
  -->
<!--
  -- Copyright (c) 1996-1999
  -- Silicon Graphics Computer Systems, Inc.
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -- Copyright (c) 1994
  -- Hewlett-Packard Company
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Hewlett-Packard Company makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  --
  -->
<Head>
<Title>Iterator Concepts</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<IMG SRC="../../../../c++boost.gif" 
     ALT="C++ Boost" width="277" height="86"> 

<BR Clear>


<h1>Iterator Concepts</h1>

<p>The standard iterator categories and requirements are flawed because
they use a single hierarchy of requirements to address two orthogonal
issues: <b><i>iterator traversal</i></b> and <b><i>dereference return
type</i></b>. The current iterator requirement hierarchy is mainly
geared towards iterator traversal (hence the category names), while
requirements that address dereference return type sneak in at various
places. 

<p>
The iterator requirements should be separated into two hierarchies.
One set of concepts handles the return type semantics: 
<ul>
  <li><a href="#concept:ReadableIterator">Readable Iterator</a></li>
  <li><a href="#concept:WritableIterator">Writable Iterator</a></li>
  <li><a href="#concept:SwappableIterator">Swappable Iterator</a></li>
  <li><a href="#concept:ConstantLvalueIterator">Constant Lvalue Iterator</a></li>
  <li><a href="#concept:MutableLvalueIterator">Mutable Lvalue Iterator</a></li>
</ul>

The other set of concepts handles iterator traversal: 

<ul>
  <li><a href="#concept:ForwardTraversalIterator">Forward Traversal Iterator</a></li>
  <li><a href="#concept:BidirectionalTraversalIterator">Bidirectional Traversal Iterator</a></li>
  <li><a href="#concept:RandomAccessTraversalIterator">Random Access Traversal Iterator</a></li>
</ul>

The current Input Iterator and Output Iterator requirements will
continue to be used as is. Note that Input Iterator implies Readable
Iterator and Output Iterator implies Writable Iterator.

<p>
Note: we considered defining a Single-Pass Iterator, which could be
combined with Readable or Writable Iterator to replace the Input and
Output Iterator requirements. We rejected this idea because there are
some differences between Input and Output Iterators that make it hard
to merge them: for example Input Iterator requires Equality Comparable
while Output Iterator does not.


<p></p>
<DIV ALIGN="CENTER"><A NAME="fig:graph-concepts"></A></A>
<TABLE>
<CAPTION ALIGN="TOP"><STRONG>Figure 1:</STRONG>
The iterator concepts and refinement relationships.
</CAPTION>
<TR><TD><IMG SRC="./iterator_concepts.gif" ></TD></TR>
</TABLE>
</DIV>
<p></p>


<h2>Relationship with the standard iterator concepts</h2>

<p>
std::Input Iterator implies boost::ReadableIterator.

<p>
std::Output Iterator implies boost::Writable Iterator.

<p>
std::Forward Iterator refines boost::Forward Iterator and
boost::Constant Lvalue Iterator or boost::Mutable Lvalue Iterator.

<p>
std::Bidirectional Iterator refines boost::Bidirectional Iterator and
boost::Constant Lvalue Iterator or boost::Mutable Lvalue Iterator.

<p>
std::Random Access Iterator refines boost::Random Access Iterator and
boost::Constant Lvalue Iterator or boost::Mutable Lvalue Iterator.


<h3>Notation</h3>
<Table>
  <tr>
    <td><tt>X</tt></td>
    <td>The iterator type.</td>
  </tr>
  <tr>
    <td><tt>T</tt></td>
    <td>The value type of <tt>X</tt>, i.e., <tt>std::iterator_traits&lt;X&gt;::value_type</tt>.</td>
  </tr>
  <tr>
    <td><tt>x</tt>, <tt>y</tt></td>
    <td>An object of type <tt>X</tt>.</td>
  </tr>
  <tr>
    <td><tt>t</tt></td>
    <td>An object of type <tt>T</tt>.</td>
  </tr>
</table>

<p>

<hr>
<!--------------------------------------------------------------------------->

<H3><A NAME="concept:ReadableIterator"></A>
Readable Iterator
</H3>

A Readable Iterator is an iterator that dereferences to produce an
rvalue that is convertible to the <tt>value_type</tt> of the
iterator. 

<h3>Associated Types</h3>

<Table border>

  <tr>
    <td>Value type</td>
    <td><tt>std::iterator_traits&lt;X&gt;::value_type</tt></td>
    <td>The type of the objects pointed to by the iterator.</td>
  </tr>

  <tr>
    <td>Reference type</td>
    <td><tt>std::iterator_traits&lt;X&gt;::reference</tt></td>
    <td>
    The return type of dereferencing the iterator. This
    type must be convertible to <tt>T</tt>.
    </td>
  </tr>

  <tr>
    <td>Return Category</td>
    <td><tt>std::return_category&lt;X&gt;::type</tt></td>
    <td>
    A type convertible to <tt>std::readable_iterator_tag</tt>
    </td>
  </tr>

</Table>

<h3>Refinement of</h3>

<A href="http://www.boost.org/libs/utility/CopyConstructible.html">Copy Constructible</A>

<h3>Valid expressions</h3>

<Table border>
<tr><TH>Name</TH><TH>Expression</TH><TH>Type requirements</TH><TH>Return type</TH></tr>
<tr>
 <td>Dereference</td>
 <td><tt>*x</tt></td>
 <td>&nbsp;</td>
 <td><tt>std::iterator_traits&lt;X&gt;::reference</tt></td>
</tr>
<tr>
 <td>Member access</td>
 <td><tt>x-&gt;m</tt></td>
 <td><tt>T</tt> is a type with a member named <tt>m</tt>.</td>
 <td>
If <tt>m</tt> is a data member, the type of <tt>m</tt>.
If <tt>m</tt> is a member function, the return type of <tt>m</tt>.
 </td>
</tr>
</table>

<p>

<hr>
<!--------------------------------------------------------------------------->

<H3><A NAME="concept:WritableIterator"></A>
Writable Iterator
</H3>

A Writable Iterator is an iterator that can be used to store a value
using the dereference-assignment expression.

<h3>Definitions</h3>

If <tt>x</tt> is an Writable Iterator of type <tt>X</tt>, then the
expression <tt>*x = a;</tt> stores the value <tt>a</tt> into
<tt>x</tt>.  Note that <tt>operator=</tt>, like other C++ functions,
may be overloaded; it may, in fact, even be a template function.  In
general, then, <tt>a</tt> may be any of several different types.  A
type <tt>A</tt> belongs to the <i>set of value types</i> of <tt>X</tt>
if, for an object <tt>a</tt> of type <tt>A</tt>, <tt>*x = a;</tt> is
well-defined and does not require performing any non-trivial
conversions on <tt>a</tt>.

<h3>Associated Types</h3>

<Table border>

  <tr>
    <td>Return Category</td>
    <td><tt>std::return_category&lt;X&gt;::type</tt></td>
    <td>
    A type convertible to <tt>std::writable_iterator_tag</tt>
    </td>
  </tr>

</Table>



<h3>Refinement of</h3>

<A href="http://www.boost.org/libs/utility/CopyConstructible.html">Copy Constructible</A>

<h3>Valid expressions</h3>

<Table border>
  <tr>
    <TH>Name</TH><TH>Expression</TH><TH>Return type</TH>
  </tr>
  <tr>
    <td>Dereference assignment</td>
    <td><tt>*x = a</tt></td>
    <td>unspecified</td>
  </tr>
</table>

<p>


<hr>
<!--------------------------------------------------------------------------->

<H3><A NAME="concept:SwappableIterator"></A>
Swappable Iterator
</H3>

A Swappable Iterator is an iterator whose dereferenced values can be
swapped.

<p>
Note: the requirements for Swappable Iterator are dependent on the
issues surrounding <tt>std::swap()</tt> being resolved. Here we assume
that the issue will be resolved by allowing the overload of
<tt>std::swap()</tt> for user-defined types.

<p>
Note: Readable Iterator and Writable Iterator combined implies
Swappable Iterator because of the fully templated
<tt>std::swap()</tt>.  However, Swappable Iterator does not imply
Readable Iterator nor Writable Iterator.

<h3>Associated Types</h3>

<Table border>

  <tr>
    <td>Return Category</td>
    <td><tt>std::return_category&lt;X&gt;::type</tt></td>
    <td>
    A type convertible to <tt>std::swappable_iterator_tag</tt>
    </td>
  </tr>

</Table>


<h3>Valid expressions</h3>

Of the two valid expressions listed below, only one <b>OR</b> the
other is required. If <tt>std::iter_swap()</tt> is overloaded for
<tt>X</tt> then <tt>std::swap()</tt> is not required. If
<tt>std::iter_swap()</tt> is not overloaded for <tt>X</tt> then the
default (fully templated) version is used, which will call
<tt>std::swap()</tt> (this means changing the current requirements for
<tt>std::iter_swap()</tt>).

<p>
<Table border>
  <tr>
    <TH>Name</TH><TH>Expression</TH><TH>Return type</TH>
  </tr>

  <tr>
    <td>Iterator Swap</td>
    <td><tt>std::iter_swap(x, y)</tt></td>
    <td>void</td>
  </tr>

  <tr>
    <td>Dereference and Swap</td>
    <td><tt>std::swap(*x, *y)</tt></td>
    <td>void</td>
  </tr>

</table>

<p>


<hr>
<!--------------------------------------------------------------------------->

<H3><A NAME="concept:ConstantLvalueIterator"></A>
Constant Lvalue Iterator
</H3>

A Constant Lvalue Iterator is an iterator that dereferences to produce a
const reference to the pointed-to object, i.e., the associated
<tt>reference</tt> type is <tt>const T&amp;</tt>. Changing the value
of or destroying an iterator that models Constant Lvalue Iterator does
not invalidate pointers and references previously obtained from that
iterator.

 
<h3>Refinement of</h3>

<a href="#concept:ReadableIterator">Readable Iterator</a> 

<h3>Associated Types</h3>

<Table border>

  <tr>
    <td>Reference type</td>
    <td><tt>std::iterator_traits&lt;X&gt;::reference</tt></td>
    <td>
     The return type of dereferencing the iterator, which must be
     <tt>const T&amp;</tt>.
    </td>
  </tr>

<!--  I don't think this is needed
  <tr>
    <td>Pointer type</td>
    <td><tt>std::iterator_traits&lt;X&gt;::pointer</tt></td>
    <td>
     The pointer to the value type, which must be <tt>const T*</tt>.
    </td>
  </tr>
-->

  <tr>
    <td>Return Category</td>
    <td><tt>std::return_category&lt;X&gt;::type</tt></td>
    <td>
    A type convertible to <tt>std::constant_lvalue_iterator_tag</tt>
    </td>
  </tr>

</table>

<!-- these are not necessary now that we use reference as operator* return type
<h3>Valid expressions</h3>

<Table border>
<tr><TH>Name</TH><TH>Expression</TH><TH>Type requirements</TH><TH>Return type</TH></tr>
<tr>
 <td>Dereference</td>
 <td><tt>*x</tt></td>
 <td>&nbsp;</td>
 <td><tt>std::iterator_traits&lt;X&gt;::reference</tt></td>
</tr>
<tr>
 <td>Member access</td>
 <td><tt>x-&gt;m</tt></td>
 <td><tt>T</tt> is a type with a member named <tt>m</tt>.</td>
 <td>
 &nbsp;
 </td>
</tr>
</table>

-->

<p>

<hr>
<!--------------------------------------------------------------------------->

<H3><A NAME="concept:MutableLvalueIterator"></A>
Mutable Lvalue Iterator
</H3>

A Mutable Lvalue Iterator is an iterator that dereferences to produce a
reference to the pointed-to object. The associated <tt>reference</tt>
type is <tt>T&amp;</tt>.  Changing the value of or destroying an
iterator that models Mutable Lvalue Iterator does not invalidate
pointers and references previously obtained from that iterator.
 
<h3>Refinement of</h3>

<a href="#concept:ReadableIterator">Readable Iterator</a>,
<a href="#concept:WritableIterator">Writable Iterator</a>,
and <a href="#concept:SwappableIterator">Swappable Iterator</a>.



<h3>Associated Types</h3>

<Table border>

  <tr>
    <td>Reference type</td>
    <td><tt>std::iterator_traits&lt;X&gt;::reference</tt></td>
    <td>The return type of dereferencing the iterator, which must be
     <tt>T&amp;</tt>.</td>
  </tr>

<!-- I don't think this is necessary
  <tr>
    <td>Pointer type</td>
    <td><tt>std::iterator_traits&lt;X&gt;::pointer</tt></td>
    <td>
     The pointer to the value type, which is <tt>T*</tt>.
    </td>
  </tr>
-->

  <tr>
    <td>Return Category</td>
    <td><tt>std::return_category&lt;X&gt;::type</tt></td>
    <td>
    A type convertible to <tt>std::mutable_lvalue_iterator_tag</tt>
    </td>
  </tr>

</table>

<!-- no longer needed since the return type is specified as reference in the readable iterator
<h3>Valid expressions</h3>

<Table border>
<tr><TH>Name</TH><TH>Expression</TH><TH>Type requirements</TH><TH>Return type</TH></tr>
<tr>
 <td>Dereference</td>
 <td><tt>*x</tt></td>
 <td>&nbsp;</td>
 <td><tt>std::iterator_traits&lt;X&gt;::reference</tt></td>
</tr>
<tr>
 <td>Member access</td>
 <td><tt>x-&gt;m</tt></td>
 <td><tt>T</tt> is a type with a member named <tt>m</tt>.</td>
 <td>
 &nbsp;
 </td>
</tr>
</table>

-->

<p>
<hr>
<!--------------------------------------------------------------------------->

<H3><A NAME="concept:ForwardTraversalIterator"></A>
Forward Traversal Iterator
</H3>

The Forward Iterator is an iterator that can be incremented. Also, it
is permissible to make multiple passes through the iterator's range.

<h3>Refinement of</h3>

<A href="http://www.boost.org/libs/utility/CopyConstructible.html">Copy Constructible</A>,
<A href="http://www.boost.org/libs/utility/Assignable.html">Assignable</A>,
<A href="http://www.sgi.com/tech/stl/DefaultConstructible.html">Default Constructible</A>, and 
<A href="http://www.sgi.com/tech/stl/EqualityComparable.html">Equality Comparable</A>


<h3>Associated types</h3>

<Table border>

  <tr>
    <td>Difference Type</td>
    <td><tt>std::iterator_traits&lt;X&gt;::difference_type</tt></td>
    <td>
    A signed integral type used for representing distances
    between iterators that point into the same range.
    </td>
  </tr>

  <tr>
    <td>Traversal Category</td>
    <td><tt>std::traversal_category&lt;X&gt;::type</tt></td>
    <td>
    A type convertible to <tt>std::forward_traversal_tag</tt>
    </td>
  </tr>
</Table>

<h3>Valid expressions</h3>

<Table border>
  <tr>
    <TH>Name</TH><TH>Expression</TH><TH>Type requirements</TH>
      <TH>Return type</TH>
  </tr>
  <tr>
    <td>Preincrement</td>
    <td><tt>++i</tt></td><td>&nbsp;</td><td><tt>X&amp;</tt></td>
  </tr>
  <tr>
    <td>Postincrement</td>
    <td><tt>i++</tt></td><td>&nbsp;</td><td>convertible to <tt>const X&amp;</tt></td>
  </tr>
</Table>

<p>
<hr>
<!--------------------------------------------------------------------------->

<H3><A NAME="concept:BidirectionalTraversalIterator"></A>
Bidirectional Traversal Iterator
</H3>

An iterator that can be incremented and decremented.

<h3>Refinement of</h3>

<a href="#concept:ForwardTraversalIterator">Forward Traversal Iterator</a>

<h3>Associated types</h3>

<Table border>
  <tr>
    <td>Traversal Category</td>
    <td><tt>std::traversal_category&lt;X&gt;::type</tt></td>
    <td>
    A type convertible to <tt>std::bidirectional_traversal_tag</tt>
    </td>
  </tr>
</Table>

<h3>Valid expressions</h3>

<Table border>
  <tr>
  <TH>Name</TH><TH>Expression</TH><TH>Type requirements</TH>
      <TH>Return type</TH>
  </tr>
  <tr><td>Predecrement</td>
      <td><tt>--i</tt></td><td>&nbsp;</td><td><tt>X&amp;</tt></td>
  </tr>
  <tr><td>Postdecrement</td>
      <td><tt>i--</tt></td><td>&nbsp;</td><td>convertible to <tt>const X&amp;</tt></td>
  </tr>
</table>

<p>
<hr>
<!--------------------------------------------------------------------------->

<H3><A NAME="concept:RandomAccessTraversalIterator"></A>
Random Access Traversal Iterator
</H3>

An iterator that provides constant-time methods for moving forward and
backward in arbitrary-sized steps.

<h3>Refinement of</h3>

<a href="#concept:BidirectionalTraversalIterator">Bidirectional Traversal Iterator</a> and
<A href="http://www.sgi.com/tech/stl/LessThanComparable.html">Less Than Comparable</A> where <tt>&lt;</tt> is a total ordering

<h3>Associated types</h3>

<Table border>
  <tr>
    <td>Traversal Category</td>
    <td><tt>std::traversal_category&lt;X&gt;::type</tt></td>
    <td>
    A type convertible to <tt>std::random_access_traversal_tag</tt>
    </td>
  </tr>
</Table>

<h3>Valid expressions</h3>

<Table border>
<tr><TH>Name</TH><TH>Expression</TH><TH>Type requirements</TH>
    <TH>Return type</TH>
</tr>
<tr><td>Iterator addition</td>
    <td><tt>i += n</tt></td><td>&nbsp;</td><td><tt>X&amp;</tt></td>
</tr>
<tr><td>Iterator addition</td>
    <td><tt>i + n</tt> or <tt>n + i</tt></td><td>&nbsp;</td><td><tt>X</tt></td>
</tr>
<tr><td>Iterator subtraction</td>
   <td><tt>i -= n</tt></td><td>&nbsp;</td><td><tt>X&amp;</tt></td>
</tr>
<tr><td>Iterator subtraction</td>
    <td><tt>i - n</tt></td><td>&nbsp;</td><td><tt>X</tt></td>
</tr>
<tr><td>Difference</td>
    <td><tt>i - j</tt></td><td>&nbsp;</td><td><tt>std::iterator_traits&lt;X&gt;::difference_type</tt></td>
</tr>
<tr><td>Element operator</td>
    <td><tt>i[n]</tt></td>
    <td><tt>X</tt> must also be a model of
     <a href="#concept:ReadableIterator">Readable Iterator</a>. </td>
    <td><tt>std::iterator_traits&lt;X&gt;::reference</tt></td>
</tr>
<tr><td>Element assignment</td>
    <td><tt>i[n] = t</tt></td>
    <td><tt>X</tt> must also be a model of
      <a href="#concept:WritableIterator">Writable Iterator</a>.</td>
    <td>unspecified</td>
</tr>
</table>

<p>

<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy 2000</TD><TD>
<A HREF="../../../../people/jeremy_siek.htm">Jeremy Siek</A>, Univ.of Notre Dame (<A HREF="mailto:jsiek@lsc.nd.edu">jsiek@lsc.nd.edu</A>)
</TD></TR></TABLE>

</body>
</html>
