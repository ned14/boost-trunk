<html>
<!--
  -- Copyright (c) Jeremy Siek 2000
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  I make no representations about the
  -- suitability of this software for any purpose.  It is provided "as is"
  -- without express or implied warranty.
  -->
  <head>
    <title>Boost Iterator Traits</title>
  </head>

  <body>
    <h1>Boost Iterator Traits</h1>
Header <tt><a href="../../boost/iterator_traits.hpp">boost/iterator_traits.hpp</a></tt>

<pre>
namespace boost {

  template &lt;typename Iterator&gt;
  struct iterator_traits
  {
    if (Iterator inherits from new_iterator_base) {
      typedef typename Iterator::value_type value_type;
      typedef typename Iterator::reference reference;
      typedef typename Iterator::pointer pointer;
      typedef typename Iterator::difference_type difference_type;
      typedef typename Iterator::return_category return_category;
      typedef typename Iterator::traversal_category traversal_category;
    } else {
      typedef std::iterator_traits&lt;Iterator&gt; OldTraits;
      typedef typename OldTraits::value_type value_type;
      typedef typename OldTraits::reference reference;
      typedef typename OldTraits::pointer pointer;
      typedef typename OldTraits::difference_type difference_type;

      typedef typename OldTraits::iterator_category Cat;

      <i>// Determine the traversal_category based on the old iterator_category</i>
      if (Cat inherits from std::random_access_iterator_tag)
        typedef boost::random_access_iterator_tag traversal_category;
      else if (Cat inherits from std::bidirectional_iterator_tag)
        typedef boost::bidirectional_iterator_tag traversal_category;
      else if (Cat inherits from std::forward_iterator_tag)
        typedef boost::forward_iterator_tag traversal_category;
      else 
        typedef boost::single_pass_iterator_tag traversal_category;

      <i>// Determine the return_category based on the old iterator_category and value_type</i>
      if (Cat inherits from std::forward_iterator_tag)
        if (is-const(T))
          typedef boost::constant_lvalue_iterator_tag return_category;
        else
          typedef boost::mutable_lvalue_iterator_tag return_category;
      else if (Cat inherits from std::input_iterator_tag)
        typedef boost::readable_iterator_tag return_category;
      else if (Cat inherits from std::output_iterator_tag)
        typedef boost::writable_iterator_tag return_category;
      else
        typedef boost::error_iterator_tag return_category;
    }
  };

  template &lt;typename T&gt;
  struct iterator_traits&lt;T*&gt;
  {
    typedef T value_type;
    typedef T&amp; reference;
    typedef T* pointer;
    typedef std::ptrdiff_t difference_type;
    if (is-const(T))
      typedef boost::constant_lvalue_iterator_tag return_category;
    else
      typedef boost::mutable_lvalue_iterator_tag return_category;
    typedef boost::random_access_iterator_tag traversal_category;
  };

}
</pre>

    <hr>
    <address><a href="mailto:jsiek@lsc.nd.edu">jeremy siek</a></address>
<!-- Created: Sun Mar 18 14:06:57 EST 2001 -->
<!-- hhmts start -->
Last modified: Sun Mar 18 17:10:26 EST 2001
<!-- hhmts end -->
  </body>
</html>
