 /*=============================================================================
    A Standard compliant C++ preprocessor

    Copyright (c) 2001-2003 Hartmut Kaiser
    http://spirit.sourceforge.net/

    Permission to copy, use, modify, sell and distribute this software
    is granted provided this copyright notice appears in all copies.
    This software is provided "as is" without express or implied
    warranty, and with no claim as to its suitability for any purpose.

    See Copyright.txt for full copyright notices and acknowledgements.
=============================================================================*/

#if !defined(_TIME_CONVERSION_HELPER_HPP__DA97E389_1797_43BA_82AE_B071064B3EF4__INCLUDED_)
#define _TIME_CONVERSION_HELPER_HPP__DA97E389_1797_43BA_82AE_B071064B3EF4__INCLUDED_

#include <ctime>
#include <boost/spirit/core.hpp>
#include <boost/spirit/symbols.hpp>

namespace cpplexer {
namespace slex {
namespace util {

///////////////////////////////////////////////////////////////////////////////
//  define, whether the rule's should generate some debug output
#define TRACE_CPP_TIME_CONVERSION \
    (BOOST_SPIRIT_DEBUG_FLAGS_CPP & BOOST_SPIRIT_DEBUG_FLAGS_TIME_CONVERSION) \
    /**/

///////////////////////////////////////////////////////////////////////////////
//  Grammar for parsing a date/time string generated by the C++ compiler from
//  __DATE__ and __TIME__ 
    class time_conversion_grammar :
        public boost::spirit::grammar<time_conversion_grammar>
    {
    public:
        time_conversion_grammar() : fYearIsCorrected(false)
        {
            memset (&time_stamp, 0, sizeof(std::tm));
            BOOST_SPIRIT_DEBUG_TRACE_RULE(*this, "time_conversion_grammar",
                TRACE_CPP_TIME_CONVERSION);
        }
        
        template <typename ScannerT>
        struct definition {
        
            definition(time_conversion_grammar const &self)
            {
                using boost::spirit::int_p;
                using boost::spirit::add;
                
            char const *m[] = {
                    "Jan", "Feb", "Mar", "Apr", "May", "Jun", 
                    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
                };

                for (int i = 0; i < 12; ++i)
                    add (month, m[i], i);

                time_rule       // expected format is 'Dec 29 2001 11:23:59'
                    =   month[boost::spirit::assign(self.time_stamp.tm_mon)]  
                    >>  int_p[boost::spirit::assign(self.time_stamp.tm_mday)]    
                    >>  int_p[boost::spirit::assign(self.time_stamp.tm_year)]
                    >>  int_p[boost::spirit::assign(self.time_stamp.tm_hour)]  
                    >>  int_p[boost::spirit::assign(self.time_stamp.tm_min)]
                    >>  int_p[boost::spirit::assign(self.time_stamp.tm_sec)]
                    ;
                    
                BOOST_SPIRIT_DEBUG_TRACE_RULE(time_rule, TRACE_CPP_TIME_CONVERSION);
            }
            
            boost::spirit::rule<ScannerT> time_rule;
            boost::spirit::symbols<> month;

            boost::spirit::rule<ScannerT> const&
            start() const { return time_rule; }
        };
    
        void correct_year() 
        { 
            if (!fYearIsCorrected) {
                time_stamp.tm_year -= 1900;
                fYearIsCorrected = true;
            }
        }

        mutable std::tm time_stamp;
        bool fYearIsCorrected;
    };
    
///////////////////////////////////////////////////////////////////////////////
// calculate the time of the compilation as a std::time_t to ensure correctness 
// of the saved dfa table 
    class time_conversion_helper
    {
    public:
        time_conversion_helper(char const *act_time) : compile_time(0)
        {
            using namespace boost::spirit;
            
        time_conversion_grammar g;

            if (parse (act_time, g, space_p | ch_p(':')).full) {
                g.correct_year();
                compile_time = std::mktime(&g.time_stamp);
            }
            BOOST_ASSERT(0 != compile_time);        
        }

        std::time_t get_time() { return compile_time; }
        
    private:
        std::time_t compile_time; 
    };

///////////////////////////////////////////////////////////////////////////////
#undef TRACE_CPP_TIME_CONVERSION

}   // namespace util
}   // namespace slex
}   // namespace cpplexer

#endif // !defined(_TIME_CONVERSION_HELPER_HPP__DA97E389_1797_43BA_82AE_B071064B3EF4__INCLUDED_)
