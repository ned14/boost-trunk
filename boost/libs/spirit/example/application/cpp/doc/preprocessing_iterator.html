<html>
    <head>
        <title>CPP - A Standard conformant C++ lexer</title>
        <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
        <link rel="stylesheet" href="theme/style.css" type="text/css">
    </head>
    <body text="#000000" background="theme/bkd.gif">
        
<h1>CPP - A Standard conformant preprocessing C++ lexer</h1>
        <blockquote>
            <p><b>Introduction</b></p>
            
  <p align="justify">During the last time many new features were developed as 
    additions to <tt>Spirit</tt> <a href="preprocessing_iterator.html#spirit">[4]</a> and we felt 
    more and more, that it would be very helpful, to have a 'real world' example, 
    which could be used as a sandbox for testing the usability of certain features. 
    Additionally&nbsp;a recent discussion on the Boost mailing list showed the 
    widespread interest of developers to have a modern C preprocessor library 
    to play with.&nbsp; </p>
  <p align="justify">The C preprocessor sample uses the <a href="http://spirit.sourceforge.net/"> 
    </a> <tt>Spirit<a href="preprocessing_iterator.html#spirit">[4]</a></tt> parser 
    construction library to implement a C++ lexer with ISO/ANSI standard conformant 
    preprocessing capabilities. This C preprocessor library exposes an iterator 
    interface, which returns the current preprocessed token from the input stream. 
    This preprocessed token is generated on the fly while iterating over the preprocessor 
    iterator sequence (in the terminology of the STL these iterators are forward 
    iterators). </p>
  <p align="justify"> The main goals for this project are:</p>
            
  <blockquote> 
    <p><b><img src="theme/bullet.gif" width="13" height="13" id="IMG1">&nbsp;</b>full 
      conformance with the C++ standard (ISO/IEC 14882) <a href="preprocessing_iterator.html#iso_cpp">[1]</a>, 
      later on with the C99 standard (ISO/IEC 9899) <a href="preprocessing_iterator.html#iso_c">[2]</a><br>
      <b><img src="theme/bullet.gif" width="13" height="13">&nbsp;</b>usage of 
      <tt>Spirit<a href="preprocessing_iterator.html#spirit">[4]</a></tt> for the parsing parts 
      of the game (certainly :-)<br>
      <b><img src="theme/bullet.gif" width="13" height="13">&nbsp;</b>maximal 
      usage of STL and/or boost libraries (for compactness and maintainability)<br>
      <b><img src="theme/bullet.gif" width="13" height="13">&nbsp;</b>straightforward 
      extendibility for implementation of additional features</p>
            </blockquote>
            
  <p>At the first steps it is not planned to make a very high performance or very 
    small C preprocessor. If you are looking for these objectives you probably 
    have to look at other places. Although our C preprocessor iterator should 
    work as expected and will be usable as a reference implementation, for instance 
    for testing of other preprocessor oriented libraries as Boost.PP et.al.</p>
            
  <p> <b>How to use the C preprocessor iterator in your own projects</b></p>
            
  <p>The actual preprocessing itself is a highly configurable process, so you 
    obviously have to define a couple of parameters to&nbsp;control this process, 
    such as:</p>
            <BLOCKQUOTE dir="ltr" style="MARGIN-RIGHT: 0px">
                <P><STRONG><IMG id="IMG1" height="13" src="theme/bullet.gif" width="13"></STRONG>&nbsp;include 
                    search pathes, which define, where to search for files to be included with <tt>#include&nbsp;&lt;...&gt;</tt>
                    and <tt>#include&nbsp;"..."</tt> directives<br>
                    <STRONG><img src="theme/bullet.gif" width="13" height="13">&nbsp;</STRONG>which 
                    macros to predefine and which of the predefined macros to undefine<br>
      <STRONG><img src="theme/bullet.gif" width="13" height="13">&nbsp;</STRONG>several 
      other options as for instance to control, whether to issue <tt>#line</tt> 
      statements in the preprocessed stream or not.</P>
            </BLOCKQUOTE>
            
  <P dir="ltr">So the main preprocessing iterators are not to be instantiated 
    directly, but should be generated through a context object, which holds all 
    the preprocessing parameters.</P>
            
  <pre><span class="comment">    // The following preprocesses a given input file.
    // Open a given file and read it into a string variable</span>
    <span class="keyword">std::ifstream</span> instream(<span class="string">&quot;input.cpp&quot;</span>);<br>    <span class="keyword">std::string </span>input<span class="keyword">(
        std::istreambuf_iterator&lt;char&gt;</span>(instream.rdbuf());
        <span class="keyword">std::istreambuf_iterator&lt;char&gt;</span>());

    <span class="keyword">using namespace</span></span> cpplexer::slex;
  
    <span class="comment">// The template lex_token&lt;&gt; is defined in several namespaces: 
    // (at least in cpplexer::slex and cpplexer::re2clex). The 
    // 'using namespace' directive above tells the compiler, 
    // which of them to use. </span>
<span class="comment">    // This token type is the central type throughout the library,
    // because it is a template parameter to many of the public
    // classes and templates and it is returned from the iterators
    // itself.</span>
    <span class="keyword">typedef</span> 
        cpp::context&lt;lex_token&lt;<span class=keyword>std::string::iterator</span>&gt; &gt;
        context_t;

    <span class="comment">// The C preprocessor iterators shouldn't be constructed directly. 
    // These are to be generated through a cpp::context&lt;&gt; object. 
    // Additionally this cpp:context&lt;&gt; object is to be used to
    // initialize and define different parameters of the actual 
    // preprocessing.
</span>    context_t ctx(input.begin(), input.end(), <span class="string">&quot;input.cpp&quot;</span>);
    context_t::iterator_t first = ctx.begin();
    context_t::iterator_t last = ctx.end();

<span class="comment">    // The preprocessing of the input stream is done on the fly 
    // behind the scenes during the iteration over the 
    // context_t::iterator_t based stream. </span>
       <span class="keyword">while</span> (first != last) {
           <span class="keyword">std::cout</span> &lt;&lt; (*first).get_value();
           ++first;
       }

</pre>
  <p>
            </p>
            
  <P dir="ltr"><B>Structure of the&nbsp;C preprocessor iterator library</B></P>
            
  <P dir="ltr">The C preprocessor iterator itself is feeded by a C++ lexer iterator, 
    which implements an unified interface. BTW, the C++ lexer iterators contained 
    with the CPP example may be used standalone too and are not tied to the C 
    preprocessor iterator at all. </P>
  <P dir="ltr">There are two different C++ lexers implemented by now,&nbsp;which 
    are functionally completely identical. The C++ lexers expose the mentioned 
    unified interface, so that the C preprocessor iterator may be used with both 
    of them. The abstraction of the C++ lexer from the C preprocessor iterator 
    library was done to allow to plug in different C++ lexers without the need 
    to reimplement the preprocessor. This will allow for benchmarking and specific 
    finetuning of the process of preprocessing itself.</P>
            
  <P dir="ltr">The first of this C++ lexers is implemented with the help of the 
    wellknown <tt>re2c</tt> <a href="preprocessing_iterator.html#re2c">[3]</a> tool, which generates 
    C code from given regular expressions. The lexers generated with <tt>re2c</tt> 
    are known to be very fast, because they are not&nbsp;table driven but the 
    whole token building logic is coded directly (very similar to hand coded lexers). 
  </P>
            
  <P dir="ltr">The second of this C++ lexers is build around a table driven lexer, 
    where the DFA tables are generated from regular expressions with the help 
    of a Spirit based lexer generating framework named <tt>Slex</tt> <a href="preprocessing_iterator.html#slex">[5]</a>. 
    The <tt>Slex</tt> is feeded during runtime with the token definitions (regular 
    expressions) and generates the resulting DFA table. This table is used to 
    combine the input characters into corresponding lexems (tokens). The generated 
    DFA table can be saved to disc to avoid the generation process at program 
    startup.</P>
            
  <P dir="ltr">It is possible to build other C++ lexers if needed. Currently there 
    are plans to adapt the <tt>Spirit</tt> C++ lexer example <tt>cpplexer</tt> 
    <a href="preprocessing_iterator.html#cpplexer">[6]</a>, which is completely based on static 
    <tt>Spirit<a href="preprocessing_iterator.html#spirit">[4]</a></tt> grammars.</P>
	
  <P dir="ltr"><b>Library compile time configuration</b></P>
  <P dir="ltr">The C preprocessor iterator library may be configured at compile 
    time by specifying different preprocessor constants to include different additional 
    features. The possible preprocessor constants are described in the following 
    table. </P>
  <table width="90%" border="0" align="center">
    <tr> 
      <td colspan="2" class="table_title"><b>Summary of possible preprocessor 
        constants for<br>
        library configuration</b></td>
    </tr>
    <tr> 
      <td width="39%" class="table_cells"><code>CPP_SUPPORT_WARNING_DIRECTIVE</code></td>
      <td width="61%" class="table_cells"> <p>Support the #warning directive</p></td>
    </tr>
    <tr> 
      <td width="39%" class="table_cells"><code>CPP_SUPPORT_MS_EXTENSIONS</code></td>
      <td width="61%" class="table_cells"> <p>Support several MS specific language 
          extensions (i.e. <tt>__int8</tt> et.al.)</p></td>
    </tr>
    <tr> 
      <td class="table_cells"><code>COMPILE_RE2C_AS_CPP</code></td>
      <td class="table_cells"><p>Allows to compile the Re2c based lexer in 'C' 
          mode instead of normal 'C++' mode.<br>
          This option is required, because at least the VC7.1 (final beta) compiler 
          has problems to compile it with optimization switched on.</p></td>
    </tr>
    <tr> 
      <td class="table_cells"><code>CPP_PREPROCESS_ERROR_MESSAGE_BODY</code></td>
      <td class="table_cells"><p>Switches on the preprocessing of the message 
          bodies of <span class="keyword">#error</span> and <span class="keyword">#warning</span> 
          directives.</p></td>
    </tr>
    <tr> 
      <td class="table_cells"><code>CPP_RETURN_PRAGMA_DIRECTIVES</code></td>
      <td class="table_cells"><p>If defined, then the <span class="keyword">#pragma</span> 
          directives are returned as a token sequence to the caller, if not defined, 
          the whole <span class="keyword">#pragma</span> directive is skipped.</p></td>
    </tr>
    <tr>
      <td class="table_cells"><code>CPP_PREPROCESS_PRAGMA_BODY</code></td>
      <td class="table_cells"><p>Switches on the preprocessing of the bodies of 
          <span class="keyword"> #pragma</span> directives</p></td>
    </tr>
  </table>
  <P dir="ltr"></P>
  <P dir="ltr"><b>Separation and inclusion compilation models</b></P>
  <P dir="ltr">The C preprocessor iterator library is build almost as a header 
    only library (except for the re2c based lexer). If you're trying to include 
    all required files at once you will mention, that the resulting compilation 
    times are very large (up to an hour - depending on your system configuration). 
    This straightforward method we'll call the inclusion compilation model. If 
    you do not pay attention to compilation times, that's the way to go, no special 
    handling is needed.</P>
            
  <P dir="ltr">If you're interested in decreasing compilation times, the following 
    method is to be used. This we will call the separation compilation model. 
    The trick is to separate the different objects such, that they are compilable 
    separately. The function, which instantiates the templated object in question 
    is factored out such, that its definition is visible to only one translation 
    unit. To simplify this further this creation function is packaged into a small 
    generator template structure.</P>
            
  <P dir="ltr">There are two levels of separation implemented: the separation 
    of the compilation of the C++ lexer and the separation of the compilation 
    of the different Spirit grammars used. To use these separations you will have 
    to define two preprocessor constants while compiling the whole application 
    and you will have to explicitely instantiate some helper templates. The following 
    tables shows these constants in detail.</P>
            
  <table width="90%" border="0" align="center">
    <tr> 
      <td colspan="2" class="table_title"><b>Summary of possible compilation constants 
        required <br>
        to enable the separation compilation model</b></td>
    </tr>
    <tr class="table_title"> 
      <td width="25%"><b>Separate</b></td>
      <td width="75%"><p><code><font face="Verdana, Arial, Helvetica, sans-serif">Preprocessor 
          constant</font></code></p></td>
    </tr>
    <tr> 
      <td width="25%" class="table_cells"><code>C++ lexer</code></td>
      <td width="75%" class="table_cells"> <p><code>CPP_SEPARATE_LEXER_INSTANTIATION</code></p></td>
    </tr>
    <tr> 
      <td width="25%" class="table_cells"><code>Spirit grammars</code></td>
      <td width="75%" class="table_cells"> <p><code>CPP_SEPARATE_GRAMMAR_INSTANTIATION</code></p></td>
    </tr>
  </table>
  <P dir="ltr">The following table shows the explicit template instantiations 
    required, if you want to use the separation compilation model. The <tt>TokenT</tt> 
    placeholder type has to be replaced with your token type to use. You will 
    achieve the best results, if you place these into separate compilation units 
    each. </P>
  <P dir="ltr">For an example of this you can look at the <tt>cpp</tt> driver 
    program included as an acompanion sample to the C preprocessor iterator library. 
    The corresponding files are named obviously <span class="string">&quot;instantiate_...something.cpp&quot;</span>, 
    where the <span class="string">'...somthing'</span> is a hint, which grammars 
    are explicitely instantiated inside. By using the separation model the compilation 
    times required to build the <tt>cpp</tt> example are dropped by up to 90%.</P>
  <table width="90%" border="0" align="center">
    <tr> 
      <td colspan="2" class="table_title"><b>Summary of required explicit template 
        instantiations <br>
        required when using the separation compilation model</b></td>
    </tr>
    <tr class="table_title"> 
      <td width="25%"><b>Separate</b></td>
      <td width="75%"><p><code><font face="Verdana, Arial, Helvetica, sans-serif">Templates 
          to explicitly instantiate</font></code></p></td>
    </tr>
    <tr> 
      <td width="25%" class="table_cells"><code>C++ lexers</code></td>
      <td width="75%" class="table_cells"> <code><span class="keyword">template</span> 
        cpplexer::re2clex::new_lexer_gen&lt;<tt>TokenT</tt>&gt;; <span class="table_cells">or</span><br>
        <span class="keyword"> template</span> cpplexer::slex::new_lexer_gen&lt;<tt>TokenT</tt>&gt;;</code></td>
    </tr>
    <tr> 
      <td width="25%" class="table_cells"><code>Spirit grammars</code></td>
      <td width="75%" class="table_cells"> <p><span class="keyword"><code>template</code><code></code></span><code> 
          cpp::grammars::cpp_grammar_gen&lt;<tt>TokenT</tt>&gt;;<br>
          <span class="keyword"> template</span> cpp::grammars::expression_grammar_gen&lt<tt>TokenT</tt>&gt;;<br>
          <span class="keyword"> template</span> cpp::grammars::intlit_grammar_gen&lt;<tt>TokenT</tt>&gt;;<br>
          <span class="keyword"> template</span> cpp::grammars::chlit_grammar_gen&lt;<tt>TokenT</tt>&gt;;<br>
          <span class="keyword"> template</span> cpp::grammars::floatlit_grammar_gen&lt;<tt>TokenT</tt>&gt;;</code></p></td>
    </tr>
  </table>
  <P dir="ltr">&nbsp;</P>
  <P dir="ltr"><b>References</b></P>
  <table width="90%" border="0" align="center">
    <tr> 
      <td class="table_cells"> 1.</td>
      <td class="table_cells"> <a name="iso_cpp"></a>INCITS/ISO/IEC </td>
      <td class="table_cells"><a href="http://webstore.ansi.org/ansidocstore/product.asp?sku=INCITS%2FISO%2FIEC%2B14882%2D1998">&quot;Programming 
        languages - C++&quot;</a> <br>
        INCITS/ISO/IEC 14882-1998</td>
    </tr>
    <tr> 
      <td width="36" class="table_cells">2.</td>
      <td width="236" class="table_cells"> <a name="iso_c"></a>INCITS/ISO/IEC 
      </td>
      <td width="520" class="table_cells"><a href="http://webstore.ansi.org/ansidocstore/product.asp?sku=INCITS/ISO/IEC%2B9899-1999">&quot;Programming 
        languages - C&quot;</a> <br>
        INCITS/ISO/IEC 9899-1999</td>
    </tr>
    <tr> 
      <td class="table_cells">3.</td>
      <td class="table_cells"> <a name="re2c"></a>Peter Bumbulis and <br>
        Donald D. Cowan</td>
      <td class="table_cells"><a href="http://www.tildeslash.org/re2c/index.html">Re2c 
        V0.9.1 </a><br>
        A tool for generating C-based recognizers from regular expressions</td>
    </tr>
    <tr> 
      <td class="table_cells">4.</td>
      <td class="table_cells"><a name="spirit"></a>Joel de Guzman et.al.</td>
      <td class="table_cells"><a href="http://spirit.sourceforge.net/">Spirit v1.5.2 
        documentation</a></td>
    </tr>
    <tr> 
      <td class="table_cells">5.</td>
      <td class="table_cells"><a name="slex"></a>Daniel C. Nuffer</td>
      <td class="table_cells"><a href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/boost/boost/libs/spirit/example/application/slex/">The 
        <tt>Spirit</tt> Slex example</a></td>
    </tr>
    <tr> 
      <td class="table_cells">6.</td>
      <td class="table_cells"><a name="cpplexer"></a>Juan Carlos Arevalo-Baeza</td>
      <td class="table_cells"><a href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/boost/boost/libs/spirit/example/application/cpp_lexer/">The 
        <tt>Spirit</tt> cpplexer example</a></td>
    </tr>
  </table>
  <P dir="ltr">&nbsp;</P>
        </blockquote>
    </body>
</html>
