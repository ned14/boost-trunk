<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>Regex++, Appendices</TITLE>
<META NAME="Template" CONTENT="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
</HEAD>
<BODY LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff">

<P><!DOCTYPE HTML PUBLIC "-//w3c//dtd html 4.0 transitional//en">&nbsp; </P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=624>
<TR><TD WIDTH="50%" VALIGN="TOP">
<H3><IMG SRC="../../c++boost.gif" WIDTH=276 HEIGHT=86 ALT="C++ Boost"></H3></TD>
<TD WIDTH="50%" VALIGN="TOP">
<H3 ALIGN="CENTER">Regex++, Appendices.</H3>
<I><P ALIGN="CENTER">(version 3.12, 18 April 2000)</I> </P>
<I><PRE>Copyright (c) 1998-2000
Dr John Maddock

Permission to use, copy, modify, distribute and sell this software
and its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear
in supporting documentation.&nbsp; Dr John Maddock makes no representations
about the suitability of this software for any purpose.&nbsp;&nbsp;
It is provided "as is" without express or implied warranty.</PRE></I></TD>
</TR>
</TABLE>

<P><HR></P>
<H3><A NAME="implementation"></A>Appendix 1: Implementation notes</H3>
<P>This is the first port of regex++ to the boost library, and is based on regex++ 2.x, see changes.txt for a full list of changes from the previous version. There are no known functionality bugs except that POSIX style equivalence classes are only guaranteed correct if the Win32 localization model is used (the default for Win32 builds of the library). </P>
<P>There are some aspects of the code that C++ puritans will consider to be poor style, in particular the use of goto in some of the algorithms. The code could be cleaned up, by changing to a recursive implementation, although it is likely to be slower in that case. </P>
<P>The performance of the algorithms should be satisfactory in most cases. For example the times taken to match the ftp response expression "^([0-9]+)(\-| |$)(.*)$" against the string "100- this is a line of ftp response which contains a message string" are: BSD implementation 450 micro seconds, GNU implementation 271 micro seconds, regex++ 127 micro seconds (Pentium P90, Win32 console app under MS Windows 95). </P>
<P>However it should be noted that there are some "pathological" expressions which may require exponential time for matching; these all involve nested repetition operators, for example attempting to match the expression "(a*a)*b" against <I>N</I> letter a's requires time proportional to <I>2<SUP>N</I></SUP>. These expressions can (almost) always be rewritten in such a way as to avoid the problem, for example "(a*a)*b" could be rewritten as "a*b" which requires only time linearly proportional to <I>N</I> to solve. In the general case, non-nested repeat expressions require time proportional to <I>N<SUP>2</I></SUP>, however if the clauses are mutually exclusive then they can be matched in linear time - this is the case with "a*b", for each character the matcher will either match an "a" or a "b" or fail, where as with "a*a" the matcher can't tell which branch to take (the first "a" or the second) and so has to try both. <I>Be careful how you write your regular expressions and avoid nested repeats if you can! New to this version, some previously pathological cases have been fixed - in particular searching for expressions which contain leading repeats and/or leading literal strings should be much faster than before. Literal strings are now searched for using the Knuth/Morris/Pratt algorithm (this is used in preference to the Boyer/More algorithm because it allows the tracking of newline characters).</I> </P>
<I><P>Some aspects of the POSIX regular expression syntax are implementation defined:</I> </P>

<UL>
<LI>The "leftmost-longest" rule for determining what matches is ambiguous, this library takes the "obvious" interpretation: find the leftmost match, then maximize the length of each sub-expression in turn with lower indexed sub-expressions taking priority over higher indexed sub-expression. </LI>
<LI>The behavior of multi-character collating elements is ambiguous in the standard, in particular expressions such as [a[.ae.]] may have subtle inconsistencies lurking in them. This implementation matches bracket expressions as follows: all bracket expressions match a single character only, unless the expression contains a multi-character collating element, either on its own, or as the endpoint to a range, in which case the expression may match more than one character. </LI>
<LI>Repeated null expressions are repeated only once, they are treated "as if" they were matched the maximum number of times allowed by the expression. </LI>
<LI>The behavior of back references is ambiguous in the standard, in particular it is unclear whether expressions of the form "((ab*)\2)+" should be allowed. This implementation allows such expressions and the back reference matches whatever the last sub-expression match was. This means that at the end of the match, the back references may have matched strings different from the final value of the sub-expression to which they refer. </LI></UL>

<P><HR></P>
<H3><A NAME="threads"></A>Appendix 2: Thread safety</H3>
<P>Class reg_expression&lt;&gt; and its typedefs regex and wregex are thread safe, in that compiled regular expressions can safely be shared between threads. The matching algorithms regex_match, regex_search, regex_grep, regex_format and regex_merge are all re-entrant and thread safe. Class match_results is now thread safe, in that the results of a match can be safely copied from one thread to another (for example one thread may find matches and push match_results instances onto a queue, while another thread pops them off the other end), otherwise use a separate instance of match_results per thread. </P>
<P>The POSIX API functions are all re-entrant and thread safe, regular expressions compiled with <I>regcomp</I> can also be shared between threads. </P>
<P>The class RegEx is only thread safe if each thread gets its own RegEx instance (apartment threading) - this is a consequence of RegEx handling both compiling and matching regular expressions. </P>
<P>Finally note that changing the global locale invalidates all compiled regular expressions, therefore calling <I>set_locale</I> from one thread while another uses regular expressions <I>will</I> produce unpredictable results. </P>
<P>There is also a requirement that there is only one thread executing prior to the start of main(). </P>
<P><HR></P>
<H3><A NAME="localisation"></A>Appendix 3: Localization</H3>
<P>&nbsp;Regex++ provides extensive support for run-time localization, the localization model used can be split into two parts: front-end and back-end. </P>
<P>Front-end localization deals with everything which the user sees - error messages, and the regular expression syntax itself. For example a French application could change [[:word:]] to [[:mot:]] and \w to \m. Modifying the front end locale requires active support from the developer, by providing the library with a message catalogue to load, containing the localized strings. Front-end locale is affected by the LC_MESSAGES category only. </P>
<P>Back-end localization deals with everything that occurs after the expression has been parsed - in other words everything that the user does not see or interact with directly. It deals with case conversion, collation, and character class membership. The back-end locale does not require any intervention from the developer - the library will acquire all the information it requires for the current locale from the underlying operating system / run time library. This means that if the program user does not interact with regular expressions directly - for example if the expressions are embedded in your C++ code - then no explicit localization is required, as the library will take care of everything for you. For example embedding the expression [[:word:]]+ in your code will always match a whole word, if the program is run on a machine with, for example, a Greek locale, then it will still match a whole word, but in Greek characters rather than Latin ones. The back-end locale is affected by the LC_TYPE and LC_COLLATE categories. </P>
<P>There are three separate localization mechanisms supported by regex++: </P>
<I><P>Win32 localization model.</I> </P>
<P>This is the default model when the library is compiled under Win32, and is encapsulated by the traits class <A HREF="template_class_ref.htm#regex_char_traits">w32_regex_traits</A>. When this model is in effect there is a single global locale as defined by the user's control panel settings, and returned by GetUserDefaultLCID. All the settings used by regex++ are acquired directly from the operating system bypassing the C run time library. Front-end localization requires a resource dll, containing a string table with the user-defined strings. The traits class exports the function: </P>
<P>static std::string set_message_catalogue(const std::string&amp; s); </P>
<P>which needs to be called with a string identifying the name of the resource dll, <I>before</I> your code compiles any regular expressions (but not necessarily before you construct any <I>reg_expression</I> instances): </P>
<P>boost::w32_regex_traits&lt;char&gt;::set_message_calalogue("mydll.dll"); </P>
<P>Note that this API sets the dll name for <I>both</I> the narrow and wide character specializations of w32_regex_traits. </P>
<P>This model does not currently support thread specific locales (via SetThreadLocale under Windows NT), the library provides full Unicode support under NT, under Windows 9x the library degrades gracefully - characters 0 to 255 are supported, the remainder are treated as "unknown" graphic characters. </P>
<I><P>C localization model.</I> </P>
<P>This is the default model when the library is compiled under an operating system other than Win32, and is encapsulated by the traits class <A HREF="template_class_ref.htm#regex_char_traits"><I>c_regex_traits</I></A>, Win32 users can force this model to take effect by defining the pre-processor symbol BOOST_RE_LOCALE_C. When this model is in effect there is a single global locale, as set by <I>setlocale</I>. All settings are acquired from your run time library, consequently Unicode support is dependent upon your run time library implementation. Front end localization requires a POSIX message catalogue. The traits class exports the function: </P>
<P>static std::string set_message_catalogue(const std::string&amp; s); </P>
<P>which needs to be called with a string identifying the name of the message catalogue, <I>before</I> your code compiles any regular expressions (but not necessarily before you construct any <I>reg_expression</I> instances): </P>
<P>boost::c_regex_traits&lt;char&gt;::set_message_calalogue("mycatalogue"); </P>
<P>Note that this API sets the dll name for <I>both</I> the narrow and wide character specializations of c_regex_traits. If your run time library does not support POSIX message catalogues, then you can either provide your own implementation of &lt;nl_types.h&gt; or define BOOST_RE_NO_CAT to disable front-end localization via message catalogues. </P>
<P>Note that calling <I>setlocale</I> invalidates all compiled regular expressions, calling <TT>setlocale(LC_ALL, "C")</TT> will make this library behave equivalent to most traditional regular expression libraries including version 1 of this library. </P>
<I><TT><P>C++ </TT>localization<TT> </TT>model<TT>.</I></TT> </P>
<P>This model is only in effect if the library is built with the pre-processor symbol BOOST_RE_LOCALE_CPP defined. When this model is in effect each instance of reg_expression&lt;&gt; has its own instance of std::locale, class reg_expression&lt;&gt; also has a member function <I>imbue</I> which allows the locale for the expression to be set on a per-instance basis. Front end localization requires a POSIX message catalogue, which will be loaded via the std::messages facet of the expression's locale, the traits class exports the symbol: </P>
<P>static std::string set_message_catalogue(const std::string&amp; s); </P>
<P>which needs to be called with a string identifying the name of the message catalogue, <I>before</I> your code compiles any regular expressions (but not necessarily before you construct any <I>reg_expression</I> instances): </P>
<P>boost::cpp_regex_traits&lt;char&gt;::set_message_calalogue("mycatalogue"); </P>
<P>Note that calling reg_expression&lt;&gt;::imbue will invalidate any expression currently compiled in that instance of reg_expression&lt;&gt;. This model is the one which closest fits the ethos of the C++ standard library, however it is the model which will produce the slowest code, and which is the least well supported by current standard library implementations, for example I have yet to find an implementation of std::locale which supports either message catalogues, or locales other than "C" or "POSIX". </P>
<P>Finally note that if you build the library with a non-default localization model, then the appropriate pre-processor symbol (BOOST_RE_LOCALE_C or BOOST_RE_LOCALE_CPP) must be defined both when you build the support library, and when you include &lt;boost/regex.hpp&gt; or &lt;boost/cregex.hpp&gt; in your code. The best way to ensure this is to add the #define to &lt;boost/regex/detail/regex_options.hpp&gt;. </P>
<I><P>Providing a message catalogue:</I> </P>
<P>In order to localize the front end of the library, you need to provide the library with the appropriate message strings contained either in a resource dll's string table (Win32 model), or a POSIX message catalogue (C or C++ models). In the latter case the messages must appear in message set zero of the catalogue. The messages and their id's are as follows: <BR>
&nbsp; </P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=6 WIDTH=624>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>Message id </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>Meaning </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>Default value </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>101 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character used to start a sub-expression. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"(" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>102 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character used to end a sub-expression declaration. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>")" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>103 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character used to denote an end of line assertion. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"$" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>104 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character used to denote the start of line assertion. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"^" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>105 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character used to denote the "match any character expression". </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"." </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>106 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The match zero or more times repetition operator. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"*" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>107 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The match one or more repetition operator. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"+" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>108 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The match zero or one repetition operator. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"?" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>109 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character set opening character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"[" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>110 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character set closing character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"]" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>111 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The alternation operator. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"|" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>112 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The escape character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"\\" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>113 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The hash character (not currently used). </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"#" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>114 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The range operator. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"-" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>115 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The repetition operator opening character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"{" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>116 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The repetition operator closing character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"}" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>117 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The digit characters. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"0123456789" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>118 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents the word boundary assertion. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"b" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>119 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents the non-word boundary assertion. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"B" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>120 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents the word-start boundary assertion. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"&lt;" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>121 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents the word-end boundary assertion. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"&gt;" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>122 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents any word character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"w" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>123 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents a non-word character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"W" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>124 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents a start of buffer assertion. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"`A" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>125 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents an end of buffer assertion. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"'z" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>126 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The newline character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"\n" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>127 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The comma separator. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"," </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>128 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents the bell character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"a" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>129 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents the form feed character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"f" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>130 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents the newline character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"n" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>131 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents the carriage return character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"r" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>132 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents the tab character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"t" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>133 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents the vertical tab character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"v" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>134 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents the start of a hexadecimal character constant. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"x" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>135 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents the start of an ASCII escape character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"c" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>136 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The colon character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>":" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>137 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The equals character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"=" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>138 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents the ASCII escape character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"e" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>139 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents any lower case character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"l" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>140 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents any non-lower case character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"L" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>141 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents any upper case character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"u" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>142 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents any non-upper case character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"U" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>143 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents any space character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"s" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>144 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents any non-space character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"S" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>145 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents any digit character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"d" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>146 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents any non-digit character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"D" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>147 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents the end quote operator. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"E" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>148 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents the start quote operator. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"Q" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>149 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents a Unicode combining character sequence. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"X" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>150 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents any single character. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"C" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>151 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents end of buffer operator. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"Z" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="21%" VALIGN="TOP">
<P>152 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character which when preceded by an escape character represents the continuation assertion. </TD>
<TD WIDTH="29%" VALIGN="TOP">
<P>"G" </TD>
<TD WIDTH="9%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
</TABLE>

<P><BR>
&nbsp; </P>
<P>Custom error messages are loaded as follows: <BR>
&nbsp; </P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=624>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>Message ID </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>Error message ID </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>Default string </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>201 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>REG_NOMATCH </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"No match" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>202 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>REG_BADPAT </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"Invalid regular expression" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>203 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>REG_ECOLLATE </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"Invalid collation character" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>204 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>REG_ECTYPE </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"Invalid character class name" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>205 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>REG_EESCAPE </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"Trailing backslash" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>206 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>REG_ESUBREG </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"Invalid back reference" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>207 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>REG_EBRACK </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"Unmatched [ or [^" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>208 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>REG_EPAREN </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"Unmatched ( or \\(" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>209 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>REG_EBRACE </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"Unmatched \\{" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>210 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>REG_BADBR </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"Invalid content of \\{\\}" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>211 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>REG_ERANGE </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"Invalid range end" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>212 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>REG_ESPACE </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"Memory exhausted" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>213 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>REG_BADRPT </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"Invalid preceding regular expression" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>214 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>REG_EEND </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"Premature end of regular expression" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>215 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>REG_ESIZE </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"Regular expression too big" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>216 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>REG_ERPAREN </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"Unmatched ) or \\)" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>217 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>REG_EMPTY </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"Empty expression" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>218 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>REG_E_UNKNOWN </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"Unknown error" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
</TABLE>

<P><BR>
&nbsp; </P>
<P>Custom character class names are loaded as followed: <BR>
&nbsp; </P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=624>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>Message ID </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>Description </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>Equivalent default class name </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>300 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character class name for alphanumeric characters. </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"alnum" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>301 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character class name for alphabetic characters. </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"alpha" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>302 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character class name for control characters. </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"cntrl" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>303 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character class name for digit characters. </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"digit" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>304 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character class name for graphics characters. </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"graph" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>305 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character class name for lower case characters. </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"lower" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>306 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character class name for printable characters. </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"print" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>307 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character class name for punctuation characters. </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"punct" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>308 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character class name for space characters. </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"space" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>309 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character class name for upper case characters. </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"upper" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>310 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character class name for hexadecimal characters. </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"xdigit" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>311 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character class name for blank characters. </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"blank" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>312 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character class name for word characters. </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"word" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="8%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="22%" VALIGN="TOP">
<P>313 </TD>
<TD WIDTH="32%" VALIGN="TOP">
<P>The character class name for Unicode characters. </TD>
<TD WIDTH="31%" VALIGN="TOP">
<P>"unicode" </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
</TABLE>

<P><BR>
&nbsp; </P>
<P>Finally, custom collating element names are loaded starting from message id 400, and terminating when the first load thereafter fails. Each message looks something like: "tagname string" where <I>tagname</I> is the name used inside [[.tagname.]] and <I>string</I> is the actual text of the collating element. Note that the value of collating element [[.zero.]] is used for the conversion of strings to numbers - if you replace this with another value then that will be used for string parsing - for example use the Unicode character 0x0660 for [[.zero.]] if you want to use Unicode Arabic-Indic digits in your regular expressions in place of Latin digits. </P>
<P>Note that the POSIX defined names for character classes and collating elements are always available - even if custom names are defined, in contrast, custom error messages, and custom syntax messages replace the default ones. </P>
<P><HR></P>
<H3><A NAME="demos"></A>Appendix 4: Example Applications</H3>
<P>There are three demo applications that ship with this library, they all come with makefiles for Borland, Microsoft and gcc compilers, otherwise you will have to create your own makefiles. </P>
<H5>regress.exe: </H5>
<P>A regression test application that gives the matching/searching algorithms a full workout. The presence of this program is your guarantee that the library will behave as claimed - at least as far as those items tested are concerned - if anyone spots anything that isn't being tested I'd be glad to hear about it. </P>
<P>Files: <A HREF="test/regress/parse.cpp">parse.cpp</A>, <A HREF="test/regress/regress.cpp">regress.cpp</A>, <A HREF="test/regress/tests.cpp">tests.cpp</A>. </P>
<H5>jgrep.exe </H5>
<P>A simple grep implementation, run with no command line options to find out its usage. Look at <A HREF="src/fileiter.cpp">fileiter.cpp</A>/fileiter.hpp and the mapfile class to see an example of a "smart" bidirectional iterator that can be used with regex++ or any other STL algorithm. </P>
<P>Files: <A HREF="example/jgrep/jgrep.cpp">jgrep.cpp</A>, <A HREF="example/jgrep/main.cpp">main.cpp</A>. </P>
<H5>timer.exe </H5>
<P>A simple interactive expression matching application, the results of all matches are timed, allowing the programmer to optimize their regular expressions where performance is critical. </P>
<P>Files: <A HREF="example/timer/regex_timer.cpp">regex_timer.cpp</A>. </P>
<P>The snippets examples contain the code examples used in the documentation:</P>
<P><A HREF="example/snippets/regex_match_example.cpp">regex_match_example.cpp</A>: ftp based regex_match example.</P>
<P><A HREF="example/snippets/regex_search_example.cpp">regex_search_example.cpp</A>: regex_search example: searches a cpp file for class definitions.</P>
<P><A HREF="example/snippets/regex_grep_example_1.cpp">regex_grep_example_1.cpp</A>: regex_grep example 1: searches a cpp file for class definitions.</P>
<P><A HREF="example/snippets/regex_merge_example.cpp">regex_merge_example.cpp</A>: regex_merge example: converts a C++ file to syntax highlighted HTML.</P>
<P><A HREF="example/snippets/regex_grep_example_2.cpp">regex_grep_example_2.cpp</A>: regex_grep example 2: searches a cpp file for class definitions, using a global callback function. </P>
<P><A HREF="example/snippets/regex_grep_example_3.cpp">regex_grep_example_3.cpp</A>: regex_grep example 2: searches a cpp file for class definitions, using a bound member function callback.</P>
<P><A HREF="example/snippets/regex_grep_example_4.cpp">regex_grep_example_4.cpp</A>: regex_grep example 2: searches a cpp file for class definitions, using a C++ Builder closure as a callback.</P>
<P><A HREF="example/snippets/regex_split_example_1.cpp">regex_split_example_1.cpp</A>: regex_split example: split a string into tokens.</P>
<P><A HREF="example/snippets/regex_split_example_2.cpp">regex_split_example_2.cpp</A>: regex_split example: spit out linked URL's.</P>
<P><HR></P>
<H3><A NAME="headers"></A>Appendix 5: Header Files</H3>
<P>There are two main headers used by this library: &lt;boost/regex.hpp&gt; provides full access to the entire library, while &lt;boost/cregex.hpp&gt; provides access to just the high level class RegEx, and the POSIX API functions. </P>
<P><HR></P>
<H3><A NAME="redist"></A>Appendix 6: Redistributables</H3>
<P>&nbsp;If you are using Microsoft or Borland C++ and link to a dll version of the run time library, then you will also link to one of the dll versions of regex++. While these dll's are redistributable, there are no "standard" versions, so when installing on the users PC, you should place these in a directory private to your application, and not in the PC's directory path. Note that if you link to a static version of your run time library, then you will also link to a static version of regex++ and no dll's will need to be distributed. The possible regex++ dll's are as follows: <BR>
&nbsp; </P>
<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=624>
<TR><TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<B><P>Development Tool</B> </TD>
<TD WIDTH="30%" VALIGN="TOP">
<B><P>Run Time Library</B> </TD>
<TD WIDTH="30%" VALIGN="TOP">
<B><P>Regex++ Dll</B> </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<P>Microsoft Visual C++ 6 </TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>Msvcp60.dll and msvcrt.dll </TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>Mre200l.dll </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<P>Microsoft Visual C++ 6 </TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>Msvcp60d.dll and msvcrtd.dll </TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>Mre300dl.dll </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<P>Borland C++ Builder 4 </TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>Cw3245.dll </TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>bcb4re300l.dll </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<P>Borland C++ Builder 4 </TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>Cw3245mt.dll </TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>bcb4re300lm.dll </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<P>Borland C++ Builder 4 </TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>Cp3245mt.dll and vcl40.bpl </TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>bcb4re300lv.dll </TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<P ALIGN="CENTER">Borland C++ Builder 5</TD>
<TD WIDTH="30%" VALIGN="TOP">
<P ALIGN="CENTER">cp3250.dll</TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>bcb5re300l.dll</TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<P ALIGN="CENTER">Borland C++ Builder 5</TD>
<TD WIDTH="30%" VALIGN="TOP">
<P ALIGN="CENTER">cp3250mt.dll</TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>bcb5re300lm.dll</TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
<TR><TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
<TD WIDTH="27%" VALIGN="TOP">
<P ALIGN="CENTER">Borland C++ Builder 5</TD>
<TD WIDTH="30%" VALIGN="TOP">
<P ALIGN="CENTER">cw3250mt.dll</TD>
<TD WIDTH="30%" VALIGN="TOP">
<P>bcb5re300lv.dll</TD>
<TD WIDTH="7%" VALIGN="TOP">
<P>&nbsp;</TD>
</TR>
</TABLE>

<P>Note: you can disable automatic library selection by defining the symbol BOOST_RE_NO_LIB when compiling, this is useful if you want to statically link even though you're using the dll version of your run time library, or if you need to debug regex++. </P>
<P><HR></P>
<H3><A NAME="upgrade"></A>Notes for upgraders</H3>
<P>This version of regex++ is the first to be ported to the <A HREF="http://www.boost.org/">boost</A> project, and as a result has a number of changes to comply with the boost coding guidelines. </P>
<P>Headers have been changed from &lt;header&gt; or &lt;header.h&gt; to &lt;boost/header.hpp&gt; </P>
<P>The library namespace has changed from "jm", to "boost". </P>
<P>The reg_xxx algorithms have been renamed regex_xxx (to improve naming consistency). </P>
<P>Algorithm query_match has been renamed regex_match, and only returns true if the expression matches the whole of the input string (think input data validation). </P>
<I><P>Compiling existing code:</I> </P>
<P>The directory, libs/regex/old_include contains a set of headers that make this version of regex++ compatible with previous ones, either add this directory to your include path, or copy these headers to the root directory of your boost installation. The contents of these headers are deprecated and undocumented - really these are just here for existing code - for new projects use the new header forms. </P>
<P><HR></P>
<H3><A NAME="furtherInfo"></A>Further Information (Contacts and Acknowledgements)</H3>
<P>The author can be contacted at <A HREF="mailto:John_Maddock@compuserve.com">John_Maddock@compuserve.com</A>, the home page for this library is at <A HREF="http://ourworld.compuserve.com/homepages/John_Maddock/regexpp.htm">http://ourworld.compuserve.com/homepages/John_Maddock/regexpp.htm</A>, and the official boost version can be obtained from <A HREF="http://www.boost.org/libraries.htm">www.boost.org/libraries.htm</A>. </P>
<P>I am indebted to Robert Sedgewick's "Algorithms in C++" for forcing me to think about algorithms and their performance, and to the folks at boost for forcing me to <I>think</I>, period. The following people have all contributed useful comments or fixes: Dave Abrahams, Mike Allison, Edan Ayal, Jayashree Balasubramanian, Beman Dawes, Paul Baxter, David Dennerline, Edward Diener, Robert Dunn, , Fabio Forno, Tobias Gabrielsson, Rob Gillen, Marc Gregoire, Chris Hecker, Nick Hodapp, Jesse Jones, Martin Jost, Boris Krasnovskiy, Jan Hermelink, Max Leung, Wei-hao Lin, Jens Maurer, Heiko Schmidt, Scobie Smith, Alexander Sokolovsky, Herv&eacute; Poirier, Marc Recht, Bruno Voigt, Alexey Voinov, Jerry Waldorf, Rob Ward, Lealon Watts, Thomas Witt and Yuval Yosef. I am also grateful to the manuals supplied with the Henry Spencer, Perl and GNU regular expression libraries - wherever possible I have tried to maintain compatibility with these libraries and with the POSIX standard - the code however is entirely my own, including any bugs! I can absolutely guarantee that I will not fix any bugs I don't know about, so if you have any comments or spot any bugs, please get in touch. </P>
<P>Useful further information can be found at: </P>
<P>A short tutorial on regular expressions <A HREF="http://www.devshed.com/Server_Side/Administration/RegExp/">can be found here</A>.</P>
<P>The <A HREF="http://www.opengroup.org/onlinepubs/7908799/toc.htm">Open Unix Specification</A> contains a wealth of useful material, including the regular expression syntax, and specifications for <A HREF="http://www.opengroup.org/onlinepubs/7908799/xsh/regex.h.html">&lt;regex.h&gt;</A> and <A HREF="http://www.opengroup.org/onlinepubs/7908799/xsh/nl_types.h.html">&lt;nl_types.h&gt;</A>. </P>
<P>The <A HREF="http://www.cs.purdue.edu/homes/stelo/pattern.html">Pattern Matching Pointers</A> site is a "must visit" resource for anyone interested in pattern matching. </P>
<P><A HREF="http://glimpse.cs.arizona.edu/">Glimpse and Agrep</A>, use a simplified regular expression syntax to achieve faster search times. </P>
<P><A HREF="http://glimpse.cs.arizona.edu/udi.html">Udi Manber</A> and <A HREF="http://www.dcc.uchile.cl/~rbaeza/">Ricardo Baeza-Yates</A> both have a selection of useful pattern matching papers available from their respective web sites. </P>
<P><HR></P>
<I><P>Copyright </I><A HREF="mailto:John_Maddock@compuserve.com"><I>Dr John Maddock</I></A><I> 1998-2000 all rights reserved.</I> </P></BODY>
</HTML>
