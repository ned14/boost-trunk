<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content=
"HTML Tidy for Linux/x86 (vers 1st March 2004), see www.w3.org" />
<meta name="GENERATOR" content="Quanta Plus" />
<meta http-equiv="Content-Type" content=
"text/html; charset=us-ascii" />
<link href="ublas.css" type="text/css" />
<title>uBLAS functions overview</title>
</head>
<body>
<h1><img src="c++boost.gif" alt="c++boost.gif" align="middle" />
Overview of Matrix and Vector Operations</h1>

<dl>
<dt>Contents:</dt>
<dd><a href="#blas">Basic Linear Algebra</a></dd>
<dd><a href="#advanced">Advanced Functions</a></dd>
<dd><a href="#sub">Submatrices, Subvectors</a></dd>
<dd><a href="#speed">Speed Improvements</a></dd>
</dl>

<h3>Definitions:</h3>

<table style="" summary="notation">
<tr><td><code>A, B, C</code></td>
<td> are matrices</td></tr>
<tr><td><code>u, v, w</code></td> 
<td>are vectors</td></tr>
<tr><td><code>i, j, k</code></td> 
<td>are integer values</td></tr>
<tr><td><code>t, t1, t2</code></td> 
<td>are scalar values</td></tr>
<tr><td><code>r, r1, r2</code></td> 
<td>are ranges, e.g. <code>range(0, 3)</code></td></tr>
<tr><td><code>s, s1, s2</code></td> 
<td>are slices, e.g. <code>slice(0, 1, 3)</code></td></tr>
</table>

<p><em>Note:</em> A range <code>r = range(start, count)</code>
contains all indices <code>i</code> with <code>start &lt;= i &lt;
start+count</code>. A slice is something more general. The slice
<code>s = slice(start, stride, count)</code> contains the indices
<code>start, start+stride, ..., start+(count-1)*stride</code>. The
stride can be any integer including 0 and -1!</p>

<h2><a name="blas">Basic Linear Algebra</a></h2>

<h3>standard operations: addition, subtraction, multiplication by a
scalar</h3>

<pre>
<code>
C = A + B; C = A - B; C = -A;
w = u + v; w = u - v; w = -u;
C = t * A; C = A * t; C = A / t;
w = t * u; w = u * t; w = u / t;
</code>
</pre>

<h3>computed assignements</h3>

<pre>
<code>
C += A; C -= A; 
w += u; w -= u; 
C *= t; C /= t; 
w *= t; w /= t;
</code>
</pre>

<h3>inner, outer and other products</h3>

<pre>
<code>
t = inner_prod(u, v);
C = outer_prod(u, v);
w = prod(A, u); w = prod(u, A); w = prec_prod(A, u); w = prec_prod(u, A);
C = prod(A, B); C = prec_prod(A, B);
w = element_prod(u, v); w = element_div(u, v);
C = element_prod(A, B); C = element_div(A, B);
</code>
</pre>

<h3>transformations</h3>

<pre>
<code>
w = conj(u); w = real(u); w = imag(u);
C = trans(A); C = conj(A); C = herm(A); C = real(A); C = imag(A);
</code>
</pre>

<h2><a name="advanced">Advanced functions</a></h2>

<h3>norms</h3>

<pre>
<code>
t = norm_inf(v); i = index_norm_inf(v);
t = norm_1(v);   t = norm_2(v); 
t = norm_inf(A); i = index_norm_inf(A);
t = norm_1(A);   t = norm_frobenius(A); 
</code>
</pre>

<h3>products</h3>

<pre>
<code>
axpy_prod(A, u, w, true);  // w = A * u
axpy_prod(A, u, w, false); // w += A * u
axpy_prod(u, A, w, true);  // w = trans(A) * u
axpy_prod(u, A, w, false); // w += trans(A) * u
axpy_prod(A, B, C, true);  // C = A * B
axpy_prod(A, B, C, false); // C += A * B
</code>
</pre>
<p><em>Note:</em> The last argument (<code>bool init</code>) of
<code>axpy_prod</code> is optional. Currently it defaults to
<code>true</code>, but this may change in the future. Set the
<code>init</code> to <code>true</code> is equivalent to call
<code>w.clear()</code> before <code>axpy_prod</code>. Up to now
there are some specialisation for compressed matrices that give a
large speed up compared to <code>prod</code>.</p>
<pre>
<code>
w = block_prod&lt;matrix_type, 64&gt; (A, u); // w = A * u
w = block_prod&lt;matrix_type, 64&gt; (u, A); // w = trans(A) * u
C = block_prod&lt;matrix_type, 64&gt; (A, B); // w = A * B
</code>
</pre>
<p><em>Note:</em> The blocksize can be any integer. However, the
total speed depends very strong on the combination of blocksize,
CPU and compiler. The function <code>block_prod</code> is designed
for large dense matrices.</p>
<h3>rank-k updates</h3>
<pre>
<code>
opb_prod(A, B, C, true);  // C = A * B
opb_prod(A, B, C, false); // C += A * B
</code>
</pre>
<p><em>Note:</em> The last argument (<code>bool init</code>) of
<code>opb_prod</code> is optional. Currently it defaults to
<code>true</code>, but this may change in the future. This function
may give a speedup if <code>A</code> has less columns than rows,
because the product is computed as a sum of outer products.</p>

<h2><a name="sub">Submatrices, Subvectors</a></h2>

<pre>
<code>
w = project(u, r); w = project(u, s);
C = project(A, r1, r2); C = project(A, s1, s2);
w = row(A, i); w = column(A, j);
</code>
</pre>
<p>There are to more ways to access some matrix elements as a
vector:</p>
<pre>
<code>
matrix_vector_range&lt;matrix_type&gt; (A, r1, r2);
matrix_vector_slice&lt;matrix_type&gt; (A, s1, s2);
</code>
</pre>
<p><em>Note:</em> These matrix proxies take a sequence of elements
of a matrix and allow you to access these as a vector. In
particular <code>matrix_vector_slice</code> can do this in a very
general way. <code>matrix_vector_range</code> is less useful as the
elements must lie along a diagonal.</p>
<p><em>Example:</em> To access the first two elements of a sub
column of a matrix we access the row with a slice with stride 1 and
the column with a slice with stride 0 thus:<br />
<code>matrix_vector_slice&lt;matrix_type&gt; (A, slice(0,1,2),
slice(0,0,2));</code></p>

<h2><a name="speed">Speed improvements</a></h2>

<p>If you know for sure that the left hand expression and the right
hand expression have no common storage, then you can tell ublas
that there is no aliasing:</p>
<pre>
<code>
noalias(C) = prod(A, B);
</code>
</pre>

<p>Most often the right hand side of an assignement is constant. 
So you can give your compiler a hint to use const member function
even if <code>A</code> is mutable. (<code>MATRIX</code> is the type of <code>A</code>.)
This cast drastically reduces the access time of sparse matrix elements, since no
temporary sparse element proxies are created.
</p>
<pre>
<code>
C = static_cast&lt;const MATRIX&amp;&gt; A;
</code>
</pre>
<!-- template:
<pre><code>
</code></pre>
-->
<hr />
<p>Copyright (&copy;) 2000-2004 Joerg Walter, Mathias Koch, Gunter
Winkler, Michael Stevens<br />
Permission to copy, use, modify, sell and distribute this document
is granted provided this copyright notice appears in all copies.
This document is provided ``as is'' without express or implied
warranty, and with no claim as to its suitability for any
purpose.</p>
<p>Last revised: 2004-07-05</p>
</body>
</html>
