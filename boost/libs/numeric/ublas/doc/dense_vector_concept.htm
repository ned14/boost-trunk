<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content=
"HTML Tidy for Linux/x86 (vers 1st March 2004), see www.w3.org" />
<meta http-equiv="Content-Type" content=
"text/html; charset=us-ascii" />
<link href="ublas.css" type="text/css" />
<title>DenseVector Concept</title>
</head>
<body>
<h1><img src="c++boost.gif" alt="c++boost.gif" align="middle" />
DenseVector Concept</h1>
<h2>DenseVector</h2>
<h4>Description</h4>
<p>A dense-vector is a, exactly as the name says, a dense vector that is intended to behave well for linear algebra operations</p>
<h4>Refinement of</h4>
<p><a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">DefaultConstructible</a>, <a href="http://www.sgi.com/tech/stl/RandomAccessContainer.html">RandomAccessContainer</a> and <a href="expression_concept.htm#vector_expression">Vector Expression</a><a href="#footnote1">[1]</a>.</p>
<h4>Associated types</h4>
<p>In addition to the types defined by <a href="http://www.sgi.com/tech/stl/RandomAccessContainer.html">RandomAccessContainer</a> and <a href="expression_concept.htm#vector_expression">Vector Expression</a></p>
<table border="1" summary="types">
<tbody>
<tr>
<td>StorageArray</td>
<td>array_type</td>
<td>The type of underlying storage used to store the elements</td>
</tr>
</tbody>
</table>
<h4>Notation</h4>
<table border="0" summary="notation">
<tbody>
<tr>
<td><code>V</code></td>
<td>A type that is a model of Vector</td>
</tr>
<tr>
<td><code>T</code></td>
<td>The value_type of elements of V</td>
</tr>
<tr>
<td><code>v</code></td>
<td>Objects of type <code>V</code></td>
</tr>
<tr>
<td><code>n, i</code></td>
<td>Objects of a type convertible to <code>size_type</code></td>
</tr>
<tr>
<td><code>t</code></td>
<td>Object of a type convertible to <code>T</code></td>
</tr>
<tr>
<td><code>p</code></td>
<td>Object of a type convertible to <code>bool</code></td>
</tr>
</tbody>
</table>
<h4>Definitions</h4>
<h4>Valid expressions</h4>
<p>In addition to the expressions defined in <a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">DefaultConstructible</a> and <a href="expression_concept.htm#vector_expression">Vector Expression</a> the following expressions must be valid.</p>
<table border="1" summary="expressions">
<tbody>
<tr>
<th>Name</th>
<th>Expression</th>
<th>Type requirements</th>
<th>Return type</th>
</tr>
<tr>
<td>Size-constructor</td>
<td><code>V v(n)</code></td>
<td>T is <a href="http://www.sgi.com/tech/stl/DefaultConstructible.html">DefaultConstructible</a></td>
<td><code>V</code></td>
</tr>
<tr>
<tr>
<td>Insert</td>
<td><code>v.insert_element (i, t)</code></td>
<td><code>v</code> is mutable.</td>
<td><code>void</code></td>
</tr>
<tr>
<td>Erase</td>
<td><code>v.erase_element (i)</code></td>
<td><code>v</code> is mutable.</td>
<td><code>void</code></td>
</tr>
<tr>
<td>Clear</td>
<td><code>v.clear ()</code></td>
<td><code>v</code> is mutable.</td>
<td><code>void</code></td>
</tr>
<tr>
<td>Resize</td>
<td><code>v.resize (n)</code><br />
<code>v.resize (n, p)</code></td>
<td><code>v</code> is mutable.</td>
<td><code>void</code></td>
</tr>
<tr>
<td>Storage</td>
<td><code>data() const</code></td>
<td></td>
<td><code>const array_type&amp;</code></td>
</tr>
<tr>
<td>Storage</td>
<td><code>data()</code></td>
<td><code>v</code> is mutable</td>
<td><code>array_type&amp;</code></td>
</tr>
</tbody>
</table>
<h4>Expression semantics</h4>
<p>Semantics of an expression is defined only where it differs
from, or is not defined in <a href=
"expression_concept.htm#vector_expression">Vector Expression</a> .</p>
<table border="1" summary="semantics">
<tr>
<th>Name</th>
<th>Expression</th>
<th>Precondition</th>
<th>Semantics</th>
<th>Postcondition</th>
</tr>
<tr>
<td>Sizing constructor</td>
<td><code>V v (n)</code></td>
<td><code>n &gt;= 0</code></td>
<td>Allocates a vector of<code>n</code> elements.</td>
<td><code>v.size () == n</code>.</td>
</tr>
<tr>
<td>Element access <a href="#element_access_note">[1]</a></td>
<td><code>v[n]</code></td>
<td><code>0&lt;n&gt;v.size()</code></td>
<td>returns the n-th element in v</td>
<td></td>
</tr>
<tr>
<td>Insert</td>
<td><code>v.insert_element (i, t)</code></td>
<td><code>0 &lt;= i &lt; v.size ()</code> and<br />
<code>v (i)</code> is equal to <code>value_type (0)</code>.</td>
<td>A copy of <code>t</code> is inserted in <code>v</code>.</td>
<td><code>v (i)</code> is a copy of <code>t</code>.</td>
</tr>
<tr>
<td>Erase</td>
<td><code>v.erase_element (i)</code></td>
<td><code>0 &lt;= i &lt; v.size ()</code></td>
<td>Destroys the element <code>v (i)</code> and replaces it with
<code>value_type ()</code>.</td>
<td><code>v (i)</code> is a copy of <code>value_type
()</code>.</td>
</tr>
<tr>
<td>Clear</td>
<td><code>v.clear ()</code></td>
<td>&nbsp;</td>
<td>Equivalent to<br />
<code>for (i = 0; i &lt; v.size (); ++ i)</code><br />
&nbsp; <code>v.erase (i);</code></td>
<td>&nbsp;</td>
</tr>
<tr>
<td>Resize</td>
<td><code>v.resize (n)
<br />v.resize (n, p)</code></td>
<td>&nbsp;</td>
<td>Reallocates the vector so that it can hold <code>n</code>
elements.<br />
Erases or appends elements in order to bring the vector to the prescribed size. Appended elements copies of <code>value_type()</code>.
<br />
When <code>p == false</code> then existing elements are not preserved and elements will not appended as normal. Instead the vector is in the same state as that after an equivalent sizing constructor.</td>
<td><code>v.size () == n</code>.</td>
</tr>
<tr>
<td>Storage</td>
<td><code>v.data()</code></td>
<td><code>v</code> is const</td>
<td>Returns a reference to the underlying storage</td>
<td></td>
</tr>
<tr>
<td>Storage</td>
<td><code>v.data()</code></td>
<td><code>v</code> is mutable</td>
<td>Returns a reference to the underlying storage</td>
<td></td>
</tr>
</table>
<h4>Complexity guarantees</h4>
<p>The run-time complexity of the sizing constructor is linear in
the vector's size.</p>
<p>The run-time complexity of insert_element and erase_element is specific for the
vector.</p>
<p>The run-time complexity of resize is linear in the vector's
size.</p>
<h4>Invariants</h4>
<h4>Models</h4>
<ul>
<li><code>vector&lt;T&gt;</code> , <code>bounded_vector&lt;T, N&gt;</code></li>
<li><code>unit_vector&lt;T&gt;</code> , <code>zero_vector&lt;T&gt;</code> , <code>scalar_vector&lt;T&gt;</code></li>
<li><code>mapped_vector&lt;T&gt;</code> , <code>compressed_vector</code> , <code>coordinate_vector</code></li>
</ul>
<h4>Notes</h4>
<p><a name="footnote1">[1]</a>
As a user you should not care about <tt>DenseVector</tt> being a refinement of the VectorExpression. Being a refinement of the VectorExpression is only important for the template-expression engine but not the user.
<a name="element_access_note">[1]</a>The <code>operator[]</code> is added purely for convenience 
and compatibility with the <code>std::vector</code>. In uBLAS however, 
generally <code>operator()</code> is used for indexing because this can be
used for both vectors and matrices.
</body>
</html>
