<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 6.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link rel="stylesheet" type="text/css" href="../../../boost.css">
<title>The Boost Statechart Library - Overview</title>
</head>

<body link="#0000ff" vlink="#800080">

<table border="0" cellpadding="7" cellspacing="0" width="100%" summary="header">
  <tr>
    <td valign="top" width="300">
    <h3><a href="../../../index.htm">
    <img alt="C++ Boost" src="../../../boost.png" border="0" width="277" height="86"></a></h3>
    </td>
    <td valign="top">
    <h1 align="center">The Boost Statechart Library</h1>
    <p align="center">(formerly known as boost::fsm)</p>
    <h2 align="center">Overview</h2>
    <p align="center"><font size="2">Version:
    <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%Y/%m/%d" startspan -->2005/06/19<!--webbot bot="Timestamp" endspan i-checksum="12685" --></font></td>
  </tr>
</table>
<hr>
<h2>Contents</h2>
<dl class="index">
  <dt><a href="#Overview">Overview</a></dt>
	<dd><a href="#Supported_platforms">Supported platforms</a></dd>
	<dd><a href="#Incompatible_compilers">Incompatible compilers</a></dd>
	<dd><a href="#Getting_started">Getting started</a></dd>
	<dd><a href="#Audience">Audience</a></dd>
	<dt>&nbsp;</dt>
	<dt><a href="tutorial.html">Tutorial</a> [pdf: <a href="tutorial.pdf">
  English</a>,
  <a href="http://prdownloads.sourceforge.jp/jyugem/7127/fsm-tutorial-jp.pdf">
  Japanese</a>]</dt>
  <dt><a href="uml_mapping.html">UML to Boost.Statechart mapping summary</a></dt>
  <dt><a href="faq.html">Frequently Asked Questions (FAQs)</a></dt>
  <dt><a href="configuration.html">Configuration</a></dt>
  <dt><a href="definitions.html">Definitions</a></dt>
  <dt><a href="reference.html">Reference</a> [pdf: <a href="reference.pdf">
  English</a>]</dt>
  <dt><a href="rationale.html">Rationale</a> [pdf: <a href="rationale.pdf">
  English</a>]</dt>
  <dt><a href="performance.html">Performance</a></dt>
  <dt><a href="acknowledgments.html">Acknowledgments</a></dt>
	<dd>&nbsp;</dd>
	<dt><a href="#To-do_list">To-do list</a></dt>
	<dt><a href="#Change_history">Change history</a></dt>
</dl>
<hr>
<h2><a name="Overview">Overview</a></h2>
<p>Welcome to Boost.Statechart, a C++ library for finite state machines. Features 
include:</p>
<ul>
  <li>Straightforward transformation from UML statechart to executable C++ code 
	and vice versa. Currently, this needs to be done manually both ways but it 
  should not be difficult to automate these tasks</li>
  <li>Comprehensive <a href="http://www.omg.org/cgi-bin/doc?formal/03-03-01">
  UML semantics</a> support:<ul>
    <li>Hierarchical (composite, nested) states</li>
    <li>Orthogonal (concurrent) states</li>
    <li>Entry-, exit- and transition-actions</li>
    <li>Guards</li>
    <li>Shallow/deep history</li>
    <li>Event deferral</li>
  </ul>
  </li>
  <li>Error handling support</li>
  <li>Maximum type-safety</li>
  <li>Compile-time statechart validation</li>
  <li>Support for asynchronous state machines and multi-threading</li>
  <li>State-local storage</li>
  <li>Generic design allowing for the customization of memory management, 
  error handling and threading</li>
</ul>
<h3><a name="Supported_platforms">Supported platforms</a></h3>
<p>All code has been tested on the following platforms using boost 
distribution 1.32.0:</p>
<ul>
  <li>MSVC 7.1 (the compiler coming with MS Visual Studio 2003)</li>
	<li>GCC 3.4.2 (MinGW 3.2.0)</li>
</ul>
<p>In addition, previous versions of the library have also been tested on 
the following platforms (I expect the current version to work, but it hasn't 
been tested yet):</p>
<ul>
  <li>GCC 3.2 (Red Hat Linux)</li>
  <li>GCC 3.2.3 (MinGW 3.1.0)</li>
	<li>GCC 3.3.1 (Dev-C++ 4.9.9.0): In release mode HistoryTest compilation 
	takes forever and compiler memory footprint goes beyond 400MB, most likely 
	a GCC bug</li>
  <li>Intel 8.0 (Win32, MS Visual Studio 2003 std library)</li>
  <li>Intel 8.1 (Win32, MS Visual Studio 2003 std library). All the examples 
	worked as expected but some tests failed with an access violation inside the 
	boost testing framework. Unfortunately, my evaluation license of the 
	compiler expired before I managed to pin down the problem</li>
</ul>
<h3><a name="Incompatible_compilers">Incompatible compilers</a></h3>
<p>The following compilers are known to have problems with Boost.Statechart:</p>
<ul>
	<li>MSVC 6.0 &amp; 7.0: Many compiler errors</li>
  <li>Intel 7.0 (Win32, MS Visual Studio 6 std library). Most of the library, 
  the examples and the tests can be compiled but the compiler appears to 
  generate wrong code under certain circumstances, leading to crashes 
  (currently (2005/05/16) the following tests fail: StateCastTest.cpp and 
  TransitionTest.cpp)</li>
  <li>BCB (all versions): Many compiler errors</li>
</ul>
<h3><a name="Getting_started">Getting started</a></h3>
<p>Boost.Statechart builds on other parts of the boost library. In order to use this 
library, the statechart directories need to be copied to their respective locations 
in the tree of the boost distribution 1.32.0. Specifically:</p>
<ol>
	<li>Follow the steps 1-3 described
	at <a href="http://www.boost.org/more/getting_started.html">
	http://www.boost.org/more/getting_started.html</a>. After 
	doing so, somewhere on your harddrive you should have a directory 
	containing the boost distribution (e.g. under <code>D:\Data\boost_1_32_0</code>) 
	and the bjam executable installed in your <code>PATH</code></li>
<li>Download <a href="http://boost-sandbox.sf.net/Statechart.zip">
http://boost-sandbox.sf.net/Statechart.zip</a> and unpack it somewhere on your harddrive, e.g. under
<code>D:\Data\Statechart</code></li>
	<li>Copy the directory <code>D:\Data\Statechart\boost\statechart</code> and all its 
	contents to <code>D:\Data\boost_1_32_0\boost\statechart</code></li>
	<li>Copy the directory <code>D:\Data\Statechart\libs\statechart</code> and all its 
	contents to <code>D:\Data\boost_1_32_0\libs\statechart</code></li>
	<li>Open a command prompt and change the current directory to
	<code>D:\Data\boost_1_32_0\libs\statechart\examples</code></li>
	<li>To compile the examples, invoke bjam with your toolset. For example, 
	for MSVC7.1, type <code>bjam &quot;-sTOOLS=vc-7_1&quot;</code>. This may 
	take a few minutes. After the build has finished you will find all 
	executables in <code>
	D:\Data\boost_1_32_0\libs\statechart\examples\run</code>. In addition to the 
	examples discussed in the tutorial, this script also builds the BitMachine executable in different variants, which show the effects of 
	various choices on runtime performance, executable size, etc. Moreover, 
	the Handcrafted executable is also built, which serves to compare 
	performance of a simple Boost.Statechart machine with its handcrafted equivalent</li>
	<li>To run the tests, invoke bjam in the directory
	<code>D:\Data\boost_1_32_0\libs\statechart\test</code></li>
</ol>
<h3><a name="Audience">Audience</a></h3>
<p>Throughout all Boost.Statechart documentation it is assumed that the reader is 
familiar with the state machine concept, UML statecharts and most of the UML 
state machine terminology. The following links might be interesting if this is 
not the case:</p>
<ul>
  <li><a href="http://www.objectmentor.com/resources/articles/umlfsm.pdf">
  http://www.objectmentor.com/resources/articles/umlfsm.pdf</a> introduces 
  state machines and UML statecharts</li>
  <li>
  <a href="http://www.sts.tu-harburg.de/teaching/ws-99.00/OOA+D/StateDiagrams.pdf">
  http://www.sts.tu-harburg.de/teaching/ws-99.00/OOA+D/StateDiagrams.pdf</a> 
  explains most of the UML statechart elements and terminology</li>
  <li>The inventor of statecharts, David Harel, presents a thorough but still 
  very readable discussion in his original paper:
  <a href="http://www.wisdom.weizmann.ac.il/~dharel/SCANNED.PAPERS/Statecharts.pdf">
  http://www.wisdom.weizmann.ac.il/~dharel/SCANNED.PAPERS/Statecharts.pdf</a></li>
  <li>The UML specifications (formal) can be found here:
  <a href="http://www.omg.org/cgi-bin/doc?formal/03-03-01">
  http://www.omg.org/cgi-bin/doc?formal/03-03-01</a> (see chapters 2.12 and 
  3.74)</li>
</ul>
<p>Some of the used terminology cannot be found in the UML specifications, 
please see <a href="definitions.html">Definitions</a> for more information.</p>
<hr>
<h2><a name="To-do_list">To-do list</a></h2>
<p>The library is mostly complete. However, there is some work 
left (<font color="#FF0000">red</font> = added as a result of the formal 
review):</p>
<ol>
    <li>Review and integrate the v2 Jamfiles supplied by Jürgen Hunold</li>
    <li><b>Add the library to the main CVS. Estimated date: 15 July, 2005</b></li>
	<li>Add <code>event_base</code> specializations to all reactions</li>
	<li>Investigate how a state machine could be serialized. A first glance at 
	the serialization library revealed that there currently (late 2004) is no 
	support for types that overload <code>operator new</code>. Such support 
	would be essential for Boost.Statechart serialization since there doesn't seem 
	to be any way to detect whether a state has an overloaded <code>operator 
	new</code> or not</li>
	<li>Design a facility allowing to specially handle events that did not 
  trigger a reaction</li>
	<li><font color="#FF0000">Eliminate the need to wrap a single templated inner 
    initial state into an mpl::list (Jonathan Turkanis)</font></li>
    <li><font color="#FF0000">Add a trouble-shooting section for compile-time 
	errors (John Spalding)</font></li>
    <li><font color="#FF0000">Augment the rationale for state-local storage 
	with the code for a StopWatch variant that does not use state-local storage 
	and explain the drawbacks of that approach (Jeff Garland, Rob Steward)</font></li>
    <li><font color="#FF0000">Put all remarks about code as comments inside 
	the code (Pavel Vozenilek, Augustus Saunders)</font></li>
    <li><font color="#FF0000">Implement a switch-like reaction (Simon Gittins, 
	Darryl Green)</font></li>
    <li>Add allocator support for broken std libs when the workaround is 
	available in boost::detail</li>
    <li>Ensure that the library can be compiled with exception support turned 
    off</li>
    <li><font color="#FF0000">Investigate how constant-time dispatch for 
    non-orthogonal state machines can be implemented (David Abrahams, Jonathan Turkanis, 
    Rob Steward, Dave Gomboc)</font></li>
    <li><font color="#FF0000">Compare performance for allocator-allocated 
	states with the one of the best possible hand-written state-specific 
	operator new implementation. If there is no significant difference change 
	the implementation to use the allocator to allocate states (Peter Petrov)</font></li>
    <li>Reimplement <code>fifo_scheduler&lt;&gt;::processor_handle</code> so that
  	<code>fifo_scheduler&lt;&gt;::create_processor&lt;&gt;()</code> and <code>fifo_scheduler&lt;&gt;::destroy_processor()</code> 
  no longer make (indirect) calls to global <code>operator new()</code> and
  	<code>operator delete()</code></li>
    <li>Link incomplete code-snippets in the tutorial to complete example code 
	where available</li>
    <li>Where appropriate, link the reference documentation to examples</li>
    <li><font color="#FF0000">Add a description of the implementation and 
	better explain performance trade-offs (Jonathan Turkanis)</font></li>
    <li><font color="#FF0000">Add links to descriptions of alternate 
	implementations and discuss performance trade-offs (Jonathan Turkanis)</font></li>
    <li>Implement <code>priority_scheduler&lt;&gt;</code></li>
    <li><font color="#FF0000">Add a list of applications that use Boost.Statechart 
	(Paul A. Bristow)</font></li>
    <li>Improve performance for state machines that use <code>null_exception_translator</code></li>
    <li>Refactor the <code>state_machine</code> class template to reduce code 
  size in applications with many different state machines</li>
    <li>Investigate whether and how <code>fifo_worker&lt;&gt;</code> should accept a policy 
  parameter defining how to lock and wait</li>
    <li>Add a diagram that helps to understand what an unstable state machine 
	is</li>
    <li>Comment MPL-heavy code</li>
    <li>Comment <code>processor_holder_ptr_type</code></li>
    <li>Add examples of often made mistakes</li>
    <li>Eliminate code-duplication in <code>fifo_scheduler</code> with PP code 
	submitted by Pavel Vozenilek</li>
    <li>Add number and label to all diagrams in docs</li>
    <li>Add <code>#pragma once</code> to all headers (speeds up compilation 
	with MS-compatible compilers)</li>
    <li>Issue an error if <code>BOOST_STATECHART_USE_NATIVE_RTTI</code> is defined 
	when C++ RTTI is turned off</li>
</ol>
<h2><a name="Change_history">Change history</a></h2>
<p>19 June, 2005</p>
<ul>
	<li>Updated the documentation for the new reaction 
    specification interface</li>
    <li><font color="#FF0000">Invalid calls to reaction functions now always 
    lead to a failing runtime assert (Jonathan Turkanis). In debug mode the
    <code>result</code> type is a class 
    with destructive copy semantics, enabling the detection of a wider range 
    of reaction function abuses. Added appropriate tests and updated the 
    documentation</font></li>
    <li><font color="#FF0000">Separated performance-related docs from the 
    rationale into a page of its own (Pavel Vozenilek)</font></li>
    <li><font color="#FF0000">Added clone functionality to events so that 
    stack-allocated events can now be deferred and posted. Updated the 
    documentation and tests accordingly (Jonathan Turkanis)</font></li>
    <li><font color="#FF0000">Clarified the definition of context (John Spalding)</font></li>
    <li><font color="#FF0000">Implemented <code>in_state_reaction&lt;&gt;</code>. 
    Updated the documentation and tests accordingly (Darryl 
	Green)</font></li>
</ul>
<p></p>
<p>12 May, 2005</p>
<ul>
	<li><b><font color="#FF0000">Breaking change: Changed the library namespace from <code>fsm</code> 
    to <code>statechart</code> (Alexander Nasonov, David Abrahams)</font></b></li>
    <li><b><font color="#FF0000">Breaking change: Changed the library name from boost::fsm to 
    Boost.Statechart (Alexander Nasonov, David Abrahams)</font></b></li>
    <li><b><font color="#FF0000">Breaking change: Reactions are now specified with a <code>reactions</code> member 
    typedef in a state class declaration instead of a template parameter (Alexander Nasonov), 
    not yet documented.</font></b></li>
</ul>
<p>03 May, 2005</p>
<ul>
	<li>Removed the to-do item for the <code>std::type_info</code> replacement. Thanks to 
	Jody Hagins for taking care of that!</li>
	<li>Added to-do items for the issues uncovered during the review</li>
	<li>Fixed documentation bugs in the effects descriptions for <code>
	state_machine::initiate()</code>, <code>state_machine::terminate()</code> 
	and <code>state_machine::process_event()</code></li>
	<li><font color="#FF0000">Moved &quot;Getting started&quot; and &quot;Audience&quot; into index.html 
	(Augustus Saunders)</font></li>
	<li><font color="#FF0000">Added Basic topics and Intermediate topics 
	headings and shortened the &quot;How to read this tutorial&quot; section (Augustus 
	Saunders)</font></li>
</ul>
<p>21 February, 2005</p>
<p></p>
<ul>
	<li>Corrected the review period length mentioned above (absolutely no 
	changes to code and documentation)</li>
</ul>
<p>20 February, 2005</p>
<p></p>
<ul>
	<li><b>Breaking change</b>: Incorporated a part of <code>
	exception_translator::operator()</code> code into the <code>state_machine</code> 
	class template. This simplifies custom exception translators and makes 
	implementing them less error-prone</li>
	<li><b>Breaking change</b>: A request to defer an exception event is no 
	longer honored and ultimately results in the exception being rethrown. This 
	change is the result of the rule that during the processing of an exception 
	no non-user code must be called that could itself propagate an exception and 
	thus mask the original exception (for event deferral <code>operator new</code> 
	must be called, which could throw). Exception event deferral has always been 
	a strange concept anyway</li>
	<li>Various code brush-ups</li>
</ul>
<p>09 February, 2005</p>
<p></p>
<ul>
	<li>Added exception testing to TransitionTest</li>
	<li>Fixed a bug that led to an access violation when orthogonal region 0 
	of a state was terminated before exiting the state (either through another 
	termination or a transition)</li>
	<li>Various minor changes</li>
</ul>
<p>07 February, 2005</p>
<p></p>
<ul>
	<li>Added FifoSchedulerTest, TerminationTest, CustomReactionTest, StateIterationTest, TypeInfoTest, StateCastTest, HistoryTest and tests for 
	inconsistent uses of history, unsupported types of deep history and 
	invalid statecharts</li>
	<li>Fixed a bug that led to a compile-time error when <code>state_downcast</code> 
	was instantiated with a reference target</li>
	<li>Fixed a bug that led to a null function pointer dereference when 
	history was cleared before making a transition to history</li>
	<li>Updated the &quot;Speed versus scalability tradeoffs&quot; section</li>
	<li>Fixed previously failing builds of single-threaded variants of the 
	PingPong example</li>
	<li>Moved the &quot;Incompatible compilers&quot; section to index.html</li>
	<li>Added explanation for the BitMachine &amp; Handcrafted examples</li>
	<li>Various minor changes</li>
</ul>
<p>25 November, 2004</p>
<ul>
	<li>Adapted to the changes in the 1.32.0 distribution (mainly MPL 
	changes). The library no longer works with 1.31.0</li>
	<li>Fixed a bug that led to a failing runtime assert during state machine 
	destruction</li>
	<li>Fixed a bug that led to events deferred in a composite state not being 
	released when that state was left</li>
	<li>Added TransitionTest and DeferralTest</li>
</ul>
<p>19 October, 2004</p>
<ul>
	<li><b>Breaking change</b>: Out of the box, a state machine no longer uses
	<code>exception_translator&lt;&gt;</code> to translate exceptions propagated into 
	the framework. Instead, <code>null_exception_translator</code> is now used, 
	which does not catch or translate any exceptions. Updated docs accordingly</li>
	<li>Implemented <a href="tutorial.html#Two_stage_exit">two stage exit</a> and updated docs accordingly</li>
	<li>Implemented an experimental feature that allows a transition action to 
	be a member of the transition source or any of its direct or indirect 
	contexts, see 
	<a href="configuration.html#Application Defined Macros">BOOST_STATECHART_RELAX_TRANSITION_CONTEXT</a></li>
	<li>Various small code and documentation improvements</li>
</ul>
<p>22 May, 2004</p>
<ul>
  <li>Integrated the Intel 7.0 workarounds provided by Pavel Vozenilek (most 
  are std library workarounds)</li>
  <li>Added the Intel 7.0 section to the configuration page</li>
  <li>Updated copyright notices</li>
</ul>
<p>12 May, 2004</p>
<ul>
  <li>Fixed a bug that could have led to an <code>exception_thrown</code> 
  event being sent to a state that is <b>not</b> the outermost unstable state 
  in an unstable state machine (as documented in the reference). Instead, the 
  event was sent to the state where the entry action of a direct inner state 
  threw an exception, which is only correct for state machines without 
  orthogonal regions. Also updated the
  <a href="tutorial.html#Exception handling">Exception handling</a> section in 
  the tutorial, which now explains this behavior in detail</li>
  <li>Fixed bug that, under extremely rare circumstances, would have prevented 
  the correct handling of out of memory situations</li>
  <li>Fixed an inconsistency in the state entry sequence when a state in an 
  orthogonal region is the target of a transition originating outside its 
  direct outer state. Now the states are always entered according to the 
  number of their orthogonal region, i.e. orthogonal region 0 first, then 
  orthogonal region 1 and so on. Since the documentation did not define the 
  sequence (it does now) users should not notice any difference</li>
  <li>Changed the implementation of <code>state_machine::terminate()</code> so 
  that orthogonal regions are now exited strictly from highest to lowest 
  number instead of arbitrarily as before. Updated docs accordingly</li>
</ul>
<p>22 April, 2004</p>
<ul>
  <li>Removed the previously added BCC 5.6.4 fixes (the BCC port was postponed 
  due to lack of knowledge how to work around certain bugs)</li>
  <li>Replaced all uses of <code>BOOST_STATIC_CONSTANT</code> with their mpl 
  counterparts (<code>bool_</code>, <code>integral_c</code>). As a result, 
  ports to buggy compilers should become easier</li>
  <li>Clarified some bits in the tutorial and added StopWatch2.cpp, which 
  details an alternative way of retrieving state machine state</li>
</ul>
<p>10 April, 2004</p>
<ul>
  <li>Added two BCC 5.6.4 fixes contributed by Pavel Vozenilek; Boost.Statechart 
  does not yet work on BCC though</li>
  <li>Implemented a few of the documentation and code improvements suggested 
  by Pavel Vozenilek, including the new &quot;UML to Boost.Statechart mapping summary&quot; 
  document</li>
</ul>
<p>26 March, 2004</p>
<ul>
  <li>Fixed a small Intel 8.0 bug in the BitMachine example</li>
</ul>
<p>25 March, 2004</p>
<ul>
  <li>Now everything compiles warning-free on Intel 8.0</li>
</ul>
<p>21 March, 2004</p>
<ul>
  <li><b>Breaking change</b>: <code>fifo_scheduler&lt;&gt;</code> and <code>
  fifo_worker&lt;&gt;</code> now always work non-blocking by default </li>
  <li>Added gcc makefiles, contributed by Mitsuo Fukasawa</li>
  <li>Added a fixed version of atomic_count_gcc.hpp to fsm.zip, see
  <a href="http://lists.boost.org/MailArchives/boost/msg57537.php">
  http://lists.boost.org/MailArchives/boost/msg57537.php</a> for more 
  information</li>
</ul>
<p>16 March, 2004</p>
<ul>
  <li><b>Breaking change</b>: Added the <code>FifoWorker</code> template 
  parameter to <code>fifo_scheduler&lt;&gt;</code> and updated documentation and 
  examples accordingly</li>
</ul>
<p>13 March, 2004</p>
<ul>
  <li><b>Breaking change</b>: Renamed <code>worker&lt;&gt;</code> to <code>
  fifo_scheduler&lt;&gt;</code> and updated documentation and examples accordingly</li>
  <li>Changed the <code>fifo_scheduler&lt;&gt;</code> implementation so that a 
  custom worker implementation needs to duplicate less code</li>
  <li>Various other small code and doc changes</li>
</ul>
<p>03 March, 2004</p>
<ul>
  <li><b>Breaking change</b>: Redesigned the <code>worker&lt;&gt;</code> and <code>
  asynchronous_state_machine&lt;&gt;</code> class templates and updated 
  documentation accordingly. Event processors can now be added and removed 
  while a worker is running. Moreover, the new design allows for custom 
  workers with non-FIFO queueing schemes</li>
  <li>The StopWatch example now uses <code>std::time()</code> instead of <code>
  std::clock()</code></li>
</ul>
<p>09 February, 2004</p>
<ul>
  <li>Integrated the standard conformance fixes contributed by Peter Petrov. 
  The library now also works on GCC 3.2 and should be much easier to port to 
  other highly conforming compilers</li>
  <li>Added the state type information facility to <code>simple_state</code></li>
  <li>Added the function templates <code>simple_state::clear_shallow_history()</code> 
  and <code>simple_state::clear_deep_history()</code></li>
</ul>
<p>11 January, 2004</p>
<ul>
  <li>Finished reference documentation</li>
  <li>Updated Copyright notices</li>
</ul>
<p>12 December, 2003</p>
<ul>
  <li><b>Thanks to Mitsuo Fukasawa the tutorial is now also available in 
  Japanese!!!</b></li>
  <li>Added a state type information facility</li>
  <li>Added reference (unfinished) and configuration documentation and updated 
  other documents</li>
  <li>Various code brush-ups (no breaking changes)</li>
</ul>
<p>12 October, 2003</p>
<ul>
  <li><b>Breaking change</b>: Removed <code>rtti_policy&lt;&gt;</code> from the 
  interface. By default, the library now uses its own (often faster) RTTI 
  implementation. Users can demand the use of native C++ RTTI by defining
  <code>BOOST_STATECHART_USE_NATIVE_RTTI</code>. This change only affects users who 
  customized <code>state_machine&lt;&gt;</code>, <code>asynchronous_state_machine&lt;&gt;</code> 
  or <code>worker&lt;&gt;</code></li>
  <li><b>Breaking change</b>: Reordered template arguments of <code>
  state_machine&lt;&gt;</code> and <code>asynchronous_state_machine&lt;&gt;</code>. This 
  change only affects users who customized <code>state_machine&lt;&gt;</code> or
  <code>asynchronous_state_machine&lt;&gt;</code></li>
  <li>Added shallow/deep history support and updated documentation accordingly</li>
  <li>Added various compile-time sanity checks</li>
  <li>Added 1 FAQ (asked by Mitsuo Fukasawa)</li>
</ul>
<p>16 August, 2003</p>
<ul>
  <li>Added <code>asynchronous_state_machine&lt;&gt;</code> and <code>worker&lt;&gt;</code> 
  and updated documentation accordingly</li>
  <li>Various minor bug fixes and code improvements (no breaking interface 
  changes)</li>
  <li>Added Keyboard and PingPong examples</li>
  <li>Added .pdf documentation</li>
</ul>
<p>08 June, 2003</p>
<ul>
  <li>Added 3 FAQs (asked by Bohdan) &amp; 1 definition</li>
  <li>Removed the superfluous public derivation specifiers in the tutorial and 
  the examples as suggested by Aleksey Gurtovoy</li>
  <li>Various code improvements (no interface changes)</li>
  <li>Various html improvements</li>
</ul>
<hr>
<p>Revised 
<!--webbot bot="Timestamp" s-type="EDITED" s-format="%d %B, %Y" startspan -->19 June, 2005<!--webbot bot="Timestamp" endspan i-checksum="19927" --></p>
<p><i>© Copyright <a href="mailto:ahd6974-spamgroupstrap@yahoo.com">Andreas Huber Dönni</a> 
2003-2005. <font color="#FF0000"><b>The link refers to a
<a href="http://en.wikipedia.org/wiki/Honeypot">spam honeypot</a>. Please remove the words spam and trap 
to obtain my real address.</b></font></i></p>
<p><i>Distributed under the Boost Software License, Version 1.0. (See 
accompanying file <a href="../../../LICENSE_1_0.txt">LICENSE_1_0.txt</a> or 
copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
http://www.boost.org/LICENSE_1_0.txt</a>)</i></p>

</body>

</html>
