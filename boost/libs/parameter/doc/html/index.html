<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.8: http://docutils.sourceforge.net/" />
<title>The Boost Parameter Library Boost</title>
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2004/01/12 02:49:54 $
:version: $Revision: 1.2 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/

.first {
  margin-top: 0 }

.last {
  margin-bottom: 0 }

a.toc-backref {
  text-decoration: none ;
  color: black }

dd {
  margin-bottom: 0.5em }

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr {
  width: 75% }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em }

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

tt {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="the-boost-parameter-library-logo">
<h1 class="title">The Boost Parameter Library <a class="reference" href="../../../../index.htm"><img alt="Boost" src="../../../../boost.png" /></a></h1>
<!-- Firefox, at least, seems to need some help lowering
subscripts. Without the following, subscripts seem not to drop
at all. -->
<style type="text/css">
sub {
  vertical-align: -20%
}
</style><hr class="docutils" />
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Authors:</th><td class="field-body">David Abrahams, Daniel Wallin</td>
</tr>
<tr class="field"><th class="field-name">Contact:</th><td class="field-body"><a class="reference" href="mailto:dave&#64;boost-consulting.com">dave&#64;boost-consulting.com</a>, <a class="reference" href="mailto:dalwan01&#64;student.umu.se">dalwan01&#64;student.umu.se</a></td>
</tr>
<tr class="field"><th class="field-name">organization:</th><td class="field-body"><a class="reference" href="http://www.boost-consulting.com">Boost Consulting</a></td>
</tr>
<tr class="field"><th class="field-name">date:</th><td class="field-body">$Date: 2005/07/14 22:41:34 $</td>
</tr>
<tr class="field"><th class="field-name">copyright:</th><td class="field-body">Copyright David Abrahams, Daniel Wallin
2005. Distributed under the Boost Software License,
Version 1.0. (See accompanying file LICENSE_1_0.txt
or copy at <a class="reference" href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)</td>
</tr>
</tbody>
</table>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Abstract:</th><td class="field-body"><p class="first">Use this library to write functions that accept
arguments by name:</p>
<pre class="literal-block">
new_window(&quot;alert&quot;, <strong>width=10</strong>, <strong>titlebar=false</strong>);
</pre>
<p class="last">This capability is especially useful when a function has more
than one argument with a useful default value, since named
arguments can be passed in any order.</p>
</td>
</tr>
</tbody>
</table>
<div class="contents topic" id="table-of-contents">
<p class="topic-title first"><a name="table-of-contents"><strong>Table of Contents</strong></a></p>
<ul class="auto-toc simple">
<li><a class="reference" href="#introduction" id="id12" name="id12">1&nbsp;&nbsp;&nbsp;Introduction</a></li>
<li><a class="reference" href="#tutorial" id="id13" name="id13">2&nbsp;&nbsp;&nbsp;Tutorial</a><ul class="auto-toc">
<li><a class="reference" href="#headers-and-namespaces" id="id14" name="id14">2.1&nbsp;&nbsp;&nbsp;Headers And Namespaces</a></li>
<li><a class="reference" href="#the-abstract-interface-to-dfs" id="id15" name="id15">2.2&nbsp;&nbsp;&nbsp;The Abstract Interface to <tt class="docutils literal"><span class="pre">depth_first_search</span></tt></a></li>
<li><a class="reference" href="#defining-the-keywords" id="id16" name="id16">2.3&nbsp;&nbsp;&nbsp;Defining the Keywords</a></li>
<li><a class="reference" href="#defining-the-implementation-function" id="id17" name="id17">2.4&nbsp;&nbsp;&nbsp;Defining the Implementation Function</a></li>
<li><a class="reference" href="#adding-defaults" id="id18" name="id18">2.5&nbsp;&nbsp;&nbsp;Adding Defaults</a><ul class="auto-toc">
<li><a class="reference" href="#syntax" id="id19" name="id19">2.5.1&nbsp;&nbsp;&nbsp;Syntax</a></li>
<li><a class="reference" href="#getting-more-realistic" id="id20" name="id20">2.5.2&nbsp;&nbsp;&nbsp;Getting More Realistic</a></li>
<li><a class="reference" href="#the-binding-metafunction" id="id21" name="id21">2.5.3&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">binding</span></tt> <span class="interpreted">Metafunction</span></a></li>
<li><a class="reference" href="#beyond-ordinary-default-arguments" id="id22" name="id22">2.5.4&nbsp;&nbsp;&nbsp;Beyond Ordinary Default Arguments</a></li>
</ul>
</li>
<li><a class="reference" href="#syntactic-refinement" id="id23" name="id23">2.6&nbsp;&nbsp;&nbsp;Syntactic Refinement</a><ul class="auto-toc">
<li><a class="reference" href="#generating-the-forwarding-functions-with-macros" id="id24" name="id24">2.6.1&nbsp;&nbsp;&nbsp;Generating the Forwarding Functions with Macros</a></li>
<li><a class="reference" href="#passing-non-const-references-positionally" id="id25" name="id25">2.6.2&nbsp;&nbsp;&nbsp;Passing non-const References positionally</a></li>
</ul>
</li>
<li><a class="reference" href="#controlling-overload-resolution" id="id26" name="id26">2.7&nbsp;&nbsp;&nbsp;Controlling Overload Resolution</a></li>
<li><a class="reference" href="#efficiency-issues" id="id27" name="id27">2.8&nbsp;&nbsp;&nbsp;Efficiency Issues</a><ul class="auto-toc">
<li><a class="reference" href="#eliminating-copies" id="id28" name="id28">2.8.1&nbsp;&nbsp;&nbsp;Eliminating Copies</a></li>
<li><a class="reference" href="#eliminating-construction" id="id29" name="id29">2.8.2&nbsp;&nbsp;&nbsp;Eliminating Construction</a></li>
<li><a class="reference" href="#default-forwarding" id="id30" name="id30">2.8.3&nbsp;&nbsp;&nbsp;Default Forwarding</a></li>
<li><a class="reference" href="#dispatching-based-on-the-presence-of-a-default" id="id31" name="id31">2.8.4&nbsp;&nbsp;&nbsp;Dispatching Based on the Presence of a Default</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<hr class="docutils" />
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id12" name="introduction">1&nbsp;&nbsp;&nbsp;Introduction</a></h1>
<p>In C++, arguments are normally given meaning by their positions
with respect to a parameter list.  That protocol is fine when there
are one or fewer parameters with default values, but when there are
even a few useful defaults, the positional interface becomes
burdensome:</p>
<ul>
<li><p class="first">Since an argument's meaning is given by its position, we have to
choose an (often arbitrary) order for parameters with default
values, making some combinations of defaults unusable:</p>
<pre class="literal-block">
window* new_window(
   char const* name, 
   <strong>int border_width = default_border_width,</strong>
   bool movable = true,
   bool initially_visible = true
   );

const bool movability = false;
window* w = new_window(&quot;alert box&quot;, movability);
</pre>
<p>In the example above we wanted to make an unmoveable window
with a default <tt class="docutils literal"><span class="pre">border_width</span></tt>, but instead we got a moveable
window with a <tt class="docutils literal"><span class="pre">border_width</span></tt> of zero.  To get the desired
effect, we'd need to write:</p>
<pre class="literal-block">
window* w = new_window(
   &quot;alert box&quot;, <strong>default_border_width</strong>, movability);
</pre>
</li>
<li><p class="first">It can become difficult for readers to understand the meaning of
arguments at the call site:</p>
<pre class="literal-block">
window* w = new_window(&quot;alert&quot;, 1, true, false);
</pre>
<p>Is this window moveable and initially invisible, or unmoveable
and initially visible?  The reader needs to remember the order
of arguments to be sure.</p>
</li>
<li><p class="first">The author of the call may not remember the order of the
arguments either, leading to hard-to-find bugs.</p>
</li>
</ul>
<p>This library addresses the problems outlined above by associating
each parameter with a keyword object.  Now users can identify
arguments by keyword, rather than by position:</p>
<pre class="literal-block">
window* w = new_window(&quot;alert box&quot;, <strong>movable=</strong>false); // OK!
</pre>
<!-- I'm inclined to leave this part out.  In particular, the 2nd
point is kinda lame because even with the library, we need to
introduce overloads - - dwa:

C++ has two other limitations, with respect to default arguments,
that are unrelated to its positional interface:

* Default values cannot depend on the values of other function
  parameters:

  .. parsed-literal::

    // Can we make resize windows to a square shape by default?
    void resize(
      window* w,
      int **width**, 
      int height **= width** // nope, error!
    );

* Default values in function templates are useless for any
  argument whose type should be deduced when the argument is
  supplied explicitly::

     template <class T> 
     void f(T x = 0);

     f(3.14) // ok: x supplied explicitly; T is double
     f();    // error: can't deduce T from default argument 0!

As a side effect of using the Boost Parameter library, you may find
that you circumvent both of these limitations quite naturally. -->
</div>
<div class="section" id="tutorial">
<h1><a class="toc-backref" href="#id13" name="tutorial">2&nbsp;&nbsp;&nbsp;Tutorial</a></h1>
<p>In this section we'll show how the Parameter library can be used to
build an expressive interface to the <a class="reference" href="../../../graph/index.html">Boost Graph library</a>'s
<a class="reference" href="../../../graph/doc/depth_first_search.html"><tt class="docutils literal"><span class="pre">depth_first_search</span></tt></a> algorithm.<a class="footnote-reference" href="#old-interface" id="id2" name="id2"><sup>1</sup></a> After laying some groundwork
and describing the algorithm's abstract interface, we'll show you
how to build a basic implementation with keyword support.  Then
we'll add support for default arguments and we'll gradually refine the
implementation with syntax improvements.  Finally we'll show how to
streamline the implementation of named parameter interfaces,
improve their participation in overload resolution, and optimize
their runtime efficiency.</p>
<div class="section" id="headers-and-namespaces">
<h2><a class="toc-backref" href="#id14" name="headers-and-namespaces">2.1&nbsp;&nbsp;&nbsp;Headers And Namespaces</a></h2>
<p>Most components of the Parameter library are declared in a
header named for the component.  For example,</p>
<pre class="literal-block">
#include &lt;boost/parameter/keyword.hpp&gt;
</pre>
<p>will ensure <tt class="docutils literal"><span class="pre">boost::parameter::keyword</span></tt> is known to the
compiler.  There is also a combined header,
<tt class="docutils literal"><span class="pre">boost/parameter.hpp</span></tt>, that includes most of the library's
components.  For the the rest of this tutorial, unless we say
otherwise, you can use the rule above to figure out which header
to <tt class="docutils literal"><span class="pre">#include</span></tt> to access any given component of the library.</p>
<p>Also, the examples below will also be written as if the
namespace alias</p>
<pre class="literal-block">
namespace parameter = boost::parameter;
</pre>
<p>has been declared: we'll write <tt class="docutils literal"><span class="pre">parameter::xxx</span></tt> instead of
<tt class="docutils literal"><span class="pre">boost::parameter::xxx</span></tt>.</p>
</div>
<div class="section" id="the-abstract-interface-to-dfs">
<h2><a class="toc-backref" href="#id15" name="the-abstract-interface-to-dfs">2.2&nbsp;&nbsp;&nbsp;The Abstract Interface to <tt class="docutils literal"><span class="pre">depth_first_search</span></tt></a></h2>
<p>The Graph library's <tt class="docutils literal"><span class="pre">depth_first_search</span></tt> algorithm is a generic function accepting
between one and four arguments by reference, as shown in the table
below:</p>
<a class="target" id="parameter-table" name="parameter-table"></a><a class="target" id="default-expressions" name="default-expressions"></a><table border="1" class="docutils">
<caption><tt class="docutils literal"><span class="pre">depth_first_search</span></tt> Parameters</caption>
<colgroup>
<col width="27%" />
<col width="17%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr><th>Parameter Name</th>
<th>Dataflow</th>
<th>Default Value (if any)</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><tt class="docutils literal"><span class="pre">graph</span></tt></td>
<td>IN</td>
<td>none - this argument is required.</td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">visitor</span></tt></td>
<td>IN</td>
<td><tt class="docutils literal"><span class="pre">boost::dfs_visitor&lt;&gt;()</span></tt></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">root_vertex</span></tt></td>
<td>OUT</td>
<td><tt class="docutils literal"><span class="pre">*vertices(g).first</span></tt></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">index_map</span></tt></td>
<td>IN</td>
<td><tt class="docutils literal"><span class="pre">get(boost::vertex_index,graph)</span></tt></td>
</tr>
<tr><td><tt class="docutils literal"><span class="pre">color_map</span></tt></td>
<td>IN</td>
<td>an <tt class="docutils literal"><span class="pre">iterator_property_map</span></tt>
created from a <tt class="docutils literal"><span class="pre">std::vector</span></tt> of
<tt class="docutils literal"><span class="pre">default_color_type</span></tt> of size
<tt class="docutils literal"><span class="pre">num_vertices(g)</span></tt> and using the
<tt class="docutils literal"><span class="pre">index_map</span></tt> for the index map.</td>
</tr>
</tbody>
</table>
<p>Don't be intimidated by the complex default values.  For the
purposes of this exercise, you don't need to understand what they
mean. Also, we'll show you how the default for <tt class="docutils literal"><span class="pre">color_map</span></tt> is
computed later in the tutorial; trust us when we say that the
complexity of its default will become valuable.</p>
</div>
<div class="section" id="defining-the-keywords">
<h2><a class="toc-backref" href="#id16" name="defining-the-keywords">2.3&nbsp;&nbsp;&nbsp;Defining the Keywords</a></h2>
<p>The point of this exercise is to make it possible to call
<tt class="docutils literal"><span class="pre">depth_first_search</span></tt> with keyword arguments, leaving out any
arguments for which the default is appropriate:</p>
<pre class="literal-block">
graphs::depth_first_search(g, <strong>color_map = my_color_map</strong>);
</pre>
<p>To make that syntax legal, there needs to be an object called
<tt class="docutils literal"><span class="pre">color_map</span></tt> with an assignment operator that can accept a
<tt class="docutils literal"><span class="pre">my_color_map</span></tt> argument.  In this step we'll create one such
<strong>keyword object</strong> for each parameter.  Each keyword object will be
identified by a unique <strong>keyword tag type</strong>.</p>
<p>We're going to define our interface in namespace <tt class="docutils literal"><span class="pre">graphs</span></tt>.  Since
users need access to the keyword objects, but not the tag types,
we'll define the keyword objects so they're acceessible through
<tt class="docutils literal"><span class="pre">graphs</span></tt>, and we'll hide the tag types away in a tested
namespace, <tt class="docutils literal"><span class="pre">graphs::tag</span></tt>.  The library provides a convenient
macro for that purpose:<a class="footnote-reference" href="#msvc-keyword" id="id4" name="id4"><sup>3</sup></a></p>
<pre class="literal-block">
#include &lt;boost/parameter/keyword.hpp&gt;

namespace graphs
{
  BOOST_PARAMETER_KEYWORD(tag, graph);
  BOOST_PARAMETER_KEYWORD(tag, visitor);
  BOOST_PARAMETER_KEYWORD(tag, root_vertex);
  BOOST_PARAMETER_KEYWORD(tag, index_map);
  BOOST_PARAMETER_KEYWORD(tag, color_map);
}
</pre>
<p>The declaration of the <tt class="docutils literal"><span class="pre">visitor</span></tt> keyword you see here is
equivalent to:</p>
<pre class="literal-block">
namespace graphs 
{
  namespace tag { struct visitor; }
  namespace { 
    boost::parameter::keyword&lt;tag::visitor&gt;&amp; visitor
    = boost::parameter::keyword&lt;tag::visitor&gt;::get();
  }
}
</pre>
<p>This “fancy dance” involving the unnamed namespace and references
is all done to avoid violating the One Definition Rule (ODR)<a class="footnote-reference" href="#odr" id="id5" name="id5"><sup>2</sup></a> when the named parameter interface is used by function
templates that are instantiated in multiple translation
units.</p>
</div>
<div class="section" id="defining-the-implementation-function">
<h2><a class="toc-backref" href="#id17" name="defining-the-implementation-function">2.4&nbsp;&nbsp;&nbsp;Defining the Implementation Function</a></h2>
<p>Next we can write the skeleton of the function that implements
the core of <tt class="docutils literal"><span class="pre">depth_first_search</span></tt>:</p>
<pre class="literal-block">
namespace graphs { namespace core
{
  template &lt;class ArgumentPack&gt;
  void depth_first_search(ArgumentPack const&amp; args)
  {
      // algorithm implementation goes here
  }
}}
</pre>
<p><tt class="docutils literal"><span class="pre">core::depth_first_search</span></tt> has an <span class="interpreted">ArgumentPack</span>
parameter: a bundle of references to the arguments that the caller
passes to the algorithm, tagged with their keywords.  To extract
each parameter, just pass its keyword object to the
<span class="interpreted">ArgumentPack</span>'s index operator.  We'll add some
temporary code to print the arguments, just to get a feel for how
it works:</p>
<pre class="literal-block">
namespace graphs { namespace core
{
  template &lt;class ArgumentPack&gt;
  void depth_first_search(ArgumentPack const&amp; args)
  {
      std::cout &lt;&lt; &quot;graph:\t&quot; &lt;&lt; <strong>args[graph]</strong> &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;visitor:\t&quot; &lt;&lt; <strong>args[visitor]</strong> &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;root_vertex:\t&quot; &lt;&lt; <strong>args[root_vertex]</strong> &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;index_map:\t&quot; &lt;&lt; <strong>args[index_map]</strong> &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;color_map:\t&quot; &lt;&lt; <strong>args[color_map]</strong> &lt;&lt; std::endl;
  }
}} // graphs::core
</pre>
<p>It's unlikely that many of the arguments the caller will eventually
pass to <tt class="docutils literal"><span class="pre">depth_first_search</span></tt> can be printed, but for now the code
above will give us something to experiment with.  To see the
keywords in action, we can write a little test driver:</p>
<pre class="literal-block">
int main()
{
    using namespace graphs;

    core::depth_first_search(<strong>(</strong>
      graph = 'G', visitor = 2, root_vertex = 3.5, 
      index_map = &quot;hello, world&quot;, color_map = false<strong>)</strong>);
}
</pre>
<p>An overloaded comma operator (<tt class="docutils literal"><span class="pre">operator,</span></tt>) combines the results
of assigning into each keyword object into a single <span class="interpreted">ArgumentPack</span>
object that gets passed on to <tt class="docutils literal"><span class="pre">core::depth_first_search</span></tt>.  The
extra set of parentheses you see in the example above are required:
without them, each assignment would be interpreted as a separate
function argument and the comma operator wouldn't take effect.
We'll show you how to get rid of the extra parentheses later in
this tutorial.</p>
<p>Of course, we can pass the arguments in any order:</p>
<pre class="literal-block">
int main()
{
    using namespace graphs;

    core::depth_first_search((
      root_vertex = 3.14, graph = 'G', color_map = false, 
      index_map = &quot;hello, world&quot;, visitor = 2));
}
</pre>
<p>either of the two programs above will print:</p>
<pre class="literal-block">
graph:       G
visitor:     2
root_vertex: 3.5
index_map:   hello, world
color_map:   false
</pre>
</div>
<div class="section" id="adding-defaults">
<h2><a class="toc-backref" href="#id18" name="adding-defaults">2.5&nbsp;&nbsp;&nbsp;Adding Defaults</a></h2>
<p>Currently, all the arguments to <tt class="docutils literal"><span class="pre">depth_first_search</span></tt> are
required.  If any parameter can't be found, there will be a
compilation error where we try to extract it from the
<span class="interpreted">ArgumentPack</span> using the square-brackets operator.  To make it
legal to omit an argument we need to give it a default value.</p>
<div class="section" id="syntax">
<h3><a class="toc-backref" href="#id19" name="syntax">2.5.1&nbsp;&nbsp;&nbsp;Syntax</a></h3>
<p>We can make any of the parameters optional by following its keyword
with the <tt class="docutils literal"><span class="pre">|</span></tt> operator and the parameter's default value within
the brackets.  In the following example, we've given
<tt class="docutils literal"><span class="pre">root_vertex</span></tt> a default of <tt class="docutils literal"><span class="pre">42</span></tt> and <tt class="docutils literal"><span class="pre">color_map</span></tt> a default of
<tt class="docutils literal"><span class="pre">&quot;hello,</span> <span class="pre">world&quot;</span></tt>.</p>
<pre class="literal-block">
namespace graphs { namespace core
{
  template &lt;class ArgumentPack&gt;
  void depth_first_search(ArgumentPack const&amp; args)
  {
      std::cout &lt;&lt; &quot;graph:\t&quot; &lt;&lt; args[graph] &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;visitor:\t&quot; &lt;&lt; args[visitor] &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;root_vertex:\t&quot; &lt;&lt; args[root_vertex<strong>|42</strong>] &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;index_map:\t&quot; &lt;&lt; args[index_map] &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;color_map:\t&quot; &lt;&lt; args[color_map<strong>|&quot;hello, world&quot;</strong>] &lt;&lt; std::endl;
  }
}} // graphs::core
</pre>
<p>Now we can invoke the function without supplying <tt class="docutils literal"><span class="pre">color_map</span></tt> or
<tt class="docutils literal"><span class="pre">root_vertex</span></tt>:</p>
<pre class="literal-block">
core::depth_first_search((
  graph = 'G', index_map = &quot;index&quot;, visitor = 6));
</pre>
<p>The call above would print:</p>
<pre class="literal-block">
graph:       G
visitor:     6
root_vertex: 42
index_map:   index
color_map:   hello, world
</pre>
<div class="important">
<p class="first admonition-title">Important</p>
<p class="last">The index expression <tt class="docutils literal"><span class="pre">args[…]</span></tt> always yields a <em>reference</em>
that is bound either to the actual argument passed by the caller
or, if no argument is explicitly specified, to the specified
default value.</p>
</div>
</div>
<div class="section" id="getting-more-realistic">
<h3><a class="toc-backref" href="#id20" name="getting-more-realistic">2.5.2&nbsp;&nbsp;&nbsp;Getting More Realistic</a></h3>
<p>Now it's time to put some more realistic defaults in place.  We'll
have to give up our print statements—at least if we want to see the
defaults work—because as we mentioned, the default values of these
parameters generally aren't printable.</p>
<p>Instead, we'll connect local variables to the arguments and use
those in our algorithm:</p>
<pre class="literal-block">
namespace graphs { namespace core
{
  template &lt;class ArgumentPack&gt;
  void depth_first_search(ArgumentPack const&amp; args)
  {
      <em>Graph</em>   g = args[graph];
      <em>Visitor</em> v = args[visitor|<em>default-expression</em><sub>1</sub>];
      <em>Vertex</em>  s = args[root_vertex|<em>default-expression</em><sub>2</sub>];
      <em>Index</em>   i = args[index_map|<em>default-expression</em><sub>3</sub>];
      <em>Color</em>   c = args[visitor|<em>default-expression</em><sub>4</sub>];

      <em>…use g, v, s, i, and c to implement the algorithm…</em>
  }
}} // graphs::core
</pre>
<p>We'll insert the <a class="reference" href="#default-expressions">default expressions</a> in a moment, but first we
need to come up with the types <em>Graph</em>, <em>Visitor</em>, <em>Vertex</em>,
<em>Index</em>, and <em>Color</em>.</p>
</div>
<div class="section" id="the-binding-metafunction">
<h3><a class="toc-backref" href="#id21" name="the-binding-metafunction">2.5.3&nbsp;&nbsp;&nbsp;The <tt class="docutils literal"><span class="pre">binding</span></tt> <a class="reference" href="../../../mpl/doc/refmanual/metafunction.html"><span class="interpreted">Metafunction</span></a></a></h3>
<p>To compute the type of a parameter we can use a <a class="reference" href="../../../mpl/doc/refmanual/metafunction.html"><span class="interpreted">Metafunction</span></a>
called <tt class="docutils literal"><span class="pre">binding</span></tt>:</p>
<pre class="literal-block">
binding&lt;ArgumentPack, Keyword, Default = void&gt;
{ typedef <em>see text</em> type; };
</pre>
<p>where <tt class="docutils literal"><span class="pre">Default</span></tt> is the type of the default argument, if any.</p>
<p>For example, to declare and initialize <tt class="docutils literal"><span class="pre">g</span></tt> above, we could write:</p>
<pre class="literal-block">
typedef typename parameter::binding&lt;
  ArgumentPack,<strong>tag::graph</strong>
&gt;::type Graph;

Graph g = args[graph];
</pre>
<p>As shown in the <a class="reference" href="#parameter-table">parameter table</a>, <tt class="docutils literal"><span class="pre">graph</span></tt> has no default, so
the <tt class="docutils literal"><span class="pre">binding</span></tt> invocation for <em>Graph</em> takes only two arguments.
The default <tt class="docutils literal"><span class="pre">visitor</span></tt> is <tt class="docutils literal"><span class="pre">boost::dfs_visitor&lt;&gt;()</span></tt>, so the
<tt class="docutils literal"><span class="pre">binding</span></tt> invocation for <em>Visitor</em> takes three:</p>
<pre class="literal-block">
typedef typename parameter::binding&lt;
  ArgumentPack,<strong>tag::visitor,boost::dfs_visitor&lt;&gt;</strong>
&gt;::type Visitor;

Visitor v = args[visitor|<strong>boost::dfs_visitor&lt;&gt;()</strong>];
</pre>
<p>Note that the default <tt class="docutils literal"><span class="pre">visitor</span></tt> is supplied as a <em>temporary</em>
instance of <tt class="docutils literal"><span class="pre">dfs_visitor</span></tt>.  Because <tt class="docutils literal"><span class="pre">args[…]</span></tt> always yields
a reference, making <tt class="docutils literal"><span class="pre">v</span></tt> a reference would cause it to bind to
that temporary, and immediately dangle.  Therefore, it's crucial
that we passed <tt class="docutils literal"><span class="pre">dfs_visitor&lt;&gt;</span></tt>, and not <tt class="docutils literal"><span class="pre">dfs_visitor&lt;&gt;</span>
<span class="pre">const&amp;</span></tt>, as the last argument to <tt class="docutils literal"><span class="pre">binding</span></tt>.</p>
<div class="important">
<p class="first admonition-title">Important</p>
<p class="last">Never pass <tt class="docutils literal"><span class="pre">binding</span></tt> a reference type as the default unless
you know that the default value passed to the <span class="interpreted">ArgumentPack</span>'s
indexing operator will outlive the reference you'll bind to it.</p>
</div>
<p>Sometimes there's no need to use <tt class="docutils literal"><span class="pre">binding</span></tt> at all.  The
<tt class="docutils literal"><span class="pre">root_vertex</span></tt> argument is required to be of the graph's
<tt class="docutils literal"><span class="pre">vertex_descriptor</span></tt> type,<a class="footnote-reference" href="#vertex-descriptor" id="id6" name="id6"><sup>4</sup></a> so we can just
use that knowledge to bypass <tt class="docutils literal"><span class="pre">binding</span></tt> altogether.</p>
<pre class="literal-block">
typename <strong>boost::graph_traits&lt;Graph&gt;::vertex_descriptor</strong>
  s = args[root_vertex|<strong>*vertices(g).first</strong>];
</pre>
<a class="target" id="dangling" name="dangling"></a></div>
<div class="section" id="beyond-ordinary-default-arguments">
<h3><a class="toc-backref" href="#id22" name="beyond-ordinary-default-arguments">2.5.4&nbsp;&nbsp;&nbsp;Beyond Ordinary Default Arguments</a></h3>
<p>Here's how you might write the declaration for the <tt class="docutils literal"><span class="pre">index_map</span></tt>
parameter:</p>
<pre class="literal-block">
typedef typename parameter::binding&lt;
    ArgumentPack
  , tag::index_map
  , <strong>typename boost::property_map&lt;Graph, vertex_index_t&gt;::const_type</strong>
&gt;::type Index;

Index i = args[index_map|<strong>get(boost::vertex_index,g)</strong>];
</pre>
<p>We'd like you to notice two capabilities we've gained over what
plain C++ default arguments provide:</p>
<ol class="arabic">
<li><p class="first">The default value of the <tt class="docutils literal"><span class="pre">index</span></tt> parameter depends on the
value of the <tt class="docutils literal"><span class="pre">graph</span></tt> parameter.  That's illegal in plain C++:</p>
<pre class="literal-block">
void f(int <strong>graph</strong>, int index = <strong>graph</strong> + 1); // error
</pre>
</li>
<li><p class="first">The <tt class="docutils literal"><span class="pre">index</span></tt> parameter has a useful default, yet it is
templated and its type can be deduced when  an <tt class="docutils literal"><span class="pre">index</span></tt>
argument is explicitly specified by the caller.  In plain C++, you
can <em>specify</em> a default value for a parameter with deduced type,
but it's not very useful:</p>
<pre class="literal-block">
template &lt;class Index&gt;
int f(Index index <strong>= 42</strong>);  // OK
int y = f();                // <strong>error; can't deduce Index</strong>
</pre>
</li>
</ol>
</div>
</div>
<div class="section" id="syntactic-refinement">
<h2><a class="toc-backref" href="#id23" name="syntactic-refinement">2.6&nbsp;&nbsp;&nbsp;Syntactic Refinement</a></h2>
<p>To allow callers to invoke <tt class="docutils literal"><span class="pre">depth_first_search</span></tt> with just one
pair of parentheses, and to omit keywords where appropriate, we'll
need to build a type that describes the allowed parameters and
their ordering when passed positionally.  This type is known as
a <span class="interpreted">ParameterSpec</span>.<a class="footnote-reference" href="#typedef" id="id7" name="id7"><sup>5</sup></a></p>
<pre class="literal-block">
namespace graphs
{
  struct dfs_params
    : parameter::parameters&lt;
          tag::graph
        , tag::visitor
        , tag::root_vertex
        , tag::index_map
        , tag::color_map
      &gt;
  {};
}
</pre>
<p>The <tt class="docutils literal"><span class="pre">parameters</span></tt> template supplies a function-call
operator that groups all its arguments into an <span class="interpreted">ArgumentPack</span>.  Any
arguments passed to it without a keyword label will be associated
with a parameter according to its position in the <span class="interpreted">ParameterSpec</span>.
So for example, given an object <tt class="docutils literal"><span class="pre">p</span></tt> of type <tt class="docutils literal"><span class="pre">dfs_params</span></tt>,</p>
<pre class="literal-block">
p('G', index_map=1)
</pre>
<p>gives the <tt class="docutils literal"><span class="pre">graph</span></tt> parameter a value of <tt class="docutils literal"><span class="pre">'G'</span></tt>, and gives the
<tt class="docutils literal"><span class="pre">index_map</span></tt> parameter a value of <tt class="docutils literal"><span class="pre">1</span></tt>.</p>
<p>Next we need a family of overloaded <tt class="docutils literal"><span class="pre">depth_first_search</span></tt> function
templates that can be called with anywhere from one to five
arguments.  These “forwarding functions” will invoke an instance of
<tt class="docutils literal"><span class="pre">dfs_params</span></tt> as a function object, passing their parameters
to its <tt class="docutils literal"><span class="pre">operator()</span></tt>, and passing the result on to
<tt class="docutils literal"><span class="pre">core::depth_first_search</span></tt>:</p>
<pre class="literal-block">
namespace graphs
{
  template &lt;class A0&gt;
  void depth_first_search(A0 const&amp; a0)
  {
     core::depth_first_search(dfs_params()(a0));
  }

  template &lt;class A0, class A1&gt;
  void depth_first_search(A0 const&amp; a0, A1 const&amp; a1)
  {
     core::depth_first_search(dfs_params()(a0,a1));
  }

                    ⋮

  template &lt;class A0, class A1&gt;
  void depth_first_search(A0 const&amp; a0, A1 const&amp; a1, …A4 const&amp; a4)
  {
     core::depth_first_search(dfs_params()(a0,a1,a2,a3,a4));
  }
}
</pre>
<p>That's it!  We can now call <tt class="docutils literal"><span class="pre">graphs::depth_first_search</span></tt> with
from one to five arguments passed positionally or via keyword.</p>
<div class="section" id="generating-the-forwarding-functions-with-macros">
<h3><a class="toc-backref" href="#id24" name="generating-the-forwarding-functions-with-macros">2.6.1&nbsp;&nbsp;&nbsp;Generating the Forwarding Functions with Macros</a></h3>
</div>
<div class="section" id="passing-non-const-references-positionally">
<h3><a class="toc-backref" href="#id25" name="passing-non-const-references-positionally">2.6.2&nbsp;&nbsp;&nbsp;Passing non-const References positionally</a></h3>
</div>
</div>
<div class="section" id="controlling-overload-resolution">
<h2><a class="toc-backref" href="#id26" name="controlling-overload-resolution">2.7&nbsp;&nbsp;&nbsp;Controlling Overload Resolution</a></h2>
</div>
<div class="section" id="efficiency-issues">
<h2><a class="toc-backref" href="#id27" name="efficiency-issues">2.8&nbsp;&nbsp;&nbsp;Efficiency Issues</a></h2>
<p>The <tt class="docutils literal"><span class="pre">color_map</span></tt> parameter gives us a few efficiency issues to
consider.  Here's a first cut at extraction and binding:</p>
<pre class="literal-block">
typedef 
  vector_property_map&lt;boost::default_color_type, Index&gt;
default_color_map;

typename parameter::binding&lt;
    ArgumentPack
  , tag::color_map
  , default_color_map
&gt;::type color = args[color_map|<strong>default_color_map(num_vertices(g),i)</strong>];
</pre>
<div class="section" id="eliminating-copies">
<h3><a class="toc-backref" href="#id28" name="eliminating-copies">2.8.1&nbsp;&nbsp;&nbsp;Eliminating Copies</a></h3>
<p>The library has no way to know whether an explicitly-supplied
argument is expensive to copy (or even if it is copiable at all),
so <tt class="docutils literal"><span class="pre">binding&lt;…,k,…&gt;::type</span></tt> is always a reference type when the
<em>k</em> parameter is supplied by the caller.  Since <tt class="docutils literal"><span class="pre">args[…]</span></tt>
yields a reference to the actual argument, <tt class="docutils literal"><span class="pre">color</span></tt> will be bound
to the actual <tt class="docutils literal"><span class="pre">color_map</span></tt> argument and no copying will be done.</p>
<p>As described <a class="reference" href="#dangling">above</a>, because the default is a temporary, it's
important that <tt class="docutils literal"><span class="pre">color</span></tt> be a non-reference when the default is
used.  In that case, the default value will be <em>copied</em> into
<tt class="docutils literal"><span class="pre">color</span></tt>.  If we store the default in a named variable, though,
<tt class="docutils literal"><span class="pre">color</span></tt> can be a reference, thereby eliminating the copy:</p>
<pre class="literal-block">
default_color_map default_color(num_vertices(g),i);

typename parameter::binding&lt;
    ArgumentPack
  , tag::color_map
  , <strong>default_color_map&amp;</strong>
&gt;::type color = args[color_map|default_color];
</pre>
<div class="hint">
<p class="first admonition-title">Hint</p>
<p class="last">To avoid making needless copies, pass a <em>reference to the
default type</em> as the third argument to <tt class="docutils literal"><span class="pre">binding</span></tt>.</p>
</div>
</div>
<div class="section" id="eliminating-construction">
<h3><a class="toc-backref" href="#id29" name="eliminating-construction">2.8.2&nbsp;&nbsp;&nbsp;Eliminating Construction</a></h3>
<p>Of course it's nice to avoid copying <tt class="docutils literal"><span class="pre">default_color</span></tt>, but the
more important cost is that of <em>constructing</em> it in the first
place.  A <tt class="docutils literal"><span class="pre">vector_property_map</span></tt> is cheap to copy, since it holds
its elements via a <a class="reference" href="../../../smart_ptr/shared_ptr.htm"><tt class="docutils literal"><span class="pre">shared_ptr</span></tt></a>.  On the other hand, construction of
<tt class="docutils literal"><span class="pre">default_color</span></tt> costs at least two dynamic memory allocations and
<tt class="docutils literal"><span class="pre">num_vertices(g)</span></tt> copies; it would be better to avoid doing this
work when the default value won't be needed.</p>
<p>To that end, the library allows us to supply a callable object
that—if no argument was supplied by the caller—will be invoked to
construct the default value.  Instead of following the keyword with
the <tt class="docutils literal"><span class="pre">|</span></tt> operator, we'll use <tt class="docutils literal"><span class="pre">||</span></tt> and follow it with a
nullary (zero-argument) function object that constructs a
default_color_map.  The function object is built using
<a class="reference" href="../../../lambda/index.html">Boost.Lambda</a>:<a class="footnote-reference" href="#bind" id="id9" name="id9"><sup>6</sup></a></p>
<pre class="literal-block">
// After #include &lt;boost/lambda/construct.hpp&gt;
typename parameter::binding&lt;
    ArgumentPack
  , tag::color_map
  , default_color_map
&gt;::type color = args[
  color_map
  <strong>|| boost::lambda::construct&lt;default_color_map&gt;(num_vertices(g),i)</strong>
];
</pre>
<div class="sidebar">
<p class="first sidebar-title">Memnonics</p>
<p class="last">To remember the difference between <tt class="docutils literal"><span class="pre">|</span></tt> and <tt class="docutils literal"><span class="pre">||</span></tt>, recall that
<tt class="docutils literal"><span class="pre">||</span></tt> normally uses short-circuit evaluation: its second
argument is only evaluated if its first argument is <tt class="docutils literal"><span class="pre">false</span></tt>.
Similarly, in <tt class="docutils literal"><span class="pre">color_map[param||f]</span></tt>, <tt class="docutils literal"><span class="pre">f</span></tt> is only invoked if
no <tt class="docutils literal"><span class="pre">color_map</span></tt> argument was supplied.</p>
</div>
</div>
<div class="section" id="default-forwarding">
<h3><a class="toc-backref" href="#id30" name="default-forwarding">2.8.3&nbsp;&nbsp;&nbsp;Default Forwarding</a></h3>
<p>Types that are expensive to construct yet cheap to copy aren't all
that typical, and even copying the color map is more expensive than
we might like.  It might be nice to avoid both needless
construction <em>and</em> needless copying of the default color map.  The
simplest way to achieve that is to avoid naming it altogether, at
least not in <tt class="docutils literal"><span class="pre">core::depth_first_search</span></tt>.  Instead, we could just
introduce another function template to implement the actual
algorithm:</p>
<pre class="literal-block">
namespace graphs { namespace core
{
  template &lt;class G, class V, class S, class I, class C&gt;
  void <strong>dfs_impl</strong>(G&amp; g, V&amp; v, S&amp; s, I&amp; i, C&amp; c)
  {
      <em>…actual algorithm implementation…</em>
  }
}}
</pre>
<p>Then, in <tt class="docutils literal"><span class="pre">core::depth_first_search</span></tt>, we'll simply forward the
result of indexing <tt class="docutils literal"><span class="pre">args</span></tt> to <tt class="docutils literal"><span class="pre">core::dfs_impl</span></tt>:</p>
<pre class="literal-block">
core::dfs_impl( 
    g,v,s,i
  , args[
      color_map
      || boost::lambda::construct&lt;default_color_map&gt;(num_vertices(g),i)
    ]);
</pre>
<p>In real code, after going to the trouble to write <tt class="docutils literal"><span class="pre">dfs_impl</span></tt>,
we'd probably just forward all the arguments.</p>
</div>
<div class="section" id="dispatching-based-on-the-presence-of-a-default">
<h3><a class="toc-backref" href="#id31" name="dispatching-based-on-the-presence-of-a-default">2.8.4&nbsp;&nbsp;&nbsp;Dispatching Based on the Presence of a Default</a></h3>
<p>In fact, the Graph library itself constructs a slightly different
<tt class="docutils literal"><span class="pre">color_map</span></tt>, to avoid even the overhead of initializing a
<a class="reference" href="../../../smart_ptr/shared_ptr.htm"><tt class="docutils literal"><span class="pre">shared_ptr</span></tt></a>:</p>
<pre class="literal-block">
std::vector&lt;boost::default_color_type&gt; 
  color_vec(num_vertices(g));

boost::iterator_property_map&lt;
    typename std::vector&lt;
       boost::default_color_type
    &gt;::iterator
  , Index
&gt; c(color_vec.begin(), i);
</pre>
<p>To avoid instantiating that code when it isn't needed, we'll have
to find a way to select different function implementations, at
compile time, based on whether a <tt class="docutils literal"><span class="pre">color_map</span></tt> argument was
supplied.  By using <a class="reference" href="../../../../more/generic_programming.html#tag_dispatching">tag dispatching</a> on the presence of a
<tt class="docutils literal"><span class="pre">color_map</span></tt> argument, we can do just that:</p>
<pre class="literal-block">
#include &lt;boost/type_traits/is_same.hpp&gt;
#include &lt;boost/mpl/bool.hpp&gt;

namespace graphs { namespace core {

  template &lt;class ArgumentPack&gt;
  void dfs_dispatch(ArgumentPack&amp; args, <strong>mpl::true_</strong>)
  {
      <em>…use the color map computed in the previous example…</em>
  }
  
  template &lt;class ArgumentPack&gt;
  void dfs_dispatch(ArgumentPack&amp; args, <strong>mpl::false_</strong>)
  {
      <em>…use args[color]…</em>
  }
  
  template &lt;class ArgumentPack&gt;
  void depth_first_search(ArgumentPack&amp; args)
  {
      typedef typename binding&lt;args,tag::color&gt;::type color_;
      core::dfs_dispatch(args, <strong>boost::is_same&lt;color_,void&gt;()</strong>);
  }
}}
</pre>
<p>We've used the fact that the default for <tt class="docutils literal"><span class="pre">binding</span></tt>'s third
argument is <tt class="docutils literal"><span class="pre">void</span></tt>: because specializations of <tt class="docutils literal"><span class="pre">is_same</span></tt> are
<tt class="docutils literal"><span class="pre">bool</span></tt>-valued MPL <a class="reference" href="../../../mpl/doc/refmanual/integral-constant.html"><span class="interpreted">Integral Constant</span></a>, it will be derived either
from <tt class="docutils literal"><span class="pre">mpl::true_</span></tt> or <tt class="docutils literal"><span class="pre">mpl::false_</span></tt>, and the appropriate
<tt class="docutils literal"><span class="pre">dfs_dispatch</span></tt> implementation will be selected.</p>
<hr class="docutils" />
<table class="docutils footnote" frame="void" id="old-interface" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2" name="old-interface">[1]</a></td><td>As of Boost 1.33.0 the Graph library was still
using an <a class="reference" href="../../../graph/doc/bgl_named_params.html">older named parameter mechanism</a>, but there are
plans to change it to use Boost.Parameter (this library) in an
upcoming release, while keeping the old interface available for
backward-compatibility.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="odr" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5" name="odr">[2]</a></td><td>The <strong>One Definition Rule</strong> says that any given entity in
a C++ program must have the same definition in all translation
units (object files) that make up a program.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="msvc-keyword" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4" name="msvc-keyword">[3]</a></td><td><p class="first">If you use Visual C++ 6.x, you may find you also
need the following using declarations, which really should be
redundant.  This need has been observed, but then it disappeared
as the code evolved, so add these only as a last resort:</p>
<pre class="last literal-block">
namespace graphs
{
  using graphs::graph;
  using graphs::visitor;
  using graphs::root_vertex;
  using graphs::index_map;
  using graphs::color_map;
}
</pre>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="vertex-descriptor" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6" name="vertex-descriptor">[4]</a></td><td>If you're not familiar with the Boost Graph
Library, don't worry about the meaning of any
Graph-library-specific details you encounter.  In this case you
could replace all mentions of vertex descriptor types with
<tt class="docutils literal"><span class="pre">int</span></tt> in the text, and your understanding of the Parameter
library wouldn't suffer.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="typedef" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7" name="typedef">[5]</a></td><td><p class="first">In principle you can also declare a
<span class="interpreted">ParameterSpec</span> as a <tt class="docutils literal"><span class="pre">typedef</span></tt>:</p>
<pre class="literal-block">
typedef parameter::parameters&lt;
      tag::graph, tag::visitor, tag::root_vertex
    , tag::index_map, tag::color_map
&gt; dfs_parameters;
</pre>
<p class="last">Some older compilers seem to be happier with the use of
inheritance, though.</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="bind" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9" name="bind">[6]</a></td><td><p class="first">The Lambda library is known not to work on <a class="reference" href="http://www.boost.org/regression/release/user/lambda.html">some
less-conformant compilers</a>.  When using one of those you could
define</p>
<pre class="last literal-block">
  template &lt;class T&gt;
  struct construct2
  {
      typedef T result_type;

      template &lt;class A1, class A2&gt;
      T operator() { return T(a1,a2); }
  };

and use Boost.Bind_ to generate the function object::

  boost::bind(construct2&lt;default_color_map&gt;,num_vertices(g),i)
</pre>
</td></tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<hr class="docutils footer" />
<div class="footer">
Generated on: 2005-07-15 01:59 UTC.
Generated by <a class="reference" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.
</div>
</body>
</html>
