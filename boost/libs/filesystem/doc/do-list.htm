<title>Boost Filesystem Do-list</title>
<h1>
<img border="0" src="../../../boost.png" align="center" width="277" height="86">Filesystem 
Do-list</h1>
<h2>Current</h2>
<ul>
  <li>Mini-review</li>
</ul>
<h2>Defer until after mini-review</h2>
<ul>
  <li>Should operations.cpp assert or BOOST_ASSERT on more preconditions?</li>
  <li>Look into the basic_directory_iterator friend problem in more detail.</li>
  <li>Apply PJP's Wide/Narrow conversion proposal to traits, once he stabilizes it.</li>
  <li>Filtered directory iterator, glob syntax -&gt; regex syntax converter. See 
  Rich Johnson's <a href="http://lists.boost.org/boost-users/2004/01/5770.php">
  lists.boost.org/boost-users/2004/01/5770.php</a>, and John Maddock's
  <a href="http://lists.boost.org/boost-users/2004/01/5770.php">lists.boost.org/boost-users/2004/01/5770.php</a></li>
  <li>Recursive directory iterator. See thread beginning with Thorsten Ottosen's
  <a href="http://lists.boost.org/boost/2004/03/2842.php">lists.boost.org/boost/2004/03/2842.php</a><ul>
    <li>Depth first vs breadth first - Unspecified. Most imps will use depth 
    first as more efficient.</li>
    <li>Issue of duplicates (caused by symlinks and hard links) is critical. 
    Both duplicate detecting and non-detecting are needed; non-detecting is far 
    more efficient, but some apps will require duplicate detection.<ul>
      <li>Names are useless for dup detection because of links, other file 
      system alias mechanisms such as drive mapping, mounts.</li>
      <li>inodes are unstable if handles are not held open, and it isn't 
      feasible to hold unlimited number of handles open.</li>
      <li>Size, dates, etc., are subject to race conditions.</li>
      <li>No one method is likely to serve all needs, but a starting point might 
      be to keep a hash-table keyed on a size/dates based signature, then do 
      equivalent() on all equal keys.</li>
    </ul>
    </li>
  </ul>
  </li>
  <li>Note Terence Wilson's efficiency concerns re: filtering; see
  <a href="http://lists.boost.org/MailArchives/boost/msg79583.php">
  //lists.boost.org/MailArchives/boost/msg79583.php</a></li>
  <li>Some or all of the above concerns may be easier to meet if 
  directory_iterator (or a wrapper) called a function object:<ul>
    <li>Argument is const char * name or const path &amp; or ?&nbsp; (is there a significant 
    efficiency difference?)</li>
    <li>Return is a code:<ul>
      <li>Continue; that is, return iterator pointing to this entry.</li>
      <li>Skip; ignore this entry completely.</li>
      <li>Skip returning this entry, but do iterate into it if directory 
      (assuming recursive iteration).</li>
      <li>Do return this entry, but don't iterate into if if a directory (don't 
      recurse).</li>
      <li>Skip and stop; return end iterator.</li>
      <li>Do return this entry, but force end iterator on next increment.</li>
    </ul>
    </li>
  </ul>
  </li>
  <li>Add a path::swap member function guaranteed not to throw? (Geurt Vos).</li>
  <li>Add an operations function based on statvfs/GetDiskFreeSpaceEx? (Steve Hartmann/Thomas Matelich)</li>
  <li>Add an is_other() function?</li>
  <li>Add constant basic_path overloads for constructors, operator=, operator/, 
  operator/. (Adrian Martin)<ul>
  <li>const path &amp;</li>
  <li>const string &amp;</li>
  <li>const char *</li>
  <li>InputIterator, InputIterator</li>
</ul>
  </li>
  <li>Issue (Adrian Martin): &gt;Comparison between paths doesn't use locale.<br>
  &gt;<br>
  &gt;The paths are not treated as plain characters since a lexicographical <br>
  &gt;compare is made. But the individual elements are treated<br>
  &gt;as plain characters and the internal string type's operator&lt; is used. This
  <br>
  &gt;is a bit contradicting. <br>
  &gt;<br>
  &gt;I think the comparison operators should compare the elements in a locale <br>
  &gt;dependent way.<br>
  <br>
  I've opened this as an issue. It needs to be answered in the context of what 
  comparison is used for. Remember that equivalence should be determined by the 
  equivalent() function. An important use of operator&lt; is when path is used as a 
  map or set key. Not sure how locale impacts that.</li>
</ul>
<hr>
<p>Revised
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan -->12 July, 2005<!--webbot bot="Timestamp" endspan i-checksum="21129" --></p>
<p>© Copyright Beman Dawes, 2002</p>
<p> Use, modification, and distribution are subject to the Boost Software 
License, Version 1.0. (See accompanying file <a href="../../../LICENSE_1_0.txt">
LICENSE_1_0.txt</a> or copy at <a href="http://www.boost.org/LICENSE_1_0.txt">
www.boost.org/LICENSE_1_0.txt</a>)</p>