[library Interprocess
    [quickbook 1.4]
    [version 1.0]
    [authors [Gazta&ntilde;aga, Ion]]
    [copyright 2005- 2006 Ion Gazta&ntilde;aga]
    [purpose Interprocess communication utilities]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[section:intro Introduction]

[*Boost.Interprocess] simplifies the use of common interprocess communication
and synchronization mechanisms and offers a wide range of them:

* Shared memory.
* Memory-mapped files.
* Semaphores, mutexes, condition variables and upgradable mutex types to place
  them in shared memory and memory mapped files.
* Named versions of those synchronization objects, similar to UNIX/Windows
  sem_open/CreateSemaphore API.
* File locking.
* Relative pointers.
* Message queues.

[*Boost.Interprocess] also offers higher-level interprocess mechanisms to allocate
dynamically portions of a shared memory or a memory mapped file (in general,
to allocate portions of a fixed size memory segment). Using these mechanisms,
[*Boost.Interprocess] offers the tools to construct C++ objects, including 
STL-like containers, in shared memory and memory mapped files:

* Dynamic creation of anonymous and named objects in a shared memory or memory
  mapped file.
* STL-like containers compatible with shared memory/memory-mapped files.
* STL-like allocators ready for shared memory/memory-mapped files implementing
  several memory allocation patterns (like pooling).

[endsect]

[section:quick_guide Quick Guide for the Impatient]

[section:qg_memory_pool Using shared memory as a pool of unnamed memory blocks]

You can just allocate a portion of a shared memory segment, copy the 
message to that buffer, send the offset of that portion of shared 
memory to another process, and you are done. Let's see the example:
     
[/ doc_ipc_messageA.cpp]

[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>

   int main ()
   {
      using namespace boost::interprocess;

      //An special shared memory from which we are
      //able to allocate raw memory buffers.
      //First remove any old shared memory of the same name and 
      //create the shared memory segment and initialize needed resources
      shared_memory_object::remove("MySharedMemory");
      managed_shared_memory segment
         (create_only, 
         "MySharedMemory",  //segment name
         65536);             //segment size in bytes

      //Allocate a portion of the segment
      void * shptr   = segment.allocate(1024/*bytes to allocate*/);

      //An handle from the base address can identify any byte of the shared 
      //memory segment even if it is mapped in different base addresses
      managed_shared_memory::handle_t handle = segment.get_handle_from_address(shptr);
      (void)handle;
      // Copy message to buffer
      // . . .
      // Send handle to other process
      // . . .
      // Wait response from other process
      // . . .

      //Deallocate the portion previously allocated
      segment.deallocate(shptr);
      return 0;
   }


In receiver process one just could write the following lines:

[/ doc_ipc_messageB.cpp]
[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>

   int main ()
   {
      using namespace boost::interprocess;

      //An special shared memory from which we are
      //able to allocate raw memory buffers.
      //Connect to the already created shared memory segment
      //and initialize needed resources
      managed_shared_memory segment(open_only, "MySharedMemory");  //segment name

      //An handle from the base address can identify any byte of the shared 
      //memory segment even if it is mapped in different base addresses
      managed_shared_memory::handle_t handle = 0;

      //Wait handle msg from the other process and put it in
      //"handle" local variable
      //Get buffer local address from handle
      void *msg = segment.get_address_from_handle(handle);
      (void)msg;
      //Do anything with msg
      //. . .
      //Send ack to sender process
      return 0;
   }

[endsect]

[section:qg_named_interprocess Creating named shared memory objects]

You want to create objects in a shared memory segment, giving a string name to them so that 
any other process can find, use and delete them from the segment when the objects are not 
needed anymore. Just write in one process:

[/ doc_named_allocA.cpp ]
[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <utility>

   int main ()
   {
      using namespace boost::interprocess;
      typedef std::pair<double, int> MyType;

      //An special shared memory where we can
      //construct objects associated with a name.
      //First remove any old shared memory of the same name, create 
      //the shared memory segment and initialize needed resources
      shared_memory_object::remove("MySharedMemory");
      managed_shared_memory segment(
         create_only,
         "MySharedMemory",   //segment name
         65536);              //segment size in bytes

      //Create an object of MyType initialized to {0.0, 0}
      MyType *instance = segment.construct<MyType>
         ("MyType instance")  /*name of the object*/
         (0.0                 /*ctor first argument*/,
          0                   /*ctor second argument*/);    

      //Create an array of 10 elements of MyType initialized to {0.0, 0}
      MyType *array = segment.construct<MyType>
         ("MyType array")     /*name of the object*/
         [10]                 /*number of elements*/
         (0.0                 /*ctor first argument*/,
          0                   /*ctor second argument*/);    
      return 0;
   }

In other process, while the first process is alive, execute the following:

[/ doc_named_allocB.cpp ]
[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <cstddef>
   #include <utility>
   #include <assert.h>

   int main ()
   {
      using namespace boost::interprocess;
      typedef std::pair<double, int> MyType;

      //An special shared memory where we can
      //construct objects associated with a name.
      //Connect to the already created shared memory segment
      //and initialize needed resources
      managed_shared_memory segment(
         open_only, 
         "MySharedMemory");

      //Find the array and object
      std::pair<MyType*, std::size_t> res;
      res = segment.find<MyType> ("MyType array");   

      std::size_t array_len   = res.second;
      //Length should be 10
      assert(array_len == 10);

      //Find the array and the object
      res = segment.find<MyType> ("MyType instance");   

      std::size_t len   = res.second;

      //Length should be 1
      assert(len == 1);

      //Use data
      // . . . 

      //We're done, delete array from memory
      segment.destroy<MyType>("MyType array");

      //We're done, delete object from memory
      segment.destroy<MyType>("MyType instance");
      return 0;
   }

[endsect]

[section:qg_offset_ptr Using an offset smart pointer for shared memory]

Interprocess offers offset_ptr smart pointer family 
as an offset pointer that stores the distance between the address of 
the offset pointer itself and the address of the pointed object.  
When offset_ptr is placed in a shared memory segment, it 
can point safely objects stored in the same shared 
memory segment, even if the segment is mapped in 
different base addresses in different processes.

This allows placing objects with pointer members 
in shared memory. For example, if we want to create 
a linked list in shared memory:

[/ doc_offset_ptr.cpp]
[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <boost/interprocess/offset_ptr.hpp>

   using namespace boost::interprocess;

   //Shared memory linked list node
   struct list_node
   {
      offset_ptr<list_node> next;
      int                   value;
   };

   int main ()
   {
      //Destroy any previous shared memory with the name to be used.
      //Create an special shared memory from which we can
      //allocate buffers of raw memory.
      shared_memory_object::remove("MySharedMemory");
      managed_shared_memory segment(
         create_only, 
         "MySharedMemory",//segment name
         65536);           //segment size in bytes

      //Create linked list with 10 nodes in shared memory
      offset_ptr<list_node> prev = 0, current, first;

      int i;
      for(i = 0; i < 10; ++i, prev = current){
         current = static_cast<list_node*>(segment.allocate(sizeof(list_node)));
         current->value = i;
         current->next  = 0;

         if(!prev)
            first = current;
         else
            prev->next = current;
      }

      //Communicate list to other processes
      //. . .
      //When done, destroy list
      for(current = first; current; /**/){
         prev = current;
         current = current->next;
         segment.deallocate(prev.get());
      }
      return 0;
   }

To help with basic data structures, [*Boost.Interprocess] offers containers like vector,
list, map, so you can avoid these manual data structures just like with standard containers.

[endsect]

[section:qg_interprocess_container Creating vectors in shared memory]

[*Boost.Interprocess] allows creating complex objects in shared memory and memory
mapped files. For example, we can construct STL-like containers in shared memory.
To do this, we just need to create a an special (managed) shared memory segment,
declare a [*Boost.Interprocess] allocator and construct the vector in shared memory
just if it was any other object. Just execute this first process:

[/doc_contA.cpp]

[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <boost/interprocess/containers/vector.hpp>
   #include <boost/interprocess/allocators/allocator.hpp>

   int main ()
   {
      using namespace boost::interprocess;
      //Shared memory front-end that is able to construct objects
      //associated with a c-string. Erase previous shared memory with the name
      //to be used and create the memory segment at the specified address and initialize resources
      shared_memory_object::remove("MySharedMemory");
      managed_shared_memory segment
         (create_only 
         ,"MySharedMemory" //segment name
         ,65536);          //segment size in bytes

      //Alias an STL compatible allocator of ints that allocates ints from the managed
      //shared memory segment.  This allocator will allow to place containers
      //in managed shared memory segments
      typedef allocator<int, managed_shared_memory::segment_manager> 
         ShmemAllocator;

      //Alias a vector that uses the previous STL-like allocator
      typedef vector<int, ShmemAllocator> MyVector;

      //Initialize shared memory STL-compatible allocator
      const ShmemAllocator alloc_inst (segment.get_segment_manager());

      //Construct a shared memory vector vector
      MyVector *myvector = 
         segment.construct<MyVector>("MyVector") //object name
                                    (alloc_inst);//first ctor parameter

      //Insert data in the vector
      for(int i = 0; i < 100; ++i){
         myvector->push_back(i);
      }

      return 0;
   }

After this process is executed we can search the constructed vector and use it with
STL algorithms:

[/doc_contB.cpp]

[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <boost/interprocess/containers/vector.hpp>
   #include <boost/interprocess/allocators/allocator.hpp>
   #include <algorithm>

   int main ()
   {
      using namespace boost::interprocess;

      //An special shared memory where we can
      //construct objects associated with a name.
      //Connect to the already created shared memory segment
      //and initialize needed resources
      managed_shared_memory segment
         (open_only 
         ,"MySharedMemory");  //segment name

      //Alias an STL compatible allocator of ints that allocates ints from the managed
      //shared memory segment.  This allocator will allow to place containers
      //in managed shared memory segments
      typedef allocator<int, managed_shared_memory::segment_manager> 
         ShmemAllocator;

      //Alias a vector that uses the previous STL-like allocator
      typedef vector<int, ShmemAllocator> MyVector;

      //Find the vector using the c-string name
      MyVector *myvector = segment.find<MyVector>("MyVector").first;

      //Use vector in reverse order
      std::sort(myvector->rbegin(), myvector->rend());
      // . . .

      //When done, destroy the vector from the segment
      segment.destroy<MyVector>("MyVector");
      return 0;
   }

[endsect]

[endsect]

[section:some_basic_explanations Some basic explanations]

[section:processes_and_threads Processes And Threads]

[*Boost.Interprocess] does not work only with processes but also with threads.
[*Boost.Interprocess] synchronization mechanisms can synchronize threads 
between from different processes, but also threads from the same process.

[endsect]

[section:sharing_information Sharing information between processes]

In the traditional programming model an operating system has multiple processes
running and each process has its own address space. To share information between
processes we have several alternatives:

* Two processes share information using a [*file]. To access to the data, each
  process uses the usual file read/write mechanisms. When updating/reading
  a file shared between processes, we need some sort of synchronization, to
  protect readers from writers.

* Two processes share information that resides in the [*kernel] of the operating
  system. This is the case, for example, of traditional message queues. The
  synchronization is guaranteed by the operating system kernel.

* Two processes can share a [*memory] region. This is the case of classical
  shared memory or memory mapped files. Once the processes set up the
  memory region, the processes can read/write the data without like any
  other memory segment without calling the operating system's kernel. This
  also requieres some kind of manual synchronization between processes.

[endsect]

[section:persistence Persistence Of Interprocess Mechanisms]

One of the biggest issues with interprocess communication mechanisms is the lifetime
of the interprocess communication mechanism.
It's important to know when an interprocess communication mechanism disappears from the
system. In [*Boost.Interprocess], we can have 3 types of persistence:

* [*Process-persistence]: The mechanism lasts until all the processes that have
  opened the mechanism close it, exit or crash.

* [*Kernel-persistence]: The mechanism exists until the kernel of the operating
  system reboots or the mechanism is explicitly deleted.

* [*Filesystem-persistence]: The mechanism exists until the mechanism is explicitly
  deleted.

Some native POSIX and Windows IPC mechanisms have different persistence so it's
difficult to achieve portability between Windows and POSIX native mechanisms. 
[*Boost.Interprocess] classes have the following persistence:

[table Boost.Interprocess Persistence Table
   [[Mechanism] [Persistence]]
   [[Shared memory]                 [Kernel or Filesystem]]
   [[Memory mapped file]            [Filesystem]]
   [[Process-shared mutex types]    [Process]]
   [[Process-shared semaphore]      [Process]]
   [[Process-shared condition]      [Process]]
   [[File lock]                     [Process]]
   [[Message queue]                 [Kernel or Filesystem]]
   [[Named mutex]                   [Kernel or Filesystem]]
   [[Named semaphore]               [Kernel or Filesystem]]
]

As you can see, [*Boost.Interprocess] defines some mechanisms with "Kernel or Filesystem"
persistence. This is because POSIX allows this possibility to native interprocess
communication implementations. One could, for example, implement
shared memory using memory mapped files and obtain filesystem persistence (for example,
there is no proper known way to emulate kernel persistence with a user library
for Windows shared memory using native shared memory,
or process persistence for POSIX shared memory, so the only portable way is to 
define "Kernel or Filesystem" persistence).

[endsect]

[section:names Names Of Interprocess Mechanisms]

Some interprocess mechanisms are anonymous objects created in shared memory or
memory-mapped files but other interprocess mechanisms need a name or identifier
so that two unrelated processes can use the same interprocess mechanism object.
Examples of this are shared memory, named mutexes and named semaphores (for example,
native windows CreateMutex/CreateSemaphore API family).

The name used to identify a interprocess mechanism is not portable, even between
UNIX systems. For this reason, [*Boost.Interprocess] limits this name to a C++ variable
identifier or keyword:

*Starts with a letter, lowercase or uppercase, such as a letter from a to z or from
 A to Z. Examples: ['Sharedmemory, sharedmemory, sHaReDmEmOrY...]
*Can include letters, underscore, or digits. Examples: ['shm1, shm2and3, ShM3plus4...]

[endsect]

[endsect]

[section:sharedmemory Shared memory]

[section:shared_memory_what_is What is shared memory?]

Shared memory is the fastest interprocess communication mechanism.
The operating system maps a memory segment in the address space of several
processes, so that several processes can read and write in that memory segment 
without calling operating system functions. However, we need some kind of 
synchronization between processes that read and write shared memory.

Consider what happens when a server process wants to send a html file to a client process
that resides in the same machine using network mechanisms:

* The server must read the file to memory and pass it to the network functions, that
  copy that memory to the OS's internal memory.

* The client uses the network functions to copy the data from the OS's internal memory
  to its own memory.

As we can see, there are two copies, one from memory to the network and another one
from the network to memory. And those copies are made using operating system calls
that normally are expensive. Shared memory avoids this overhead, but we need to 
synchronize both processes:

* The server maps a shared memory in its address space and also gets access to a
  synchronization mechanism. The server obtains exclusive access to the memory using
  the synchronization mechanism and copies the file to memory.

* The client maps the shared memory in its address space. Waits until the server releases
  the exclusive access and uses the data.

Using shared memory, we can avoid two data copies, but we have to synchronize the access
to the shared memory segment.

[endsect]

[section:shared_memory_steps Creating memory segments that can be shared between processes]

To use shared memory, we have to perform 2 basic steps:

* Request to the operating system a memory segment that can be shared between
processes. The user can create/destroy/open this memory using a [*shared memory object]:
['An object that represents memory that can be mapped concurrently into the 
  address space of more than one process.].

* Associate a part of that memory or the whole memory with the address space of the
  calling process. The operating system looks for a big enough memory address range
  in the calling process' address space and marks that address range as an
  special range. Changes in that address range are automatically seen
  by other process that also have mapped the same shared memory object.

Once the two steps have been successfully completed, the process can start writing to
and reading from the address space to send to and receive data from other processes.
Now, let's see how can we do this using [*Boost.Interprocess]:

[endsect]

[section:shared_memory_header Header]

To manage shared memory, you just need to include the following header:

[c++]

   #include <boost/interprocess/shared_memory.hpp>

[endsect]

[section:shared_memory_creating_shared_memory_segments Creating shared memory segments]

As we've mentioned we have to use the `shared_memory_object` class to create, open
and destroy shared memory segments that can be mapped by several processes. We can
specify the access mode of that shared memory object (read only or read-write),
just as if it was a file:

* Create a shared memory segment. Throws if already created:

[c++]

      using boost::interprocess;
      shared_memory_object shm_obj
         (create_only                  //only create
         ,"shared_memory"              //name
         ,memory_mappable::read_write  //read-write mode
         );

* To open or create a shared memory segment:

[c++]

      using boost::interprocess;
      shared_memory_object shm_obj
         (open_or_create               //open or create
         ,"shared_memory"              //name
         ,memory_mappable::read_only   //read-only mode
         );

* To only open a shared memory segment. Throws if does not exist:

[c++]

      using boost::interprocess;
      shared_memory_object shm_obj
         (open_only                    //only open
         ,"shared_memory"              //name
         ,memory_mappable::read_write  //read-write mode
         );

When a shared memory object is created, its size is 0.
To set the size of the shared memory, the user must use the `truncate` function
call, in a shared memory that has been opened with read-write attributes:

[c++]

      shm_obj.truncate(10000);

As shared memory has kernel or filesystem persistence, the user must explicitly
destroy it. The `remove` operation might fail returning
false if the shared memory does not exist, the file is open or the file is 
still memory mapped by other processes:

[c++]

      using boost::interprocess;
      shared_memory_object::remove("shared_memory");


For more details regarding `shared_memory_object` see the 
[classref boost::interprocess::shared_memory_object] class reference.

[endsect]

[section:shared_memory_mapping_shared_memory_segments Mapping Shared Memory Segments]

Once created or opened, a process just has to map the shared memory object in the process'
address space. The user can map the whole shared memory or just part of it. The
mapping process is done using the the `mapped_region` class. The class represents
a memory region that has been mapped from a shared memory or from other devices
that have also mapping capabilities (for example, files). A `mapped_region` can be
created from any `memory_mappable` object and as you might imagine, `shared_memory_object`
is a `memory_mappable` object:

[c++]

      using boost::interprocess;
      std::size_t ShmSize = ...

      //Map the second half of the memory
      mapped_region region
         ( shm                      //Memory-mappable object
         , mapped_region::read_write//Access mode
         , ShmSize/2                //Offset from the beginning of shm
         , ShmSize-ShmSize/2        //Length of the region
         );
      
      //Get the address of the region
      region.get_address();

      //Get the size of the region
      region.get_size();

The user can specify the offset from the mappable object where the mapped region
should start and the size of the mapped region. If no offset or size is specified,
the whole mappable object (in this case, shared memory) is mapped. If the offset
is specified, but not the size, the mapped region covers from the offset until
the end of the mappable object.

For more details regarding `mapped_region` see the 
[classref boost::interprocess::mapped_region] class reference.

[endsect]

[section:shared_memory_a_simple_example A Simple Example]

Let's see a simple example of shared memory use. A server process creates a file,
maps it and initializes all the bytes to a value. After that, 
a client process opens the shared memory, maps it, and checks
that the data is correctly initialized. This is the server process:

[/ doc_shared_memory.cppW]

[c++]

   #include <boost/interprocess/shared_memory.hpp>
   #include <iostream>
   #include <cstring>

   int main ()
   {
      using namespace boost::interprocess;
      try{
         //Create a shared memory object.
         shared_memory_object shm
            (create_only                  //only open
            ,"shared_memory"              //name
            ,memory_mappable::read_write  //read-write mode
            );

         //Set the size of the shared memory segment
         shm.truncate(1000);

         //Map the whole shared memory in this process
         mapped_region region
            (shm                       //What to map
            ,mapped_region::read_write //Map it as read-write
            );

         //Get the address of the mapped region
         void * addr       = region.get_address();
         std::size_t size  = region.get_size();

         //Write all the memory to 1
         std::memset(addr, 1, size);

      }
      catch(interprocess_exception &ex){
         std::cout << ex.what() << std::endl;
         return 1;
      }

      return 0;
   }

Now the client process:

[c++]

   #include <boost/interprocess/shared_memory.hpp>
   #include <iostream>

   int main ()
   {
      using namespace boost::interprocess;
      try{
         //Open already created shared memory object.
         shared_memory_object shm
            (open_only                 //only create
            ,"shared_memory"           //name
            ,memory_mappable::read_only//read-only mode
            );

         //Map the whole shared memory in this process
         mapped_region region
            (shm                       //What to map
            ,mapped_region::read_only  //Map it as read-only
            );

         //Get the address of the mapped region
         void * addr       = region.get_address();

         //Check that memory was initialized to 1
         const char *mem = static_cast<char*>(addr);
         for(std::size_t i = 0; i < size; ++i){
            if(*mem++ != 1){
               std::cout << "Error checking memory!" << std::endl;
               return 1;
            }
         }

         std::cout << "Test successful!" << std::endl;
      }
      catch(interprocess_exception &ex){
         std::cout << "Unexpected exception: " << ex.what() << std::endl;
         return 1;
      }
      return 0;
   }

[endsect]

[endsect]

[section:mapped_file Memory Mapped Files]

[section:mapped_file_what_is What is a memory mapped file?]

File mapping is the association of a file's contents with a portion of the address space 
of a process. The system creates a file mapping to associate the file and the address 
space of the process. A mapped region is the portion of address space that the process 
uses to access the file's contents. A single file mapping can have several mapped regions, 
so that the user can associate parts of the file with the address space of the process 
without mapping the entire file in the address space, since the file can be bigger
than the whole address space of the process (a 9GB DVD image file in a usual 32
bit systems). Processes read from and write to 
the file using pointers, just like with dynamic memory. File mapping has the following 
advantages: 

* Uniform resource use. Files and memory can be treated using the same functions. 
* Automatic file data synchronization and cache from the OS. 
* Reuse of C++ utilities (STL containers, algorithms) in files. 
* Shared memory between two or more applications. 
* Allows efficient work with a large files, without mapping the whole file into memory 
* If several processes use the same file mapping to create mapped regions of a file, each 
  process' views contain identical copies of the file on disk.

File mapping is not only used for interprocess communication, it can be used also to
simplify file usage, so the user does not need to use file-management functions to
write the file. The user just writes data to the process memory, and the operating
systems dumps the data to the file.

When two processes map the same file in memory, the memory that one process writes is
seen by another process, so memory mapped files can be used as an interprocess
communication mechanism. We can say that memory-mapped files offer the same interprocess
communication services as shared memory with the addition of filesystem persistence.
However, as the operating system has to synchronize the file contents with the memory
contents, memory-mapped files are not as fast as shared memory.

[endsect]

[section:mapped_file_steps Using mapped files]

To use memory-mapped files, we have to perform 2 basic steps:

* Create a mappable object that represent an already created file of the
  filesystem. This object will be used to create multiple mapped regions of the
  the file.

* Associate the whole file or parts of the file with the address space of the
  calling process. The operating system looks for a big enough memory address range
  in the calling process' address space and marks that address range as an
  special range. Changes in that address range are automatically seen
  by other process that also have mapped the same file and those changes
  are also transferred to the disk automatically.

Once the two steps have been successfully completed, the process can start writing to
and reading from the address space to send to and receive data from other processes
and synchronize the file's contents with the changes made to the mapped region.
Now, let's see how can we do this using [*Boost.Interprocess]:

[endsect]

[section:mapped_file_header Header]

To manage mapped files, you just need to include the following header:

[c++]

   #include <boost/interprocess/mapped_file.hpp>

[endsect]

[section:mapped_file_creating_file Creating a file mapping]

First, we have to link a file's contents with the process' address space. To do
this, we have to create a mappable object that represents that file. This is
achieved in [*Boost.Interprocess] creating a `file_mapping` object:

[c++]

      using boost::interprocess;
      file_mapping m_file
         ("/usr/home/file"             //filename
         ,memory_mappable::read_write  //read-write mode
         );

Now we can use the newly created object to create mapped regions. For more details
regarding `file_mapping` see the 
[classref boost::interprocess::file_mapping] class reference.

[endsect]

[section:mapped_file_mapping_regions Mapping File's Contents In Memory]

After creating a file mapping, a process just has to map the shared memory in the
process' address space. The user can map the whole shared memory or just part of it.
The mapping process is done using the the `mapped_region` class. as we have said before
The class represents a memory region that has been mapped from a shared memory or from other
devices that have also mapping capabilities: 

[c++]

      using boost::interprocess;
      std::size_t FileSize = ...

      //Map the second half of the file
      mapped_region region
         ( m_file                   //Memory-mappable object
         , mapped_region::read_write//Access mode
         , FileSize/2               //Offset from the beginning of shm
         , FileSize-FileSize/2      //Length of the region
         );
      
      //Get the address of the region
      region.get_address();

      //Get the size of the region
      region.get_size();


The user can specify the offset from the file where the mapped region
should start and the size of the mapped region. If no offset or size is specified,
the whole file is mapped. If the offset is specified, but not the size, 
the mapped region covers from the offset until the end of the file.

If several processes map the same file, and a process modifies a memory range
from a mapped region that is also mapped by other process, the changes are
inmedially visible to other processes. However, the file contents on disk are
not updated immediately, since that would hurt performance (writting to disk
is several times slower than writing to memory). If the user wants to make sure
that file's contents have been updated, it can flush a range from the view to disk.
When the function returns, the data should have been written to disk:

[c++]

      //Flush the whole region
      region.flush();

      //Flush from an offset until the end of the region
      region.flush(offset);

      //Flush a memory range starting on an offset
      region.flush(offset, size);

Remember that the offset is [*not] an offset on the file, but an offset in the
mapped region. If a region covers the second half of a file and flushes the
whole region, only the half of the file is guaranteed to have been flushed.

For more details regarding `mapped_region` see the 
[classref boost::interprocess::mapped_region] class reference.

[endsect]

[section:mapped_file_a_simple_example A Simple Example]

Let's reproduce the same example described in the shared memory section, using
memory mapped files. A server process creates a shared
memory segment, maps it and initializes all the bytes the a value. After that, 
a client process opens the shared memory, maps it, and checks
that the data is correctly initialized. This is the server process:

[c++]

   #include <boost/interprocess/mapped_file.hpp>
   #include <iostream>
   #include <fstream>
   #include <cstring>
   #include <cstddef>

   int main ()
   {
      using namespace boost::interprocess;
      try{
         //Create a file
         std::filebuf fbuf;
         fbuf.open("file.bin", std::ios_base::in | std::ios_base::out 
                             | std::ios_base::trunc | std::ios_base::binary); 

         //Set the size
         fbuf.pubseekoff(9999, std::ios_base::beg);
         fbuf.sputc(0);
         fbuf.close();

         //Create a file mapping.
         file_mapping m_file("file.bin", memory_mappable::read_write);

         //Map the whole file in this process
         mapped_region region
            (m_file                    //What to map
            ,mapped_region::read_write //Map it as read-write
            );

         if(region.get_size() != 10000)
            return 1;

         //Get the address of the mapped region
         void * addr       = region.get_address();
         std::size_t size  = region.get_size();

         //Write all the memory to 1
         std::memset(addr, 1, size);

      }
      catch(interprocess_exception &ex){
         std::cout << ex.what() << std::endl;
         return 1;
      }

      return 0;
   }

Now the client process:

[c++]

   #include <boost/interprocess/mapped_file.hpp>
   #include <iostream>
   #include <cstddef>
   #include <vector>

   int main ()
   {
      using namespace boost::interprocess;
      try{
         //Open the file mapping
         file_mapping m_file ("file.bin", memory_mappable::read_only);

         //Map the whole file in this process
         mapped_region region
            (m_file                    //What to map
            ,mapped_region::read_only  //Map it as read-only
            );

         //Get the address of the mapped region
         void * addr       = region.get_address();
         std::size_t size  = region.get_size();

         //Check that memory was initialized to 1
         const char *mem = static_cast<char*>(addr);
         for(std::size_t i = 0; i < size; ++i){
            if(*mem++ != 1){
               std::cout << "Error checking memory!" << std::endl;
               return 1;
            }
         }

         //Flush data to disk
         region.flush();

         //Now test it reading the file
         std::filebuf fbuf;
         fbuf.open("file.bin", std::ios_base::in | std::ios_base::binary); 

         //Read it to memory
         std::vector<char> vect(region.get_size(), 0);
         fbuf.sgetn(&vect[0], std::streamsize(vect.size()));

         //Check that memory was initialized to 1
         mem = static_cast<char*>(&vect[0]);
         for(std::size_t i = 0; i < size; ++i){
            if(*mem++ != 1){
               std::cout << "Error checking memory!" << std::endl;
               return 1;
            }
         }

         std::cout << "Test successful!" << std::endl;
      }
      catch(interprocess_exception &ex){
         std::cout << "Unexpected exception: " << ex.what() << std::endl;
         return 1;
      }
      return 0;
   }

[endsect]

[endsect]

[section:mapped_region More About Mapped Regions]

[section:mapped_region_one_class One Class To Rule Them All]

As we have seen, both `shared_memory_object` and `file_mapping` objects can be used
to create `mapped_region` objects. A mapped region created from a shared memory
object or a file mapping are the same class and this has many advantages.

One can, for example, mix in STL containers mapped regions from shared memory
and memory mapped files. The libraries that only depend on mapped regions can
be used to work with shared memory or memory mapped files without recompiling them.

[endsect]

[section:mapped_region_address_mapping Mapping Address In Several Processes]

In the example we have seen, the file or shared memory contents are mapped
to the address space of the process, but the address was chosen by the operating
system.

If several processes map the same file/shared memory, the mapping address will be
surely different in each process. Since each process might have used its address space
in a different way (allocation of more or less dynamic memory, for example), there is
no guarantee that the file/shared memory is going to be mapped in the same address.

If two processes map the same object in different addresses, this invalids the use
of pointers in that memory, since the pointer (which is an absolute address) would 
only make sense for the process that wrote it. The solution for this is to use offsets 
(distance) between objects instead of pointers: If two objects are placed in the same
shared memory segment by one process, [*the address of each object will be different]
in another process but [*the distance between them (in bytes) will be the same].

So the first advice when mapping shared memory and memory mapped files is to avoid
using raw pointers, unless you know what you are doing. Use offsets between data or
relative pointers to obtain pointer functionality when an object placed in a mapped
region wants to point to an object placed in the same mapped region. [*Boost.Interprocess]
offers a smart pointer called [classref boost::interprocess::offset_ptr] that
can be safely placed in shared memory and that can be used to point to another
object placed in the same shared memory / memory mapped file.

[endsect]

[section:mapped_region_fixed_address_mapping Fixed Address Mapping]

The use of relative pointers is less efficient than using raw pointers, so if a user
can succeed mapping the same file or shared memory object in the same address in two
processes, using raw pointers can be a good idea.

To map an object in a fixed address, the user can specify that address in the
`mapped region`'s constructor:

[c++]

   mapped_region region ( shm                         //Map shared memory
                        , mapped_region::read_write   //Map it as read-write
                        , 0                           //Map from offset 0
                        , 0                           //Map until the end
                        , (void*)0x3F000000           //Map it exactly there
                        );

However, the user can't map the region in any address, even if the address is not
being used. The offset parameter that marks the start of the mapping region 
is also limited. This limitations are explained in the next section.

[endsect]

[section:mapped_region_mapping_problems Mapping Offset And Address Limitations]

As mentioned, the user can't map the memory mappable object at any address and it can
specify the offset of the mappable object that is equivalent to the start of the mapping
region to an arbitrary value.
Most operating systems limit the mapping address and the offset of the mappable object
to a multiple of a value called [*page size]. This is due to the fact that the 
[*operating system performs mapping operations over whole pages].

If fixed mapping address is used, ['offset] and ['address] 
parameters should be multiples of that value. This value is, tipically, 4KB or 8KB.

[c++]

   //These might fail because the offset is not a multiple of the page size
   //and we are using fixed address mapping
   mapped_region region1( shm                         //Map shared memory
                        , mapped_region::read_write   //Map it as read-write
                        , 1                           //Map from offset 1
                        , 1                           //Map 1 byte
                        , (void*)0x3F000000           //Aligned mapping address
                        );

   //These might fail because the address is not a multiple of the page size
   mapped_region region2( shm                         //Map shared memory
                        , mapped_region::read_write   //Map it as read-write
                        , 0                           //Map from offset 0
                        , 1                           //Map 1 byte
                        , (void*)0x3F000001           //Not aligned mapping address
                        );

Since the operating system performs mapping operations over whole pages, specifying
a mapping ['size] or ['offset] that are not multiple of the page size will waste
more resources than necessary. If the user specifies the following 1 byte mapping:

[c++]

   //Map one byte of the shared memory object.
   //A whole memory page will be used for this.
   mapped_region region ( shm                         //Map shared memory
                        , mapped_region::read_write   //Map it as read-write
                        , 0                           //Map from offset 0
                        , 1                           //Map 1 byte
                        );

The operating system will reserve a whole page that will not be reused by any
other mapping so we are going to waste [*(page size - 1)] bytes. If we want
to use effiently operating system resources, we should create regions whose size
is a multiple of [*page size] bytes. If the user specifies the following two
mapped regions for a file with as size = 2*page_size bytes:

   //Map the first quarter of the file
   //This will use a whole page
   mapped_region region1( shm                         //Map shared memory
                        , mapped_region::read_write   //Map it as read-write
                        , 0                           //Map from offset 0
                        , page_size/2                 //Map page_size/2 bytes
                        );

   //Map the rest of the file
   //This will use a 2 pages
   mapped_region region2( shm                         //Map shared memory
                        , mapped_region::read_write   //Map it as read-write
                        , page_size/2                 //Map from offset 0
                        , 3*page_size/2               //Map page_size/2 bytes
                        );

In this example, a half of the page is wasted in the first mapping and another
half is wasted in the second because the offset is not a multiple of the
page size. The mapping with the minimum resource usage would be to map whole pages:

   //Map the whole first half: uses 1 page
   mapped_region region1( shm                         //Map shared memory
                        , mapped_region::read_write   //Map it as read-write
                        , 0                           //Map from offset 0
                        , page_size                   //Map page_size/2 bytes
                        );

   //Map the second half: uses 1 page
   mapped_region region2( shm                         //Map shared memory
                        , mapped_region::read_write   //Map it as read-write
                        , page_size                   //Map from offset 0
                        , page_size                   //Map page_size/2 bytes
                        );

How can we obtain the [*page size]? The `mapped_region` class has an static
function that returns that value:

[c++]

   //Obtain the page size of the system
   std::size_t page_size = mapped_region::get_page_size();

   //This mapping will optimally use system resources
   mapped_region region ( shm                         //Map shared memory
                        , mapped_region::read_write   //Map it as read-write
                        , 0                           //Map from offset 0
                        , page_size                   //Map whole page
                        );

An operating system might also limit the number of mapped memory regions per
process or per system.

[endsect]

[endsect]

[section:mapped_region_object_limitations Limitations When Constructing Objects In Mapped Regions]

When two processes create a mapped region of the same mappable object, two processes
can communicate writing and reading that memory. A process could construct a C++ object
in that memory so that the second process can use it. However, a mapped region shared
by multiple processes, can't hold any C++ object, because not every class is ready
to be a process-shared object, specially, if the mapped region is mapped in different 
address in each process.

[section:offset_pointer Offset pointers instead of raw pointers]

When placing objects in a mapped region and mapping
that region in different address in every process,
raw pointers are a problem since they are only valid for the
process that placed them there. To solve this, [*Boost.Interprocess] offers
an special smart pointer that can be used instead of a raw pointer.
So user classes containing raw pointers (or Boost smart pointers, that
internally own a raw pointer) can't be safely placed in a process shared
mapped region. These pointers must be replaced with offset pointers, and
these pointers must point only to objects placed in the same mapped region
if you want to use these shared objects from different processes.

Of course, a pointer placed in a mapped region shared between processes should
only point to an object of that mapped region. Otherwise, the pointer would
point to an address that it's only valid one process and other
processes may crash when accesing to that address.

[endsect]

[section:references_forbidden References forbidden]

References suffer from the same problem as pointers 
(mainly because they are implemented as pointers).
However, it is not possible to create a fully workable 
smart reference currently in C++ (for example,
`operator .()` can't be overloaded). Because of this,
if the user wants to put an object in shared memory, 
the object can't have any (smart or not) reference
as a member.

References will only work if the mapped region is mapped in the same
base address in all processes sharing a memory segment.
Like pointers, a reference placed in a mapped region should only point
to an object of that mapped region.

[endsect]

[section:virtuality_limitation Virtuality forbidden]

The virtual table pointer and the virtual table
are in the address space of the process
that constructs the object, so if we place a class
with a virtual function or virtual base class, the virtual
pointer placed in shared memory will be invalid for other processes
and they will crash.

This problem is very difficult to solve, since each process needs a
different virtual table pointer and the object that contains that pointer
is shared accross many processes. Even if we map the mapped region in
the same address in every process, the virtual table can be in a different
address in every process. To enable virtual functions for objects
shared between processes, deep compiler changes are needed and virtual
functions would suffer a performance hit. That's why
[*Boost.Interprocess] does not have any plan to support virtual function
and virtual inheritance in mapped regions shared between processes.

[endsect]

[section:statics_warning Be careful with static class members]

Static members of classes are global objects shared by 
all instances of the class. Because of this, static
members are implemented as global variables in processes.

When constructing a class with static members, each process
has its own copy of the static member, so updating a static
member in one process does not change the value of the static
member the another process. So be careful with these classes. Static
members are not dangerous if they are just constant variables initialized
when the process starts, but they don't change at all (for example,
when used like enums) and their value is the same for all processes.

[endsect]

[endsect]

[section:synchronization_mechanisms Synchronization mechanisms overview]

As mentioned before, the ability to shared memory between processes through memory
mapped files or shared memory objects is not very useful if the access to that 
memory can't be effectively synchronized. This is the same problem that happens with
thread-synchronization mechanisms, where heap memory and global variables are
shared between threads, but the access to these resources needs to be synchronized
tipically through mutex and condition variables. [*Boost.Threads] implements these
synchronization utilities between threads inside the same process. [*Boost.Interprocess]
implements similar mechanisms to synchronize threads from different processes.

[section:synchronization_mechanisms_named_vs_anonymous Named And Anonymous Synchronization Mechanisms]

[*Boost.Interprocess] presents two types of synchronization objects:

* [*Named utilities]: When two processes want
  to create an object of such type, both processes must ['create] or ['open] an object
  using the same name. This is similar to creating or opening files: a process creates
  a file with using a `fstream` with the name ['filename] and another process opens
  that file using another `fstream` with the same ['filename] argument. 
  [*Each process uses a different object to access to the resource, but both processes
  are using the the same underlying resource].

* [*Anonymous utilities]: Since these utilities have no name, two processes must
  share [*the same object] through shared memory or memory mapped files. This is
  similar to traditional thread synchronization objects: [*Both processes share the
  same object]. Unlike thread synchronization, where global variables and heap
  memory is shared between threads of the same process, sharing objects between
  two threads from different process can be only possible through mapped regions
  that map the same mappable resource (for example, shared memory or memory mapped files).

Each type has it's own advantages and disadvantages:

* Named utilities are easier to handle for simple synchronization tasks, since both process
  don't have to create a shared memory region and construct the synchronization mechanism there.
  
* Anonymous utilities can be serialized to disk when using memory mapped objects obtaining
  automatic persistence of synchronization utilities. One could construct a synchronization
  utility in a memory mapped file, reboot the system, map the file again, and use the
  synchronization utility again without any problem. This can't be achieved with named
  synchronization utilities.

The main interface difference between named and anonymous utilities are the constructors.
Usually anonymous utilities have only one contructor, whereas the named utilities have
several constructors whose first argument is an special type that requests creation, 
opening or opening or creation of the underlying resource:

[c++]

  using namespace boost::interprocess;

  //Create the synchronization utility. If it previously
  //exists, throws an error
  NamedUtility(create_only, ...)

  //Open the synchronization utility. If it does not previously
  //exist, throws an error.
  NamedUtility(open_or_create, ...)

  //Open the synchronization utility. If it does not previously
  //exist, create it.
  NamedUtility(open_only, ...)

On the other hand the anonymous synchronization utility can only
be created and the processes must synchronize using other mechanisms
who creates the utility:

[c++]

  using namespace boost::interprocess;

  //Create the synchronization utility.
  AnonymousUtility(...)

[endsect]

[section:synchronization_mechanisms_types Types Of Synchronization Mechanisms]

Apart from its named/anonymous nature, [*Boost.Interprocess] presents the following
synchronization utilities:

* Mutexes (named and anonymous)
* Condition variables (named and anonymous)
* Semaphores (named and anonymous)
* Upgradable mutexes
* File locks

[endsect]

[endsect]

[section:mutexes Mutexes]

[section:mutexes_whats_a_mutex What's A Mutex?]

['Mutex] stands for [*mut]ual [*ex]clusion and it's the most basic form of
synchronization between processes.
Mutexes guarantee that only one thread can lock a given mutex. If a code section
is surrounded by a mutex locking and unlocking, it's guaranteed that only a thread 
at a time executes that section of code.
When that thread [*unlocks] the mutex, other threads can enter to that code
region:

[c++]

   //The mutex has been previously constructed

   lock_the_mutex();

   //This code will be executed only by one thread
   //at a time.

   unlock_the_mutex();

A mutex can also be [*recursive] or [*non-recursive]:

* Recursive mutexes can be locked several types by the same thread. To fully unlock the
  mutex, the thread has two unlock the mutex the same times it has locked it.

* Non-recursive mutexes can't be locked several types by the same thread. If a mutex
  is locked twice by a thread, the result is undefined, it might throw an error or 
  the thread could be blocked forever.

[endsect]

[section:mutexes_mutex_operations Mutex Operations]

All the mutex types from [*Boost.Interprocess] implement the following operations:

[blurb ['[*void lock()]]]

[*Effects:]
 The calling thread tries to obtain ownership of the mutex, and if another thread has ownership of the mutex, it waits until it can obtain the ownership. If a thread takes ownership of the mutex the mutex must be unlocked by the same mutex. If the mutex supports recursive locking, the mutex must be unlocked the same number of times it is locked.

[*Throws:] *interprocess_exception* on error.

[blurb ['[*bool try_lock()]]]

[*Effects:] The calling thread tries to obtain ownership of the mutex, and if another thread has ownership of the mutex returns immediately. If the mutex supports recursive locking, the mutex must be unlocked the same number of times it is locked.

[*Returns:] If the thread acquires ownership of the mutex, returns true, if the another thread has ownership of the mutex, returns false.

[*Throws:] *interprocess_exception* on error.

[blurb ['[*bool timed_lock(const boost::posix_time::ptime &abs_time)]]]

[*Effects:] The calling thread will try to obtain exclusive ownership of the mutex if it can do so in until the specified time is reached. If the mutex supports recursive locking, the mutex must be unlocked the same number of times it is locked.

[*Returns:] If the thread acquires ownership of the mutex, returns true, if the timeout expires returns false.

[*Throws:] *interprocess_exception* on error.

[blurb ['[*void unlock()]]]

[*Precondition:] The thread must have exclusive ownership of the mutex.

[*Effects:] The calling thread releases the exclusive ownership of the mutex. If the mutex supports recursive locking, the mutex must be unlocked the same number of times it is locked.

[*Throws:] An exception derived from *interprocess_exception* on error.

[endsect]

[section:mutexes_interprocess_mutexes Boost.Interprocess Mutex Types And Headers]

Boost.Interprocess offers the following mutex types:

[c++]

   #include <boost/interprocess/sync/interprocess_mutex.hpp>

* [classref boost::interprocess::interprocess_mutex]: A non-recursive,
  anonymous mutex that can be placed in shared memory or memory mapped files.

[c++]

   #include <boost/interprocess/sync/interprocess_recursive_mutex.hpp>

* [classref boost::interprocess::interprocess_mutex]: A recursive,
  anonymous mutex that can be placed in shared memory or memory mapped files.

[c++]

   #include <boost/interprocess/sync/named_mutex.hpp>

* [classref boost::interprocess::interprocess_mutex named_mutex]: A non-recursive,
  named mutex.

[c++]

   #include <boost/interprocess/sync/named_recursive_mutex.hpp>

* [classref boost::interprocess::interprocess_mutex named_recursive_mutex]: A recursive,
  named mutex.

[endsect]

[section:mutexes_scoped_lock Scoped lock]

It's very important to unlock a mutex after the process has read or written the data.
This can be difficult when dealing with exceptions, so usually mutexes are used
with a scoped lock, a class that can guarantee that a mutex will always be unlocked
even when an exception occurs. To use an scoped lock just include:

[c++]

   #include <boost/interprocess/sync/scoped_lock.hpp>

Basically, a scoped lock calls [*unlock()] in its destructor, and a mutex is always
unlocked when an exception occurs. Scoped lock has many constructors to lock,
try_lock, timed_lock a mutex or not to lock it at all. 


[c++]

   using namespace boost::interprocess;

   //Let's create any mutex type:
   MutexType mutex;

   {
      //This will lock the mutex
      scoped_lock<MutexType> lock(mutex);
      
      //Some code

      //The mutex will be unlocked here
   }

   {
      //This will try_lock the mutex
      scoped_lock<MutexType> lock(mutex, try_to_lock);
      
      //Check if the mutex has been successfully locked
      if(lock){
         //Some code
      }
   
      //If the mutex was locked it will be unlocked
   }
   
   {
      boost::posix_time::ptime abs_time = ...

      //This will timed_lock the mutex
      scoped_lock<MutexType> lock(mutex, abs_time);
      
      //Check if the mutex has been successfully locked
      if(lock){
         //Some code
      }
   
      //If the mutex was locked it will be unlocked
   }

For more information, check the 
[classref boost::interprocess::scoped_lock scoped_lock's reference].

[endsect]

[section:mutexes_anonymous_example Anonymous mutex example]

Imagine that two processes need to write traces to a cyclic buffer built
in shared memory. Each process needs to obtain exclusive access to the
cyclic buffer, write the trace and continue.

To protect the cyclic buffer, we can store a process shared mutex in the
cyclic buffer. Each process will lock the mutex before writing the data and
will write a flag when ends writing the traces:

[c++]

   #include <boost/interprocess/sync/interprocess_mutex.hpp>
   #include <iostream>

   struct shared_memory_log
   {
      enum { NumItems = 100 };
      enum { LineSize = 100 };

      shared_memory_log()
         :  current_line(0)
         ,  end_a(false)
         ,  end_b(false)
      {}

      //Mutex to protect access to the queue
      boost::interprocess::interprocess_mutex mutex;

      //Items to fill
      char   items[NumItems][LineSize];
      int    current_line;
      bool   end_a;
      bool   end_b;
   };

This is the process main process. Creates the shared memory, constructs 
the the cyclic buffer and start writing traces:

[c++]

   #include <boost/interprocess/shared_memory.hpp>
   #include <boost/interprocess/sync/scoped_lock.hpp>
   #include "doc_anonymous_mutex_shared_data.hpp"
   #include <iostream>
   #include <cstdlib>

   using namespace boost::interprocess;
   
   int main ()
   {
      try{
         //Erase previous shared memory
         shared_memory_object::remove("shared_memory");

         //Create a shared memory object.
         shared_memory_object shm
            (create_only               //only create
            ,"shared_memory"           //name
            ,memory_mappable::read_write   //read-write mode
            );

         //Set size
         shm.truncate(sizeof(shared_memory_log));

         //Map the whole shared memory in this process
         mapped_region region
            (shm                       //What to map
            ,mapped_region::read_write   //Map it as read-write
            );

         //Get the address of the mapped region
         void * addr       = region.get_address();

         //Construct the shared structure in memory
         shared_memory_log * data = new (addr) shared_memory_log;

         //Write some logs
         for(int i = 0; i < shared_memory_log::NumItems; ++i){
            //Lock the mutex
            scoped_lock<interprocess_mutex> lock(data->mutex);
            sprintf(data->items[(data->current_line++) % shared_memory_log::NumItems]
                   ,"%s_%d", "process_a", i);
            if(i == (shared_memory_log::NumItems-1))
               data->end_a = true;
            //Mutex is released here
         }
   
         //Wait until the other process ends
         while(1){
            scoped_lock<interprocess_mutex> lock(data->mutex);
            if(data->end_b)
               break;
         }
      }
      catch(interprocess_exception &ex){
         std::cout << ex.what() << std::endl;
         return 1;
      }

      //Erase shared memory
      shared_memory_object::remove("shared_memory");

      return 0;
   }

The second process opens the shared memory, obtains access to the cyclic buffer
and starts writing traces:

[c++]

   #include <boost/interprocess/shared_memory.hpp>
   #include <boost/interprocess/sync/scoped_lock.hpp>
   #include "doc_anonymous_mutex_shared_data.hpp"
   #include <iostream>

   using namespace boost::interprocess;
   
   int main ()
   {
      try{
         //Open the shared memory object.
         shared_memory_object shm
            (open_only                    //only create
            ,"shared_memory"              //name
            ,memory_mappable::read_write  //read-write mode
            );

         //Map the whole shared memory in this process
         mapped_region region
            (shm                       //What to map
            ,mapped_region::read_write //Map it as read-write
            );

         //Get the address of the mapped region
         void * addr       = region.get_address();

         //Construct the shared structure in memory
         shared_memory_log * data = static_cast<shared_memory_log*>(addr);

         //Write some logs
         for(int i = 0; i < 100; ++i){
            //Lock the mutex
            scoped_lock<interprocess_mutex> lock(data->mutex);
            sprintf(data->items[(data->current_line++) % shared_memory_log::NumItems]
                   ,"%s_%d", "process_a", i);
            if(i == (shared_memory_log::NumItems-1))
               data->end_b = true;
            //Mutex is released here
         }

         //Wait until the other process ends
         while(1){
            scoped_lock<interprocess_mutex> lock(data->mutex);
            if(data->end_a)
               break;
         }
      }
      catch(interprocess_exception &ex){
         std::cout << ex.what() << std::endl;
         return 1;
      }

      return 0;
   }

As we can see, a mutex is useful to protect data but not to notify to another process
an event. For this, we need a condition variable, as we will see in the next section.

[endsect]

[section:mutexes_named_example Named mutex example]

Now imagine that two processes want to write a trace to a file. First they write
their name, and after that they write the message. Since the operating system can
interrupt a process in any moment we can mix parts of the messages of both processes,
so we need a way to write the whole message to the file atomically. To achieve this, 
we can use a named mutex so that each process locks the mutex before writing:

[c++]

   #include <boost/interprocess/sync/scoped_lock.hpp>
   #include <boost/interprocess/sync/named_mutex.hpp>
   #include <fstream>

   int main ()
   {
      using namespace boost::interprocess;
      try{
         
         //Open or create the named mutex
         named_mutex mutex(open_or_create, "cout_named_mutex");

         std::ofstream file("file_name");

         for(int i = 0; i < 10; ++i){
            
            //Do some operations...

            //Write to console atomically
            scoped_lock<named_mutex> lock(mutex);
            file << "Process name, ";
            file << "This is iteration #" << i;
            file << std::endl;
         }
      }
      catch(interprocess_exception &ex){
         std::cout << ex.what() << std::endl;
         return 1;
      }

      return 0;
   }


[endsect]

[endsect]

[section:conditions Conditions]

[section:conditions_whats_a_condition What's A Condition Variable?]

In the previous example, a mutex is used to ['lock] but we can't use it to
['wait] efficiently until the condition to continue is met. A condition variable
can do two things:

*  [*wait]: The thread is blocked until some other thread notifies that it can
   continue because the condition that lead to waiting has dissapeared.

*  [*notify]: The thread sends a signal to one blocked thread or to all blocked
   threads to tell them that they the condition that provoked their wait has
   dissapeared.

Waiting in a condition variable is always associated with a mutex. 
The mutex must be locked prior to waiting on the condition. When waiting
on the condition variable, the thread unlocks the mutex and waits [*atomically].

When the thread returns from a wait function (because of a signal or a timeout,
for example) the mutex object is again locked.

[endsect]

[section:conditions_interprocess_conditions Boost.Interprocess Condition Types And Headers]

Boost.Interprocess offers the following condition types:

[c++]

   #include <boost/interprocess/sync/interprocess_condition.hpp>

* [classref boost::interprocess::interprocess_condition]:
  An anonymous condition variable that can be placed in shared memory or memory
  mapped files to be used with [classref boost::interprocess::interprocess_mutex].

[c++]

   #include <boost/interprocess/sync/named_condition.hpp>

* [classref boost::interprocess::named_condition]: A named
  condition variable to be used with [classref boost::interprocess::named_mutex].

Named conditions are similar to anonymous conditions, but they are used in
combination with named mutexes. Several times, we don't want to store
synchronization objects with the synchronized data:

*  We want to change the synchronization method (from interprocess 
   to intra-process, or without any synchronization) using the same data.
   Storing the process-shared anonymous synchronization with the synchronized
   data would forbid this.

*  We want to send the synchronized data through the network or any other
   communication method. Sending the process-shared synchronization objects
   wouldn't have any sense.

[endsect]

[section:conditions_anonymous_example Anonymous condition example]

Imagine that a process that writes a trace to a simple shared memory buffer that
another process prints one by one. The first process writes the trace and waits
until the other process prints the data. To achieve this, we can use two
condition variables: the first one is used to block the sender until the second
process prints the message and the second one to block the receiver until the
buffer has a trace to print.

The shared memory trace buffer:

[c++]

   #include <boost/interprocess/sync/interprocess_mutex.hpp>
   #include <boost/interprocess/sync/interprocess_condition.hpp>

   struct trace_queue
   {
      enum { LineSize = 100 };

      trace_queue()
         :  message_in(false)
      {}

      //Mutex to protect access to the queue
      boost::interprocess::interprocess_mutex      mutex;

      //Condition to wait when the queue is empty
      boost::interprocess::interprocess_condition  cond_empty;

      //Condition to wait when the queue is full
      boost::interprocess::interprocess_condition  cond_full;

      //Items to fill
      char   items[LineSize];

      //Is there any message
      bool message_in;
   };

This is the process main process. Creates the shared memory, places there
the buffer and starts writing messages one by one until it writes "last message"
to indicate that there are no more messages to print:

[c++]

   #include <boost/interprocess/shared_memory.hpp>
   #include <boost/interprocess/sync/scoped_lock.hpp>
   #include <iostream>
   #include "doc_anonymous_condition_shared_data.hpp"

   using namespace boost::interprocess;
   
   int main ()
   {
      try{
         //Erase previous shared memory
         shared_memory_object::remove("shared_memory");

         //Create a shared memory object.
         shared_memory_object shm
            (create_only               //only create
            ,"shared_memory"           //name
            ,memory_mappable::read_write   //read-write mode
            );

         //Set size
         shm.truncate(sizeof(trace_queue));

         //Map the whole shared memory in this process
         mapped_region region
            (shm                       //What to map
            ,mapped_region::read_write //Map it as read-write
            );

         //Get the address of the mapped region
         void * addr       = region.get_address();

         //Construct the shared structure in memory
         trace_queue * data = new (addr) trace_queue;

         const int NumMsg = 100;

         for(int i = 0; i < NumMsg; ++i){
            scoped_lock<interprocess_mutex> lock(data->mutex);
            if(data->message_in){
               data->cond_full.wait(lock);
            }
            if(i == (NumMsg-1))
               sprintf(data->items, "%s", "last message");
            else
               sprintf(data->items, "%s_%d", "my_trace", i);

            //Notify to the other process that there is a message
            data->cond_empty.notify_one();

            //Mark message buffer as full
            data->message_in = true;
         }
      }
      catch(interprocess_exception &ex){
         std::cout << ex.what() << std::endl;
         return 1;
      }

      //Erase shared memory
      shared_memory_object::remove("shared_memory");

      return 0;
   }


The second process opens the shared memory and prints each message
until the "last message" message is received:

[c++]

   #include <boost/interprocess/shared_memory.hpp>
   #include <boost/interprocess/sync/scoped_lock.hpp>
   #include <iostream>
   #include "doc_anonymous_condition_shared_data.hpp"

   using namespace boost::interprocess;
   
   int main ()
   {
      try{
         //Erase previous shared memory
         shared_memory_object::remove("shared_memory");

         //Create a shared memory object.
         shared_memory_object shm
            (open_only                    //only create
            ,"shared_memory"              //name
            ,memory_mappable::read_write  //read-write mode
            );

         //Map the whole shared memory in this process
         mapped_region region
            (shm                       //What to map
            ,mapped_region::read_write //Map it as read-write
            );

         //Get the address of the mapped region
         void * addr       = region.get_address();

         //Obtain a pointer to the shared structure
         trace_queue * data = static_cast<trace_queue*>(addr);

         //Print messages until the other process marks the end
         bool end_loop = false;
         do{
            scoped_lock<interprocess_mutex> lock(data->mutex);
            if(!data->message_in){
               data->cond_empty.wait(lock);
            }
            if(strcmp(data->items, "last message") == 0){
               end_loop = true;
            }
            else{
               //Print the message
               std::cout << data->items << std::endl;
               //Notify the other process that the buffer is empty
               data->message_in = false;
               data->cond_full.notify_one();
            }
         }
         while(!end_loop);
      }
      catch(interprocess_exception &ex){
         std::cout << ex.what() << std::endl;
         return 1;
      }

      //Erase shared memory
      shared_memory_object::remove("shared_memory");

      return 0;
   }

With condition variables, a process can block if it can't continue the work,
and when the conditions to continue are met another process can wake it.

[endsect]

[endsect]

[section:semaphores Semaphores]

[section:semaphores_whats_a_semaphores What's A Semaphore?]

A semaphore is a synchronization mechanism between processes based in an internal
count that offers two basic operations:

*  [*Wait]: Tests the value of the semaphore count, and waits if the value is less than or
   equal than 0. Otherwise, decrements the semaphore count.

*  [*Post]: Increments the semaphore count. If any process is blocked, one of those processes
   is awoken.

If the initial semaphore count is initialized to 1, a [*Wait] operation is equivalent to a 
mutex locking and [*Post] is equivalent to a mutex unlocking. This type of semaphore is known
as a [*binary semaphore]. 

Although semaphores can be used like mutexes, they have a unique feature: unlike mutexes, 
a [*Post] operation need not be executed by the same thread/process that executed the
[*Wait] operation.

[endsect]

[section:semaphores_interprocess_semaphores Boost.Interprocess Semaphore Types And Headers]

Boost.Interprocess offers the following semaphore types:

[c++]

   #include <boost/interprocess/sync/interprocess_semaphore.hpp>

* [classref boost::interprocess::interprocess_semaphore]:
  An anonymous semaphore that can be placed in shared memory or memory
  mapped files.

[c++]

   #include <boost/interprocess/sync/named_semaphore.hpp>

* [classref boost::interprocess::named_condition]: A named
  semaphore.

Named conditions are similar to anonymous conditions, but they are used in
combination with named mutexes. Several times, we don't want to store
synchronization objects with the synchronized data:

[endsect]

[section:semaphores_anonymous_example Anonymous semaphore example]

We will implement a integer array in shared memory that will be used to trasfer data
from one process to another process. The first process will write some integers
to the array and the process will block if the array is full.

The second process will copy the transmitted data to its own buffer, blocking if
there is no new data in the buffer.

This is the shared integer array:

[c++]

   #include <boost/interprocess/sync/interprocess_semaphore.hpp>

   struct shared_memory_buffer
   {
      enum { NumItems = 10 };

      shared_memory_buffer()
         : mutex(1), nempty(NumItems), nstored(0)
      {}

      //Semaphores to protect and synchronize access
      boost::interprocess::interprocess_semaphore
         mutex, nempty, nstored;

      //Items to fill
      int items[NumItems];
   };

This is the process main process. Creates the shared memory, places there
the interger array and starts integers one by one, blocking if the array 
is full:

[c++]

   #include <boost/interprocess/shared_memory.hpp>
   #include <iostream>
   #include "doc_anonymous_semaphore_shared_data.hpp"

   using namespace boost::interprocess;
   
   int main ()
   {
      try{
         //Erase previous shared memory
         shared_memory_object::remove("shared_memory");

         //Create a shared memory object.
         shared_memory_object shm
            (create_only                  //only create
            ,"shared_memory"              //name
            ,memory_mappable::read_write  //read-write mode
            );

         //Set size
         shm.truncate(sizeof(shared_memory_buffer));

         //Map the whole shared memory in this process
         mapped_region region
            (shm                       //What to map
            ,mapped_region::read_write //Map it as read-write
            );

         //Get the address of the mapped region
         void * addr       = region.get_address();

         //Construct the shared structure in memory
         shared_memory_buffer * data = new (addr) shared_memory_buffer;

         const int NumMsg = 100;

         //Insert data in the array
         for(int i = 0; i < NumMsg; ++i){
            data->nempty.wait();
            data->mutex.wait();
            data->items[i % shared_memory_buffer::NumItems] = i;
            data->mutex.post();
            data->nstored.post();
         }
      }
      catch(interprocess_exception &ex){
         std::cout << ex.what() << std::endl;
         return 1;
      }

      //Erase shared memory
      shared_memory_object::remove("shared_memory");

      return 0;
   }

The second process opens the shared memory and copies the received integers
to it's own buffer:

[c++]

   #include <boost/interprocess/shared_memory.hpp>
   #include <iostream>
   #include "doc_anonymous_semaphore_shared_data.hpp"

   using namespace boost::interprocess;
   
   int main ()
   {
      try{
         //Create a shared memory object.
         shared_memory_object shm
            (open_only                    //only create
            ,"shared_memory"              //name
            ,memory_mappable::read_write  //read-write mode
            );

         //Map the whole shared memory in this process
         mapped_region region
            (shm                       //What to map
            ,mapped_region::read_write //Map it as read-write
            );

         //Get the address of the mapped region
         void * addr       = region.get_address();

         //Obtain the shared structure
         shared_memory_buffer * data = static_cast<shared_memory_buffer*>(addr);

         const int NumMsg = 100;

         int extracted_data [NumMsg];

         //Extract the data
         for(int i = 0; i < NumMsg; ++i){
            data->nstored.wait();
            data->mutex.wait();
            extracted_data[i] = data->items[i % shared_memory_buffer::NumItems];
            data->mutex.post();
            data->nempty.post();
         }
      }
      catch(interprocess_exception &ex){
         std::cout << ex.what() << std::endl;
         return 1;
      }

      //Erase shared memory
      shared_memory_object::remove("shared_memory");

      return 0;
   }

The same interprocess communication can be achieved with a condition variables 
and mutexes, but for several synchronization patterns, a semaphore is more
efficient than a mutex/condition combination.

[endsect]

[endsect]

[section:upgradable_mutexes Upgradable Mutexes]

[section:upgradable_whats_a_mutex What's An Upgradable Mutex?]

An upgradable mutex is an special mutex that offers more locking possibilities than
a normal mutex. Sometimes, we can distinguish between [*reading] the data and
[*modifying] the data. If just some threads need to modify the data, and a plain mutex
is used to protect the data from concurrent access, concurrency is pretty limited:
two threads that only read the data will be serialized instead of being executed
concurrently.

If we allow concurrent access to threads that just read the data but we avoid
concurrent access between threads that read and modify or between threads that modify,
we can increase performance. This is specially true in applications where data reading
is more common than data modification and the synchronized data reading code needs
some time to execute. With an upgradable mutex we can acquire 3 
lock types:

*  [*Exclusive lock]: Similar to a plain mutex. If a thread acquires an exclusive
   lock, no other thread can acquire any lock (exclusive or other) until the exclusive
   lock is released. If any thread has a sharable or upgradable lock a thread trying
   to acquire an exclusive lock will block.
   This lock will be acquired by threads that will modify the data.

*  [*Sharable lock]: If a thread acquires a sharable lock, other threads
   can acquire a sharable lock or an upgradable lock. If any thread has acquired
   the exclusive lock a thread trying to acquire a sharable lock will block.
   This locking is executed by threads that just need to read the data.

*  [*Upgradable lock]: Acquiring an upgradable lock is similar to acquiring
   a [*privileged sharable lock]. If a thread acquires an upgradable lock, other threads
   can acquire a sharable lock. If any thread has acquired the exclusive or upgradable lock 
   a thread trying to acquire an upgradable lock will block.
   A thread that has acquired an upgradable lock,
   is guaranteed to be able to acquire atomically an exclusive lock when other threads
   that have acquired a sharable lock release it. This is used for
   a thread that [*maybe] needs to modify the data, but usually just needs to read the data.
   This thread acquires the upgradable lock and other threads can acquire the sharable lock.
   If the upgradable thread reads the data and it has to modify it, the thread can be promoted
   to acquire the exclusive lock: when all sharable threads have released the sharable lock, the
   upgradable lock is atomically promoted to an exclusive lock. The newly promoted thread 
   can modify the data and it can be sure that no other thread has modified it while
   doing the transition. [*Only 1 thread can acquire the upgradable
   (privileged reader) lock].

To sum up:

[table Locking Possibilities
   [[If a thread has acquired the...] [Other threads can acquire...]]
   [[Sharable lock]    [many sharable locks and 1 upgradable lock]]
   [[Upgradable lock]  [many sharable locks]]
   [[Exclusive lock]   [no locks]]
]

A thread that has acquired a lock can try to acquire another lock type atomically.
All lock transitions are not guaranteed to succeed. Even if a transition is guaranteed
to succeed, some transitions will block the thread waiting until other threads release
the sharable locks. [*Atomically] means that no other thread will acquire an Upgradable 
or Exclusive lock in the transition, [*so data is guaranteed to remain unchanged]:

[table Transition Possibilities
   [[If a thread has acquired the...] [It can atomically release the previous lock and...]]
   [[Sharable lock]    [try to obtain (not guaranteed) immediately the Exclusive lock if no other thread has exclusive or upgrable lock]]
   [[Sharable lock]    [try to obtain (not guaranteed) immediately the Upgradable lock if no other thread has exclusive or upgrable lock]]
   [[Upgradable lock]  [obtain the Exclusive lock when all sharable locks are released]]
   [[Upgradable lock]  [obtain the Sharable lock immediately]]
   [[Exclusive lock]   [obtain the Upgradable lock immediately]]
   [[Exclusive lock]   [obtain the Sharable lock immediately]]
]

As we can see, an upgradable mutex is a powerful synchronization utility that can improve
the concurrency. However, if most of the time we have to modify the data, or the
synchronized code section is very short, it's more efficient to use a plain mutex, since
it has less overhead. Upgradable lock shines when the synchronized code section is bigger
and there are more readers than modifiers.

[endsect]

[section:upgradable_mutexes_operations Upgradable Mutex Operations]

All the upgradable mutex types from [*Boost.Interprocess] implement
the following operations:

[section:upgradable_mutexes_operations_exclusive Exclusive Locking]

[blurb ['[*void lock()]]]

[*Effects:]
The calling thread tries to obtain exclusive ownership of the mutex, and if 
another thread has exclusive, sharable or upgradable ownership of the mutex, 
it waits until it can obtain the ownership.

[*Throws:] *interprocess_exception* on error.

[blurb ['[*bool try_lock()]]]

[*Effects:] 
The calling thread tries to acquire exclusive ownership of the mutex without
waiting. If no other thread has exclusive, sharable or upgradable ownership of 
the mutex this succeeds.

[*Returns:] If it can acquire exclusive ownership immediately returns true. 
If it has to wait, returns false.

[*Throws:] *interprocess_exception* on error.

[blurb ['[*bool timed_lock(const boost::posix_time::ptime &abs_time)]]]

[*Effects:] 
The calling thread tries to acquire exclusive ownership of the mutex
waiting if necessary until no other thread has has exclusive,
sharable or upgradable ownership of the mutex or abs_time is reached.

[*Returns:] If acquires exclusive ownership, returns true. Otherwise 
returns false.

[*Throws:] *interprocess_exception* on error.

[blurb ['[*void unlock()]]]

[*Precondition:] The thread must have exclusive ownership of the mutex.

[*Effects:] The calling thread releases the exclusive ownership of the mutex.

[*Throws:] An exception derived from *interprocess_exception* on error.

[endsect]

[section:upgradable_mutexes_operations_sharable Sharable Locking]

[blurb ['[*void lock_sharable()]]]

[*Effects:]
The calling thread tries to obtain sharable ownership of the mutex, and if 
another thread has exclusive or upgradable ownership of the mutex, 
waits until it can obtain the ownership.

[*Throws:] *interprocess_exception* on error.

[blurb ['[*bool try_lock_sharable()]]]

[*Effects:] 
The calling thread tries to acquire sharable ownership of the mutex without
waiting. If no other thread has has exclusive or upgradable ownership of 
the mutex this succeeds.

[*Returns:] If it can acquire sharable ownership immediately returns true. 
If it has to wait, returns false.

[*Throws:] *interprocess_exception* on error.

[blurb ['[*bool timed_lock_sharable(const boost::posix_time::ptime &abs_time)]]]

[*Effects:] 
The calling thread tries to acquire sharable ownership of the mutex
waiting if necessary until no other thread has has exclusive
or upgradable ownership of the mutex or abs_time is reached.

[*Returns:] If acquires sharable ownership, returns true. Otherwise 
returns false.

[*Throws:] *interprocess_exception* on error.

[blurb ['[*void unlock_sharable()]]]

[*Precondition:] The thread must have sharable ownership of the mutex.

[*Effects:] The calling thread releases the sharable ownership of the mutex.

[*Throws:] An exception derived from *interprocess_exception* on error.

[endsect]

[section:upgradable_mutexes_operations_upgradable Upgradable Locking]

[blurb ['[*void lock_upgradable()]]]

[*Effects:]
The calling thread tries to obtain upgradable ownership of the mutex, and if 
another thread has exclusive or upgradable ownership of the mutex, 
waits until it can obtain the ownership.

[*Throws:] *interprocess_exception* on error.

[blurb ['[*bool try_lock_upgradable()]]]

[*Effects:] 
The calling thread tries to acquire upgradable ownership of the mutex without
waiting. If no other thread has has exclusive or upgradable ownership of 
the mutex this succeeds.

[*Returns:] If it can acquire upgradable ownership immediately returns true. 
If it has to wait, returns false.

[*Throws:] *interprocess_exception* on error.

[blurb ['[*bool timed_lock_upgradable(const boost::posix_time::ptime &abs_time)]]]

[*Effects:] 
The calling thread tries to acquire upgradable ownership of the mutex
waiting if necessary until no other thread has has exclusive
or upgradable ownership of the mutex or abs_time is reached.

[*Returns:] If acquires upgradable ownership, returns true. Otherwise 
returns false.

[*Throws:] *interprocess_exception* on error.

[blurb ['[*void unlock_upgradable()]]]

[*Precondition:] The thread must have upgradable ownership of the mutex.

[*Effects:] The calling thread releases the upgradable ownership of the mutex.

[*Throws:] An exception derived from *interprocess_exception* on error.

[endsect]

[section:upgradable_mutexes_operations_demotions Demotions]

[blurb ['[*void unlock_and_lock_upgradable()]]]

[*Precondition:] The thread must have exclusive ownership of the mutex.

[*Effects:] The thread atomically releases exclusive ownership and acquires upgradable
ownership. This operation is non-blocking.

[*Throws:] An exception derived from *interprocess_exception* on error.

[blurb ['[*void unlock_and_lock_sharable()]]]

[*Precondition:] The thread must have exclusive ownership of the mutex.

[*Effects:] The thread atomically releases exclusive ownership and acquires sharable
ownership. This operation is non-blocking.

[*Throws:] An exception derived from *interprocess_exception* on error.

[blurb ['[*void unlock_upgradable_and_lock_sharable()]]]

[*Precondition:] The thread must have upgradable ownership of the mutex.

[*Effects:] The thread atomically releases upgradable ownership and acquires sharable
ownership. This operation is non-blocking.

[*Throws:] An exception derived from *interprocess_exception* on error.

[endsect]

[section:upgradable_mutexes_operations_promotions Promotions]

[blurb ['[*void unlock_upgradable_and_lock()]]]

[*Precondition:] The thread must have upgradable ownership of the mutex.

[*Effects:] The thread atomically releases upgradable ownership and acquires exclusive
ownership. This operation will block until all threads with sharable ownership releas it.

[*Throws:] An exception derived from *interprocess_exception* on error.

[blurb ['[*bool try_unlock_upgradable_and_lock()]]]

[*Precondition:] The thread must have upgradable ownership of the mutex.

[*Effects:] The thread atomically releases upgradable ownership and tries to acquire exclusive
ownership. This operation will fail if there are threads with sharable ownership, but
it will maintain upgradable ownership.

[*Returns:] If acquires exclusive ownership, returns true. Otherwise 
returns false.

[*Throws:] An exception derived from *interprocess_exception* on error.

[blurb ['[*bool timed_unlock_upgradable_and_lock(const boost::posix_time::ptime &abs_time)]]]

[*Precondition:] The thread must have upgradable ownership of the mutex.

[*Effects:] The thread atomically releases upgradable ownership and tries to acquire
exclusive ownership, waiting if necessary until abs_time. This operation will fail 
if there are threads with sharable ownership or timeout reaches, but it will maintain 
upgradable ownership.

[*Returns:] If acquires exclusive ownership, returns true. Otherwise 
returns false.

[*Throws:] An exception derived from *interprocess_exception* on error.

[blurb ['[*bool try_unlock_sharable_and_lock()]]]

[*Precondition:] The thread must have sharable ownership of the mutex.

[*Effects:] The thread atomically releases sharable ownership and tries to acquire exclusive
ownership. This operation will fail if there are threads with sharable or upgradable ownership,
but it will maintain sharable ownership.

[*Returns:] If acquires exclusive ownership, returns true. Otherwise 
returns false.

[*Throws:] An exception derived from *interprocess_exception* on error.

[blurb ['[*bool try_unlock_sharable_and_lock_upgradable()]]]

[*Precondition:] The thread must have sharable ownership of the mutex.

[*Effects:] The thread atomically releases sharable ownership and tries to acquire upgradable
ownership. This operation will fail if there are threads with sharable or upgradable ownership,
but it will maintain sharable ownership.

[*Returns:] If acquires upgradable ownership, returns true. Otherwise 
returns false.

[*Throws:] An exception derived from *interprocess_exception* on error.

[endsect]

[endsect]

[section:upgradable_mutexes_mutex_interprocess_mutexes Boost.Interprocess Upgradable Mutex Types And Headers]

Boost.Interprocess offers the following upgradable mutex types:

[c++]

   #include <boost/interprocess/sync/interprocess_upgradable_mutex.hpp>

* [classref boost::interprocess::interprocess_upgradable_mutex]: A non-recursive,
  anonymous upgradable mutex that can be placed in shared memory or memory mapped files.

[c++]

   #include <boost/interprocess/sync/named_upgradable_mutex.hpp>

* [classref boost::interprocess::named_upgradable_mutex named_upgradable_mutex]: A non-recursive,
  named upgradable mutex.

[endsect]

[section:upgradable_mutexes_locks Sharable Lock And Upgradable Lock]

As with plain mutexes, it's important to release the acquired lock even in the presence
of exceptions. [*Boost.Interprocess] mutexes are best used with the 
[classref boost::interprocess::scoped_lock] utility,
and this class only offers exclusive locking.

As we have sharable locking and upgradable locking with upgradable mutexes, we have two new
utilities: [classref boost::interprocess::sharable_lock] and 
[classref boost::interprocess::upgradable_lock]. Both classes are similar to `scoped_lock`
but `sharable_lock` acquires the sharable lock in the constructor and `upgradable_lock`
acquires the upgradable lock in the constructor.

These two utilities can be use with any synchronization object that offers the needed
operations. For example, a user defined mutex type with no upgradable locking features
can use `sharable_lock` if the synchronization object offers [*lock_sharable()] and
[*unlock_sharable()] operations:

[section:upgradable_mutexes_lock_types Sharable Lock And Upgradable Lock Headers]

[c++]

   #include <boost/interprocess/sync/sharable_lock.hpp>

[c++]

   #include <boost/interprocess/sync/upgradable_lock.hpp>

[endsect]

`sharable_lock` calls [*unlock_sharable()] in its destructor, and 
`upgradable_lock` calls [*unlock_upgradable()] in its destructor, so the
upgradable mutex is always unlocked when an exception occurs. 
Scoped lock has many constructors to lock,
try_lock, timed_lock a mutex or not to lock it at all. 


[c++]

   using namespace boost::interprocess;

   //Let's create any mutex type:
   MutexType mutex;

   {
      //This will call lock_sharable()
      sharable_lock<MutexType> lock(mutex);
      
      //Some code

      //The mutex will be unlocked here
   }

   {
      //This won't lock the mutex()
      sharable_lock<MutexType> lock(mutex, defer_lock);
      
      //Lock it on demand. This will call lock_sharable()
      lock.lock();
      
      //Some code

      //The mutex will be unlocked here
   }

   {
      //This will call try_lock_sharable()
      sharable_lock<MutexType> lock(mutex, try_to_lock);
      
      //Check if the mutex has been successfully locked
      if(lock){
         //Some code
      }
      //If the mutex was locked it will be unlocked
   }
   
   {
      boost::posix_time::ptime abs_time = ...

      //This will call timed_lock_sharable()
      scoped_lock<MutexType> lock(mutex, abs_time);
      
      //Check if the mutex has been successfully locked
      if(lock){
         //Some code
      }
      //If the mutex was locked it will be unlocked
   }

   {
      //This will call lock_upgradable()
      upgradable_lock<MutexType> lock(mutex);
      
      //Some code

      //The mutex will be unlocked here
   }

   {
      //This won't lock the mutex()
      upgradable_lock<MutexType> lock(mutex, defer_lock);
      
      //Lock it on demand. This will call lock_upgradable()
      lock.lock();
      
      //Some code

      //The mutex will be unlocked here
   }

   {
      //This will call try_lock_upgradable()
      upgradable_lock<MutexType> lock(mutex, try_to_lock);
      
      //Check if the mutex has been successfully locked
      if(lock){
         //Some code
      }
      //If the mutex was locked it will be unlocked
   }
   
   {
      boost::posix_time::ptime abs_time = ...

      //This will call timed_lock_upgradable()
      scoped_lock<MutexType> lock(mutex, abs_time);
      
      //Check if the mutex has been successfully locked
      if(lock){
         //Some code
      }
      //If the mutex was locked it will be unlocked
   }

[classref boost::interprocess::upgradable_lock upgradable_lock] and
[classref boost::interprocess::sharable_lock sharable_lock] offer
more features and operations, see their reference for more informations

[endsect]

[section:upgradable_mutexes_example Anonymous Upgradable Mutex Example]

[endsect]

[endsect]

[section:lock_conversions Lock Transfers Through Move Semantics]

[blurb [*Interprocess uses its own move semantics emulation code. 
This is a temporary solution until a Boost move semantics library is accepted.]]

Scoped locks and similar utilities offer simple resource management possibilities,
but with advanced mutex types like upgradable mutexes, there are operations where
an acquired lock type is released and another lock type is acquired atomically.
This is implemented by upgradable mutex operations like `unlock_and_lock_sharable()`.

These operations can be managed more effectively using [*lock transfer operations].
A lock transfer operations explicitly indicates that a mutex owned by a lock is
trasferred to another lock executing atomic unlocking plus locking operations.

[section:lock_trasfer_simple_transfer Simple Lock Transfer]

Imagine that a thread modifies some data in the beginning but after that, it has to 
just read it in a long time. The code can acquire the exclusive lock, modify the data
and atomically release the exclusive lock and acquire the sharable lock. With these
sequence we guarantee that no other thread can modify the data in the transition 
and that more readers can acquire sharable lock, increasing concurrency. 
Without lock transfer operations, this would be coded like this:

[c++]

   using boost::interprocess;
   interprocess_upgradable_mutex mutex;

   //Acquire exclusive lock
   mutex.lock();

   //Modify data

   //Atomically release exclusive lock and acquire sharable lock.
   //More threads can acquire the sharable lock and read the data.
   mutex.unlock_and_lock_sharable();

   //Read data

   //Explicit unlocking
   mutex.unlock_sharable();


This can be simple, but in the presence of exceptions, it's complicated to know
what type of lock the mutex had when the exception was thrown and what function
we should call to unlock it:

[c++]

   try{
      //Mutex operations
   }
   catch(...){
      //What should we call? "unlock()" or "unlock_sharable()"
      //Is the mutex locked?
   }

We can use [*lock transfer] to simplify all this management:

[c++]

   using boost::interprocess;
   interprocess_upgradable_mutex mutex;

   //Acquire exclusive lock
   scoped_lock s_lock(mutex);

   //Modify data

   //Atomically release exclusive lock and acquire sharable lock.
   //More threads can acquire the sharable lock and read the data.
   sharable_lock(move(s_lock));

   //Read data

   //The lock is automatically unlocked calling the appropiate unlock
   //function even in the presence of exceptions.
   //If the mutex was not locked, no function is called.

As we can see, even if an exception is thrown at any moment, the mutex
will be automatically unlocked calling the appropiate `unlock()` or
`unlock_sharable()` method.

[endsect]

[section:lock_trasfer_summary Lock Transfer Summary]

There are many lock trasfer operations that we can classify according to
the operations presented in the upgradable mutex operations:

* [*Guaranteed to succeed and non-blocking:] Any transition from a more
   restrictive lock to a less restrictive one. Scoped -> Upgradable,
   Scoped -> Sharable, Upgradable -> Sharable.

* [*Not guaranteed to succeed:] The operation might succeed if no one has 
   acquired the upgradable or exclusive lock: Sharable -> Exclusive. This
   operation is a try operation.

* [*Guaranteed to succeed if using an infinite waiting:] Any transition that will succeed
   but needs to wait until all Sharable locks are released: Upgradable -> Scoped.
   Since this is a blocking operation, we can also choose not to wait infinitely
   and just try or wait until a timeout is reached.

[section:lock_transfer_summary_scoped Transfers To Scoped Lock]

Transfers to `scoped_lock` are guaranteed to succeed only from an `upgradable_lock`
and only if a blocking operation is requested, due to the fact that this operation
needs to wait until all sharable locks are released. The user can also use "try"
or "timed" transfer to avoid infinite locking, but succeed is not guaranteed.

A conversion from a `sharable_lock` is never guaranteed and thus, only a try operation
is permitted:

[c++]

   //Conversions to scoped_lock
   {
      upgradable_lock<Mutex>  u_lock(mut);
      //This calls unlock_upgradable_and_lock()
      scoped_lock<Mutex>      e_lock(move(u_lock));
   }
   {
      upgradable_lock<Mutex>  u_lock(mut);
      //This calls try_unlock_upgradable_and_lock()
      scoped_lock<Mutex>      e_lock(move(u_lock, try_to_lock));
   }
   {
      boost::posix_time::ptime t = test::delay(100);
      upgradable_lock<Mutex>  u_lock(mut);
      //This calls timed_unlock_upgradable_and_lock()
      scoped_lock<Mutex>      e_lock(move(u_lock));
   }
   {
      sharable_lock<Mutex>    s_lock(mut);
      //This calls try_unlock_sharable_and_lock()
      scoped_lock<Mutex>      e_lock(move(s_lock, try_to_lock));
   }

[endsect]

[section:lock_transfer_summary_upgradable Transfers To Upgradable Lock]

A transfer to an `upgradable_lock` is guaranteed to succeed only from an `scoped_lock`
since scoped locking is a more restrictive locking than an upgradable locking. This
operation is also non-blocking.

A transfer from a `sharable_lock` is not guaranteed and only a "try" operation is permitted:

[c++]

   //Conversions to upgradable
   {
      sharable_lock<Mutex>    s_lock(mut);
      //This calls try_unlock_sharable_and_lock_upgradable()
      upgradable_lock<Mutex>  u_lock(move(s_lock, try_to_lock));
   }
   {
      scoped_lock<Mutex>      e_lock(mut);
      //This calls unlock_and_lock_upgradable()
      upgradable_lock<Mutex>  u_lock(move(e_lock));
   }

[endsect]

[section:lock_transfer_summary_sharable Transfers To Sharable Lock]

All transfers to a `sharable_lock` are guaranteed to succeed since both
`upgradable_lock` and `scoped_lock` are more restrictive than `sharable_lock`.
These operations are also non-blocking:

[c++]

   //Conversions to sharable_lock
   {
      upgradable_lock<Mutex>  u_lock(mut);
      //This calls unlock_upgradable_and_lock_sharable()
      sharable_lock<Mutex>    s_lock(move(u_lock));
   }
   {
      scoped_lock<Mutex>      e_lock(mut);
      //This calls unlock_and_lock_sharable()
      sharable_lock<Mutex>    s_lock(move(e_lock));
   }

[endsect]

[endsect]

[section:lock_trasfer_not_locked Transferring Unlocked Locks]

In the previous examples, the mutex used in the transfer operation was previously
locked:

[c++]

      Mutex mut;

      //This calls mut.lock()
      scoped_lock<Mutex>      e_lock(mut);

      //This calls unlock_and_lock_sharable()
      sharable_lock<Mutex>    s_lock(move(e_lock));
   }

but it's possible to execute the transfer with an unlocked source, due to explicit
unlocking, a try, timed or a `defer_lock` constructor:

[c++]

   //These operations can left the mutex unlocked!

   {
      //Try might fail
      scoped_lock<Mutex>      e_lock(mut, try_to_lock);
      sharable_lock<Mutex>    s_lock(move(e_lock));
   }
   {
      //Timed operation might fail
      scoped_lock<Mutex>      e_lock(mut, time);
      sharable_lock<Mutex>    s_lock(move(e_lock));
   }
   {
      //Avoid mutex locking
      scoped_lock<Mutex>      e_lock(mut, defer_lock);
      sharable_lock<Mutex>    s_lock(move(e_lock));
   }
   {
      //Explicitly call unlock
      scoped_lock<Mutex>      e_lock(mut);
      e_lock.unlock();
      //Mutex was explicitly unlocked
      sharable_lock<Mutex>    s_lock(move(e_lock));
   }

If the source mutex was not locked:

* The target lock does not executes the atomic `unlock_xxx_and_lock_xxx` operation.
* The target lock is also unlocked.
* The source lock is released() and the ownership of the mutex is transferred to the target.

[c++]

   {
      scoped_lock<Mutex>      e_lock(mut, defer_lock);
      sharable_lock<Mutex>    s_lock(move(e_lock));

      //Assertions
      assert(e_lock.mutex() == 0);
      assert(s_lock.mutex() != 0);
      assert(e_lock.owns()  == false);
   }

[endsect]

[section:lock_trasfer_failure Transfer Failures]

When executing a lock transfer, the operation can fail:

* The executed atomic mutex unlock plus lock function might throw.
* The executed atomic function might be a "try" or "timed" function that can fail.

In the first case, the mutex ownership is not transferred and the source lock's
destructor will unlock the mutex:

[c++]

   {
      scoped_lock<Mutex>      e_lock(mut, defer_lock);

      //This operations throws because
      //"unlock_and_lock_sharable()" throws!!!
      sharable_lock<Mutex>    s_lock(move(e_lock));

      //Some code ...

      //e_lock's destructor will call "unlock()"
   }

In the second case, if an internal "try" or "timed" operation fails (returns "false")
then the mutex ownership is [*not] transferred, the source lock is unchanged and the target
lock's state will the same as a default construction:

[c++]

   {
      sharable_lock<Mutex>    s_lock(mut);

      //Internal "try_unlock_sharable_and_lock_upgradable()" returns false
      upgradable_lock<Mutex>  u_lock(move(s_lock, try_to_lock));

      assert(s_lock.mutex() == &mut);
      assert(s_lock.owns()  == true);
      assert(u_lock.mutex() == 0);
      assert(u_lock.owns()  == false);

      //u_lock's destructor does nothing
      //s_lock's destructor calls "unlock()"
   }

[endsect]

[endsect]

[section:message_queue Message Queue]

[section:message_queue_whats_a_mq What's A Message Queue?]

A message queue is similar to a list of messages. Threads can put messages
in the queue and they can also remove messages from the queue. Each message
can have also a [*priority] so that higher priority messages are read before
lower priority messages. Each message has some attributes:

* A priority.
* The length of the message.
* The data (if length is bigger than 0).

A thread can send a message to or receive a message from the message 
queue using 3 methods:

* [*Blocking]: If the message queue is full when sending or the message queue
   is empty when receiving, the thread is blocked until there
   is room for a new message or there is a new message.
* [*Try]: If the message queue is full when sending or the message queue is empty
   when receiving, the thread returns immediately with an error.
* [*Timed]: If the message queue is full when sending or the message queue is empty
   when receiving, the thread retries the operation until succeeds (returning
   successful state) or a timeout is reached (returning a failure).

A message queue [*just copies raw bytes between processes] and does not send
objects. This means that if we want to send an object using a message queue 
[*the object must be binary serializable]. For example, we can send integers
between processes but [*not] a std::string. You should use [*Boost.Serialization]
or use advanced [*Boost.Interprocess] mechanisms to send complex data between
processes.

The [*Boost.Interprocess] message queue is a named interprocess communication: the
message queue is created with a name and it's opened with a name, just like a file.
When creating a message queue, the user must specify the maximum message size and
the maximum message number that the message queue can store. These parameters will
define the resources (for example the size of the shared memory used to implement 
the message queue if shared memory is used).

[c++]

   using boost::interprocess;
   //Create a message_queue. If the queue
   //exists throws an exception
   message_queue mq
      (create_only         //only create
      ,"message_queue"     //name
      ,100                 //max message number
      ,100                 //max message size
      );

[c++]

   using boost::interprocess;
   //Creates or opens a message_queue. If the queue
   //does not exist creates it, otherwise opens it.
   //Message number and size are ignored if the queue
   //is opened
   message_queue mq
      (open_or_create      //open or create
      ,"message_queue"     //name
      ,100                 //max message number
      ,100                 //max message size
      );

[c++]

   using boost::interprocess;
   //Opens a message_queue. If the queue
   //does not exist throws an exception.
   message_queue mq
      (open_only           //only open
      ,"message_queue"     //name
      );

The message queue is explicitly removed calling the static `remove` function:

[c++]

   using boost::interprocess;
   message_queue::remove("message_queue");

The funtion might fail if the message queue is still being used by any process.

[endsect]

[section:message_queue_example Using a message queue]

To use a message queue you must include the following header:

[c++]

   #include <boost/interprocess/ipc/message_queue.hpp>

In the following example, the first process creates the message queue, and writes
an array of integers on it. The other process just reads the array and checks that
the sequence number is correct.

[c++]

   #include <boost/interprocess/ipc/message_queue.hpp>
   #include <iostream>
   #include <vector>

   using namespace boost::interprocess;
   
   int main ()
   {
      try{
         //Erase previous message queue
         message_queue::remove("message_queue");

         //Create a message_queue.
         message_queue mq
            (create_only               //only create
            ,"message_queue"           //name
            ,100                       //max message number
            ,sizeof(int)               //max message size
            );

         //Send 100 numbers
         for(int i = 0; i < 100; ++i){
            mq.send(&i, sizeof(i), 0);
         }
      }
      catch(interprocess_exception &ex){
         std::cout << ex.what() << std::endl;
         return 1;
      }

      return 0;
   }


[c++]

   #include <boost/interprocess/ipc/message_queue.hpp>
   #include <iostream>
   #include <vector>

   using namespace boost::interprocess;
   
   int main ()
   {
      try{
         //Open a message queue.
         message_queue mq
            (open_only        //only create
            ,"message_queue"  //name
            );

         unsigned int priority;
         unsigned int recvd_size;

         //Receive 100 numbers
         for(int i = 0; i < 100; ++i){
            int number;
            mq.receive(&number, sizeof(number), recvd_size, priority);
            if(number != i || recvd_size != sizeof(number))
               return 1;
         }
      }
      catch(interprocess_exception &ex){
         std::cout << ex.what() << std::endl;
         return 1;
      }

      return 0;
   }

To know more about this class and all its operations, please see the
[classref boost::interprocess::message_queue] class reference.

[endsect]

[endsect]

[section:file_lock File Locks]

[section:file_lock_whats_a_file_lock What's A File Lock?]

A file lock is an interprocess synchronization mechanism to protect concurrent
writes and reads to files using a mutex ['embedded] in the file. This ['embedded mutex]
has sharable and exclusive locking capabilities.
With a file lock, an existing file can be used as a mutex without the need
of creating additional synchronization objects to control concurrent file
reads or writes.

Generally speaking, we can have two file locking capabilities:

*  [*Advisory locking:] The operating system kernel maintains a list of files that
   have been locked. But does not prevent writing to those files even if a process
   has acquired a sharable lock or does not prevent reading from the file when a process
   has acquired the exclusive lock. Any process can ignore an advisory lock. 
   This means that advisory locks are for [*cooperating] processes,
   processes that can trust each other. This is similar to a mutex protecting data
   in a shared memory segment: any process connected to that memory can overwrite the
   data but [*cooperative] processes use mutexes to protect the data first acquiring
   the mutex lock.

*  [*Mandatory locking:] The OS kernel checks every read and write request to verify
   that the operation can be performed according to the acquired lock. Reads and writes
   block until the lock is released.

[*Boost.Interprocess] implements [*advisory blocking] because of portability reasons.
This means that every process accessing to a file concurrently, must cooperate using
file locks to synchronize the access.

In some systems file locking can be even further refined, leading to [*record locking],
where a user can specify a [*byte range] within the file where the lock is applied.
This allows concurrent write access by several processes if they need to access a 
different byte range in the file. [*Boost.Interprocess] does [*not] offer record
locking for the moment, but might offer it in the future. To use a file lock just
include:

[c++]

   #include <boost/interprocess/sync/file_lock.hpp>

A file locking is a class that has [*process lifetime]. This means that if a process
holding a file lock ends or crashes, the operating system will automatically unlock
it. This feature is very useful in some situations where we want to assure
automatic unlocking even when the process crashes and avoid leaving blocked resources
in the system. A file lock is constructed using the name of the file as an argument:

[c++]

   #include <boost/interprocess/sync/file_lock.hpp>

   int main()
   {
      //This throws if the file does not exist or it can't
      //open it with read-write access!
      boost::interprocess::file_lock flock("my_file");
      return 0;
   }


[endsect]

[section:file_lock_operations File Locking Operations]

File locking has normal mutex operations plus sharable locking capabilities.
This means that we can have multiple readers holding the sharable lock and
writers holding the exclusive lock waiting until the readers end their job.

However, file locking does [*not] support upgradable locking or promotion or 
demotion (lock transfers), so it's more limited than an upgradable lock.
These are the operations:

[blurb ['[*void lock()]]]

[*Effects:]
The calling thread tries to obtain exclusive ownership of the file lock, and if 
another thread has exclusive or sharable ownership of the mutex, 
it waits until it can obtain the ownership.

[*Throws:] *interprocess_exception* on error.

[blurb ['[*bool try_lock()]]]

[*Effects:] 
The calling thread tries to acquire exclusive ownership of the file lock
without waiting. If no other thread has exclusive or sharable ownership of 
the file lock this succeeds.

[*Returns:] If it can acquire exclusive ownership immediately returns true. 
If it has to wait, returns false.

[*Throws:] *interprocess_exception* on error.

[blurb ['[*bool timed_lock(const boost::posix_time::ptime &abs_time)]]]

[*Effects:] 
The calling thread tries to acquire exclusive ownership of the file lock
waiting if necessary until no other thread has has exclusive or
sharable ownership of the file lock or abs_time is reached.

[*Returns:] If acquires exclusive ownership, returns true. Otherwise 
returns false.

[*Throws:] *interprocess_exception* on error.

[blurb ['[*void unlock()]]]

[*Precondition:] The thread must have exclusive ownership of the file lock.

[*Effects:] The calling thread releases the exclusive ownership of the file lock.

[*Throws:] An exception derived from *interprocess_exception* on error.

[blurb ['[*void lock_sharable()]]]

[*Effects:]
The calling thread tries to obtain sharable ownership of the file lock,
and if another thread has exclusive ownership of the file lock, 
waits until it can obtain the ownership.

[*Throws:] *interprocess_exception* on error.

[blurb ['[*bool try_lock_sharable()]]]

[*Effects:] 
The calling thread tries to acquire sharable ownership of the file
lock without waiting. If no other thread has has exclusive ownership of 
the file lock this succeeds.

[*Returns:] If it can acquire sharable ownership immediately returns true. 
If it has to wait, returns false.

[*Throws:] *interprocess_exception* on error.

[blurb ['[*bool timed_lock_sharable(const boost::posix_time::ptime &abs_time)]]]

[*Effects:] 
The calling thread tries to acquire sharable ownership of the file lock
waiting if necessary until no other thread has has exclusive
ownership of the file lock or abs_time is reached.

[*Returns:] If acquires sharable ownership, returns true. Otherwise 
returns false.

[*Throws:] *interprocess_exception* on error.

[blurb ['[*void unlock_sharable()]]]

[*Precondition:] The thread must have sharable ownership of the file lock.

[*Effects:] The calling thread releases the sharable ownership of the file lock.

[*Throws:] An exception derived from *interprocess_exception* on error.

For more file locking methods, please
[classref boost::interprocess::file_lock file_lock reference].

[endsect]

[section:file_lock_scoped_locks Scoped Lock and Sharable Lock With File Locking]

[classref boost::interprocess::scoped_lock scoped_lock] and
[classref boost::interprocess::sharable_lock sharable_lock] can be used to make
file locking easier in the presence of exceptions, just like with mutexes:

[c++]

   #include <boost/interprocess/sync/file_lock.hpp>
   #include <boost/interprocess/sync/sharable_lock.hpp>
   //...

   using namespace boost::interprocess;
   //This process reads the file
   //    ...
   //Open the file lock
   file_lock f_lock("my_file");

   {
      //Construct a sharable lock with the filel lock.
      //This will call "f_lock.sharable_lock()".
      sharable_lock<file_lock> sh_lock(f_lock);

      //Now read the file...

      //The sharable lock is automatically released by
      //sh_lock's destructor
   }
   
[c++]

   #include <boost/interprocess/sync/file_lock.hpp>
   #include <boost/interprocess/sync/scoped_lock.hpp>

   //...

   using namespace boost::interprocess;
   //This process writes the file
   //    ...
   //Open the file lock
   file_lock f_lock("my_file");

   {
      //Construct a sharable lock with the filel lock.
      //This will call "f_lock.lock()".
      scoped_lock<file_lock> e_lock(f_lock);

      //Now write the file...

      //The exclusive lock is automatically released by
      //e_lock's destructor
   }

However, lock transfers are only allowed between same type of locks, that is,
from a sharable lock to another sharable lock or from a scoped lock to another
scoped lock.  A transfer from a scoped lock to a sharable lock is not allowed,
because [classref boost::interprocess::file_lock file_lock] has no lock
promotion or demotion functions like `unlock_and_lock_sharable()`.
This will produce a compilation error:

[c++]

   //Open the file lock
   file_lock f_lock("my_file");

   scoped_lock<file_lock> e_lock(f_lock);

   //Compilation error, f_lock has no "unlock_and_lock_sharable()" member!
   sharable_lock<file_lock> e_lock(move(f_lock));


[endsect]

[section:file_lock_careful Be Careful With Iostream Writing]

As we've seen file locking can be useful to synchronize two processes
reading and writing to a file, but [*make sure data is written to the file]
before unlocking the file lock. Take in care that iostream classes do some
kind of buffering, so if you want to make sure that other processes can
see the data you've written, you have the following alternatives:

*  Use native file functions (read()/write() in Unix systems and ReadFile/WriteFile
   in Windows systems) instead of iostream.

*  Flush data before unlocking the file lock in writers using `fflush` if you are using
   standard C functions or the `flush()` member function when using C++ iostreams.

   //...

   using namespace boost::interprocess;
   //This process writes the file
   //    ...
   //Open the file lock
   fstream file("my_file")
   file_lock f_lock("my_file");

   {
      scoped_lock<file_lock> e_lock(f_lock);

      //Now write the file...

      //Flush data before unlocking the exclusive lock
      file.flush();
   }

[endsect]

[endsect]

[section:offset_ptr Mapping Address Independent Pointer: offset_ptr]

When creating shared memory and memory mapped files to communicate two
processes. The memory segment can be mapped in different address in each process:

[c++]

   #include<boost/interprocess/shared_memory_object.hpp>

   // ...

   using boost::interprocess;

   //Open a shared memory segment
   shared_memory_object shm_obj
      (open_only                    //open or create
      ,"shared_memory"              //name
      ,memory_mappable::read_only   //read-only mode
      );

   //Map the whole shared memory
   mapped_region region
      ( shm                         //Memory-mappable object
      , mapped_region::read_write   //Access mode
      );   

   //This address can be different in each process
   void *addr = region.get_address();

This difficults the creation of complex objects in mapped regions: a C++
class instance placed in a mapped region might have a pointer pointing to
another object also placed in the mapped region. Since the pointer stores an 
absolute address, that address is only valid for the process that placed 
the object there, unless all processes map the mapped region in the same
address.

To be able to simulate pointers in mapped regions, users must use [*offsets]
(distance between objets) instead of absolute address. The offset between
two objects in a mapped region is the same for any process that maps the
mapped region, even if that region is placed in different base addreses.
To facilitate the use of offsets, [*Boost.Interprocess] offers 
[classref boost::interprocess::offset_ptr offset_ptr].

[classref boost::interprocess::offset_ptr offset_ptr]
wraps all the background operations 
needed to offer a pointer-like interface. The class interface is 
inspired in Boost Smart Pointers and stores the offset (distance in bytes)
between the pointee's address and the 
[classref boost::interprocess::offset_ptr offset_ptr]'s "this" pointer 
(the address of the offset_ptr itself). Imagine an structure in a common
32 bit processor:

[c++]

   struct structure
   {
      int               integer1;   //This is placed at offset 0 in the structure
      offset_ptr<int>   ptr;        //This is placed at offset 4 in the structure
      int               integer2;   //This is placed at offset 8 in the structure
   };

   //...

   structure s;
   
   //Assign the address of "integer1" to "ptr".
   //"ptr" will store internally "-4": 
   //    (char*)&s.integer1 - (char*)&s.ptr;
   s.ptr = &s.integer1;

   //Assign the address of "integer2" to "ptr".
   //"ptr" will store internally "4": 
   //    (char*)&s.integer2 - (char*)&s.ptr;
   s.ptr = &s.integer2;


One of the big problems of 
`offset_ptr` is the representation of the null pointer. The null pointer 
can't be safely represented like an offset, since the 0 absolute address 
is always out of the mapped region and since the segment can be
mapped in a different base address, the distance between the address 0
and `offset_ptr` is different for every process.

Some implementations choose 
0 offset as a null pointer but this is not valid for many uses, 
since many times structures like linked lists or nodes from STL containers
point to themselves (the 
end node in an empty container, for example), and 0 offset value 
is needed. An alternative is to store, in addition to the offset, a boolean
to indicate if the pointer is null. However, this increments the size of the
pointer and huts performance.

In consequence,
[classref boost::interprocess::offset_ptr offset_ptr] defines offset 1
as the null pointer, meaning that this class can point to the byte
after its own ['this] pointer:

[c++]

   using namespace boost::interprocess;

   offset_ptr<char> ptr;
   
   //Pointing to the next byte of it's own address
   //marks the smart pointer as null.
   ptr = (char*)&ptr + 1;

   //ptr is equal to null
   assert(!ptr);

   //This is the same as assigning the null value...
   ptr = 0;

   //ptr is also equal to null
   assert(!ptr);


In practice, this limitation is not important, since a user almost never
wants to point to this address.

The offset_ptr class offers all pointer-like operations and
random_access_iterator typedefs, so it can be used in STL 
algorithms requiring random access and detected via traits.
For more information about the members and operations of the class, see
[classref boost::interprocess::offset_ptr offset_ptr reference].

[endsect]

[section:managed_memory_segments Managed Memory Segments: Making Interprocess Data Communication Easy]

[section:managed_memory_segments_intro Introduction]

As we have seen, [*Boost.Interprocess] offers some basic classes to create shared memory 
objects and file mappings and map those mappable classes to the process' address space.

However, managing those memory segments is not not easy for non-trivial tasks.
A mapped region is a fixed-length memory buffer and creating and destroying objects
of any type dynamically, requires a lot of work, since it would require programming
a memory management algorithm to allocate portions of that segment.
Many times, we also want to associate a names to objects created in shared memory, so
all the processes can find the object using the name.

Managed memory segments offer a lot of possibilities and [*Boost.Interprocess] offers
4 managed memory segment classes:

*  To manage a shared memory mapped region ([*basic_managed_shared_memory] class).
*  To manage a memory mapped file ([*basic_managed_mapped_file]).
*  To manage a heap allocated (`operator new`) memory buffer ([*basic_managed_heap_memory] class).
*  To manage a user provided fixed size buffer ([*basic_managed_external_buffer] class).

The first two classes manage memory segments that can be shared between processes. The
third is useful to create complex data-bases to be sent though other mechanisms like
message queues to other processes. The fourth class can manage any fixed size memory
buffer. The first two classes will be explained in the next two sections.
[*basic_managed_heap_memory] and [*basic_managed_external_buffer] will be explained later.

The most important services of a managed memory segment are:

*  Dynamic allocation of portions of a memory the segment.
*  Construction of C++ objects in the memory segment. These objects can be anonymous
   or we can associate a name to them.
*  Searching capabilities for named objects.
*  Customization of many features: memory allocation algorithm, index types or
   character types.
*  Atomic constructions and destructions so that if the segment is shared between
   two processes it's impossible to create two objects associated with the same 
   name, simplifying synchronization.

[endsect]

[section:managed_memory_segment_int Declaration of managed memory segment classes]

All [*Boost.Interprocess] managed memory segment classes are templatized classes
that can be customized by the user:

[c++]

   template
         <
            class CharType, 
            class MemoryAlgorithm, 
            template<class IndexConfig> class IndexType
         >
   class basic_managed_shared_memory / basic_managed_mapped_file /
         basic_managed_heap_memory   / basic_external_buffer;

These classes can be customized with the following template parameters:

*  *CharType* is the type of the character that will be used to identify
   the created named objects (for example, *char* or *wchar_t*)

*  *MemoryAlgorithm* is the memory algorithm used to allocate portions of the
   segment (for example simple sequential fit). The internal typedefs of the
   memory algorithm also define:
   *  The synchronization type (`MemoryAlgorithm::mutex_family`) to be used
      in all allocation operations.
      This allows the use of user-defined mutexes or avoiding internal
      locking (maybe code will be externally synchronized by the user).

   *  The Pointer type (`MemoryAlgorithm::void_pointer`) to be used 
      by the memory allocation algorithm or additional helper structures
      (like a map to mantain object/name associations). All STL compatible
      allocators and containers to be used with this managed memory segment
      will use this pointer type. The pointer type
      will define if the managed memory segment can be mapped between
      several processes. For example, if `void_pointer` is `offset_ptr<void>`
      we will be able to map the managed segment in different base
      addresses in each process. If `void_pointer` is `void*` only fixed
      address mapping could be used.

   *  See [link interprocess.customizing_boost_interprocess.custom_interprocess_alloc Writing a new memory 
      allocation algorithm] for more details about memory algorithms.
     
*  *IndexType* is the type of index that will be used to store the name-object 
   association (for example, a map, a hash-map, or an ordered vector).

This way, we can use `char` or `wchar_t` strings to identify created C++
objects in the memory segment, we can plug new shared memory allocation
algorithms, and use the index type that is best suited to our needs.

[endsect]

[endsect]

[section:managed_shared_memory Managed Shared Memory]

[section:managed_memory_common_shm Common Managed Shared Memory Classes]

As seen, *basic_managed_shared_memory* offers a great variety of customization. But
for the average user, a common, default shared memory named object creation is needed.
Because of this, [*Boost.Interprocess] defines the most common managed shared memory
specializations:

[c++]

   /*!Defines a managed shared memory with c-strings as keys for named objects,
      the simple sequential fit algorithm (with process-shared mutexes, 
      and offset_ptr pointer)
      as memory allocation algorithm and flat_map (an ordered vector) as index.
      This class allows the shared memory to be mapped in different base 
      in different processes*/
   typedef 
      basic_managed_shared_memory <char
                                ,simple_seq_fit<mutex_family, offset_ptr<void> >
                                ,flat_map_index>  
      managed_shared_memory;

   /*!Defines a managed shared memory with wide strings as keys for named objects,
      the simple sequential fit algorithm (with process-shared mutexes, 
      and offset_ptr pointer)
      as memory allocation algorithm and flat_map (an ordered vector) as index.
      This class allows the shared memory to be mapped in different base 
      in different processes*/
   typedef 
      basic_managed_shared_memory <wchar_t
                                ,simple_seq_fit<mutex_family, offset_ptr<void> >
                                ,flat_map_index>  
      wmanaged_shared_memory;

`managed_shared_memory` allocates objects in shared memory asociated with a c-string and
`wmanaged_shared_memory` allocates objects in shared memory asociated with a wchar_t null
terminated string. Both define the pointer type as `offset_ptr<void>` so they can be
used to map the shared memory at different base addresses in different processes.

[endsect]

[section:constructing_managed_shared_memories Constructing Managed Shared Memory]

Managed shared memory is an advanced class that combines a shared memory object
and a mapped region that covers all the shared memory object. That means that
when we [*create] a new managed shared memory:

*  A new shared memory object is created.
*  The whole shared memory object is mapped in the process' address space. 
*  Some helper objects are constructed (name-object index, internal synchronization
   objects, internal variables...) in the mapped region to implement
   managed memory segment features.

When we [*open] a managed shared memory

*  A shared memory object is opened.
*  The whole shared memory object is mapped in the process' address space. 

To use a managed shared memory, you must include the following header:

[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>


[c++]

   //1.  Creates a new shared memory object
   //    called "MySharedMemory".
   //2.  Maps the whole object to this
   //    process' address space.
   //3.  Constructs some objects in shared memory
   //    to implement managed features.
   //!!  If anything fails, throws interprocess_exception
   //
   managed_shared_memory segment
      (create_only, 
      "MySharedMemory", //Shared memory object name
      65536);           //Shared memory object size in bytes

[c++]

   //1.  Opens a shared memory object
   //    called "MySharedMemory".
   //2.  Maps the whole object to this
   //    process' address space.
   //3.  Obtains pointers to constructed internal objects
   //    to implement managed features.
   //!!  If anything fails, throws interprocess_exception
   //
   managed_shared_memory segment
      (open_only, 
      "MySharedMemory");//Shared memory object name

[c++]

   //1.  If the segment was previously created
   //    equivalent to "open_only".
   //2.  Otherwise, equivalent to "open_only" (size is ignored)
   //!!  If anything fails, throws interprocess_exception
   //
   managed_shared_memory segment
      (open_or_create, 
      "MySharedMemory", //Shared memory object name
      65536);           //Shared memory object size in bytes

When the a `managed_shared_memory` object is destroyed, the shared memory
object is automatically unmapped, and all the resources are freed. To remove
the shared memory object from the system you must use the `shared_memory_object::remove`
function. Shared memory object removing might fail if any 
process still has the shared memory object mapped.

[endsect]

For more information about managed shared memory capabilities, see
[classref boost::interprocess::basic_managed_shared_memory] class reference.

[endsect]

[section:managed_mapped_files Managed Mapped File]

[section:managed_memory_common_mfile Common Managed Mapped Files]

As seen, *basic_managed_mapped_file* offers a great variety of customization. But
for the average user, a common, default shared memory named object creation is needed.
Because of this, [*Boost.Interprocess] defines the most common managed mapped file
specializations:

[c++]

   //Named object creation managed memory segment
   //All objects are constructed in the memory-mapped file
   //   Names are c-strings, 
   //   Default memory management algorithm(simple_seq_fit with no mutexes)
   //   Name-object mappings are stored in the default index type (flat_map)
   typedef basic_managed_mapped_file < 
      char, 
      simple_seq_fit<mutex_family, offset_ptr<void> >,
      flat_map_index
      >  managed_mapped_file;

   //Named object creation managed memory segment
   //All objects are constructed in the memory-mapped file
   //   Names are wide-strings, 
   //   Default memory management algorithm(simple_seq_fit with no mutexes)
   //   Name-object mappings are stored in the default index type (flat_map)
   typedef basic_managed_mapped_file< 
      wchar_t, 
      simple_seq_fit<mutex_family, offset_ptr<void> >,
      flat_map_index
      >  wmanaged_mapped_file;

`managed_mapped_file` allocates objects in a memory mapped files asociated with a c-string
and `wmanaged_mapped_file` allocates objects in a memory mapped file asociated with a wchar_t null
terminated string. Both define the pointer type as `offset_ptr<void>` so they can be
used to map the file at different base addresses in different processes.

[endsect]

[section:constructing_managed_mapped_files Constructing Managed Mapped Files]

Managed mapped file is an advanced class that combines a file
and a mapped region that covers all the file.  That means that
when we [*create] a new managed mapped file:

*  A new file is created.
*  The whole file is mapped in the process' address space. 
*  Some helper objects are constructed (name-object index, internal synchronization
   objects, internal variables...) in the mapped region to implement
   managed memory segment features.

When we [*open] a managed mapped file

*  A file is opened.
*  The whole file is mapped in the process' address space. 

To use a managed mapped file, you must include the following header:

[c++]

   #include <boost/interprocess/managed_mapped_file.hpp>

[c++]

   //1.  Creates a new file
   //    called "MyMappedFile".
   //2.  Maps the whole file to this
   //    process' address space.
   //3.  Constructs some objects in the memory mapped
   //    file to implement managed features.
   //!!  If anything fails, throws interprocess_exception
   //
   managed_mapped_file mfile
      (create_only,
      "MyMappedFile",   //Mapped file name
      65536);           //Mapped file size

[c++]

   //1.  Opens a file
   //    called "MyMappedFile".
   //2.  Maps the whole file to this
   //    process' address space.
   //3.  Obtains pointers to constructed internal objects
   //    to implement managed features.
   //!!  If anything fails, throws interprocess_exception
   //
   managed_mapped_file mfile
      (open_only,
      "MyMappedFile");  //Mapped file name

[c++]

   //1.  If the file was previously created
   //    equivalent to "open_only".
   //2.  Otherwise, equivalent to "open_only" (size is ignored)
   //
   //!!  If anything fails, throws interprocess_exception
   //
   managed_mapped_file mfile
      (open_or_create,
      "MyMappedFile",   //Mapped file name
      65536);           //Mapped file size

When the a `managed_mapped_file` object is destroyed, the file is
automatically unmapped, and all the resources are freed. To remove
the file from the filesystem you can use standard C `std::remove` 
or [*Boost.Filesystem]'s `remove()` functions. File removing might fail
if any process still has the file mapped in memory or the file is open 
by any process.

[endsect]

For more information about managed mapped file capabilities, see
[classref boost::interprocess::basic_managed_mapped_file] class reference.

[endsect]

[section:managed_memory_segment_features Managed Memory Segment Features]

The following features are common to all managed memory segment classes, but
we will use managed shared memory in our examples. We can do the same with 
memory mapped files or other managed memory segment classes.

[section:allocate_deallocate Allocating fragments of a managed memory segment]

If a basic raw-byte allocation is needed from a managed memory
segment, (for example, a managed shared memory), to implement
top-level interprocess communications, this class offers 
[*allocate] and [*deallocate] functions. The allocation function
comes with throwing and no throwing versions. Throwing version throws
boost::interprocess::bad_alloc (which derives from `std::bad_alloc`)
if there is no more memory and the non-throwing version returns 0 pointer.

[c++]
   
   #include <boost/interprocess/managed_shared_memory.hpp>

   int main()
   {
      using namespace boost::interprocess;

      //Managed memory segment that allocates portions of a shared memory
      //segment with the default management algorithm
      managed_shared_memory managed_shm(create_only, "MyManagedShm", 65536);

      //Allocate 100 bytes of memory from segment, throwing version
      void *ptr = managed_shm.allocate(100);

      //Deallocate it
      managed_shm.deallocate(ptr);

      //Non throwing version
      ptr = managed_shm.allocate(100, std::nothrow);

      //Deallocate it
      managed_shm.deallocate(ptr);
      return 0;
   }

[endsect]

[section:segment_offset Obtaining handles to identify data]

The class also offers conversions between absolute addresses that belong to 
a managed memory segment and a handle that can be passed using any
interprocess mechanism. That handle can be transformed again to an absolute
address using a managed memory segment that also contains that object.
Handles can be used as keys between processes to identify allocated portions
of a managed memory segment or objects constructed in the managed segment.

[c++]

	//Process A obtains the offset of the address
	managed_shared_memory::handle handle = 
      segment.get_handle_from_address(processA_address);

	//Process A sends this address using any mechanism to process B

	//Process B obtains the handle and transforms it again to an address
   managed_shared_memory::handle handle = ...
	void * processB_address = segment.get_address_from_handle(handle);

[endsect]

[section:allocation_types Object construction function family]

When constructing objects in a managed memory segment (managed shared memory, 
managed mapped files...) associated with a name, the user has a varied object
construction family to "construct" or to "construct if not found". [*Boost.Interprocess]
can construct a single object or an array of objects. The array can be constructed with 
the same parameters for all objects or we can define each parameter from a list of iterators:

[c++]

   /*!Allocates and constructs an object of type MyType (throwing version) */
   MyType *ptr = managed_memory_segment.construct<MyType>("Name") (par1, par2...);

   /*!Allocates and constructs an array of objects of type MyType (throwing version) 
     Each object receives the same parameters (par1, par2, ...)*/
   MyType *ptr = managed_memory_segment.construct<MyType>("Name")[count](par1, par2...);

   /*!Tries to find a previously created object. If not present, allocates 
      and constructs an object of type MyType (throwing version) */
   MyType *ptr = managed_memory_segment.find_or_construct<MyType>("Name") (par1, par2...);

   /*!Tries to find a previously created object. If not present, allocates and 
      constructs an array of objects of type MyType (throwing version). Each object 
      receives the same parameters (par1, par2, ...)*/
   MyType *ptr = managed_memory_segment.find_or_construct<MyType>("Name")[count](par1, par2...);

   /*!Allocates and constructs an array of objects of type MyType (throwing version) 
     Each object receives parameters returned with the expression (*it1++, *it2++,... )*/
   MyType *ptr = managed_memory_segment.construct_it<MyType>("Name")[count](it1, it2...);

   /*!Tries to find a previously created object. If not present, allocates and constructs 
      an array of objects of type MyType (throwing version).  Each object receives  
      parameters returned with the expression (*it1++, *it2++,... ) */
   MyType *ptr = managed_memory_segment.find_or_construct_it<MyType>("Name")[count](it1, it2...);

   /*!Tries to find a previously created object. Returns a pointer to the object and the 
      count (if it is not an array, returns 1). If not present, the returned pointer is 0*/
   std::pair<MyType *,std::size_t> ret = managed_memory_segment.find<MyType>("Name");

   /*!Destroys the created object, returns false if not present*/
   bool destroyed = managed_memory_segment.destroy<MyType>("Name");

   /*!Destroys the created object via pointer*/
   managed_memory_segment.destroy_ptr(ptr);

All these functions have a non-throwing version, that 
is invoked with an additional parameter std::nothrow. 
For example, for simple object construction:

[c++]

   /*!Allocates and constructs an object of type MyType (no throwing version) */
   MyType *ptr = managed_memory_segment.construct<MyType>("Name", std::nothrow) (par1, par2...);

[endsect]

[section:anonymous Anonymous instance construction]

Sometimes, the user doesn't want to create class objects associated with a name.
For this purpose, [*Boost.Interprocess] can create anonymous objects in a managed
memory segment. All named object construction functions are available to construct
anonymous objects. To allocate an anonymous objects, the user must use 
"boost::interprocess::anonymous_instance" name instead of a normal name:

[c++]

   MyType *ptr = managed_memory_segment.construct<MyType>(anonymous_instance) (par1, par2...);

   //Other construct variants can also be used (including non-throwing ones)
   ...

   //We can only destroy the anonymous object via pointer
   managed_memory_segment.destroy_ptr(ptr);

Find functions have no sense here, since anonymous objects have no name. 
We can only destroy the anonymous object via pointer.

[endsect]

[section:unique Unique instance construction]

Sometimes, the user wants to emulate a singleton in a managed memory segment. Obviously, 
as the managed memory segment is constructed at run-time, the user must construct and
destroy this object explicitly. But how can the user be sure that the object is the only
object of its type in the managed memory segment? This can be emulated using
a named object and checking if it is present before trying to create one, but
all processes must agree in the object's name, that can also conflict with
other existing names.

To solve this, [*Boost.Interprocess] offers a "unique object" creation in a managed memory segment.
Only one instance of a class can be created in a managed memory segment using this
"unique object" service (you can create more named objects of this class, though)
so it makes easier the emulation of singleton-like objects across processes, for example,
to design pooled, shared memory allocators. The object can be searched using the type 
of the class as a key. 

[c++]

   // Construct
   MyType *ptr = managed_memory_segment.construct<MyType>(unique_instance) (par1, par2...);

   // Find it
   std::pair<MyType *,std::size_t> ret = managed_memory_segment.find<MyType>(unique_instance);

   // Destroy it
   managed_memory_segment.destroy<MyType>(unique_instance);

   // Other construct and find variants can also be used (including non-throwing ones)
   //...

[c++]

   // We can also destroy the unique object via pointer
   MyType *ptr = managed_memory_segment.construct<MyType>(unique_instance) (par1, par2...);
   managed_shared_memory.destroy_ptr(ptr);

The find function obtains a pointer to the only object of type T that can be created
using this "unique instance" mechanism. 

[endsect]

[section:synchronization Synchronization guarantees]

One of the features of named/anonymous/unique allocations/searches/destructions is that
they are [*atomic]. Named allocations use the synchronization scheme defined by the
internal `mutex_family` typedef defined by the template parameter MemoryAlgorithm of 
the managed memory segment. So that two processes can call:

[c++]

   MyType *ptr = managed_shared_memory.find_or_construct<MyType>("Name")[count](par1, par2...);
   
at the same time, but only one process will create the object and the other will 
obtain a pointer to the created object.

Raw allocation using `allocate()` can be called also safely while executing 
named/anonymous/unique allocations, just like when programming a multithreaded 
application inserting an object in a mutex-protected map does not block other threads
from calling new[] while the map thread is searching the place where it has to insert the
new object. The synchronization does happen once the map finds the correct place and
it has to allocate raw memory to construct the new value.

This means that if we are creating or searching for a lot of named objects,
we only block creation/searches from other processes but we don't block another 
process if that process is inserting elements in a shared memory vector.

[endsect]

[section:index_types Index types for name/object mappings]

As seen, managed memory segments, when creating named objects, store the name/object
association in an index. The index is a map with the name of the object as a key and
a pointer to the object as the mapped type. The default specializations, 
*managed_shared_memory* and *wmanaged_shared_memory*, use *flat_map_index* as the index type.

Each index has its own characteristics, like search-time, insertion time, deletion time, 
memory use, and memory allocation patterns. [*Boost.Interprocess] offers 3 index types 
right now:

*  [*boost::interprocess::flat_map_index]: Based on boost::interprocess::flat_map, an ordered 
   vector similar to Loki library's AssocVector class, offers great search time and
   minimum memory use. But the vector must be reallocated when is full, so all data
   must be copied to the new buffer. Ideal when insertions are mainly in initialization
   time and in run-time we just need searches.

*  [*boost::interprocess::map_index]: Based on boost::interprocess::map, a managed memory ready
   version of std::map. Since it's a node based container, it has no reallocations, the tree
   must be just rebalanced sometimes. Offers equilibrated insertion/deletion/search
   times with more overhead per node comparing to *boost::interprocess::flat_map_index*.
   Ideal when searches/insertions/deletions are in random order.

*  [*boost::interprocess::null_index]: This index is for people using a managed
   memory segment just for raw memory buffer allocations and they don't make use
   of named/unique allocations. This class is just empty and saves some space and
   compilation time.
   If you try to use named object creation with a managed memory segment using this
   index, you will get a compilation error.

As an example, if we want to define new managed shared memory class 
using *boost::interprocess::map* as the index type we
just must specify [boost::interprocess::map_index] as a template parameter:

[c++]

   //This managed memory segment can allocate objects with:
   // -> a wchar_t string as key
   // -> boost::interprocess::simple_seq_fit with process-shared mutexes 
   //       as memory allocation algorithm.
   // -> boost::interprocess::map<...> as the index to store name/object mappings
   //
   typedef boost::interprocess::basic_managed_shared_memory
            <  wchar_t
            ,  boost::interprocess::simple_seq_fit<boost::interprocess::mutex_family, offset_ptr<void> >
            ,  boost::interprocess::map_index
            >  my_managed_shared_memory;

[*Boost.Interprocess] plans to offer an *unordered_map* based index as soon as this
container is included in Boost. If these indexes are not enough for you, you can define
your own index type. To know how to do this, go to 
[link interprocess.customizing_boost_interprocess.custom_indexes Building custom indexes] section.

[endsect]

[section:managed_memory_segment_segment_manager Segment Manager]

All [*Boost.Interprocess] managed memory segment classes construct in their
respective memory segments (shared memory, memory mapped files, heap memory...)
some structures to implement the memory management algorithm, named allocations,
synchronization objects... All these objects are encapsulated in a single object
called [*segment manager]. A managed memory mapped file and a managed shared
memory use the same [*segment manager] to implement all managed memory segment
features, due to the fact that a [*segment manager] is a class that manages
a fixed size memory buffer. Since both shared memory or memory mapped files
are accessed though a mapped region, and a mapped region is a fixed size
memory buffer, a single [*segment manager] class can manage several managed
memory segment types.

Some [*Boost.Interprocess] classes require a pointer to the segment manager in
their constructor, and this can be obtained from any managed memory segment using
`get_segment_manager` member:

[c++]

   managed_shared_memory::segment_manager *seg_manager =
      managed_shm.get_segment_manager();

[endsect]

[endsect]

[section:stl_allocators STL compatible allocators]

[section:allocator_introduction Introduction to STL compatible allocators]

As seen, [*Boost.Interprocess] offers raw memory allocation and object construction using managed
memory segments (managed shared memory, managed mapped files...) and
one of the first user requests is the use of containers in managed shared memories. To achieve this, 
[*Boost.Interprocess] makes use of managed memory segment's memory allocation algorithms to build 2 common
memory allocation schemes: variable size object allocation and fixed size object allocation (segregated storage),
implemented in these allocators: 

*  *boost::interprocess::allocator* offers general purpose, variable size allocation.

*  *boost::interprocess::node_allocator* offers a segregated storage allocation scheme sharing a common
   pool between all instances of the class placed in the same managed memory, so memory usage is optimized.

*  *boost::interprocess::private_node_allocator* offers a segregated storage allocation scheme where
   each `private_node_allocator` owns its own pool. This allocator offers faster allocation
   than node_allocator since it avoids synchronization between threads/processes that happens
   when accesing the common pool, but imposes a higher memory usage. Take in care that the 
   standard does not recommend this private, per allocator, pool.

*  *boost::interprocess::cached_node_allocator* offers a segregated storage allocation scheme between
   node_allocator and private_node_allocator. This allocator caches some nodes from the common
   the common pool and stores them privately so that these are quickly available
   without the synchronization overhead for future allocations.

[*Boost.Interprocess] STL compatible allocators are configurable via template parameters. 
Allocators define their `pointer` typedef based on the `void_pointer` typedef of the segment manager
passed as template argument. When this `segment_manager::void_pointer` is a relative pointer, 
(for example, `boost::interprocess::offset_ptr<void>`) the user can place these allocators in
memory mapped in different base addresses in several processes.

[endsect]

[section:allocator boost::interprocess::allocator: STL compatible allocator for managed memory segments]

The *boost::interprocess::allocator* class defines a STL compatible allocator class that 
uses the managed memory segment's algorithm to allocate and deallocate memory. This is
achieved though the [*segment manager] of the managed memory segment.
This allocator is templatized with the allocated type, and the segment manager.

To use `boost::interprocess::allocator`, you must include the following header:

[c++]

   #include <boost/interprocess/allocators/allocator.hpp>

[c++]

   namespace boost::interprocess {

   /*!An STL compatible allocator that uses a segment manager as 
      memory source. The internal pointer type will of the same type (raw, smart) as
      "typename SegmentManager::void_pointer" type. This allows
      placing the allocator in shared memory, memory mapped-files, etc...*/
   template<class T, class SegmentManager>
   class allocator 
   {
      public:

      /*!Returns the segment manager. Never throws*/
      segment_manager* get_segment_manager() const;

      /*!Constructor from the segment manager. Never throws*/
      allocator(segment_manager *segment_mngr);

      //The rest of the interface is the same of std::allocator
   };

   }} //      namespace boost::interprocess {

The class *allocator* must be always initialized with the allocation
algorithm obtained from the segment where you want *boost::interprocess::allocator* 
to allocate memory.

[c++]

   //Alias allocator type with
   //    T=int
   //    SegmentManager = managed_shared_memory::segment_manager
   typedef allocator<int, managed_shared_memory::segment_manager> Allocator;

   //Initialize allocator with the segment manager
   Allocator alloc_inst (segment.get_segment_manager());

The allocator just provides the needed typedefs and forwards all allocation
and deallocation requests to the segment manager passed in the constructor.

[endsect]

[section:node_allocator boost::interprocess::node_allocator: a simple segregated storage]

Variable size memory algorithms waste 
some space in management information for each allocation. Sometimes, 
usually for small objects, this is not acceptable. Memory algorithms can
also fragment the managed memory segment under some allocation and 
deallocation schemes, reducing their performance. When allocating 
many objects of the same type, a simple segregated storage becomes 
a fast and space-friendly allocator, as explained in Boost Pool library.

To build normal node allocators, usually a global, thread shared singleton
pool is used for each node size. This is not possible if you try to share 
a node allocator between processes. To achieve this sharing, the *node_allocator* 
uses a unique name to identify the pool shared by all this node_allocators. In the
initialization, a *node_allocator* object searches this unique object in the segment.
If it is not preset, it builds one.  This way, all *node_allocator* objects built
inside a memory segment share a unique memory pool. 

The common segregated storage is not only shared between node_allocators of the
same type, but it is also  shared between all node_allocators that allocate objects 
of the same size, for example, *node_allocator<uint32>* and *node_allocator<float32>*. 
This saves a lot of memory but also imposes an synchronization overhead for each 
node allocation.

The common segregated storage, dynamically created using the unique name explained before,
integrates a reference count so that a node_allocator can know if any other node_allocator 
is attached to the same common segregated storage to allow an ordered common segregated 
storage destruction when the last node_allocator is destroyed.

To use `boost::interprocess::node_allocator`, you must include the following header:

[c++]

   #include <boost/interprocess/allocators/node_allocator.hpp>

[c++]

   /*!An STL node allocator that uses a segment manager as memory 
      source. The internal pointer type will of the same type (raw, smart) as
      "typename SegmentManager::void_pointer" type. This allows
      placing the allocator in shared memory, memory mapped-files, etc...
      This node allocator shares a segregated storage between all instances 
      of node_allocator with equal sizeof(T) placed in the same segment 
      group. N is the number of nodes allocated at once when the allocator
      needs runs out of nodes*/
   template<class T, std::size_t N, class SegmentManager>
   class node_allocator
   {
    public:

      //No default constructor

      /*!Constructor from a segment manager.
         Can throw boost::interprocess::bad_alloc*/
      node_allocator(SegmentManager *segment_mngr);

      /*!Returns a pointer to the segment manager. Never throws*/
      SegmentManager *get_segment_manager() const;

      /*...*/
      //The rest is the same interface as std::allocator
      /*...*/

The [*node_allocator] must be always initialized with the segment 
manager obtained from the segment where you want [*node_allocator] to allocate memory.

[c++]

   //Alias allocator type with
   //    T=int
   //    N=64
   //    SegmentManager = managed_shared_memory::segment_manager
   typedef node_allocator<int, 64, managed_shared_memory::segment_manager> NodeAllocator;

   //Initialize allocator instance with the segment manager
   NodeAllocator alloc_inst (segment.get_segment_manager());

All STL compatible containers that want to use this allocation scheme 
must be constructed with an initialized node_allocator so 
that they can allocate the values with the node allocator:

[c++]

   MyIntList mylist(alloc_inst);
   mylist.insert(mylist.begin(), 3);

[endsect]

[section:private_node_allocator boost::interprocess::private_node_allocator: a private segregated storage]

As said, the node_allocator shares a common segregated storage between 
node_allocators that allocate objects of the same size and this optimizes
memory usage. However, it needs a unique/named object construction feature
so that this sharing can be possible. Also
imposes a synchronization overhead per node allocation because of this share.
Sometimes, the unique object service is not available (for example, when
building index types to implement the named allocation service itself) or the 
synchronization overhead is not acceptable.

So [*private_node_allocator] uses the same segregated storage as `node_allocator`,
but each [*private_node_allocator] has its own segregated storage pool. No synchronization
is used when allocating nodes, so there is far less overhead for an operation
that usually involves just a few pointer operations when allocating and 
deallocating a node.

To use `boost::interprocess::private_node_allocator`, you must include the following header:

[c++]

   #include <boost/interprocess/allocators/private_node_allocator.hpp>

[c++]

   /*!An STL node allocator that uses a segment manager as memory 
      source. The internal pointer type will of the same type (raw, smart) as
      "typename SegmentManager::void_pointer" type. This allows
      placing the allocator in shared memory, memory mapped-files, etc...
      This allocator has its own node pool. N is the number of nodes allocated 
      at once when the allocator needs runs out of nodes*/
   template<class T, std::size_t N, class SegmentManager>
   class private_node_allocator
   {
    public:

      //No default constructor

      /*!Constructor from a segment manager. Never throws*/
      private_node_allocator(SegmentManager *segment_mngr);

      /*!Returns a pointer to the segment manager. Never throws*/
      SegmentManager *get_segment_manager() const;

      /*...*/
      //The rest is the same interface as std::allocator
      /*...*/

Any [*private_node_allocator] must be initialized with a pointer 
to the segment manager of the segment from you want [*private_node_allocator]
to allocate memory:

[c++]

   //Alias allocator type with
   //    T=int
   //    N=64
   //    SegmentManager = managed_shared_memory::segment_manager
   typedef private_node_allocator<int, 64, managed_shared_memory::segment_manager> 
      PrivateNodeAllocator;

   //Initialize allocator instance with the segment manager
   PrivateNodeAllocator alloc_inst (segment.get_segment_manager());

All STL compatible containers that want to use this allocation scheme 
must be constructed with an initialized private_node_allocator so 
that they can allocate the values with the private node allocator:

[c++]

   MyIntList mylist(alloc_inst);
   mylist.insert(mylist.begin(), 3);

[endsect]

[section:cached_node_allocator boost::interprocess::cached_node_allocator: caching nodes to avoid overhead]

The total node sharing of [*boost::interprocess::node_allocator] can impose a high overhead for some
applications and the minimal synchronization overhead of [*boost::interprocess::private_node_allocator]
can impose a unacceptable memory waste for other applications.

To solve this, [*Boost.Interprocess] offers an allocator, [*boost::interprocess::cached_node_allocator], that 
allocates nodes from the common pool but caches some of them privately so that following 
allocations have no synchronization overhead. When the cache is full, the allocator 
returns some cached nodes to the common pool, and those will be available to other 
allocators.

To use `boost::interprocess::cached_node_allocator`, you must include the following header:

[c++]

   #include <boost/interprocess/allocators/cached_node_allocator.hpp>

[c++]

   /*!An STL node allocator that uses a segment manager as memory 
      source. The internal pointer type will of the same type (raw, smart) as
      "typename SegmentManager::void_pointer" type. This allows
      placing the allocator in shared memory, memory mapped-files, etc...
      This node allocator shares a segregated storage between all instances
      of cached_node_allocator with equal sizeof(T) placed in the same
      managed memory segment. But also caches some nodes privately to
      avoid some synchronization overhead./*

   template<class T, class SegmentManager>
   class cached_node_allocator
   {
    public:

      //No default constructor

      /*!Constructor from a segment manager. Never throws*/
      cached_node_allocator(AllocAlgo_t *segment_mngr);

      /*!Returns a pointer to the segment manager. Never throws*/
      SegmentManager *get_segment_manager() const;

      /*!Sets the new max cached nodes value. This can provoke deallocations
         if "newmax" is less than current cached nodes. Never throws*/
      void set_max_cached_nodes(std::size_t newmax);

      /*!Returns the max cached nodes parameter. Never throws*/
      std::size_t get_max_cached_nodes() const;

      /*...*/
      //The rest is the same interface as std::allocator
      /*...*/

Any *cached_node_allocator* must be initialized with a pointer to the segment
manager of the managed memory segment:

[c++]

   //Alias allocator type with
   //    T=int
   //    SegmentManager = managed_shared_memory::segment_manager
   typedef cached_node_allocator<int, managed_shared_memory::segment_manager> 
      CachedNodeAllocator;

   //Initialize allocator instance with algorithm
   CachedNodeAllocator alloc_inst (segment.get_segment_manager());

All STL compatible containers that want to use this allocation scheme 
must be constructed with an initialized `cached_node_allocator` so 
that they can allocate the values with the cached_node_allocator:

[c++]

   //Change cache size as desired (for example 100 nodes)
   alloc_inst.set_max_cached_nodes(100);

   //Initialize container
   MyIntList mylist(alloc_inst);
   mylist.insert(mylist.begin(), 3);

[endsect]

[section:allocator_swapping Swapping STL compatible allocators]

When swapping STL containers, there is an active discussion on what to do with 
the allocators. Some STL implementations, for example Dinkumware from Visual .NET 2003,
perform a deep swap of the whole container through a temporary when allocators are not equal.
The [@http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1599.html proposed resolution]
to container swapping is that allocators should be swapped in a non-throwing way.

Unfortunately, this approach is not valid with shared memory. Using heap allocators, if
Group1 of node allocators share a common segregated storage, and Group2 share another common
segregated storage, a simple pointer swapping is needed to swap an allocator of Group1 and another
allocator of Group2. But when the user wants to swap two shared memory allocators, each one
placed in a different shared memory segment, this is not possible. As generally shared memory
is mapped in different addresses in each process, a pointer placed in one segment can't point
to any object placed in other shared memory segment, since in each process, the distance between
the segments is different. However, if both shared memory allocators are in the same segment,
a non-throwing swap is possible, just like heap allocators.

Until a final resolution is achieved. [*Boost.Interprocess] STL compatible allocators implement a non-throwing
swap function that swaps internal pointers. If an allocator placed in a shared memory segment is
swapped with other placed in a different shared memory segment, the result is undefined. But a 
crash is quite sure.

[endsect]

[endsect]

[section:containers_explained Interprocess and containers in managed memory segments]

[section:stl_container_requirements Container requirements for Boost.Interprocess allocators]

[*Boost.Interprocess] STL compatible allocators offer a STL compatible allocator
interface and if they define their internal *pointer* typedef as a relative pointer, 
they can sbe used to place STL containers in shared memory, memory mapped files or
in a user defined memory segment.

However, as Scott Meyers mentions in his Effective STL 
book, Item 10, ['"Be aware of allocator conventions and 
restrictions"]: 

* ['"the Standard explicitly allows library implementers 
to assume that every allocator's pointer typedef is 
a synonym for T*"]

* ['"the Standard says that an implementation of the STL is 
permitted to assume that all allocator objects of the 
same type are equivalent and always compare equal"]

Obviously, if any STL implementation ignores pointer typedefs, 
no smart pointer can be used as allocator::pointer. If STL 
implementations assume all allocator objects of the same 
type compare equal, it will assume that two allocators, 
each one allocating from a different memory pool
are equal, which is a complete disaster. 

STL containers that we want to place in shared memory or memory
mapped files with [*Boost.Interprocess] can't make any of these assumptions, so:

* STL containers may not assume that memory allocated with 
  an allocator can be deallocated with other allocators of 
  the same type. All allocators objects must compare equal 
  only if memory allocated with one object can be deallocated 
  with the other one, and this can only tested with 
  operator==() at run-time.

* Containers' internal pointers should be of the type allocator::pointer 
  and containers may not assume allocator::pointer is a raw pointer.

* All objects must be constructed-destroyed via 
  allocator::construct and allocator::destroy functions.

[endsect]

[section:containers STL containers in managed memory segments]

Unfortunately, many STL implementations use raw pointers
for internal data and ignore allocator pointer typedefs 
and others suppose at some point that the allocator::typedef 
is T*. This is because in practice,
there wasn't need of allocators with a pointer typedef 
different from T* for pooled/node memory
allocators.

Until STL implementations handle allocator::pointer typedefs
in a generic way, [*Boost.Interprocess] offers the following classes:

*  [*boost:interprocess::vector] is the implementation of std::vector ready
   to be used in managed memory segments like shared memory. To use it include:

[c++]

   #include <boost/interprocess/containers/vector.hpp>
        
*  [*boost:interprocess::deque] is the implementation of std::deque ready 
   to be used in managed memory segments like shared memory. To use it include:

[c++]

   #include <boost/interprocess/containers/deque.hpp>
        
*  [boost:interprocess::list] is the implementation of std::list ready
   to be used in managed memory segments like shared memory. To use it include:

[c++]

   #include <boost/interprocess/containers/list.hpp>

*  [boost:interprocess::slist] is the implementation of SGI's slist container (singly linked list) ready
   to be used in managed memory segments like shared memory. To use it include:

[c++]

   #include <boost/interprocess/containers/slist.hpp>
        
*  [boost:interprocess::set/multiset/map/multimap] family is the implementation of 
   std::set/multiset/map/multimap family ready
   to be used in managed memory segments like shared memory. To use them include:

[c++]

   #include <boost/interprocess/containers/map.hpp>
   #include <boost/interprocess/containers/set.hpp>
   #include <boost/interprocess/containers/multimap.hpp>
   #include <boost/interprocess/containers/multiset.hpp>

        
*  [*boost:interprocess::flat_set/flat_multiset/flat_map/flat_multimap] classes are the 
   adaptation and extension of Andrei Alexandrescu's famous AssocVector class 
   from Loki library, ready for the shared memory. These classes offer the same 
   functionality as std::set/multiset/map/multimap implemented with an ordered vector, 
   which has faster lookups than the standard ordered associative containers 
   based on red-black trees, but slower insertions. To use it include:

[c++]

   #include <boost/interprocess/containers/flat_map.hpp>
   #include <boost/interprocess/containers/flat_set.hpp>
   #include <boost/interprocess/containers/flat_multimap.hpp>
   #include <boost/interprocess/containers/flat_multiset.hpp>
        
*  [*boost:interprocess::basic_string] is the implementation of std::basic_string ready
   to be used in managed memory segments like shared memory.
   It's implemented using a vector-like contiguous storage, so
   it has fast c string conversion and can be used with the 
   [link interprocess.streams.vectorstream vectorstream] iostream formatting classes.
   To use it include:

[c++]

   #include <boost/interprocess/containers/string.hpp>
        
All these containers have the same default arguments as standard 
containers and they can be used with other, non [*Boost.Interprocess]
allocators (std::allocator, or boost::pool_allocator, for example). 

To place any of these containers in managed memory segments, we must
define the allocator template parameter with a [*Boost.Interprocess] allocator
so that the container allocates the values in the managed memory segment.
To place the container itself in shared memory, we construct it
in the managed memory segment just like any other object with [*Boost.Interprocess]:

[/doc_cont.cpp]

[c++]

   #include <boost/interprocess/containers/vector.hpp>
   #include <boost/interprocess/managed_shared_memory.hpp>

   int main ()
   {
      using namespace boost::interprocess;

      shared_memory_object::remove("MySharedMemory");
      //A managed shared memory where we can construct objects
      //associated with a c-string
      managed_shared_memory segment(create_only,
                                  "MySharedMemory",  //segment name
                                  65536);

      //Alias an STL-like allocator of ints that allocates ints from the segment
      typedef allocator<int, managed_shared_memory::segment_manager> 
         ShmemAllocator;

      //Alias a vector that uses the previous STL-like allocator
      typedef vector<int, ShmemAllocator> MyVector;

      int initVal[]        = {0, 1, 2, 3, 4, 5, 6 };
      const int *begVal    = initVal;
      const int *endVal    = initVal + sizeof(initVal)/sizeof(initVal[0]);

      //Initialize the STL-like allocator
      const ShmemAllocator alloc_inst (segment.get_segment_manager());

      //Construct the vector in the shared memory segment with the STL-like allocator 
      //from a range of iterators
      MyVector *myvector = 
         segment.construct<MyVector>
           ("MyVector")/*object name*/
           (begVal     /*first ctor parameter*/,
            endVal     /*second ctor parameter*/, 
            alloc_inst /*third ctor parameter*/); 

      //Use vector as your want
      std::sort(myvector->rbegin(), myvector->rend());
      // . . .
      //When done, destroy and delete vector from the segment
      segment.destroy<MyVector>("MyVector");
      return 0;
   }

These containers also show how easy is to create/modify 
an existing container making possible to place it in shared memory.

[endsect]

[section:where_allocate Where is this being allocated?]

[*Boost.Interprocess] containers are placed in shared memory/memory mapped files,
etc... using two mechanisms [*at the same time]:

*  [*Boost.Interprocess] `construct<>`, `find_or_construct<>`... functions. These
   functions place a C++ object in the shared memory/memory mapped file. But this
   places only the object, but *not* the memory that this object may allocate dynamically.

*  Shared memory allocators. These allow allocating shared memory/memory mapped file
   portions so that containers can allocate dynamically fragments of memory to store
   new inserted elements.

This means that to place any [*Boost.Interprocess] container (including
[*Boost.Interprocess] strings) in shared memory/memory mapped file all containers *must*:

* Define their template allocator parameter to a shared memory one.

* Every container constructor must take a shared memory allocator as parameter.

* You must use construct<>/find_or_construct<>... functions to place the container
  in shared memory.

If you do the first two points but you don't use construct<>/find_or_construct<> 
you are creating a container placed *only* in your process but that allocates memory 
for contained types from shared memory/memory mapped file.

Let's see an example:

[/doc_where_allocate.cpp]

[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <boost/interprocess/containers/vector.hpp>
   #include <boost/interprocess/containers/string.hpp>
   #include <boost/interprocess/allocators/allocator.hpp>

   int main ()
   {
      using namespace boost::interprocess;
      //Typedefs
      typedef allocator<char, managed_shared_memory::segment_manager> 
         CharAllocator;
      typedef basic_string<char, std::char_traits<char>, CharAllocator>
         MyShmString;
      typedef allocator<MyShmString, managed_shared_memory::segment_manager>
         StringAllocator;      
      typedef vector<MyShmString, StringAllocator>
         MyShmStringVector;

      //Open shared memory
      shared_memory_object::remove("myshm");
      managed_shared_memory shm(create_only, "myshm", 10000);

      //Create allocators
      CharAllocator     charallocator  (shm.get_segment_manager());
      StringAllocator   stringallocator(shm.get_segment_manager());

      //This string is in only in this process (the pointer pointing to the
      //buffer that will hold the text is not in shared memory). 
      //But the buffer that will hold "this is my text" is allocated from 
      //shared memory
      MyShmString mystring(charallocator);
      mystring = "this is my text";

      //This vector is only in this process (the pointer pointing to the
      //buffer that will hold the MyShmString-s is not in shared memory). 
      //But the buffer that will hold 10 MyShmString-s is allocated from 
      //shared memory using StringAllocator. Since strings use a shared 
      //memory allocator (CharAllocator) the 10 buffers that hold 
      //"this is my text" text are also in shared memory.
      MyShmStringVector myvector(stringallocator);
      myvector.insert(myvector.begin(), 10, mystring);

      //This vector is fully constructed in shared memory. All pointers
      //buffers are constructed in the same shared memory segment
      //This vector can be safely accessed from other processes.
      MyShmStringVector *myshmvector = 
         shm.construct<MyShmStringVector>("myshmvector")(stringallocator);
      myshmvector->insert(myshmvector->begin(), 10, mystring);

      //Destroy vector. This will free all strings that the vector contains
      shm.destroy_ptr(myshmvector);
      return 0;
   }

[endsect]

[endsect]

[section:managed_heap_memory_external_buffer Managed Heap Memory And Managed External Buffer]

[*Boost.Interprocess] offers managed shared memory between processes using
`managed_shared_memory` or `managed_mapped_file`. Two processes just map the same
the memory mappable resoure and read from and write to that object.

Many times, we don't want to use that shared memory approach and we prefer
to send serialized data through network, local socket or message queues. Serialization
can be done through [*Boost.Serialization] or similar library. However, if two processes
share the same ABI (application binary interface), we could use the same object and
container construction capabilities of `managed_shared_memory` or `managed_heap_memory`
to build all the information in a single buffer that will be sent, for example, 
though message queues. The receiver would just copy the data to a local buffer, and it
could read or modify it directly without deserializing the data . This approach can be
much more efficient that a complex serialization mechanism.

Applications for [*Boost.Interprocess] services using non-shared memory buffers:

* Create and use STL compatible containers and allocators, 
  in systems where dynamic memory is not suggested.

* Build complex, easily serializable databases in a single buffer:

   * To share data between threads

   * To save and load information from/to files.

*  Duplicate information (containers, allocators, etc...) just copying the contents of 
   one buffer to another one.

*  Send complex information and objects/databases using serial/inter-process/network
   communications.

To help with this management, [*Boost.Interprocess] provides two useful classes,
`basic_managed_heap_memory` and `basic_managed_external_buffer`:

[section:managed_external_buffer Managed External Buffer: Constructing all Boost.Interprocess objects in a user provided buffer]

Sometimes, the user wants to create simple objects, STL compatible containers, STL compatible
strings and more, all in a single buffer. This buffer could be a big static buffer, 
a memory-mapped auxiliary device or any other user buffer.

This would allow a easy serialization, since we just have copy the buffer to duplicate
all the objects created in the original buffer, and this includes complex objects like
maps, lists or any user classes. [*Boost.Interprocess] offers classes to handle user
provided buffers that allow the same functionality as shared memory classes:

[c++]

   //Named object creation managed memory segment
   //All objects are constructed in a a user provided buffer
   template <
               class CharType, 
               class MemoryAlgorithm, 
               template<class IndexConfig> class IndexType
            >
   class basic_managed_external_buffer;

   //Named object creation managed memory segment
   //All objects are constructed in a a user provided buffer
   //   Names are c-strings, 
   //   Default memory management algorithm
   //    (simple_seq_fit with no mutexes and relative pointers)
   //   Name-object mappings are stored in the default index type (flat_map)
   typedef basic_managed_external_buffer < 
      char, 
      simple_seq_fit<null_mutex_family>, offset_ptr<void> ,
      flat_map_index
      >  managed_external_buffer;

   //Named object creation managed memory segment
   //All objects are constructed in a a user provided buffer
   //   Names are wide-strings, 
   //   Default memory management algorithm
   //    (simple_seq_fit with no mutexes and relative pointers)
   //   Name-object mappings are stored in the default index type (flat_map)
   typedef basic_managed_external_buffer< 
      wchar_t, 
      simple_seq_fit<null_mutex_family, offset_ptr<void> >,
      flat_map_index
      >  wmanaged_external_buffer;

To use a managed external buffer, you must include the following header:

[c++]

   #include <boost/interprocess/managed_external_buffer.hpp>
   
Let's see an example of the use of these classes:

[c++]

   //Create the user memory who will store all objects
   const int memsize = 65536;
   static char static_buffer [memsize];

   //Named (wide-string) new capable class
   //Initializes the static buffer
   wmanaged_external_buffer objects_in_user_memory
      (create_only, static_buffer, memsize);

   //We optimize resources to create 100 named objects in the static buffer
   objects_in_user_memory.reserve_named_objects(100);

   //Alias <integer, 64 element per chunk> node allocator type
   //This allocator will allocate memory inside the static buffer
   typedef wmanaged_external_buffer::node_allocator_type
      <int, 64>::type node_allocator_t;

   //Alias a STL compatible list to be constructed in the static buffer
   typedef boost::interprocess::list<int, node_allocator_t>    MyBufferList;

   //The list must be initialized with the allocator
   MyBufferList *list = objects_in_user_memory.construct<MyBufferList>(L"MyList")
                           (objects_in_user_memory.get_segment_manager());

   //All objects created with objects_in_user_memory will be stored in the static_buffer!

   //Destroy the whole list from the static buffer
   objects_in_user_memory.destroy<MyBufferList>(L"MyList");

[*Boost.Interprocess] STL compatible allocators can also be used to place STL 
compatible containers in the user segment.

[endsect]

[section:managed_heap_memory Managed Heap Memory: Boost.Interprocess machinery in heap memory]

The use of heap memory (new/delete) to obtain a buffer where the user wants to store all 
his data is very common, so [*Boost.Interprocess] provides some specialized 
classes that work exclusively with heap memory. 

These are the classes:

[c++]

   //Named object creation managed memory segment
   //All objects are constructed in a single buffer allocated via new[]
   template <
               class CharType, 
               class MemoryAlgorithm, 
               template<class IndexConfig> class IndexType
            >
   class basic_managed_heap_memory;

   //Named object creation managed memory segment
   //All objects are constructed in a single buffer allocated via new[]
   //   Names are c-strings, 
   //   Default memory management algorithm
   //    (simple_seq_fit with no mutexes and relative pointers)
   //   Name-object mappings are stored in the default index type (flat_map)
   typedef basic_managed_heap_memory < 
      char, 
      simple_seq_fit<null_mutex_family>,
      flat_map_index
      >  managed_heap_memory;

   //Named object creation managed memory segment
   //All objects are constructed in a single buffer allocated via new[]
   //   Names are wide-strings, 
   //   Default memory management algorithm
   //    (simple_seq_fit with no mutexes and relative pointers)
   //   Name-object mappings are stored in the default index type (flat_map)
   typedef basic_managed_heap_memory< 
      wchar_t, 
      simple_seq_fit<null_mutex_family>,
      flat_map_index
      >  wmanaged_heap_memory;

To use a managed heap memory, you must include the following header:

[c++]

   #include <boost/interprocess/managed_heap_memory.hpp>

The use is exactly the same as before, except that memory is created by
the managed memory segment itself using dynamic (new/delete) memory:

[c++]

   //Create the heap memory who will store all objects
   const int memsize = 65536;

   //Managed memory segment built above heap memory (new/delete)
   wmanaged_heap_memory objects_in_heap_memory(memsize);

   //We optimize resources to create 100 named objects in the dynamic buffer
   objects_in_heap_memory.reserve_named_objects(100);

   //Alias <integer, 64 element per chunk> node allocator type
   //This allocator will allocate memory inside the dynamic buffer
   typedef wmanaged_heap_memory::node_allocator_type
      <int, 64 >::type node_allocator_t;

   //Alias a STL compatible list to be constructed in the dynamic buffer
   typedef boost::interprocess::list<int, node_allocator_t>    MyHeapList;

   //The list must be initialized with the allocator
   //since it has no default constructor
   MyHeapList *heaplist = objects_in_heap_memory.construct<MyHeapList>(L"MyList")
                           (objects_in_heap_memory.get_segment_manager());

   //All objects created with objects_in_user_memory will be stored in the static_buffer!

   //Destroy the whole list from the dynamic buffer
   objects_in_heap_memory.destroy<MyHeapList>(L"MyList");

[*basic_managed_heap_memory] also offers a `grow(std::size_t extra_bytes)` function that
tries to resize internal heap memory so that we have room for more objects. 
But *be careful*, if memory is reallocated, the old buffer will be copied into 
the new one so all the objects will be binary-copied to the new buffer. 
To be able to use this function, all pointers constructed in the heap buffer that
point to objects in the heap buffer must be relative pointers (for example `offset_ptr`).
Otherwise, the result is undefined. Here is an example:

[c++]

   #include <boost/interprocess/containers/list.hpp>
   #include <boost/interprocess/managed_heap_memory.hpp>
   #include <boost/interprocess/allocators/allocator.hpp>
   #include <cstddef>

   using namespace boost::interprocess;
   typedef list<int, allocator<int, managed_heap_memory::segment_manager> > 
      MyList;

   int main ()
   {
      //We will create a buffer of 1000 bytes to store a list
      managed_heap_memory heap_memory(1000);

      MyList * mylist = heap_memory.construct<MyList>("MyList")
                           (heap_memory.get_segment_manager());

      //Obtain handle, that identifies the list in the buffer
      managed_heap_memory::handle_t list_handle = heap_memory.get_handle_from_address(mylist);

      //Fill list until there is no more memory in the buffer
      try{
         while(1) {
            mylist->insert(mylist->begin(), 0);
         }
      }
      catch(const bad_alloc &){
         //memory is full
      }
      //Let's obtain the size of the list
      std::size_t old_size = mylist->size();

      //To make the list bigger, let's increase the heap buffer
      //in 1000 bytes more.
      heap_memory.grow(1000);

      //If memory has been reallocated, the old pointer is invalid, so
      //use previously obtained handle to find the new pointer.
      mylist = static_cast<MyList *>
                  (heap_memory.get_address_from_handle(list_handle));
      
      //Fill list until there is no more memory in the buffer
      try{
         while(1) {
            mylist->insert(mylist->begin(), 0);
         }
      }
      catch(const bad_alloc &){
         //memory is full
      }

      //Let's obtain the new size of the list      
      std::size_t new_size = mylist->size();

      assert(new_size > old_size);

      //Destroy list
      heap_memory.destroy_ptr(mylist);

      return 0;
   }

[endsect]

[section:managed_heap_memory_external_buffer_diff Differences between managed memory segments]

All managed memory segments have similar capabilities
(memory allocation inside the memory segment, named object construction...),
but there are some remarkable differences between [*managed_shared_memory],
[*managed_mapped_file] and [*managed_heap_memory], [*managed_external_file].

*  Default specializations of managed shared memory and mapped file use process-shared
   mutexes. Heap memory and external buffer have no internal synchronization by default.
   The cause is that the first two are thought to be shared between processes (although
   memory mapped files could be used just to obtain a persistent object data-base for a
   process) whereas the last two are thought to be used inside one process to construct
   a serialized named object data-base that can be sent though serial interprocess
   communications (like message queues, localhost network...).

*  The first two create a system-global object (a shared memory object or a file) shared
   by several processes, whereas the last two are objects that don't create system-wide
   resources.

[endsect]

[section:shared_message_queue_ex Example: Serializing a database through the message queue]

To see the utility of managed heap memory and managed external buffer classes, 
the following example shows how a message queue can be used to serialize a whole
database constructed in a memory buffer using [*Boost.Interprocess], send the database
through a message queue and duplicated in another buffer:

[c++]
   
   //This test creates a in memory data-base using Interprocess machinery and 
   //serializes it through a message queue. Then rebuilds the data-base in 
   //another buffer and checks it against the original data-base
   bool test_serialize_db()
   {
      //Typedef data to create a Interprocess map   
      typedef std::pair<const std::size_t, std::size_t> MyPair;
      typedef std::less<std::size_t>   MyLess;
      typedef node_allocator<MyPair, 64, managed_external_buffer::segment_manager>
         node_allocator_t;
      typedef map<std::size_t, 
                  std::size_t, 
                  std::less<std::size_t>, 
                  node_allocator_t>
                  MyMap;

      //Some constants
      const std::size_t BufferSize  = 65536;
      const std::size_t MaxMsgSize  = 100;

      //Allocate a memory buffer to hold the destiny database using vector<char>
      std::vector<char> buffer_destiny(BufferSize, 0);

      message_queue::remove("message_queue");
      //Create the message-queues
      message_queue mq1(create_only, "message_queue", 1, MaxMsgSize);

      //Open previously created message-queue simulating other process
      message_queue mq2(open_only, "message_queue");

      //A managed heap memory to create the origin database
      managed_heap_memory db_origin(buffer_destiny.size());

      //Construct the map in the first buffer
      MyMap *map1 = db_origin.construct<MyMap>("MyMap")
                                       (MyLess(), 
                                       db_origin.get_segment_manager());
      if(!map1)
         return false;

      //Fill map1 until is full 
      try{
         std::size_t i = 0;
         while(1){
            (*map1)[i] = i;
            ++i;
         }
      }
      catch(boost::interprocess::bad_alloc &){}

      //Data control data sending through the message queue
      std::size_t sent = 0;
      std::size_t recvd = 0;
      std::size_t total_recvd = 0;
      unsigned int priority;

      //Send whole first buffer through the mq1, read it 
      //through mq2 to the second buffer
      while(1){
         //Send a fragment of buffer1 through mq1
         std::size_t bytes_to_send = MaxMsgSize < (db_origin.get_size() - sent) ? 
                                       MaxMsgSize : (db_origin.get_size() - sent);
         mq1.send( &static_cast<char*>(db_origin.get_address())[sent]
               , bytes_to_send
               , 0);
         sent += bytes_to_send;
         //Receive the fragment through mq2 to buffer_destiny
         mq2.receive( &buffer_destiny[total_recvd]
                  , BufferSize - recvd
                  , recvd
                  , priority);
         total_recvd += recvd;

         //Check if we have received all the buffer
         if(total_recvd == BufferSize){
            break;
         }
      }
      
      //The buffer will contain a copy of the original database 
      //so let's interpret the buffer with managed_external_buffer
      managed_external_buffer db_destiny(open_only, &buffer_destiny[0], BufferSize);

      //Let's find the map
      std::pair<MyMap *, std::size_t> ret = db_destiny.find<MyMap>("MyMap");
      MyMap *map2 = ret.first;

      //Check if we have found it
      if(!map2){
         return false;
      }

      //Check if it is a single variable (not an array)
      if(ret.second != 1){
         return false;
      }

      //Now let's compare size
      if(map1->size() != map2->size()){
         return false;
      }

      //Now let's compare all db values
      for(std::size_t i = 0, num_elements = map1->size(); i < num_elements; ++i){
         if((*map1)[i] != (*map2)[i]){
            return false;
         }
      }
      
      //Destroy maps from db-s
      db_origin.destroy_ptr(map1);
      db_destiny.destroy_ptr(map2);

      return true;
   }

[endsect]

[endsect]

[section:customizing_boost_interprocess Customizing Boost.Interprocess]

[section:custom_interprocess_alloc Writing a new shared memory allocation algorithm]

Interprocess by default, uses a simple, space-friendly allocation algorithm implemented
by the class simple_seq_fit:

[section:simple_seq_fit simple_seq_fit: Default shared memory management algorithm]

The algorithm is a variation of sequential fit using singly 
linked list of free memory buffers. The algorithm is based 
on the article about shared memory titled 
[@http://home.earthlink.net/~joshwalker1/writing/SharedMemory.html ['"Taming Shared Memory"] ]. 
The algorithm is as follows:

The shared memory is divided in blocks of free shared memory, 
each one with some control data and several bytes of memory 
ready to be used. The control data contains a pointer (in 
our case offset_ptr) to the next free block and the size of 
the block. The allocator consists of a singly linked list 
of free blocks, ordered by address. The last block, points 
always to the first block:

[c++]

   simple_seq_fit  extra    free_block  1         free_block  2         free_block  3    
                   header   block_ctrl    usr     block_ctrl    usr     block_ctrl    usr
    ____________   _____   ___________________   ___________________   ___________________ 
   |            | |     | |             |     | |             |     | |             |     |
   | free | ctrl| |extra| | next | size | mem | | next | size | mem | | next | size | mem |
   |____________| |_____| |_____________|_____| |_____________|_____| |_____________|_____|
         |                 |   |                 |    |                 |  |               
         |__>__>__>__> _> _|   |__>__>__>__>__>__|    |__>__>__>__>__>__|  |              
                           |                                               | 
                           |_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_|


When a user requests N bytes of memory, the allocator 
traverses the free block list looking for a block large 
enough. If the "mem" part of the block has the same 
size as the requested memory, we erase the block from 
the list and return a pointer to the "mem" part of the 
block. If the "mem" part size is bigger than needed, 
we split the block in two blocks, one of the requested 
size and the other with remaining size. Now, we take 
the block with the exact size, erase it from list and 
give it to the user.

When the user deallocates a block, we traverse the list (remember 
that the list is ordered), and search its place depending on 
the block address. Once found, we try to merge the block with 
adjacent blocks if possible.

To ease implementation, the size of the free memory block 
is measured in multiples of "basic_size" bytes.  The basic 
size will be the size of the control block aligned to 
machine most restrictive alignment.

[c++]

   /*!This class implements the simple sequential fit algorithm with a simply
      linked list of free buffers.*/
   template<class MutexFamily, class VoidPointer>
   class simple_seq_fit : private boost::noncopyable
   {
    private:

      /*!Block control stucture*/
      struct block_ctrl
      {
         /*!Offset pointer to the next block. This pointer
            can't be null, since it's a diff pointer.*/
         offset_ptr<block_ctrl, offset_1_null_ptr>    next;
         /*!This block's memory size (including block_ctrl 
            header) in BasicSize units*/
         std::size_t                                  size;
      };

      /*...*/  
   
    public:
      /*!Shared interprocess_mutex family used for the rest of the interprocess framework*/
      typedef MutexFamily                          mutex_family;
      /*!the pointer type to be used for the rest of the interprocess framework*/
      typedef VoidPointer                          void_pointer;

    public:
      /*!Constructor. "size" is the total size of the maanged memory segment, 
         "extra_hdr_bytes" indicates the extra bytes after the sizeof(simple_seq_fit)
         that the allocator should not use at all.*/
      simple_seq_fit           (std::size_t size, std::size_t extra_hdr_bytes);
      /*!Obtains the minimium size needed by the algorithm*/
      static std::size_t get_min_size (std::size_t extra_hdr_bytes);
      /*!Allocates bytes, returns 0 if there is not more memory*/
      void* allocate            (std::size_t nbytes);
      /*!Deallocates previously allocated bytes*/
      void   deallocate          (void *adr);
      /*!Returns the size of the memory segment*/
      std::size_t get_size()  const;
      /*!Increases managed memory in extra_size bytes more*/
      void grow(std::size_t extra_size);
      /*...*/  
   };

Let's explain these structs:

* [*simple_seq_fit] is the main control block of the allocator. 

* The [*extra_hdr_bytes] memory comes just after simple_seq_fit object. 
  This memory will be used by other classes to write more control 
  data at fixed position.

* [*block_ctrl] is the structure which controls a free block 
  in memory. It contains the size of the free block (in aligned 
  sizeof (block_ctrl) units, called basic_size, as we've 
  said before) and an offset pointer to the next free block 
  in the shared memory segment. The number of bytes returned 
  by the allocator will be multiple of basic_size bytes to 
  maintain the alignment requirements.

[endsect]

[section:custom_alloc_algo How to implement you own algorithm]

If the default algorithm does not satisfy user requirements, 
it's easy to provide different algorithms like bitmapping or 
more advanced segregated lists to meet requirements. The characteristics
of your own algorithm:

* It shouldn't have any virtual function or virtual inheritance or
  any indirect base class with virtual function or inheritance.

* I has to implement the same public functions and typedefs of 
simple_seq_fit.

Let's see the public typedefs to define:

[c++]

   typedef /* . . . */ void_pointer;
   typedef /* . . . */ mutex_family;

The `void_pointer` typedef specifies the pointer type to be used in 
the [*Boost.Interprocess] framework that uses the algorithm. For example, if we define

[c++]

   typedef void * void_pointer;

all [*Boost.Interprocess] framework using this algorithm will use raw pointers as members.
But if we define:

[c++]

   typedef offset_ptr<void> void_pointer;

then all [*Boost.Interprocess] framework will use relative pointers.

The `mutex_family` is an structure containing typedefs 
for different interprocess_mutex types to be used in the [*Boost.Interprocess] 
framework. For example the defined

[c++]

   struct mutex_family
   {
      typedef boost::interprocess::interprocess_mutex             mutex_type;
      typedef boost::interprocess::interprocess_recursive_mutex   recursive_mutex_type;
   };

defines all interprocess_mutex types using boost::interprocess interprocess_mutex types.
The user can specify the desired mutex family.

[c++]

   typedef mutex_family mutex_family;

The new algorithm (let's call it *my_algorithm*) must implement the all the functions
that boost::interprocess::simple_seq_fit class offers:

*  The *my_algorithm* constructor must take 2 arguments: 
   *  *size* indicates the total size of the managed memory segment, and
      the *my_algorithm* object will be always constructed a at offset 0 
      of the memory segment. 
 
   *  The *extra_hdr_bytes* parameter indicates the number of bytes after
      the offset sizeof(*my_algorithm*) that *my_algorithm* can't use at all. This extra
      bytes will be used to store additional data that should not be overwritten.
      So, *my_algorithm* will be placed at address XXX of the memory segment, and will
      manage the *[XXX + sizeof(my_algorithm) + extra_hdr_bytes, XXX + size)* range of
      the segment.

*  The [*get_min_size()] function should return the minimum space the algorithm 
   needs to be valid with the passed *extra_hdr_bytes* parameter. This function will 
   be used to check if the memory segment is big enough to place the algorithm there.

*  The [*allocate()] function must return 0 if there is no more available memory. 
   The memory returned by *my_algorithm*
   must be aligned to the most restrictive memory alignment of the system, for example,
   to the value returned by *boost::alignment_of<boost::detail::max_align>::value*.
   This function should be executed with the synchronization capabilities offered
   by `typename mutex_family::mutex_type` interprocess_mutex. That means, that if we define 
   `typedef mutex_family mutex_family;` then this function should offer
   the same synchronization as if it was surrounded by a interprocess_mutex lock/unlock.
   Normally, this is implemented using a member of type `mutex_family::mutex_type`, but
   it could be done using atomic instructions or lock free algorithms.

*  The [*deallocate()] function must make the returned buffer available for new 
   allocations. This function should offer the same synchronization as `allocate()`.

*  The [*size()] function will return the passed [*size] parameter in the constructor. 
   So, *my_algorithm* should store the size internally.

*  The [*grow()] function will expand the managed memory by [*my_algorithm] in [*extra_size]
   bytes. So [*size()] function should return the updated size,
   and the new managed memory range will be (if the address where the algorithm is
   constructed is XXX): [*[XXX + sizeof(my_algorithm) + extra_hdr_bytes, XXX + old_size + extra_size)].
   This function should offer the same synchronization as `allocate()`.

That's it. Now we can create new managed shared memory that uses our new algorithm:

[c++]

   //Managed memory segment to allocate named (c-string) objects
   //using a user-defined memory allocation algorithm
   basic_managed_shared_memory<char, 
                            ,my_algorithm
                            ,flat_map_index>  
      my_managed_shared_memory;

[endsect]

[endsect]

[section:custom_allocators Building custom STL compatible allocators for Boost.Interprocess]

If provided STL-like allocators don't satisfy user needs, the user 
can implement another STL compatible allocator using raw memory allocation 
and named object construction functions. 
The user can this way implement more suitable allocation 
schemes on top of basic shared memory allocation schemes, 
just like more complex allocators are built on top of 
new/delete functions.

When using a managed memory segment, [*get_segment_manager()]
function returns a pointer to the segment manager. With this pointer,
the raw memory allocation and named object construction functions can be 
called directly:

[c++]

   //Create the managed shared memory and initialize resources
   managed_shared_memory segment
      (create_only
      ,"/MySharedMemory"   //segment name
      ,65536);             //segment size in bytes
                  
   //Obtain the segment manager
   managed_shared_memory::segment_manager *segment_mngr 
      = segment.get_segment_manager();

   //With the segment manager, now we have access to all allocation functions
   segment_mngr->deallocate(segment_mngr->allocate(32));
   segment_mngr->construct<int>("My_Int")[32](0);
   segment_mngr->destroy<int>("My_Int");

   //Initialize the custom, managed memory segment compatible 
   //allocator with the segment manager.
   //
   //MySTLAllocator uses segment_mngr->xxx functions to 
   //implement its allocation scheme
   MySTLAllocator<int> stl_alloc(segment_mngr);

   //Alias a new vector type that uses the custom STL compatible allocator
   typedef std::vector<int, MySTLAllocator<int> > MyVect;

   //Construct the vector in shared memory with the allocator as constructor parameter
   segment.construct<MyVect>("MyVect_instance")(stl_alloc);

The user can create new STL compatible allocators that use the segment manager to access
to all memory management/object construction functions. All [*Boost.Interprocess]' STL
compatible allocators are based on this approach. [*Remember] that to be compatible with 
managed memory segments, allocators should define their *pointer* typedef as the same
pointer family as `segment_manager::void_pointer` typedef. This means that if `segment_manager::void_pointer` is
`offset_ptr<void>`, `MySTLAllocator<int>` should define `pointer` as `offset_ptr<int>`. The
reason for this is that allocators are members of containers, and if we want to put
the container in a managed memory segment, the allocator should be ready for that.

If the user wants to optimize further allocator usage in [*Boost.Interprocess] node
containers, he can change the common allocator::construct function from:

[c++]

   void construct(pointer ptr, const value_type &value);

to this one:

[c++]

   template<class Convertible>
   void construct(pointer ptr, const Convertible &value)

and define a specialization of `boost::interprocess::has_convertible_construct<...>` 
defined in `<boost/interprocess/detail/utilities.hpp>` file:

[c++]

   namespace boost{ namespace interprocess{ 

   template<class T, class SegmentManager>
   struct has_convertible_construct
      <my_allocator<T, SegmentManager> >
   {
      enum {   value = true };
   };

   }} //namespace boost{ namespace interprocess{ 

Using this optimization, [*Boost.Interprocess] node containers will just store one allocator instance
instead of 2, because nodes could be constructed from the value type directly.
[*Boost.Interprocess] STL-like allocators implement this optimization.

[endsect]

[section:custom_indexes Building custom indexes]

The managed memory segment uses a name/object index to
speed up object searching and creation. Default specializations of 
managed memory segments (`managed_shared_memory` for example),
use `boost::interprocess::flat_map` as index.

However, the index type can be chosen via template parameter, so that
the user can define its own index type if he needs that. To construct
a new index type, the user must create a class with the following guidelines:

* The interface of the index must follow the common public interface of std::map
  and std::tr1::unordered_map including public typedefs. 
  The `value_type` typedef can be of type:

[c++]

   std::pair<key_type, mapped_type> 

or 

[c++]

   std::pair<const key_type, mapped_type>


so that ordered arrays or deques can be used as index types. 
Some known classes following this basic interface are `boost::unordered_map`, 
`boost::interprocess::flat_map` and `boost::interprocess::map`.

* The class must be a class template taking only a traits struct of this type:

[c++]

   struct index_traits
   {
      typedef /*...*/   key_type;
      typedef /*...*/   mapped_type;
      typedef /*...*/   segment_manager;
   };

[c++]

   template <class IndexTraits>
   class my_index_type;

The `key_type` typedef of the passed `index_traits` will be a specialization of the
following class:
            
[c++]

   /*!The key of the the named allocation information index. Stores a to
      a null string and the length of the string to speed up sorting*/
   template<...>
   struct index_key
   {
      typedef /*...*/                              char_type;
      typedef /*...*/                              const_char_ptr_t;

      //Pointer to the object's name (null terminated)
      const_char_ptr_t                             mp_str;

      //Length of the name buffer (null NOT included)
      std::size_t                                  m_len;

      /*!Constructor of the key*/
      index_key (const CharT *name, std::size_t length);

      /*!Less than function for index ordering*/
      bool operator < (const index_key & right) const;

      /*!Equal to function for index ordering*/
      bool operator == (const index_key & right) const;
   };

The `mapped_type` is not directly modified by the customized index but it is needed to 
define the index type. The *segment_manager* will be the type of the segment manager that
will manage the index. `segment_manager` will define interesting internal types like 
`void_pointer` or `mutex_family`.
            
* The constructor of the customized index type must take a pointer to segment_manager
  as constructor argument:

[c++]

   constructor(segment_manager *segment_mngr);

* The index must provide a memory reservation function, that optimizes the index if the 
  user knows the number of elements to be inserted in the index:

[c++]

   void reserve(std::size_t n);

For example, the default index type `flat_map_index` based in `boost::interprocess::flat_map` 
is just defined as:

[c++]

   namespace boost { namespace interprocess {

   /*!Helper class to define typedefs from IndexTraits*/
   template <class MapConfig>
   struct flat_map_index_aux
   {
      typedef typename MapConfig::key_type            key_type;
      typedef typename MapConfig::mapped_type         mapped_type;
      typedef typename MapConfig::segment_manager     segment_manager;
      typedef std::less<key_type>                     key_less;
      typedef std::pair<key_type, mapped_type>        value_type;
      typedef allocator<value_type, segment_manager>  allocator_type;
      typedef flat_map<key_type, mapped_type,
                       key_less, allocator_type>      index_t;
   };

   /*!Index type based in flat_map. Just derives from flat_map and
      defines the interface needed by the shared named object creation class.*/
   template <class MapConfig>
   class flat_map_index
      //Derive class from `flat_map` specialization
      : public flat_map_index_aux<MapConfig>::index_t
   {
      typedef flat_map_index_aux<MapConfig>        index_aux;
      typedef typename index_aux::index_t          base_type;
      typedef typename index_aux::segment_manager  segment_manager;

      public:
      /*!Constructor. Takes a pointer to the
         segment manager. Can throw*/
      flat_map_index(segment_manager *segment_mngr)
         : base_type(typename index_aux::key_less(),
                     typename index_aux::allocator_type(segment_mngr))
      {}

      /*!This reserves memory to optimize the insertion of n
         elements in the index*/
      void reserve(std::size_t n)
      {  base_type::reserve(n);  }
   };

   }}   //namespace boost { namespace interprocess

If the user is defining a node container based index (a container whose iterators 
are not invalidated when inserting or erasing other elements), [*Boost.Interprocess] can
optimize named object destruction when destructing via pointer. [*Boost.Interprocess] can
store an iterator next to the object and instead of using the name of the object to erase 
the index entry, it uses the iterator, which is a faster operation. So if you are creating
a new node container based index (for example, a tree), you should define an
specialization of `boost::interprocess::is_node_index<...>` defined in 
`<boost/interprocess/detail/utilities.hpp>`:

[c++]

   /*!Trait classes to detect if an index is a node
      index. This allows more efficient operations
      when deallocating named objects.*/
   template<class MapConfig>
   struct is_node_index
      <my_index<MapConfig> >
   {
      enum {   value = true };
   };

Interprocess also defines other index types:

* [*boost::map_index] uses *boost::interprocess::map* as index type.

* [*boost::null_index] that uses an dummy index type if the user just needs
  anonymous allocations and want's to save some space and class instantations.

Defininge a new managed memory segment that uses the new index is easy. For
example, a new managed shared memory that uses the new index:

[c++]

   /*!Defines a managed shared memory with a c-strings as 
      a keys, the simple sequential fit algorithm (with process-shared mutexes
      and offset_ptr pointers) as raw shared memory management algorithm
      and a custom index*/
   typedef 
      basic_managed_shared_memory < 
                                 char, 
                                 simple_seq_fit<mutex_family>,
                                 my_index_type
                                >  
      my_managed_shared_memory;

[endsect]

[endsect]

[section:streams Direct iostream formatting: vectorstream and bufferstream]

Shared memory, memory-mapped files and all [*Boost.Interprocess] mechanisms are focused
on efficiency. The reason why shared memory is used is that it's the
fastest IPC mechanism available. When passing text-oriented messages through
shared memory, there is need to format the message. Obviously C++ offers
the iostream framework for that work.

Some programmers appreciate the iostream safety and design for memory
formatting but feel that the stringstream family is far from efficient not
when formatting, but when obtaining formatted data to a string, or when 
setting the string from which the stream will extract data. An example:

[c++]

   //Some formatting elements
   std::string my_text = "...";
   int number;
   
   //Data reader
   std::istringstream input_processor;
   
   //This makes a copy of the string. If not using a
   //reference counted string, this is a serious overhead.
   input_processor.str(my_text);

   //Extract data
   while(/*...*/){
      input_processor >> number;
   }
   
   //Data writer
   std::ostringstream output_processor;
   
   //Write data
   while(/*...*/){
      output_processor << number;
   }
   
   //This returns a temporary string. Even with return-value
   //optimization this is expensive.
   my_text = input_processor.str();

The problem is even worse if the string is a shared-memory string, because
to extract data, we must copy the data first from shared-memory to a 
std::string and then to a stringstream. To encode data in a shared-memory
string we should copy data from a stringstream to a std::string and then 
to the shared-memory string. 

Because of this overhead, [*Boost.Interprocess] offers a way to format memory-strings
(in shared memory, memory mapped files or any other memory segment) that
can avoid all unneeded string copy and memory allocation/deallocation, while
using all iostream facilities. [*Boost.Interprocess] *vectorstream* and *bufferstream* implement
vector-based and fixed-size buffer based storage support for iostreams and
all the formatting/locale hard work is done by standard std::basic_streambuf<>
and std::basic_iostream<> classes.

[section:vectorstream Formatting directly in your character vector: vectorstream]

The *vectorstream* class family (*basic_vectorbuf*, *basic_ivectorstream*
,*basic_ovectorstream* and *basic_vectorstream*) is an efficient way to obtain 
formatted reading/writing directly in a character vector. This way, if
a shared-memory vector is used, data is extracted/written from/to the shared-memory
vector, without additional copy/allocation. We can see the declaration of 
basic_vectorbuf and basic_vectorstream here:

[c++]

   /*!A streambuf class that controls the transmission of elements to and from
      a basic_ivectorstream, basic_ovectorstream or basic_vectorstream. 
      It holds a character vector specified by CharVector template parameter
      as its formatting buffer. The vector must have contiguous storage, like 
      std::vector, boost::interprocess::vector or boost::interprocess::basic_string*/
   template <class CharVector, class CharTraits = 
            std::char_traits<typename CharVector::value_type> >
   class basic_vectorbuf 
      : public std::basic_streambuf<typename CharVector::value_type, CharTraits>
   {
      public:
      typedef CharVector                        vector_type;
      typedef typename CharVector::value_type   char_type;
      typedef typename CharTraits::int_type     int_type;
      typedef typename CharTraits::pos_type     pos_type;
      typedef typename CharTraits::off_type     off_type;
      typedef CharTraits                        traits_type;

      /*!Constructor. Throws if vector_type default constructor throws.*/
      explicit basic_vectorbuf(std::ios_base::openmode mode
                                 = std::ios_base::in | std::ios_base::out);

      /*!Constructor. Throws if vector_type(const Parameter &param) throws.*/
      template<class Parameter>
      explicit basic_vectorbuf(const Parameter &param,
                              std::ios_base::openmode mode
                                    = std::ios_base::in | std::ios_base::out);
      virtual ~basic_vectorbuf(){}

      /*!Swaps the underlying vector with the passed vector. 
         This function resets the position in the stream.
         Does not throw.*/
      void swap_vector(vector_type &vect);

      /*!Returns a const reference to the internal vector.
         Does not throw.*/
      const vector_type &vector() const;

      /*!Calls resize() method of the internal vector.
         Resets the stream to the first position.
         Throws if the internals vector's resize throws.*/
      void resize(typename vector_type::size_type size);
   };

   /*!A basic_iostream class that holds a character vector specified by CharVector
      template parameter as its formatting buffer. The vector must have
      contiguous storage, like std::vector, boost::interprocess::vector or
      boost::interprocess::basic_string*/
   template <class CharVector, class CharTraits = 
            std::char_traits<typename CharVector::value_type> >
   class basic_vectorstream 
   : public std::basic_iostream<typename CharVector::value_type, CharTraits>

   {
      public:
      typedef CharVector                                                   vector_type;
      typedef typename std::basic_ios
         <typename CharVector::value_type, CharTraits>::char_type          char_type;
      typedef typename std::basic_ios<char_type, CharTraits>::int_type     int_type;
      typedef typename std::basic_ios<char_type, CharTraits>::pos_type     pos_type;
      typedef typename std::basic_ios<char_type, CharTraits>::off_type     off_type;
      typedef typename std::basic_ios<char_type, CharTraits>::traits_type  traits_type;

      /*!Constructor. Throws if vector_type default constructor throws.*/
      basic_vectorstream(std::ios_base::openmode mode 
                        = std::ios_base::in | std::ios_base::out);

      /*!Constructor. Throws if vector_type(const Parameter &param) throws.*/
      template<class Parameter>
      basic_vectorstream(const Parameter &param, std::ios_base::openmode mode
                        = std::ios_base::in | std::ios_base::out);

      ~basic_vectorstream(){}

      //Returns the address of the stored stream buffer.
      basic_vectorbuf<CharVector, CharTraits>* rdbuf() const;

      /*!Swaps the underlying vector with the passed vector. 
         This function resets the position in the stream.
         Does not throw.*/
      void swap_vector(vector_type &vect);

      /*!Returns a const reference to the internal vector.
         Does not throw.*/
      const vector_type &vector() const;

      /*!Calls resize() method of the internal vector.
         Resets the stream to the first position.
         Throws if the internals vector's resize throws.*/
      void resize(typename vector_type::size_type size);
   };

The vector type is templatized, so that we can use any type of vector:
*std::vector*, *boost::interprocess::vector*.... But the storage must be *contiguous*,
we can't use a deque. We can even use *boost::interprocess::basic_string*, since it has a 
vector interface and it has contiguous storage. *We can't use std::string*, because 
although some std::string implementation are vector-based, others can have 
optimizations and reference-counted implementations.

The user can obtain a const reference to the internal vector using 
`vector_type vector() const` function and he also can swap the internal vector
with an external one calling `void swap_vector(vector_type &vect)`. 
The swap function resets the stream position.
This functions allow efficient methods to obtain the formatted data avoiding
all allocations and data copies. 

Let's see an example to see how to use vectorstream:

[/ doc_vectorstream.cpp]

[c++]

   #include <boost/interprocess/containers/vector.hpp>
   #include <boost/interprocess/containers/string.hpp>
   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <boost/interprocess/streams/vectorstream.hpp>
   #include <iterator>
   
   using namespace boost::interprocess;

   typedef allocator<int, managed_shared_memory::segment_manager> 
      IntAllocator;
   typedef allocator<char, managed_shared_memory::segment_manager> 
      CharAllocator;
   typedef vector<int, IntAllocator>   MyVector;
   typedef basic_string
      <char, std::char_traits<char>, CharAllocator>   MyString;
   typedef basic_vectorstream<MyString>               MyVectorStream;

   int main ()
   {
      //Create shared memory
      shared_memory_object::remove("MySharedMemory");
      managed_shared_memory segment(
         create_only, 
         "MySharedMemory", //segment name
         65536);           //segment size in bytes

      //Construct shared memory vector
      MyVector *myvector = 
         segment.construct<MyVector>("MyVector")
         (IntAllocator(segment.get_segment_manager()));

      //Fill vector
      myvector->reserve(100);
      for(int i = 0; i < 100; ++i){
         myvector->push_back(i);
      }

      //Create the vectorstream. To create the internal shared memory
      //basic_string we need to pass the shared memory allocator as
      //a constructor argument
      MyVectorStream myvectorstream(CharAllocator(segment.get_segment_manager()));

      //Reserve the internal string
      myvectorstream.reserve(100*5);

      //Write all vector elements as text in the internal string
      //Data will be directly written in shared memory, because
      //internal string's allocator is a shared memory allocator
      for(std::size_t i = 0, max = myvector->size(); i < max; ++i){
         myvectorstream << (*myvector)[i] << std::endl;
      }

      //Auxiliary vector to compare original data
      MyVector *myvector2 =
         segment.construct<MyVector>("MyVector2")
         (IntAllocator(segment.get_segment_manager()));

      //Avoid reallocations
      myvector2->reserve(100);

      //Extract all values from the internal 
      //string directly to a shared memory vector.
      std::istream_iterator<int> it(myvectorstream), itend;
      std::copy(it, itend, std::back_inserter(*myvector2));

      //Compare vectors
      assert(std::equal(myvector->begin(), myvector->end(), myvector2->begin()));

      //Create a copy of the internal string
      MyString stringcopy (myvectorstream.vector());

      //Now we create a new empty shared memory string...
      MyString *mystring = 
         segment.construct<MyString>("MyString")
         (CharAllocator(segment.get_segment_manager()));
   
      //...and we swap vectorstream's internal string
      //with the new one: after this statement mystring
      //will be the owner of the formatted data.
      //No reallocations, no data copies
      myvectorstream.swap_vector(*mystring);

      //Let's compare both strings
      assert(stringcopy == *mystring);

      //Done, destroy and delete vectors and string from the segment
      segment.destroy_ptr(myvector2);
      segment.destroy_ptr(myvector);
      segment.destroy_ptr(mystring);
      return 0;
   }

   
[endsect]

[section:bufferstream Formatting directly in your character buffer: bufferstream]

As seen, vectorstream offers an easy and secure way for efficient iostream
formatting, but many times, we have to read or write formatted data from/to a
fixed size character buffer (a static buffer, a c-string, or any other).
Because of the overhead of stringstream, many developers (specially in 
embedded systems) choose sprintf family. The *bufferstream* classes offer 
iostream interface with direct formatting in a fixed size memory buffer with 
protection against buffer overflows. This is the interface:

   /*!A streambuf class that controls the transmission of elements to and from
      a basic_xbufferstream. The elements are transmitted from a to a fixed
      size buffer*/
   template <class CharT, class CharTraits = std::char_traits<CharT> >
   class basic_bufferbuf 
      : public std::basic_streambuf<CharT, CharTraits>
   {
      public:
      typedef CharT                             char_type;
      typedef typename CharTraits::int_type     int_type;
      typedef typename CharTraits::pos_type     pos_type;
      typedef typename CharTraits::off_type     off_type;
      typedef CharTraits                        traits_type;
      typedef std::basic_streambuf<char_type, traits_type> base_t;

      public:
      /*!Constructor. Does not throw.*/
      explicit basic_bufferbuf(std::ios_base::openmode mode
                               = std::ios_base::in | std::ios_base::out);

      /*!Constructor. Assigns formatting buffer. Does not throw.*/
      explicit basic_bufferbuf(CharT *buffer, std::size_t length, 
                               std::ios_base::openmode mode
                                 = std::ios_base::in | std::ios_base::out);

      /*!Returns the pointer and size of the internal buffer. 
         Does not throw.*/
      std::pair<CharT *, std::size_t> buffer() const;

      /*!Sets the underlying buffer to a new value. Does not throw.*/
      void buffer(CharT *buffer, std::size_t length);
   };

   /*!A basic_iostream class that uses a fixed size character buffer
      as its formatting buffer.*/
   template <class CharT, class CharTraits = std::char_traits<CharT> >
   class basic_bufferstream 
      : public std::basic_iostream<CharT, CharTraits>

   {
      public:                         // Typedefs
      typedef typename std::basic_ios
         <CharT, CharTraits>::char_type          char_type;
      typedef typename std::basic_ios<char_type, CharTraits>::int_type     int_type;
      typedef typename std::basic_ios<char_type, CharTraits>::pos_type     pos_type;
      typedef typename std::basic_ios<char_type, CharTraits>::off_type     off_type;
      typedef typename std::basic_ios<char_type, CharTraits>::traits_type  traits_type;
      
      /*!Constructor. Does not throw.*/
      basic_bufferstream(std::ios_base::openmode mode 
                        = std::ios_base::in | std::ios_base::out);

      /*!Constructor. Assigns formatting buffer. Does not throw.*/
      basic_bufferstream(CharT *buffer, std::size_t length,
                        std::ios_base::openmode mode
                           = std::ios_base::in | std::ios_base::out);

      /*!Returns the address of the stored stream buffer.*/
      basic_bufferbuf<CharT, CharTraits>* rdbuf() const;

      /*!Returns the pointer and size of the internal buffer. 
         Does not throw.*/
      std::pair<CharT *, std::size_t> buffer() const;

      /*!Sets the underlying buffer to a new value. Resets 
         stream position. Does not throw.*/
      void buffer(CharT *buffer, std::size_t length);
   };   

   //Some typedefs to simplify usage
   typedef basic_bufferbuf<char>        bufferbuf;
   typedef basic_bufferstream<char>     bufferstream;
   typedef basic_ibufferstream<char>    ibufferstream;
   typedef basic_obufferstream<char>    obufferstream;

   typedef basic_bufferbuf<wchar_t>     wbufferbuf;
   typedef basic_bufferstream<wchar_t>  wbufferstream;
   typedef basic_ibufferstream<wchar_t> wibufferstream;
   typedef basic_obufferstream<wchar_t> wobufferstream;

While reading from a fixed size buffer, *bufferstream* activates endbit flag if
we try to read an address beyond the end of the buffer. While writing to a
fixed size buffer, *bufferstream* will active the badbit flag if a buffer overflow
is going to happen and disallows writing. This way, the fixed size buffer 
formatting through *bufferstream* is secure and efficient, and offers a good 
alternative to sprintf/sscanf functions. Let's see an example:

[/doc_bufferstream.cpp]

[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <boost/interprocess/streams/bufferstream.hpp>
   #include <vector>
   #include <iterator>
   
   using namespace boost::interprocess;

   int main ()
   {
      shared_memory_object::remove("MySharedMemory");
      //Create shared memory
      managed_shared_memory segment(create_only
                                   ,"MySharedMemory"  //segment name
                                   ,65536);

      //Fill data
      std::vector<int> data, data2;
      data.reserve(100);
      for(int i = 0; i < 100; ++i){
         data.push_back(i);
      }

      //Allocate a buffer in shared memory to write data
      char *my_cstring = 
         segment.construct<char>("MyCString")[100*5](0);
      bufferstream mybufstream(my_cstring, 100*5);

      //Now write data to the buffer
      for(int i = 0; i < 100; ++i){
         mybufstream << data[i] << std::endl;
      }

      //Check there was no overflow attempt
      assert(mybufstream.good());

      //Extract all values from the shared memory string
      //directly to a vector.
      data2.reserve(100);
      std::istream_iterator<int> it(mybufstream), itend;
      std::copy(it, itend, std::back_inserter(data2));

      //This extraction should have ended will fail error since 
      //the numbers formatted in the buffer end before the end
      //of the buffer. (Otherwise it would trigger eofbit)
      assert(mybufstream.fail());

      //Compare data
      assert(std::equal(data.begin(), data.end(), data2.begin()));

      //Clear errors and rewind
      mybufstream.clear();
      mybufstream.seekp(0, std::ios::beg);
      
      //Now write again the data trying to do a buffer overflow
      for(int i = 0; i < 500; ++i){
         mybufstream << data[i] << std::endl;
      }

      //Now make sure badbit is active
      //which means overflow attempt.
      assert(!mybufstream.good());
      assert(mybufstream.bad());
      segment.destroy_ptr(my_cstring);      
      return 0;
   }

As seen, *bufferstream* offers an efficient way to format data without any 
allocation and extra copies. This is very helpful in embedded systems, or
formatting inside time-critical loops, where stringstream extra copies would
be too expensive. Unlike sprintf/sscanf, it has protection against buffer
overflows. As we know, according to the *Technical Report on C++ Performance*, 
it's possible to design efficient iostreams for embedded platforms, so this 
bufferstream class comes handy to format data to stack, static or shared memory
buffers.

[endsect]

[endsect]

[section:interprocess_smart_ptr Boost.Interprocess ownership smart pointers]

C++ users know the importance of ownership smart pointers when dealing with resources.
Boost offers a wide range of such type of pointers: `intrusive_ptr<>`,
`scoped_ptr<>`, `shared_ptr<>`...

When building complex shared memory/memory mapped files structures, programmers
would like to use also the advantages of these smart pointers. The problem is that
Boost and C++ TR1 smart pointers are not ready to be used for shared memory. The cause 
is that those smart pointers contain raw pointers and they use virtual functions,
something that is not possible if you want to place your data in shared memory.
The virtual function limitation makes even impossible to achieve the same level of
functionality of Boost and TR1 with [*Boost.Interprocess] smart pointers. 

Interprocess ownership smart pointers are mainly "smart pointers contaning smart pointers",
so we can specify the pointer type they contain.

[section:intrusive_ptr Intrusive pointer]

`boost::interprocess::intrusive_ptr<>` is the generalization of `boost::intrusive_ptr<>`
to allow non-raw pointers as intrusive pointer members. As the known 
`boost::intrusive_ptr` we must specify the pointee type but we also must also specify 
the pointer type to be stored in the intrusive_ptr:

[c++]

   /*!The intrusive_ptr class template stores a pointer to an object
      with an embedded reference count. intrusive_ptr is parameterized on
      T (the type of the object pointed to) and VoidPointer(a void pointer type 
      that defines the type of pointer that intrusive_ptr will store).
      intrusive_ptr<T, void *> defines a class with a T* member whereas
      intrusive_ptr<T, offset_ptr<void> > defines a class with a offset_ptr<T> member.
      Relies on unqualified calls to:
       
      void intrusive_ptr_add_ref(T * p);
      void intrusive_ptr_release(T * p);

      with (p != 0)

      The object is responsible for destroying itself.*/
   template<class T, class VoidPointer>
   class intrusive_ptr
   {
      public:
      /*!Provides the type of the internal stored pointer.*/
      typedef typename /*...*/ pointer;
      /*!Provides the type of the stored pointer.*/
      typedef T element_type;

      /*!Constructor. Initializes internal pointer to 0. Does not throw*/
      intrusive_ptr();

      /*!Constructor. Copies pointer and if "p" is not zero and 
         "add_ref" is true calls intrusive_ptr_add_ref(get_pointer(p)).
         Does not throw*/
      intrusive_ptr(const pointer &p, bool add_ref = true);

      /*!Copy constructor. Copies the internal pointer and if "p" is not
         zero calls intrusive_ptr_add_ref(get_pointer(p)). Does not throw*/
      intrusive_ptr(intrusive_ptr const & rhs);

      /*!Constructor from related. Copies the internal pointer and if "p" is not
         zero calls intrusive_ptr_add_ref(get_pointer(p)). Does not throw*/
      template<class U> intrusive_ptr (intrusive_ptr<U, VP> const & rhs);

      /*!Destructor. If internal pointer is not 0, calls
         intrusive_ptr_release(get_pointer(m_ptr)). Does not throw*/
      ~intrusive_ptr();

      /*!Assignment operator. Equivalent to intrusive_ptr(r).swap(*this). 
         Does not throw*/
      intrusive_ptr & operator=(intrusive_ptr const & rhs);

      /*!Assignment from related. Equivalent to intrusive_ptr(r).swap(*this). 
         Does not throw*/
      template<class U> intrusive_ptr & operator= (intrusive_ptr<U, VP> const & rhs);

      /*!Assignment from pointer. Equivalent to intrusive_ptr(r).swap(*this). 
         Does not throw*/
      intrusive_ptr & operator=(pointer rhs);
      
      /*!Returns a reference to the internal pointer. Does not throw*/
      pointer &get();

      /*!Returns a reference to the internal pointer. Does not throw*/
      const pointer &get() const;

      /*!Returns *get(). Does not throw*/
      T & operator*() const;

      /*!Returns *get(). Does not throw*/
      const pointer &operator->() const;

      /*!Returns get(). Does not throw*/
      pointer &operator->();

      operator unspecified_bool_type () const;

      /*!Not operator. Does not throw*/
      bool operator! () const;

      /*!Exchanges the contents of the two smart pointers. Does not throw*/
      void swap(intrusive_ptr & rhs);
   };

So `boost::interprocess::intrusive_ptr<MyClass, void*>` is equivalent to 
`boost::instrusive_ptr<MyClass>`. But if we want to place the intrusive_ptr in 
shared memory we must specify a relative pointer type like 
`boost::interprocess::intrusive_ptr<MyClass, boost::interprocess::offset_ptr<void> >`

[/doc_intrusive.cpp]

[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <boost/interprocess/smart_ptr/intrusive_ptr.hpp>

   using namespace boost::interprocess;

   namespace N {

   //A class that has an internal reference count
   class reference_counted_class
   {
      private:
      //Non-copyable
      reference_counted_class(const reference_counted_class  &);
      //Non-assignable
      reference_counted_class & operator=(const reference_counted_class &);
      //A typedef to save typing
      typedef managed_shared_memory::segment_manager segment_manager;
      //This is the reference count
      unsigned int m_use_count;
      //The segment manager allows deletion from shared memory segment
      offset_ptr<segment_manager> mp_segment_manager;
   
      public:
      //Constructor
      reference_counted_class(segment_manager *s_mngr)
      : m_use_count(0), mp_segment_manager(s_mngr){}
      //Destructor
      ~reference_counted_class(){}

      public:
      //Returns the reference count
      unsigned int use_count() const
      {  return m_use_count;   }
      //Adds a reference
      inline friend void intrusive_ptr_add_ref(reference_counted_class * p)
      {  ++p->m_use_count; }
      //Releases a reference
      inline friend void intrusive_ptr_release(reference_counted_class * p)
      {  if(--p->m_use_count == 0)  p->mp_segment_manager->destroy_ptr(p); }
   };

   }  //namespace N {

   //A class that has an intrusive pointer to reference_counted_class
   class intrusive_ptr_owner
   {
      typedef intrusive_ptr<N::reference_counted_class, 
                            offset_ptr<void> > intrusive_ptr_t;
      intrusive_ptr_t m_intrusive_ptr;

      public:
      //Takes a pointer to the reference counted class
      intrusive_ptr_owner(N::reference_counted_class *ptr) 
         : m_intrusive_ptr(ptr){}
   };

   int main ()
   {
      shared_memory_object::remove("my_shmem");
      //Create shared memory
      managed_shared_memory shmem(create_only, "my_shmem", 10000);
      //Create the unique reference counted object in shared memory
      N::reference_counted_class *ref_counted = 
         shmem.construct<N::reference_counted_class>
            ("ref_counted")(shmem.get_segment_manager());
      //Create an array of ten intrusive pointer owners in shared memory
      intrusive_ptr_owner *intrusive_owner_array = 
         shmem.construct<intrusive_ptr_owner>
            (anonymous_instance)[10](ref_counted);
      //Now test that reference count is ten
      if(ref_counted->use_count() != 10)
         return 1;

      //Now destroy the array of intrusive pointer owners
      //This should destroy every intrusive_ptr and because of
      //that reference_counted_class will be destroyed
      shmem.destroy_ptr(intrusive_owner_array);

      //Now the reference counted object should have been destroyed
      if(shmem.find<intrusive_ptr_owner>("ref_counted").first)
         return 1;
      //Success!
      return 0;
   }

[endsect]

[section:scoped_ptr Scoped pointer]

`boost::interprocess::scoped_ptr<>` is the big brother of `boost::scoped_ptr<>`, which
adds a custom deleter to specify how the pointer passed to the scoped_ptr must be destroyed.
Also, the `pointer` typedef of the deleter will specify the pointer type stored by scoped_ptr.

[c++]

   /*!scoped_ptr stores a pointer to a dynamically allocated object. 
      The object pointed to is guaranteed to be deleted, either on destruction
      of the scoped_ptr, or via an explicit reset. The user can avoid this
      deletion using release().
      scoped_ptr is parameterized on T (the type of the object pointed to) and 
      Deleter (the functor to be executed to delete the internal pointer).
      The internal pointer will be of the same pointer type as typename 
      Deleter::pointer type (that is, if typename Deleter::pointer is 
      offset_ptr<void>, the internal pointer will be offset_ptr<T>).*/
   template<class T, class Deleter>
   class scoped_ptr
   {
      public:

      /*!Provides the type of the stored pointer.*/
      typedef T element_type;

      /*!Provides the type of the internal stored pointer.*/
      typedef /*...*/ pointer;

      /*!Constructs a scoped_ptr, storing a copy of p(which can be 0) and d.
         Does not throw.*/
      explicit scoped_ptr(const pointer &p = 0, const Deleter &d = Deleter());

      /*!If the stored pointer is not 0, destroys the object pointed to by the stored pointer. 
         calling the operator() of the stored deleter.*/
      ~scoped_ptr();

      /*!Deletes the object pointed to by the stored pointer and then
         stores a copy of p. Never throws*/
      void reset(const pointer &p = 0);

      /*!Deletes the object pointed to by the stored pointer and then
         stores a copy of p and a copy of d.*/
      void reset(const pointer &p, const Deleter &d);

      /*!Assigns internal pointer as 0 and returns previous pointer. This will
         avoid deletion on destructor*/
      pointer release():

      /*!Returns a reference to the object pointed to by the stored pointer.
         Never throws.*/
      reference operator*() const;

      /*!Returns the internal stored pointer. Never throws*/
      pointer &operator->();

      /*!Returns the internal stored pointer. Never throws.*/
      const pointer &operator->() const;

      /*!Returns the stored pointer. Never throws.*/
      pointer & get();

      /*!Returns the stored pointer. Never throws.*/
      const pointer & get() const;

      /*!Returns true if the stored pointer is 0. Never throws.*/
      bool operator! () const;

      /*!Exchanges the internal pointer and deleter with other scoped_ptr
         Never throws.*/
      void swap(scoped_ptr & b);
   };
   
`scoped_ptr<>` comes handy to implement *rollbacks* with exceptions: if an exception 
is thrown or we call `return` in the scope of `scoped_ptr<>` the deleter is
automatically called so that *the deleter can be considered as a rollback* function.
If all goes well, we call `release()` member function to avoid rollback when
the `scoped_ptr` goes out of scope.

[/doc_scoped_ptr.cpp]

[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <boost/interprocess/smart_ptr/scoped_ptr.hpp>

   using namespace boost::interprocess;

   class my_class
   {};

   class my_exception
   {};

   //A functor that destroys the shared memory object
   template<class T>
   class my_deleter
   {
      private:
      //A typedef to save typing
      typedef managed_shared_memory::segment_manager segment_manager;
      //This my_deleter is created in the stack, not in shared memory,
      //so we can use raw pointers
      segment_manager *mp_segment_manager;
   
      public:
      //This typedef will specify the pointer type that
      //scoped_ptr will store
      typedef T *pointer;
      //Constructor
      my_deleter(segment_manager *s_mngr)
      : mp_segment_manager(s_mngr){}

      void operator()(pointer object_to_delete)
      {  mp_segment_manager->destroy_ptr(object_to_delete);  }
   };

   int main ()
   {
      //Create shared memory
      shared_memory_object::remove("my_shmem");
      managed_shared_memory shmem(create_only, "my_shmem", 10000);

      //In the first try, there will be no exceptions
      //in the second try we will throw an exception
      for(int i = 0; i < 2; ++i){
         //Create an object in shared memory
         my_class * my_object = shmem.construct<my_class>("my_object")();
         
         //Since the next shared memory allocation can throw
         //assign it to a scoped_ptr so that if an exception occurs
         //we destroy the object automatically
         my_deleter<my_class> d(shmem.get_segment_manager());

         try{
            scoped_ptr<my_class, my_deleter<my_class> > s_ptr(my_object, d);
            //Let's emulate a exception capable operation
            //In the second try, throw an exception
            if(i == 1){
               throw(my_exception());
            }
            //If we have passed the dangerous zone
            //we can release the scoped pointer
            //to avoid destruction
            s_ptr.release();
         }
         catch(const my_exception &){}

         //Here, scoped_ptr is destroyed
         //so it we haven't thrown an exception
         //the object should be there, otherwise, destroyed
         if(i == 0){
            //Make sure the object is alive
            if(!shmem.find<my_class>("my_object").first){
               return 1;
            }
            //Now we can use it and delete it manually
            shmem.destroy<my_class>("my_object");
         }
         else{
            //Make sure the object has been deleted
            if(shmem.find<my_class>("my_object").first){
               return 1;
            }
         }
      }
      return 0;
   }

[endsect]

[endsect]

[section:architecture Boost.Interprocess architecture and internals]

[section:basic_guidelines Basic guidelines]

When building [*Boost.Interprocess] architecture, I took some basic guidelines that can be
resumed in these points:

*  [*Boost.Interprocess] should be portable at least in UNIX and Windows systems. That
   means unifying not only interfaces but also behaviour. This is why
   [*Boost.Interprocess] has chosen kernel or filesystem persistence for shared memory
   and named synchronization mechanisms. Process persistence for shared memory is also
   desirable but it's difficult to achieve in UNIX systems.

*  [*Boost.Interprocess] inter-process synchronization primitives should be equal to thread 
   synchronization primitives. [*Boost.Interprocess] aims to define interface as the C++
   standard thread API.

*  [*Boost.Interprocess] architecture should be modular, customizable but efficient. That's
   why [*Boost.Interprocess] is based on templates and memory algorithms, index types,
   mutex types and other classes are templatizable.

*  [*Boost.Interprocess] architecture should allow the same concurrency as thread based
   programming. Different mutual exclusion levels are defined so that a process
   can concurrently allocate raw memory when expanding a shared memory vector while another
   process can be safely searching a named object.

*  [*Boost.Interprocess] containers know nothing about [*Boost.Interprocess]. All specific
   behaviour is contained in the STL-like allocators. That allows STL vendors to slightly
   modify (or better said, generalize) their standard container implementations and obtain
   a fully std::allocator and boost::interprocess::allocator compatible container. This also
   make [*Boost.Interprocess] containers compatible with standard algorithms.

Interprocess is built above 3 basic classes: a *memory algorithm* a *segment manager* and
a *managed memory segment*:

[endsect]

[section:architecture_memory_algorithm The memory algorithm]

The *memory algorithm* is an object that is placed in the first bytes of a 
shared memory/memory mapped file segment. The *memory algorithm* can return 
portions of that segment to users marking them as used and the user can return those
portions to the memory manager so that the memory manager mark them as free
again. There is an exception though, some bytes beyond the end of the memory
algorithm object, are reserved and can't be used for this dynamic allocation.
This "reserved" zone will be used to place other additional objects
in a well-known place.

To sum up, a *memory algorithm* has the same mission as malloc/free of
standard C library, but it just can return portions of the segment
where it is placed. The layout of a memory segment would be:

[c++]

   Layout of the memory segment:
    ____________ __________ ____________________________________________  
   |            |          |                                            | 
   |   memory   | reserved |  The memory algorithm will return portions | 
   | algorithm  |          |  of the rest of the segment.               | 
   |____________|__________|____________________________________________| 


The memory algorithm takes care of memory synchronizations, just like malloc/free
guarantees that two threads can call malloc/free at the same time. This is usually
achieved placing a process-shared mutex as a member of the memory algorithm. Take
in care that the memory algorithm knows *nothing* about the segment (if it is
shared memory, a shared memory file, etc.). For the memory algorithm the segment 
is just a fixed size memory buffer.

The *memory manager* is also a configuration point for the rest of the [*Boost.Interprocess] 
framework since it defines two basic types as member typedefs:

[c++]

   typedef /*implementation dependent*/ void_pointer;
   typedef /*implementation dependent*/ mutex_family;


The `void_pointer` typedef defines the pointer type that will be used in the
[*Boost.Interprocess] framework (segment manager, allocators, containers). If the memory
algorithm is ready to be placed in a shared memory/mapped file mapped in different base
addresses, this pointer type will be defined as `offset_ptr<void>` or a similar relative
pointer. If the memory algorithm will be used just with fixed address mapping,
`void_pointer` can be defined as `void*`.

The rest of the interface of a [*Boost.Interprocess] *memory algorithm* is described in 
[link interprocess.customizing_boost_interprocess.custom_interprocess_alloc Writing a new shared memory allocation algorithm] 
section. As memory algorithm examples, you can see the implementations
[@../../../../boost/interprocess/mem_algo/simple_seq_fit.hpp  boost::interprocess::simple_seq_fit] or
[@../../../../boost/interprocess/mem_algo/seq_fit.hpp  boost::interprocess::seq_fit] classes.

[endsect]

[section:architecture_segment_manager The segment manager]

The *segment manager*, is an object also placed in the first bytes of the
managed memory segment (shared memory, memory mapped file), that offers more
sofisticated services built above the [*memory algorithm]. How can [*both] the
segment manager and memory algorithm be placed in the beginning of the segment?
That's because the segment manager [*owns] the memory algorithm: The
truth is that the memory algorithm is [*embedded] in the segment manager:


[c++]

   The layout of managed memory segment:
    _______ _________________
   |       |         |       |
   | some  | memory  | other |<- The memory algorithm considers 
   |members|algorithm|members|   "other members" as reserved memory, so
   |_______|_________|_______|   it does not use it for dynamic allocation.
   |_________________________|____________________________________________
   |                         |                                            |
   |    segment manager      |  The memory algorithm will return portions |
   |                         |  of the rest of the segment.               |
   |_________________________|____________________________________________|


The segment manager initializes the memory algorithm and tells the memory 
manager that it should not use the memory where the rest of the 
segment manager's member are placed for dynamic allocations. The 
other members of the [*segment manager] are [*a recursive mutex]
(defined by the memory algorithm's [*mutex_family::recursive_mutex] typedef member),
and [*two indexes (maps)]: one to implement named allocations, and another one to
implement "unique instance" allocations. 

*  The first index is a map with a pointer to a c-string (the name of the named object) 
   as a key and a structure with information of the dynamically allocated object
   (the most importants being the address and the size of the object). 

*  The second index is used to implement "unique instances" 
   and is basically the same as the first index, 
   but the name of the object comes from a `typeid(T).name()` operation.

The memory needed to store [name pointer, object information] pairs in the index is 
allocated also via the *memory algorithm*, so we can tell that internal indexes
are just like ordinary user objects built in the segment. The rest of the memory
to store the name of the object, the object itself, and meta-data for 
destruction/deallocation is allocated using the *memory algorithm* in a single
`allocate()` call.

As seen, the segment manager knows *nothing* about shared memory/memory mapped files. 
The segment segment manager itself does not allocate portions of the segment, 
it just asks the *memory algorithm* to allocate the needed memory from the rest 
of the segment. The *segment manager* is a class built above the memory algorithm 
that offers named object construction, unique instance constructions, and many
other services.

The [*segment manager] is implemented in [*Boost.Interprocess] in 
[@../../../../boost/interprocess/detail/segment_manager.hpp boost::interprocess::segment_manager]
class.

[c++]

   template<class CharType 
           ,class MemoryAlgorithm
           ,template<class IndexConfig> class IndexType>
   class segment_manager;

As seen, the segment manager is quite generic: we can specify the character type
to be used to identify named objects, we can specify the memory algorithm that will
control dynamically the portions of the memory segment, and we can specify 
also the index type that will store the [name pointer, object information] mapping.
We can construct our own index types as explained in
[link interprocess.customizing_boost_interprocess.custom_indexes Building custom indexes] section.

[endsect]

[section:architecture_managed_memory Boost.Interprocess managed memory segments]

The [*Boost.Interprocess] managed memory segments that construct the shared memory/memory
mapped file, place there the segment manager and forward the user requests to the
segment manager. For example, [*boost::interprocess::basic_managed_shared_memory<...>]
is a [*Boost.Interprocess] managed memory segment that works with shared memory. 
[*boost::interprocess::basic_managed_mapped_file<...>] works with memory mapped files, etc...

Basically, the interface of a [*Boost.Interprocess] managed memory segment is the same as
the [*segment manager] but it also offers functions to "open", "create", or "open or create" 
shared memory/memory-mapped files segments and initialize all needed resources.
Managed memory segment classes are not built in shared memory or memory mapped files, they
are normal C++ classes that store a pointer to the segment manager (which are built
in shared memory or memory mapped files).

Apart from this, managed memory segments offer specific functions: `managed_mapped_file`
offers functions to flush memory contents to the file, `managed_heap_memory` offers
functions to expand the memory, etc...

Most of the functions of [*Boost.Interprocess] managed memory segments can be shared
between all managed memory segments, since many times they just forward the functions 
to the segment manager. Because of this,
in [*Boost.Interprocess] all managed memory segments derive from a common class that
implements memory-independent (shared memory, memory mapped files) functions:
[@../../../../boost/interprocess/detail/managed_memory_impl.hpp 
boost::interprocess::detail::basic_managed_memory_impl]

Deriving from this class, [*Boost.Interprocess] implements several managed memory
classes, for different memory backends:

* [@../../../../boost/interprocess/managed_shared_memory.hpp boost::interprocess::basic_managed_shared_memory] (for shared memory),
* [@../../../../boost/interprocess/managed_mapped_file.hpp boost::interprocess::basic_managed_mapped_file] (for memory mapped files),
* [@../../../../boost/interprocess/managed_heap_memory.hpp boost::interprocess::basic_managed_heap_memory] (for heap allocated memory),
* [@../../../../boost/interprocess/managed_external_buffer.hpp boost::interprocess::basic_managed_external_buffer] (for user provided memory buffer),

[endsect]

[section:architecture_allocators Boost.Interprocess allocators]

The [*Boost.Interprocess] STL-like allocators are fairly simple and follow the usual C++
allocator approach. Normally, allocators for STL containers are based above new/delete
operators and above those, they implement pools, arenas and other allocation tricks.

In [*Boost.Interprocess] allocators, the approach is similar, but all allocators are based
on the *segment manager*. The segment manager is the only one that provides from simple
memory allocation to named object creations. [*Boost.Interprocess] allocators always store
a pointer to the segment manager, so that they can obtain memory from the segment or share
a common pool between allocators.

As you can imagine, the member pointers of the allocator are not a raw pointers, but
pointer types defined by the `segment_manager::void_pointer` type. Apart from this,
the `pointer` typedef of [*Boost.Interprocess] allocators is also of the same type of
`segment_manager::void_pointer`.

This means that if our allocation algorithm defines `void_pointer` as `offset_ptr<void>`,
`boost::interprocess::allocator<T>` will store an `offset_ptr<segment_manager>`
to point to the segment manager and the `boost::interprocess::allocator<T>::pointer` type
will be `offset_ptr<T>`. This way, [*Boost.Interprocess] allocators can be placed in the
memory segment managed by the segment manager, that is, shared memory, memory mapped files,
etc...

[*Boost.Interprocess] implements basically two allocator approaches: normal and pooled.
All pooled allocators share most of the implementation. This common implementation is in 
[@../../../../boost/interprocess/allocators/detail/node_pool.hpp
boost::interprocess::detail::private_node_pool and boost::interprocess::detail::node_pool]
classes.

[endsect]

[section:architecture_containers Boost.Interprocess containers]

[*Boost.Interprocess] containers are standard conforming counterparts of STL containers
in boost::interprocess namespace, but with these little details:

*  [*Boost.Interprocess] STL containers don't assume that memory allocated with 
   an allocator can be deallocated with other allocator of 
   the same type. They always compare allocators with `operator==()`
   to know if this is possible.

*  The pointers of the internal structures of the [*Boost.Interprocess] containers are
   of the same type the `pointer` type defined by the allocator of the container. This
   allows placing containers in managed memory segments mapped in different base addresses.

*  All objects are constructed-destroyed via allocator::construct and 
   allocator::destroy functions.

[endsect]

[endsect]

[section:performance Performance of Boost.Interprocess]

This section tries to explain the performance characteristics of [*Boost.Interprocess],
so that you can optimize [*Boost.Interprocess] usage if you need more performance.

[section:performance_allocations Performance of raw memory allocations]

You can have two types of raw memory allocations with [*Boost.Interprocess] classes:

*  [*Explicit]: The user calls `allocate()` and  `deallocate()` functions of
   managed_shared_memory/managed_mapped_file... managed memory segments. This call is 
   translated to a `MemoryAlgorithm::allocate()` function, which means that you 
   will need just the time that the memory algorithm associated with the managed memory segment
   needs to allocate data. 

*  [*Implicit]: For example, you are using `boost::interprocess::allocator<...>` with
   [*Boost.Interprocess] containers. This allocator calls the same `MemoryAlgorithm::allocate()`
   function than the explicit method, [*every] time a vector/string has to reallocate its
   buffer or [*every] time you insert an object in a node container.

If you see that memory allocation is a bottleneck in your application, you have
these alternatives:

*  If you use map/set associative containers, try using `flat_map` family instead
   of the map family if you mainly do searches and the insertion/removal is mainly done
   in an initialization phase. The overhead is now when the ordered vector has to
   reallocate its storage and move data. You can also call the `reserve()` method
   of these containers when you know beforehand how much data you will insert.
   However in these containers iterators are invalidated in insertions so this
   substitution is only effective in some applications.
  
*  Use a [*Boost.Interprocess] pooled allocator for node containers, because pooled
   allocators call `allocate()` only when the pool runs out of nodes. This is pretty
   efficient (much more than the current default general-purpose algorithm) and this
   can save a lot of memory. See
   [link interprocess.stl_allocators Boost.Interprocess STL compatible allocators] to compare
   the [*Boost.Interprocess] node allocators and their trade-offs.

*  Write your own memory algorithm. If you have experience with memory allocation algorithms
   and you think another algorithm is better suited than the default one for your application,
   you can specify it in all [*Boost.Interprocess] managed memory segments. See the section
   [link interprocess.customizing_boost_interprocess.custom_interprocess_alloc Writing a new shared memory allocation algorithm]
   to know how to do this. If you think its better than the default one for general-purpose
   applications, be polite and donate it to [*Boost.Interprocess] to make it default!

[endsect]

[section:performance_named_allocation Performance of named allocations]

[*Boost.Interprocess] allows the same paralelism as two threads writing to a common
structure, except when the user creates/searches named/unique objects. The steps
when creating a named object are these:

*  Lock a recursive mutex (so that you can make named allocations inside
   the constructor of the object to be created).

*  Try to insert the [name pointer, object information] in the name/object index.
   This lookup has to assure that the name has not been used before.
   This is achieved calling `insert()` function in the index. So the time this
   requires is dependent on the index type (ordered vector, tree, hash...).
   This can require a call to the memory algorithm allocation function if
   the index has to be reallocated, it's a node allocator, uses pooled allocations...

*  Allocate a single buffer to hold the name of the object, the object itself,
   and meta-data for destruction (number of objects, etc...).

*  Call the constructors of the object being created. If it's an array, one
   construtor per array element.

*  Unlock the recursive mutex.

The steps when destroying a named object using the name of the object
(`destroy<T>(name)`) are these:

*  Lock a recursive mutex .

*  Search in the index the entry associated to that name. Copy that information and
   erase the index entry. This is done using `find(const key_type &)` and `erase(iterator)`
   members of the index. This can require element reordering if the index is a
   balanced tree, an ordered vector...

*  Call the destructor of the object (many if it's an array).

*  Deallocate the memory buffer containing the name, metadata and the object itself
   using the allocation algorithm.

*  Unlock the recursive mutex.

The steps when destroying a named object using the pointer of the object
(`destroy_ptr(T *ptr)`) are these:

*  Lock a recursive mutex .

*  Depending on the index type, this can be different:

   *  If the index is a node index, (marked with `boost::interprocess::is_node_index`
      specialization): Take the iterator stored near the object and call
      `erase(iterator)`. This can require element reordering if the index is a
      balanced tree, an ordered vector...

   *  If it's not an node index: Take the name stored near the object and erase
      the index entry calling `erase(const key &). This can require element reordering
      if the index is a balanced tree, an ordered vector...
      
*  Call the destructor of the object (many if it's an array).

*  Deallocate the memory buffer containing the name, metadata and the object itself
   using the allocation algorithm.

*  Unlock the recursive mutex.

If you see that the performance is not good enough you have these alternatives:

*  Maybe the problem is that the lock time is too big and it hurts paralelism.
   Try to reduce the number of named objects in the global index and if your
   application serves several clients try to build a new managed memory segment
   for each one instead of using a common one.

*  Use another [*Boost.Interprocess] index type if you feel the default one is
   not fast enough. If you are not still satisfied, write your own index type. See
   [link interprocess.customizing_boost_interprocess.custom_indexes Building custom indexes] for this.

*  Destruction via pointer is at least as fast as using the name of the object and
   can be faster (in node containers, for example). So if your problem is that you
   make at lot of named destructions, try to use the pointer. If the index is a
   node index you can save some time.

[endsect]

[endsect]

[section:future_improvements Future Improvements...]

There are some Interprocess features that I would like to implement and some
[*Boost.Interprocess] code that can be much better. Let's see some ideas:

[section:win32_sync Win32 synchronization is too basic]

Win32 version of shared mutexes and shared conditions are based on "spin and wait"
atomic instructions. This leads to poor performance and does not manage any issues
like priority inversions. We would need very serious help from threading experts on
this. And I'm not sure that this can be achieved in user-level software. Posix based
implementations use PTHREAD_PROCESS_SHARED attribute to place mutexes in shared memory,
so there are no such problems. I'm not aware of any implementation that simulates 
PTHREAD_PROCESS_SHARED attribute for Win32. We should be able to construct these
primitives in memory mapped files, so that we can get filesystem persistence just like
with POSIX primitives.

[endsect]

[section:default_algorithm Default allocation algorithm can be improved]

The default memory management algorithm used by [*Boost.Interprocess] to manage
the managed memory segment is a "first fit" algorithm. This could be changed
to a "best fit" algorithm to try to minimize fragmentation, but this would 
hurt performance if a list is used to mantain the free memory portions.
This can be solved with a tree-like free memory management, so that we can
search the best portion in logarithmic time. And we have to implement the
tree inside the given segment wasting minimum space. This seems complicated, 
but with the help of an intrusive tree implementation this can be achieved.

Suggestions and help from memory management experts are welcome!

[endsect]

[section:future_objectnames Use of wide character names on Boost.Interprocess basic resources]

Currently Interprocess only allows *char* based names for basic named 
objects. However, several operating systems use *wchar_t* names for resources 
(mapped files, for example). 
In the future Interprocess should try to present a portable narrow/wide char interface.
To do this, it would be useful to have a boost wstring <-> string conversion 
utilities to translate resource names (escaping needed characters
that can conflict with OS names) in a portable way. It would be interesting also 
the use of [*boost::filesystem] paths to avoid operating system specific issues.

[endsect]

[section:future_security Security attributes]

[*Boost.Interprocess] does not define security attributes for shared memory and
synchronization objects. Standard C++ also ignores security attributes with files
so adding security attributes would require some serious work.

[endsect]

[section:future_ipc Future inter-process communications]

[*Boost.Interprocess] offers a process-shared message queue based on
[*Boost.Interprocess] primitives like mutexes and conditions. I would want to
develop more mechanisms, like stream-oriented named fifo so that we can use it
with a iostream-interface wrapper (we can imitate Unix pipes).

C++ needs more complex mechanisms and it would be nice to have a stream and
datagram oriented PF_UNIX-like mechanism in C++. And for very fast inter-process 
remote calls Solaris doors is an interesting alternative to implement for C++.
But the work to implement PF_UNIX-like sockets and doors would be huge 
(and it might be difficult in a user-level library). Any network expert volunteer?

[endsect]

[section:future_containers Unordered associative containers and other containers]

We should be able to construct boost::unordered_xxx family in managed memory segments,
so that there is no code duplication in boost. So [*Boost.Interprocess] should cooperate
with boost container developers instead of duplicating effort writing it's own containers.

A very interesting project is making [*boost::multi_index] compatible with
[*Boost.Interprocess] ready for shared memory. This could be a good basis for memory
mapped data-bases. The work to achieve this, however, can be huge. It would be
interesting a collaboration with [*Intrusive] library to achieve shared memory
intrusive containers.

[endsect]

[section:future_move_semantics Move semantics]

Move semantics offer a great performance improvement in several areas and 
[*Boost.Interprocess] containers and a great place to implement them. This
way, managing vectors of strings in shared memory should be a lot cheaper
than the current copy semantics containers.

[endsect]


[endsect]

[section:thanks_to Thanks to...]

Many people have contributed with ideas and revisions, so this is the place to
thank them:

*  Thanks to all people who have shown interest in the library and have downloaded
   and tested the snapshots.

*  Thanks to [*Francis Andre] and [*Anders Hybertz] for their ideas and suggestions. 
   Many of them are not implemented yet but I hope to include them when library gets some stability.

*  Thanks to [*Hiang Swee Chiang], [*Phil Endecott], [*Rene Rivera],
   [*Harold Pirtle], [*Paul Ryan] [*Shumin Wu], [*Michal Wozniak], [*Peter Johnson]
   and [*Kim Barrett] for their bug fixes and library testing.

*  Thanks to [*Martin Adrian] who suggested the use of Interprocess framework for user defined buffers.

*  Thanks to [*Synge Todo] for his boostbook-doxygen patch to improve Interprocess documentation.

*  Thanks to [*Olaf Krzikalla] for his Intrusive library. I have taken some ideas to 
   improve red black tree implementation from his library.
      
*  Thanks to [*Daniel James] for his unordered_map/set family and his help with allocators.
   His great unordered implementation has been a reference to design exception safe containers.  

*  Thanks to [*Howard Hinnant] for his patience explaining allocator swapping,
   move semantics and for developing upgradable mutex and lock transfer features.

*  Thanks to [*Pavel Vozenilek] for his continuous review process, suggestions, code and 
   help. He is the major supporter of Interprocess library. The library has grown with his
   many and great advices.

*  And finally, thank you to all Boosters. *Long live to C++!*

[endsect]

[section:references References and interesting links]

Some useful references about C++ language, C++ internals, shared memory, 
allocators and containers, I've used to design Interprocess.

[section:references_books Books]

* Great book about multithreading, and POSIX: [*['"Programming with Posix Threads"]],
  [*David R. Butenhof]

* The UNIX inter-process bible: [*['"UNIX Network Programming, Volume 2: Interprocess Communications"]],
  [*W. Richard Stevens]

* Current STL allocator issues: [*['"Effective STL"]], [*Scott Meyers]

* My C++ bible: [*['"Thinking in C++, Volume 1 & 2"]], [*Bruce Eckel and Chuck Allison]

* The book every C++ programmer should read: [*['"Inside the C++ Object Model"]], [*Stanley B. Lippman]

* A must-read: [*['"ISO/IEC TR 18015: Technical Report on C++ Performance"]], [*ISO WG21-SC22 members.]

[endsect]

[section:references_links Links]

* A framework to put STL in shared memory: [@http://allocator.sourceforge.net/ ['"A C++ Standard Allocator for the Standard Template Library"] ]. 

* A design for instantiating C++ objects in shared memory: [@http://www.cs.ubc.ca/local/reading/proceedings/cascon94/htm/english/abs/hon.htm ['"Using objects in shared memory for C++ application"] ].

* A shared memory allocator and relative pointer: [@http://home.earthlink.net/~joshwalker1/writing/SharedMemory.html ['"Taming Shared Memory"] ].

[endsect]

[endsect]


[xinclude interprocess_doxygen.boostbook]
