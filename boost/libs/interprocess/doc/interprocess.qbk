[library Interprocess
    [version 1.0]
    [authors [Gazta&ntilde;aga, Ion]]
    [copyright 2005- 2006 Ion Gazta&ntilde;aga]
    [purpose Interprocess communication utilities]
    [license
         Distributed under the Boost Software License, Version 1.0.
         (See accompanying file LICENSE_1_0.txt or copy at
         <ulink url="http://www.boost.org/LICENSE_1_0.txt">
            http://www.boost.org/LICENSE_1_0.txt
         </ulink>)
    ]
    [last-revision $Date$]
]

[/ QuickBook Document version 1.1 ]

[section:intro Introduction]

Boost.Interprocess simplifies the use of common interprocess communication
and synchronization mechanisms and offers a wide range of them:

* Shared memory.
* Memory-mapped files.
* Semaphores, mutexes, condition variables and upgradable mutex types to place
  them in shared memory and memory mapped files.
* Named versions of those synchronization objects, similar to UNIX/Windows
  sem_open/CreateSemaphore API.
* File locking.
* Relative pointers.
* Message queues.

Boost.Interprocess also offers higher-level interprocess mechanisms, to allocate
dynamically portions of a shared memory or a memory mapped file (in general,
to allocate portions of a fixed size memory segment). Using these mechanisms,
Interprocess offers the tools to place STL-like containers in shared memory
and memory mapped files:

* Dynamic creation of anonymous and named objects in a shared memory or memory
  mapped file.
* STL-like containers compatible with shared memory/memory-mapped files.
* STL-like allocators ready for shared memory/memory-mapped files implementing
  several memory allocation patterns (like pooling).

[endsect]

[section:some_basic_explanations Some basic explanations]

[section:processes_and_threads Processes And Threads]

Boost.Interprocess does not work only with processes but also with threads.
Boost.Interprocess synchronization mechanisms are synchronize threads 
between from different processes, but also threads from the same process.

[endsect]

[section:sharing_information Sharing information between processes]

In the traditional programming model an operating system has multiple processes
running and each process has its own address space. To share information between
processes we have several alternatives:

* Two processes shared information using a [*file]. To access to the data, each
  process uses the usual file read/write mechanisms. When updating/reading
  a file shared between processes, we need some sort of synchronization, to
  protect readers from writers.

* Two processes share information that resides in the [*kernel] of the operating
  system. This is the case, for example, of traditional message queues. The
  synchronization is guaranteed by the operating system kernel.

* Two processes can share a [*memory] region. This is the case of classical
  shared memory or memory mapped files. Once the processes set up the
  memory region, the processes can read/write the data without like any
  other memory segment without calling the operating system's kernel. This
  also requieres some kind of synchronization between processes.

[endsect]

[section:persistence Persistance Of Interprocess Utilities]

One of the biggest issues with interprocess communication mechanisms is the lifetime.
It's important to know when an interprocess communication mechanism disappears from the
system. In Boost.Interprocess, we can have 3 types of persistence:

* [*Process-persistence]: The mechanism lasts until all the processes that have
  opened the mechanism close it, exit or crash.

* [*Kernel-persistence]: The mechanism exists until the kernel of the operating
  system reboots or the mechanism is explicitly deleted.

* [*Filesystem-persistence]: The mechanism exists until the mechanism is explicitly
  deleted.

Some native POSIX and Windows IPC mechanisms have different persistence so it's
difficult to achieve portability between Windows and POSIX native mechanisms. 
Boost.Interproces classes have the following persistence:

[table Boost.Interprocess Persistence Table
   [[Mechanism] [Persistence]]
   [[Shared memory]                 [At least, kernel]]
   [[Memory mapped file]            [Filesystem]]
   [[Process-shared mutex types]    [Process]]
   [[Process-shared semaphore]      [Process]]
   [[Process-shared condition]      [Process]]
   [[File lock]                     [Process]]
   [[Message queue]                 [At least, kernel]]
   [[Named mutex]                   [At least, kernel]]
   [[Named semaphore]               [At least, kernel]]
]

As you can see, Boost.Interprocess defines some mechanisms like "At least, kernel"
persistence. This is because POSIX allows this possibility to native interprocess
communication implementations. One could, for example, implement
shared memory using memory mapped files and obtain filesystem persistence (for example,
there is no proper known way to emulate kernel persistence with a user library
for Windows shared memory using native shared memory,
or process persistence for POSIX shared memory, so the only portable way is to 
define "At least, kernel" persistence).

[endsect]

[section:names Names Of Interprocess Mechanisms]

Some interprocess mechanisms are anonymous objects created in shared memory or
memory-mapped files but other interprocess mechanisms need a name or identifier
so that two unrelated processes can use the same interprocess mechanism object.
Examples of this are shared memory, named mutexes and named semaphores (for example,
native windows CreateMutex/CreateSemaphore API family).

The name used to identify a interprocess mechanism 

[endsect]

[endsect]

[section:quick_guide Quick Guide for the Impatient]

[section:qg_memory_pool Using shared memory as a pool of unnamed memory blocks]

You can just allocate a portion of a shared memory segment, copy the 
message to that buffer, send the offset of that portion of shared 
memory to another process, and you are done. Let's see the example:
     
[/include doc/doc_ipc_messageA.cpp]

[/ interprocess_doc_ipc_messageA.cpp]

[c++]


   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <cstddef>

   int main ()
   {
      using namespace boost::interprocess;

      //A shared memory front-end that is able to 
      //allocate raw memory buffers from a shared memory segment
      managed_shared_memory segment;

      //Create the shared memory segment and initialize needed resources
      if(!segment.create("/MySharedMemory",  //segment name
                        65536)){            //segment size in bytes
         return -1;
      }

      //Allocate a portion of the segment
      void * shptr   = segment.allocate(1024/*bytes to allocate*/);

      //An offset from the base address can identify any byte of the shared 
      //memory segment even if it is mapped in different base addresses
      std::ptrdiff_t offset = segment.get_offset_from_address(shptr);
      (void)offset;
      // Copy message to buffer
      // . . .
      // Send offset to other process
      // . . .
      // Wait response from other process
      // . . .

      //Deallocate the portion previously allocated
      segment.deallocate(shptr);
      return 0;
   }


In receiver process one just could write the following lines:

[/ interprocess_doc_ipc_messageB.cpp]
[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <cstddef>

   int main ()
   {
      using namespace boost::interprocess;

      //A shared memory front-end that is able to 
      //allocate raw memory buffers from a shared memory segment
      managed_shared_memory segment;

      //Connect to the shared memory segment and initialize needed resources
      if(!segment.open("/MySharedMemory")){  //segment name
         return -1;
      }

      //An offset from the base address can identify any byte of the shared 
      //memory segment even if it is mapped in different base addresses
      std::ptrdiff_t offset = 0;

      //Wait offset msg from the other process and put it in
      //"offset" local variable
      //Get buffer local address from offset
      void *msg = segment.get_address_from_offset(offset);
      (void)msg;
      //Do anything with msg
      //. . .
      //Send ack to sender process
      return 0;
   }

[endsect]


[section:qg_named_interprocess Creating named shared memory objects]

You want to create objects in a shared memory segment, giving a string name to them so that 
any other process can find, use and delete them from the segment when the objects are not 
needed anymore. Just write in one process:

[/ interprocess_doc_named_allocA ]
[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>

   int main ()
   {
      using namespace boost::interprocess;
      typedef std::pair<double, int> MyType;

      //A shared memory front-end that is able to construct 
      //objects associated with a c-string
      managed_shared_memory segment;

      //Create the shared memory segment and initialize resources
      if(!segment.create("/MySharedMemory",  //segment name
                         65536)){            //segment size in bytes
         return -1;
      }
                     

      //Create an object of MyType initialized to {0.0, 0}
      MyType *instance = segment.construct<MyType>
         ("MyType instance")  /*name of the object*/
         (0.0                 /*ctor first argument*/,
          0                   /*ctor second argument*/);    

      //Create an array of 10 elements of MyType initialized to {0.0, 0}
      MyType *array = segment.construct<MyType>
         ("MyType array")     /*name of the object*/
         [10]                 /*number of elements*/
         (0.0                 /*ctor first argument*/,
          0                   /*ctor second argument*/);    
      return 0;
   }

In other process, while the first process is alive, execute the following:

[/ interprocess_doc_named_allocB ]
[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <cstddef>
   #include <assert.h>

   int main ()
   {
      using namespace boost::interprocess;
      typedef std::pair<double, int> MyType;

      //A shared memory front-end that is able to construct 
      //objects associated with a c-string
      managed_shared_memory segment;

      //Connect to the shared memory segment and initialize resources
      if(!segment.open("/MySharedMemory")){
         return -1;
      }

      //Find the array and object
      std::pair<MyType*, std::size_t> res;
      res = segment.find<MyType> ("MyType array");   

      std::size_t array_len   = res.second;
      //Length should be 10
      assert(array_len == 10);

      //Find the array and the object
      res = segment.find<MyType> ("MyType instance");   

      std::size_t len   = res.second;

      //Length should be 1
      assert(len == 1);

      //Use data
      // . . . 

      //We're done, delete array from memory
      segment.destroy<MyType>("MyType array");

      //We're done, delete object from memory
      segment.destroy<MyType>("MyType instance");
      return 0;
   }


[endsect]

[section:qg_offset_ptr Using an offset smart pointer for shared memory]

Interprocess offers offset_ptr smart pointer family 
as an offset pointer that stores the distance between the address of 
the offset pointer itself and the address of the pointed object.  
When offset_ptr is placed in a shared memory segment, it 
can point safely objects stored in the same shared 
memory segment, even if the segment is mapped in 
different base addresses in different processes.

This allows placing objects with pointer members 
in shared memory. For example, if we want to create 
a linked list in shared memory:

[/ interprocess_doc_offset_ptr]
[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <boost/interprocess/offset_ptr.hpp>

   using namespace boost::interprocess;

   //Shared memory linked list node
   struct list_node
   {
      offset_ptr<list_node> next;
      int                   value;
   };

   int main ()
   {
      //Create shared memory
      managed_shared_memory segment;
      segment.create("/MySharedMemory",//segment name
                     65536);           //segment size in bytes

      //Create linked list with 10 nodes in shared memory
      offset_ptr<list_node> prev = 0, current, first;

      int i;
      for(i = 0; i < 10; ++i, prev = current){
         current = static_cast<list_node*>(segment.allocate(sizeof(list_node)));
         current->value = i;
         current->next  = 0;

         if(!prev)
            first = current;
         else
            prev->next = current;
      }

      //Communicate list to other processes
      //. . .
      //When done, destroy list
      for(current = first; current; /**/){
         prev = current;
         current = current->next
         segment.deallocate(prev.get());
      }
      return 0;
   }

To help with basic data structures, Interprocess offers containers like vector, list, map,
so you can avoid these manual data structures just like with standard containers.

[endsect]

[section:qg_interprocess_container Creating vectors in shared memory with different base addresses]

To place STL-compatible containers in shared memory, Interprocess allocators
define allocator<T>::pointer typedef as a relative pointer type, instead of T*.
Although the use of smart pointers is allowed by the standard, 
current STL implementations can't handle Interprocess shared memory STL 
compatible allocators. 

Until STL implementations fix this and for older STL owners, 
Interprocess provides STL compatible containers. 
All Interprocess containers can be safely placed 
in shared memory, if we obtain STL compatible 
shared memory allocators and pass them to the Interprocess containers
in constructors:
      
[c++]

   #include <boost/interprocess/containers/vector.hpp>
   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <algorithm>

   int main ()
   {
      using namespace boost::interprocess;

      //Shared memory front-end that is able to construct objects
      //associated with a c-string
      managed_shared_memory segment;

      //Create the memory segment and initialize resources
      if(!segment.create("/MySharedMemory",  //segment name
                         65536)){            //segment size in bytes
         return -1;
      }

      //Alias an STL compatible allocator of ints that allocates ints from the segment
      typedef allocator<int, managed_shared_memory::segment_manager> ShmemAllocator;

      //Alias a vector that uses the previous STL compatible allocator
      typedef boost::interprocess::vector<int, ShmemAllocator> MyVector;

      int initVal[] = {0, 1, 2, 3, 4, 5, 6 };
      const int *begVal    = initVal;
      const int *endVal    = initVal + sizeof(initVal)/sizeof(initVal[0]);

      //Initialize the STL compatible allocator
      const ShmemAllocator alloc_inst (segment.get_segment_manager());

      //Construct the vector in the shared memory segment with the STL compatible allocator 
      //from a range of iterators
      MyVector *myvector = 
         segment.construct<MyVector>
           ("MyVector")/*object name*/
           (begVal     /*first ctor parameter*/,
            endVal     /*second ctor parameter*/, 
            alloc_inst /*third ctor parameter*/); 

      //Use vector as your want
      std::sort(myvector->rbegin(), myvector->rend());
      // . . .
      //When done, destroy and delete vector from the segment
      segment.destroy<MyVector>("MyVector");
      return 0;
   }

[endsect]

[section:qg_mapping Using STL containers and mapping the memory at a fixed address]

By default, Interprocess maps the shared memory in an address chosen by the operating system, 
but you can change this. If your STL implementation is not compatible with Interprocess STL 
compatible allocators or if you prefer to use raw pointers instead of offset ones 
to obtain better performance (a offset pointer assignment needs a couple of arithmetic operations)
and forget about managing offset_ptr-s, you can specify the mapping address. To do this, 
you just have to create the shared memory passing the desired address in one process and 
use a Interprocess STL compatible allocator with a raw pointer as allocator::pointer typedef.

[c++]

   #include <vector>
   #include <boost/interprocess/managed_shared_memory.hpp>

   int main ()
   {
      using namespace boost::interprocess;
      //Shared memory front-end that is able to construct objects
      //associated with a c-string
      fixed_managed_shared_memory segment;

      //Create the memory segment at the specified address and initialize resources
      segment.create("/MySharedMemory",  //segment name
                     65536,              //segment size in bytes
                     (void*)0x03000000); //mapping address

      //Alias an STL compatible allocator of ints that allocates ints from the segment
      //and that defines allocator::pointer as "int *". This allocator will be compatible
      //with most STL implementations.
      typedef allocator<int, fixed_managed_shared_memory::segment_manager> 
         ShmemAllocator;

      //Alias a vector that uses the previous STL-like allocator
      typedef std::vector<int, ShmemAllocator> MyVector;

      //Initialize shared memory STL-compatible allocator
      const ShmemAllocator alloc_inst (segment.get_segment_manager());

      //Initialize vector
      MyVector *myvector = 
         segment.construct<MyVector>("MyVector") //object name
                                    (alloc_inst);//first ctor parameter 
      (void)myvector;
      return 0;
   }


Other process can open the segment and map it in the same 
address. The container can be found using the Interprocess 
framework. 
      
[c++]

   #include <vector>
   #include <boost/interprocess/managed_shared_memory.hpp>

   int main ()
   {
      using namespace boost::interprocess;
       //Shared memory front-end that is able to construct objects
      //associated with a c-string
      fixed_managed_shared_memory segment;

      //Open the memory segment at the specified address and initialize resources
      if(!segment.open("/MySharedMemory",    //segment name
                       (void*)0x03000000)){  //mapping address
         return -1;
      }

      //Alias an STL compatible allocator of ints that allocates ints from the segment
      //and that defines allocator::pointer as "int *". This allocator will be compatible
      //with most STL implementations.
      typedef allocator<int, fixed_managed_shared_memory::segment_manager> 
         ShmemAllocator;

      //Alias a vector that uses the previous STL-like allocator
      typedef std::vector<int, ShmemAllocator> MyVector;

      //Find the vector using the c-string name
      MyVector *myvector = segment.find<MyVector>("MyVector").first;

      //Use vector as you want
      std::sort(myvector->rbegin(), myvector->rend());
      // . . .

      //When done, destroy and delete vector
      segment.destroy<MyVector>("MyVector");
   }

[endsect]

[endsect]


[section:limitations Current limitations]

[section:growing_limitation Memory growth Limitation]

Interprocess wants to be portable across multiple operating systems
so that it can not count with an operating systems that maps shared
memory to the same base address in all processes in the system,
although it provides a way to map the shared memory in the same
base address.

However, without this capability, it is quite complicated to
design a growing shared memory allocator, one that allocates
new shared memory segments when a segment is full of objects.
For this reason, this first version of this library will be
limited to a shared memory segment, and its size must be
calculated beforehand by the user. If there is no more
memory, an exception will be thrown. This is very performance
friendly, but it is also a limiting factor. In near future, there
is a plan to add growing capacity to Interprocess.

[endsect]

[section:stl_limitation Problems with most STL implementations]

Since Interprocess does not count with same mapping address in
different processes for the same shared memory segment, it
must use a new, offset containing smart pointer. Many STL 
container implementations, suppose that
allocator::pointer type is a raw pointer, so they do not
allow Interprocess allocators to be used in those containers. Currently, I 
am not aware of any STL implementation that works with this smart 
pointer approach. Dinkumware STL from Visual .NET 2003 is very
close, but fails in some instantiations. libstdc++ and STLPort
use directly raw pointers in containers, and they don't pay 
attention to this allocator::pointer type. This is likely 
to change soon, as soon as containers start using allocators 
with pointer types different from T*.

To solve this, Interprocess provides some STL compliant
containers, that are ready to use with shared memory. 
These implementations, valid for both normal 
(std::)allocator and shared memory allocator, 
implement the techniques described in the
[link interprocess.stl_container_requirements "Container requirements for Interprocess allocators"]
section.

[endsect]

[section:offset_pointer Offset pointers instead of raw pointers]

When placing objects in shared memory and mapping
that memory in different segments in different processes,
raw pointers are a problem since they are only valid for
the process that placed them there. To solve this, Interprocess offers
an offset pointer that can be used instead of a raw pointer.

But user classes containing raw pointers (or Boost smart pointers, that 
internally own a raw pointer) can't be safely placed in shared memory. 
These pointers must be replaced with offset pointers, and these
pointers must point only to objects placed in the same memory
segment if you want to use these shared objects from different processes.

[endsect]

[section:references_forbidden References forbidden]

References suffer from the same problem as pointers 
(mainly because they are implemented as pointers).
However, it is not possible to create a fully workable 
smart reference currently in C++(for example,
"operator dot" can't be overloaded). Because of this,
if the user wants to put an object in shared memory, 
the object can't have any member (smart or not) reference.

References will only work if memory is mapped in the same
base address in all processes sharing a memory segment.

[endsect]

[section:virtuality_limitation Virtuality forbidden]

This is not an specific problem of Interprocess, it is a problem
for all shared memory object placing mechanisms.
The virtual table pointer and the virtual table
are in the address space of the process
that constructs the object, so if we place a class
with virtual function or inheritance, the virtual
function pointer placed in shared memory will be
invalid for other processes.

This problem would be very difficult to solve, since each process needs a 
different virtual table pointer and the object that contains tha pointer
is shared accross many processes.The virtual table pointer is the most 
common mechanism to implement virtual functions but it's implementation 
defined and can't be easily overwriten. Maybe even compiler help is needed 
for this. So Interprocess does not have any plan to support virtual function and 
virtual inheritance in shared memory.

[endsect]

[section:statics_warning Be careful with static class members]

Static members of classes are global objects shared by 
all instances of the class. Because of this, static
members are implemented as global variables in processes.

When constructing a class with static members, each process
has its own copy of the static member, so updating a static
member in one process does not change the value the other 
process has. So be careful with these classes. Static members
are not dangerous if they are just constant variables initialized
when the process starts, but they don't change at all (for example,
when used like enums).

[endsect]

[endsect]

[section:rationale Rationale]

[section:rationale_mutex Rationale for process-shared mutexes and interprocess_condition variables]

A shared memory segment is not itself very useful to share data between processes 
without synchronization primitives like mutexes and and interprocess_condition variables. Following
Boost.Thread's interface, Interprocess defines process-shared mutexes and interprocess_condition variables.

This interface follows Boost.Thread's interprocess_mutex and interprocess_condition variables' rationale, so 
that the constructors of interprocess_mutex and interprocess_condition can throw if the 
construction of the resource fails, and mutexes are used mainly with scoped locks.

However, currently it's not possible to reuse Boost Threads utilities like scoped 
locks and time functions (xtime time structure, functions to obtain time, etc...)
because Boost.Thread checks in headers if those headers are included in a 
multithreaded build. This is logical since Boost.Thread has no sense without
multithreaded builds, but with Interprocess two single-threaded processes can use
process-shared mutexes, so Boost.Thread locks and utilities don't allow this.

Because of this, Interprocess reproduces the needed scoped locks and time structures from
Boost.Thread in the boost::interprocess namespace. In the future, it would be logical to
share utilities and locks between Boost.Thread or Interprocess or even to move 
process-shared interprocess_mutex synchronization objects from Interprocess to Boost.Thread.

If Boost.Thread's model changes or C++ standarized interprocess_mutex and interprocess_condition variables
are published, process-shared interprocess_mutex and interprocess_condition variable should follow this change.


[endsect]

[section:rationale_containers Rationale for process-shared STL compatible containers]

One the most important features of Interprocess are the shared-memory STL compatible containers.
To make this possible, Interprocess makes use of standard allocator interface, so that
Interprocess STL compatible allocators define allocator::pointer as an offset pointer.

The standard allows allocator::pointer to be a smart pointer but allows 
implementations to ignore this and suppose allocator::pointer is equal to T*.
Most implementations tested don't support smart allocator::pointer approach, 
because in practice, all STL compatible allocators (like Boost.Pool) use T* as 
pointer typedef.

For this reason, Interprocess offers implementations of STL containers that can be placed
in shared memory. This implementations show how a STL compatible container can easily
be modified to use it in shared memory.

The allocator::pointer typedef is a type that provides a pointer to the type of 
object managed by the allocator. But the container can use internally pointers
not related to objects allocated with a STL compatible allocator, because the standard
says nothing about members. However, to place a container in shared memory, 
mapped in different base addresses across several processes, all member pointers 
of a containers must be offset pointers. This is why Interprocess offers a wide-range of
containers that can be safely placed in shared memory.

[endsect]

[endsect]

[section:concepts Concepts and definitions]

Interprocess uses some concepts that can be confusing: algorithm, allocator, memory, etc...
This section tries to clarify how these concepts are used in Interprocess:

* An *memory algorithm* is an object that takes control of one (or more) big memory 
segments and returns portions from them. The memory algorithm is built in the same
memory it controls (for example, in shared memory, if the memory algorithm returns
portions of shared memory).

* A *segment manager* is an object that *contains* a memory algorithm and offers
additional higher level services, like named allocations. The segment manager
is an object constructed in the same memory it manages. For example, if a segment
manager offers shared memory named allocations, the segment manager itself is
constructed in the shared memory.

* An *allocator* is a class that follows the STL-allocator interface and is
used to allocate memory portions for STL-like containers. In Interprocess, an allocator
usually contains a pointer to a *segment manager*, which is the one that
really implements the memory allocation. The *allocator* can implement more
complex strategies, like node pooling, using the services the *segment manager*
offers. In Interprocess, an allocator can be placed in the same memory as the *segment manager*,
that is, it can be placed in shared memory or memory mapped files.

*A *front-end* is a class that constructs/destroys the memory to be used (for 
example, shared memory) and places the *segment manager* there. It also *forwards* all
user requests to the *segment manager* (allocations, named allocations...).
The front-end is just an ordinary class that is not constructed in the same 
memory type of the *segment manager*, it's just a proxy to the segment manager.

*A *container* in Interprocess has the same meaning as STL containers. The difference is
that a Interprocess *container* is ready to be constructed in the same memory type as
the *segment manager* (shared memory, memory mapped files...)

[endsect]

[section:oswrappers Basic Interprocess classes]

These classes provide basic operating system resources to build higher
level inter-process communications. In named objects, like shared memory,
memory-mapped files, and named interprocess_semaphore and interprocess_mutex, the semantic of the
name used to construct the object is operating system dependent. All basic
objects in Interprocess share the same namespace, so a we can't create a named interprocess_mutex
called "MyObject" and shared memory called also "MyObject". The user should 
choose separate names for both objects.

[section:shared_memory Shared memory]

This class allows the creation, connection and destruction 
of a shared memory segment. 

[c++]

   /*!A class that wraps basic shared memory management*/
   class shared_memory : private boost::noncopyable
   {
   public:

      class segment_info_t
      {
       public:
         /*!Returns pointer to the shared memory fragment
            the user can overwrite*/
         void *      get_address() const;
         /*!Returns the size of the shared memory fragment
            the user can overwrite*/
         std::size_t get_size()const;
      };

      /*!Initializes members. Does not throw*/
      shared_memory();

      /*!Calls close. Does not throw*/
      ~shared_memory();

      /*!Creates a shared memory segment with name "name", with size "size".
         User can specify the mapping address. Never throws.*/
      bool create(const char *name,          std::size_t size, 
                  const void *addr = 0);

      /*!Creates a shared memory segment with name "name", with size "size".
         User can also specify the mapping address in "addr". Never throws.
         It also executes the functor "func" atomically if the segment is created.
         Functor has must have the following signature:

         bool operator()(const segment_info_t * info, bool created) const
         
         "info" is an initialized segment info structure, and "created" 
         must be "true". If the functor returns "false", an error is supposed
         and segment will be closed. The functor must not throw.
         */
      template <class Func>
      bool create_with_func(const char *name, std::size_t size, Func func,
                            const void *addr = 0);

      /*!Opens previously created shared memory segment with name "name". 
         If the memory segment was not previously created, 
         the function return false. User can specify the mapping address. 
         Never throws.*/
      bool open(const char *name, const void *addr = 0);

      /*!Opens previously created shared memory segment with name "name". 
         If the memory segment was not previously created, 
         the function returns "false". User can specify the mapping address. 
         Never throws.
         It also executes the functor "func" atomically if the segment is opened.
         Functor has must have the following signature:

         bool operator()(const segment_info_t * info, bool created) const
         
         "info" is an initialized segment info structure, and "created" 
         must be "false". If the functor returns "false", an error is supposed
         and segment will be closed. The functor must not throw.*/
      template <class Func>
      bool open_with_func(const char *name, Func func,
                        const void *addr = 0);

      /*!Creates a shared memory segment with name "name", and size "size" if
         the shared memory was not previously created. If it was previously 
         created it tries to open it. User can specify the mapping address.
         Never throws.*/
      bool open_or_create(const char *name, std::size_t size, const void *addr = 0);

      /*!Creates a shared memory segment with name "name", and size "size" if
         the shared memory was not previously created. If it was previously 
         created it tries to open it. User can specify the mapping address.
         Never throws.
         It also executes the functor "func" atomically if the segment is 
         created or opened. Functor has must have the following signature:

         bool operator()(const segment_info_t * info, bool created) const
         
         "info" is an initialized segment info structure, and "created" 
         will be "true" if the segment was created or "false" if the segment was
         opened. If the functor returns "false", an error is supposed
         and segment will be closed. The functor must not throw.*/
      template <class Func>
      bool open_or_create_with_func(const char *name, std::size_t size, 
                                    Func func,        const void *addr = 0);

      /*!Returns the size of the shared memory segment. Never throws.*/
      std::size_t get_size()  const;

      /*!Returns shared memory segment's base address for this process. 
         Never throws.*/
      void* get_address()  const;

      /*!Unmaps shared memory from process' address space. Never throws.*/
      void close();

      /*!Unmaps shared memory from process' address space . Never throws.
         It also executes the functor "func" atomically.
         Functor has must have the following signature:

         void operator()(const segment_info_t * info, bool last) const
         
         "info" is an initialized segment info structure, and "last" 
         indicates if this unmapping is the last unmapping so that
         there will be no no other processes attached to the segment.
         The functor must not throw.*/
      template <class Func>
      void close_with_func(Func func);
   };


The create function takes 3 parameters. The first one 
is the name of the shared memory we want to create, 
the second is the size of the shared memory, and the last 
the mapping address. The function returns false if the shared memory exists 
previously or the mapping can be achieved.

Caution: If you specify the mapping address, (for example, 0x30000000)
this does not mean that you can start to write that in that address! shared_memory
stores some metadata in the first bytes of the segment, so please get the address
you can overwrite calling get_address() function. The "size" argument passed when
constructing the segment represents the size the user needs. The real segment
size will be bigger to store the metadata.

The open function opens a previously 
created shared memory segment. The open_or_create 
function opens the segment if it was previously 
created or creates it otherwise.

All creation, opening and closing functions are atomic. This means that two processes
can concurrently try to open_or_create a segment. One will create the segment and other
will connect. The xxx_with_func functions will also execute the functor atomically.

The xxx_with_with_func versions are really useful to execute logic atomically so that
we can implement higher level IPC mechanisms like message queues with atomic 
initializations.

The close() call does not destroy the shared memory segment, it just unmaps it from the
process' address space. When all processes connected to the shared memory segment
execute the close call, the shared memory segment is destroyed.

[*Note:] Interprocess's shared memory uses a named interprocess_mutex/interprocess_semaphore shared accross all processes
that use Interprocess to guarantee atomic initializations. If some how a process that has locked
that lock dies, it can lock all processes. This shouldn't be a problem in systems
that unlock automatically all resources owned by a process. The lock is called 
['"/boost_interprocess_shm_global_mutex"]. If you suspect somehow a process has died
while locking this resource (for example, user provided functors in xxx_with_func
are executed while holding this), try erase it manually. To be able to execute atomic
user functions while constructing shared memory we would surely need kernel help.
In windows systems the global lock is automatically released if the process is 
terminated, so there is no deadlock risk. Unix systems don't guarantee this, though.

[*Additional note:] As you can see, xxx_with_func functions should be used with care, so
just execute initialization functions that can't crash your program. Follow
the KISS principle: Keep It Simple, Stupid.

[endsect]

[section:file_mapping Memory mapped file]

This class allows portable memory-mapping files so that we can work with files
just like memory. We can map a file to the address-space of the process and 
achieve automatic persistence for data written in memory.

[c++]

   /*!A class that wraps basic file-mapping management*/
   class file_mapping : private boost::noncopyable
   {
    public:
      typedef enum { 
                     ro_mode = 0x01, rw_mode = 0x02, access_mode_mask = 0xff 
                   }    accessmode;

      /*!Initializes members. Does not throw*/
      file_mapping();

      /*!Calls close. Does not throw*/
      ~file_mapping();

      /*!Opens a file mapping of file "filename", starting in offset 
         "file_offset", and the mapping's size will be "size". The mapping 
         can be opened as read-only "ro_mode" or read-write "rw_mode. 
         Never throws.*/
      bool open(const char *filename,  fileoff_t file_offset, 
                std::size_t size,      accessmode mode);

      /*!Closes a previously opened mode file mapping. Never throws.*/
      void close();

      /*!Returns if file mapping is open. Never throws.*/
      bool     is_open()  const;

      /*!Returns the size of the file mapping. Never throws.*/
      std::size_t get_size() const;

      /*!Returns the base address of the file mapping. Never throws.*/
      void* get_address() const;

      /*!Returns the file offset of the file mapping from the beginning of the file.
         Never throws.*/
      fileoff_t get_file_offset() const;

      /*!Flushes to the disk a byte range within the mapped file. 
         Never throws*/
      bool flush(std::size_t mapping_offset = 0, std::size_t numbytes = 0);
   };


*Note:* shared memory uses a unique lock shared accross all processes that use Interprocess 
to guarantee atomic initializations. If some how a process that has locked that
lock dies, it can lock all processes. This lock is called "/boost_interprocess_shm_global_mutex".
If you have problems with this lock, try erase it manually.

[endsect]

[section:interprocess_mutex Process-shared mutexes]

Interprocess process shared mutexes follow the basic guidelines of Boost Thread Mutexes. 
Mutexes can't be used without a scoped_lock and for that reason, Interprocess provides 
lock classes similar to Boost Thread ones. In the future it would be interesting 
to unify both locks under the same library. The same happens with xtime structure
and functions. The reason for this duplication is that Boost Threads checks for multithreaded
builds when including headers, and emits a compilation error when a single threaded
process includes xtime or scoped_lock classes. Since Interprocess can be used between
single threaded processes, that functionality is replicated in Interprocess. If Interprocess
is reviewed and accepted, this scoped lock and xtime structs could be independent
from multithreaded builds so that the same locks and xtime could beused by 
Boost.Thread and Interprocess.     

interprocess_mutex wraps a interprocess_mutex that can be placed in shared memory and used to 
mutually exclude different process and threads. interprocess_mutex, wraps the 
same interprocess_mutex functionality with additional try_lock mechanism to avoid blocking 
if the interprocess_mutex is already blocked by another process.

interprocess_recursive_mutex wraps a interprocess_mutex that can be placed in shared 
memory and used to mutually exclude different process and threads 
and that can be blocked several times by the same process/thread. 
shared_recursive_try_mutex and shared_recursive_timed_mutex, wraps the 
same interprocess_mutex functionality with additional try_lock and timed_lock mechanisms 
to avoid blocking if the interprocess_mutex is already blocked by another process.
The recursive mutexes can be locked by the same thread several times.

All mutexes have the same interface, taken from Boost Threads library:

[c++]

   /*!Wraps a interprocess_mutex that can be placed in shared memory and can be 
      shared between processes. Allows lock trying*/
   class interprocess_mutex : private boost::noncopyable
   {
    public:

      /*!Creates interprocess_mutex resources, throws process_resource_error
         if there are available resources */
      interprocess_mutex();

      /*!Destructs resources, does not throw */
     ~interprocess_mutex();

      // Friend classes.. .
    private:
      /*!Locks interprocess_mutex, sleeps when interprocess_mutex is already locked.
         Throws process_lock_error if a severe error is found*/
      void do_lock(void);

      /*! Tries to lock the interprocess_mutex, returns false when interprocess_mutex 
         is already locked, returns true when success.
         Throws process_lock_error if a severe error is found*/
      bool do_trylock(void);

      /*! Unlocks the interprocess_mutex */
      void do_unlock(void);
      // . . .
   };

[endsect]

[section:interprocess_condition Process-shared interprocess_condition variables]

Similar to boost thread conditions, interprocess_condition class provides 
a way to signal and wait for events, but between processes. This 
interprocess_condition can be placed in shared memory to construct more 
complex inter-process communication mechanisms, like message queues.

[c++]

   class interprocess_condition: private boost::noncopyable
   {
    public:
      /*!Constructs a interprocess_condition*/
      interprocess_condition();

      /*!Destroys *this*/
     ~interprocess_condition();

      /*!If there is a thread waiting on *this, change that 
         thread's state to ready. Otherwise there is no effect.*/
      void notify_one();

      /*!Change the state of all threads waiting on *this to ready.
         If there are no waiting threads, notify_all() has no effect.*/
      void notify_all();

      /*!Releases the lock on the interprocess_mutex object associated with lock, blocks 
         the current thread of execution until readied by a call to 
         this->notify_one() or this->notify_all(), and then reacquires the lock.*/
      template <class L>
      void wait(L& lock);

      /*!The same as: while (!pred()) wait(lock)*/
      template <class L, class Pr>
      void wait(L& lock, Pr pred);

      /*!Releases the lock on the interprocess_mutex object associated with lock, blocks 
         the current thread of execution until readied by a call to 
         this->notify_one() or this->notify_all(), or until time abs_time is reached, 
         and then reacquires the lock.
         Returns: false if time abs_time is reached, otherwise true.*/
      template <class L>
      bool timed_wait(L& lock, const boost::posix_time::ptime &abs_time);

      /*!The same as:   while (!pred()) { 
                           if (!timed_wait(lock, abs_time)) return false; 
                        } return true;*/
      template <class L, class Pr>
      bool timed_wait(L& lock, const boost::posix_time::ptime &abs_time, Pr pred);
      // . . .
   };

[endsect]

[section:named_semaphore Named interprocess_semaphore]

Not necessary for interprocess management but very useful to synchronize 
different processes and send very efficient acknowledgements. 
It can also guarantee atomicity for object creation and initialization.

named_semaphore can't be placed in shared memory, each process must have 
its own named_semaphore instance.

[c++]

   /*!A interprocess_semaphore with a global name, so it can be found from different 
      processes. Allows several resource sharing patterns and efficient 
      acknowledgment mechanisms.*/
   class named_semaphore : private boost::noncopyable
   {
   public:
      /*!Initializes member variables. Does not throw*/
      named_semaphore();

      /*!Calls close(). Does not throw*/
      ~named_semaphore();

      /*!Creates a global interprocess_semaphore with a name, and an initial count. 
         It will return an false if the interprocess_semaphore is already created. 
         Does not throw*/
      bool create(const char *name, int initialCount);

      /*!Opens or creates a global interprocess_semaphore with a name, and an initial count. 
         If the interprocess_semaphore is created, this call is equivalent to create(). 
         If the interprocess_semaphore is already created, this call is equivalent to open()
         and initialCount is ignored. Does not throw*/
      bool open_or_create(const char *name, int initialCount);

      /*!Opens a global interprocess_semaphore with a name if that interprocess_semaphore is previously.
         created. If it is not previously created this function return false.
         Does not throw*/
      bool open(const char *name);

      /*!Frees system resources. Does not throw*/
      void close();

      /*!Increments interprocess_semaphore count. If there is any waiting process, wakes
         up the process. If there is an error throws sem_exception*/
      void post();

      /*!Waits for the interprocess_semaphore to the posted if count is 0. 
         If there is an error throws sem_exception*/
      void wait();

      /*!Waits for the interprocess_semaphore to the posted if count is 0 or until
         timeout expires. Returns true if wait was ok, false if timeout
         expires. If there is an error throws sem_exception*/
      bool timed_wait(const boost::posix_time::ptime &abs_time);

      /*!Tries to wait for the interprocess_semaphore to the posted if count is 0 or until
         timeout expires. Returns true if wait was ok, false if wait was not
         successful. If there is an error throws sem_exception*/
      bool try_wait();
      //. . .
   };

[endsect]


[section:named_mutex Named interprocess_mutex]

Not necessary for interprocess management but very useful to synchronize 
different processes without creating a shared memory segment and 
constructing there a interprocess_mutex. named_mutex can't be placed in shared memory, each process must have 
its own named_mutex instance.

[c++]

   /*!A interprocess_mutex with a global name, so it can be found from different 
      processes. This interprocess_mutex can't be placed in shared memory, and
      each process should have it's own interprocess_mutex.*/
   class named_mutex : private boost::noncopyable
   {
   public:
      /*!Initializes member variables. Does not throw*/
      named_mutex();

      /*!Calls close(). Does not throw*/
      ~named_mutex();

      /*!Creates a global interprocess_mutex with a name. 
         It will return an false if the interprocess_mutex is already created. 
         Does not throw*/
      bool create(const char *name);

      /*!Opens or creates a global interprocess_mutex with a name. 
         If the interprocess_mutex is created, this call is equivalent to create(). 
         If the interprocess_mutex is already created, this call is equivalent to open(). 
         Does not throw*/
      bool open_or_create(const char *name);

      /*!Opens a global interprocess_mutex with a name if that interprocess_mutex is previously.
         created. If it is not previously created this function return false.
         Does not throw*/
      bool open(const char *name);

      /*!Closes the interprocess_mutex. Does not throw*/
      void close();

      /*!Unlocks a previously locked interprocess_mutex.*/
      void unlock();

      /*!Locks interprocess_mutex, sleeps when interprocess_mutex is already locked.
         Throws interprocess_exception if a severe error is found*/
      void lock();

      /*! Tries to lock the interprocess_mutex, returns false when interprocess_mutex 
         is already locked, returns true when success.
         Throws interprocess_exception if a severe error is found*/
      bool try_lock();

      /*! Tries to lock the interprocess_mutex until time abs_time,
         Returns false when timeout expires, returns true when locks.
         Throws interprocess_exception if a severe error is found*/
      bool timed_lock(const boost::posix_time::ptime &abs_time);
	//. . .
   };

[endsect]

[section:barrier Process-shared barrier]

Similar to boost barrier, barrier is a synchronization primitive 
used to cause a set of threads from different processes to wait until they 
each perform a certain function or each reach a particular point in their 
execution. It has the same interface as boost::threads

[c++]

   /*!An object of class barrier is a synchronization primitive that 
      can be placed in shared memory used to cause a set of threads from 
      different processes to wait until they each perform a certain 
      function or each reach a particular point in their execution.*/
   class barrier
   {
    public:
      /*!Constructs a barrier object that will cause count threads 
         to block on a call to wait(). */
      barrier(unsigned int count);

      /*!Destroys *this. If threads are still executing their wait() 
         operations, the behavior for these threads is undefined.*/
      ~barrier(){};

      /*!Effects: Wait until N threads call wait(), where N equals the count 
         provided to the constructor for the barrier object.
         Note that if the barrier is destroyed before wait() can return, 
         the behavior is undefined.
         Returns: Exactly one of the N threads will receive a return value 
         of true, the others will receive a value of false. Precisely which 
         thread receives the return value of true will be implementation-defined. 
         Applications can use this value to designate one thread as a leader that 
         will take a certain action, and the other threads emerging from the barrier 
         can wait for that action to take place.*/
      bool wait();
      //. . .
   };

[endsect]

[section:shared_read_write_mutex Process-shared read/write mutexes]

These read_write_mutexes, follow the same interface as Boost Thread 
read_write_mutexes and offer the same functionality but between threads
of different processes.  

Interprocess has adapted Boost.Thread read/write locks to offer shared memory
versions of Boost.Thread read/write locks: shared_read_write_mutex, 
shared_read_write_try_mutex and shared_read_write_timed_mutex classes

[c++]

   class shared_read_write_mutex
   {
      public:
      /*!Effects: Constructs a read_write_mutex object with a scheduling policy. 
         Postconditions: *this is in an unlocked state.*/
      shared_read_write_mutex
         (read_write_scheduling_policy::read_write_scheduling_policy_enum sp) 
         : m_impl(sp) { }

      /*!Effects: Destroys a read_write_mutex object.
         Requires: *this is in an unlocked state.
         Notes: Danger: Destruction of a locked interprocess_mutex is a serious programming 
         error resulting in undefined behavior such as a program crash.*/
      ~shared_read_write_mutex() { }

      /*!Returns the scheduling policy used by this shared_read_write_mutex.*/
      read_write_scheduling_policy::read_write_scheduling_policy_enum policy() const 
         { return m_impl.m_sp; }

      friend class boost::interprocess::read_write_lock_ops<shared_read_write_mutex>;
      typedef boost::interprocess::scoped_read_write_lock
         <shared_read_write_mutex>; scoped_read_write_lock;
      typedef boost::interprocess::scoped_read_lock
         <shared_read_write_mutex>; scoped_read_lock;
      typedef boost::interprocess::scoped_write_lock
         <shared_read_write_mutex>; scoped_write_lock;
      //. . .
   };

[endsect]

[endsect]

[section:offset_ptr A shared memory pointer: offset_ptr]

As said, Interprocess does not count with same address shared memory 
mapping. Because of that, raw pointers stored in shared memory may become 
invalid. To solve this we can use offsets instead absolute addresses 
to point to an object in the same shared memory segment.

The smart pointer offset_ptr wraps all the background operations 
needed to offer a pointer-like interface. The class interface is 
inspired in Boost Smart Pointers and stores the offset between 
the pointee's address and the "this" pointer (the address of the
offset_ptr itself). One of the big problems of 
offset_ptr is the representation of NULL pointer. Null pointer 
can't be safely represented like an offset, since the 0 address 
is always out of the shared memory segment. Some implementations choose 
0 offset as a null pointer but this is not valid for many uses, 
since many times nodes from STL containers point to themselves (the 
end node in an empty container, for example), and 0 offset value 
is needed.

offset_ptr offers a templatized basic implementation that allows 
different flavours of offset pointers. 

[c++]

   template <class PointedType, class RootPtr = offset_1_null_ptr>
   class offset_ptr;

The default implementation considers offset==1 as null pointer.
This implies that the pointer can not point the byte pointed by
(reinterpret_cast<char>(&offset_ptr))+1
because this byte is considered as the null value. The pointer
will contain only a std::ptrdiff_t value. This default 
implementation is activated using offset_1_null_ptr type in
the second template parameter. 

To obtain a full range addressing, an additional member is needed
so the size of the pointer grows to sizeof(std::ptrdiff_t) + sizeof(bool).
The bool member indicates if the pointer is null or not. This implementation
is activated using full_offset_ptr in the second template parameter.

The offset_ptr class offers all pointer-like operations and
random_access_iterator typedefs, so it can be used in STL 
algorithms requiring random access and detected via traits:

[c++]

   template <class PointedType, class RootPtr>
   class offset_ptr : public RootPtr
   {
      //. . .
    public:   //Public Functions 
      typedef     /*...*/     pointer;
      typedef     /*...*/     reference;
      typedef     /*...*/     value_type;
      typedef     /*...*/     difference_type;
      typedef     /*...*/     iterator_category;

      /*! Default Constructor */
      offset_ptr(){ }

      /*!   Ctor from raw pointer (allows "0" pointer conversion) */
      offset_ptr(pointer ptr) {  this->set_offset(ptr); }

      /*!   Ctor from other offset_ptr */
      offset_ptr(const offset_ptr& ptr);

      /*!   Ctor from other offset_ptr. If pointers of pointee types 
            are convertible, offset_ptrs will be convertibles. */
      template<class T2>
      offset_ptr(const offset_ptr<T2>& ptr);

      /*!   Obtains raw pointer from offset. */
      pointer get()const;

      /*!   Pointer-like -> operator. It can return 0 pointer */
      pointer operator->() const;

      /*!   Derefencing operator, if it is a null offset_ptr behaviour 
            is undefined. */
      reference operator* () const;

      /*!   Indexing operator. */
      reference operator[](ptrdiff_t idx) const;

      /*!   Assignment from pointer (saves extra conversion). */
      offset_ptr& operator= (const_pointer from);

      /*!   Assignment from other offset_ptr. */
      offset_ptr& operator= (const offset_ptr & pt);

      /*!   Assignment from related offset_ptr. If pointers of pointee types 
            are assignable, offset_ptrs will be assignable. */
      template <class T2>
      offset_ptr& operator= (const offset_ptr<T2> & pt);

      /*!   safe bool conversion operator*/
      operator unspecified_bool_type() const;

      /*!   Not operator. Not needed in theory, but improves portability */
      bool operator! () const;

      //. . . Pointer Arithmetic and Comparison 
   };

[endsect]

[section:managed_shared_memory Named shared memory object allocation]

The most useful feature of Interprocess is the ability to treat a shared memory
segment like a memory pool where you can allocate/deallocate fragments or
construct/destroy objects just like you can do with malloc/free or new/delete.
This way, several processes can share memory buffers to implement fast 
inter-process communication and create named objects that can be found 
using that name.

When creating objects in shared memory, however, there are two problems, 
the explicit constructor call needed and the problem when other 
process has to find the created object in shared memory.

Interprocess solves this with the front-end *basic_managed_shared_memory*. It offers
a simple interface to construct objects in shared 
memory associated with a string. All constructions and 
destructions are atomic so that two processes can't create 
two objects associated with the same name.

[section:managed_shared_memory_int The interface]

[c++]

   template
         <
            class CharType, 
            class MemoryAlgorithm, 
            template<class IndexConfig> class IndexType
         >
   class basic_managed_shared_memory
   {
      /*...*/
   public: 
      typedef /*...*/                                    segment_manager;
      typedef CharType                                   char_t;
      typedef typename MemoryAlgorithm::void_pointer     void_pointer;

      /*!Returns the  memory base address in this process. Never throws.*/
      void *   get_address   () const;

      /*!Returns the size of memory segment. Never throws.*/
      std::size_t   get_size   () const;

      /*!Returns a pointer to the segment manager. Never throws.*/
      segment_manager *get_segment_manager() const;

      /*!Transforms an absolute address into an offset from base address. 
         The address must belong to the memory segment. Never throws.*/
      std::ptrdiff_t get_offset_from_address   (const void *ptr) const;

      /*!Transforms previously obtained offset into an absolute address in the 
         process space of the current process. Never throws.*/
      void *    get_address_from_offset (std::ptrdiff_t offset) const;

      /*!Searches for nbytes of free memory in the segment, marks the
         memory as used and return the pointer to the memory. If no 
         memory is available throws a boost::interprocess::bad_alloc exception*/
      void* allocate             (std::size_t nbytes);

      /*!Searches for nbytes of free memory in the segment, marks the 
         memory as used and return the pointer to the memory. If no memory 
         is available return 0. Never throws.*/
      void* allocate             (std::size_t nbytes, std::nothrow_t &nothrow);

      /*!Marks previously allocated memory as free. Never throws.*/
      void  deallocate           (void *addr);

      /*!Creates shared memory from file. Never throws.*/
      template<class CharT> 
      bool create_from_file (const CharT *filename, const char *mem_name, 
                             const void *addr = 0);

      /*!Creates shared memory from an istream. Never throws.*/
      bool create_from_istream (std::istream &instream, std::size_t size,
                                const char *mem_name, const void *addr = 0);

      /*!Saves shared memory to a file. Never throws.*/
      template<class CharT> 
      bool save_to_file (const CharT *filename);

      /*!Saves memory to a std::ostream. Never throws.*/
      bool save_to_ostream (std::ostream &outstream)

      /*!Constructor. Allocates basic resources. Never throws.*/
      basic_managed_shared_memory(){}

      /*!Destructor. Calls close. Never throws.*/
      ~basic_managed_shared_memory();

      /*!Creates shared memory, and places segment manager there. Never throws.*/
      bool  create   (const char *name, std::size_t size, const void *addr = 0);
    
      /*!Connects to a created share memory and its segment manager. Never throws.*/
      bool  open     (const char* name, std::size_t size, const void *addr = 0);

      /*!Frees resources and unmaps memory. Never throws.*/
      void close();

      /*!Tries to find the address of a previous named allocation. Returns a memory
         buffer and the object count. If not found returned pointer is 0.
         Never throws.*/
      template <class T>
      std::pair<T*, std::size_t> find  (char_ptr_holder_t name);

      /*!Creates a named object or array in shared memory.*/
      template <class T>
      typename named_object_algo_t::template construct_proxy<T, true>::type
         construct(char_ptr_holder_t name);

      /*!Finds or creates a named object or array in shared memory.*/
      template <class T>
      typename named_object_algo_t::template find_construct_proxy<T, true>::type
         find_or_construct(char_ptr_holder_t name);

      /*!Creates a named object or array in shared memory.*/
      template <class T>
      typename named_object_algo_t::template construct_proxy<T, false>::type
         construct(char_ptr_holder_t name, std::nothrow_t nothrow);

      /*!Finds or creates a named object or array in shared memory.*/
      template <class T>
      typename named_object_algo_t::template find_construct_proxy<T, false>::type
         find_or_construct(char_ptr_holder_t name, std::nothrow_t nothrow);

      /*!Creates a named array from iterators in shared memory .*/
      template <class T>
      typename named_object_algo_t::template construct_iter_proxy<T, true>::type
         construct_it(char_ptr_holder_t name);

      /*!Finds or creates a named array from iterators in shared memory.*/
      template <class T>
      typename named_object_algo_t::template find_construct_iter_proxy<T, true>::type
         find_or_construct_it(char_ptr_holder_t name);

      /*!Creates a named array from iterators in shared memory.*/
      template <class T>
      typename named_object_algo_t::template construct_iter_proxy<T, false>::type
         construct_it(char_ptr_holder_t name, std::nothrow_t nothrow);

      /*!Finds or creates a named array from iterators in shared memory.*/
      template <class T>
      typename named_object_algo_t::template find_construct_iter_proxy<T, false>::type
         find_or_construct_it(char_ptr_holder_t name, std::nothrow_t nothrow);

      /*!Calls a functor and guarantees that no new construction, search or
         destruction will be executed by any process while executing the object
         function call. If the functor throws, this function throws.*/
      template <class Func>
      void atomic_func(Func &f);

      /*!Destroys a named shared memory object or array.*/
      template <class T>
      bool destroy(const CharType *name);

      /*!Destroys an anonymous shared memory object or array.*/
      template <class T>
      bool destroy(const detail::anonymous_instance_t *, const void *object);

      /*!Destroys the unique instance of type T of the shared memory segment.*/
      template <class T>
      bool destroy(const detail::unique_instance_t *);

      /*!Destroys the object (named, anonymous, or unique)of type T.*/
      template <class T>
      bool destroy_ptr(const T *name);

      /*!Returns the name of an object created with construct/find_or_construct
         functions. Does not throw*/
      template<class T>
      const char *get_name(const T *ptr);

      /*!Returns is the the name of an object created with construct/find_or_construct
         functions. Does not throw*/
      template<class T>
      InstanceType get_type(const T *ptr);

      /*!Preallocates needed index resources to optimize the 
         creation of "num" named objects in the shared memory segment.
         Can throw boost::interprocess::bad_alloc if there is no enough memory.*/
      void reserve_named_objects(std::size_t num);

      /*!Preallocates needed index resources to optimize the 
         creation of "num" unique objects in the shared memory segment.
         Can throw boost::interprocess::bad_alloc if there is no enough memory.*/
      void reserve_unique_objects(std::size_t num);

      //. . .
   };

The close() call does not destroy the shared memory segment, it just unmaps it from the
process' address space. When all processes connected to the shared memory segment
execute the close call, the shared memory segment is destroyed.

*Caution:* *All* member functions of basic_named_object need a successful open/create
of the shared memory to work. If we call these functions before a successful 
opening/creating the result is *undefined*.

This class can be customized with the following parameters:

[c++]

   class CharType, 
   class MemoryAlgorithm, 
   template<class IndexConfig> class IndexType


* *CharType* is the type of the character that will be used to identify
  the created named objects (for example, *char* or *wchar_t*)

* *MemoryAlgorithm* is the shared memory segment management algorithm 
   (for example simple sequential fit). The typedefs of memory algorithm 
   also define:
   *The synchronization type (`MemoryAlgorithm::mutex_family`) to use 
    in the all basic_managed_shared_memory allocation operations.

   *The Pointer type (`MemoryAlgorithm::void_pointer`) to be used in all 
    classes based on basic_managed_shared_memory (STL allocators, for example).

   *See [link interprocess.custom_interprocess_alloc Writing a new shared memory allocation
    algorithm] for details about memory algorithms.
     
* *IndexType* is the type of index that will be used to store the name-object association 
   (for example, a map, a hash-map, or an ordered vector)

This way, we can use char or wchar_t to name the shared memory 
objects, we can plug new shared memory allocation algorithms, and
use the index type that is best suited to our needs.

[endsect]

[section:common_managed_shared_memorys Common named shared object classes]

As seen, *basic_managed_shared_memory* offers a great variety of customization. But
for the average user, a common, default shared memory named object creation is needed.
Because of this, Interprocess defines the most common named shared object specializations:

[c++]

   /*!Defines the named shared object allocation with a c-string as 
      a key, the simple sequential fit algorithm (with process-shared mutexes)
      as memory management algorithm and flat_map as a index.
      This class allows the shared memory to be mapped in different base 
      in different processes*/
   typedef 
      basic_managed_shared_memory <char
                                ,simple_seq_fit<mutex_family, offset_ptr<void> >
                                ,flat_map_index>  
      managed_shared_memory;

   /*!Defines the named shared object allocation with a wchar_t string as 
      a key, the simple sequential fit algorithm (with process-shared mutexes) 
      as memory management algorithm and flat_map as a index
      This class allows the shared memory to be mapped in different base 
      in different processes*/
   typedef 
      basic_managed_shared_memory <wchar_t
                                ,simple_seq_fit<mutex_family, offset_ptr<void> >
                                ,flat_map_index>  
      wmanaged_shared_memory;

   /*!Defines the named shared object allocation with a c-string as 
      a key, the simple sequential fit algorithm (with process-shared mutexes)
      as memory management algorithm and flat_map as a index.
      This class only works if shared memory is mapped to the same address
      in different processes*/
   typedef 
      basic_managed_shared_memory <char
                                ,simple_seq_fit<mutex_family, void *>
                                ,flat_map_index>  
      fixed_managed_shared_memory;

   /*!Defines the named shared object allocation with a wchar_t string as 
      a key, the simple sequential fit algorithm (with process-shared mutexes) 
      as memory management algorithm and flat_map as a index
      This class only works if shared memory is mapped to the same address
      in different processes*/
   typedef 
      basic_managed_shared_memory <wchar_t
                                ,simple_seq_fit<mutex_family, void *>
                                ,flat_map_index>  
      wfixed_managed_shared_memory;

managed_shared_memory allocates objects in shared memory asociated with a c-string and
wmanaged_shared_memory allocates objects in shared memory asociated with a wchar_t null
terminated string. Both define the pointer type as `offset_ptr<void>` so they can be
used to map the shared memory at different base addresses in different processes.
*fixed_managed_shared_memory* and *wfixed_managed_shared_memory* are the counterparts
for fixed shared memory mapping, since they define the pointer type as `void*` 

[endsect]

[section:allocate_deallocate Allocating fragments of a shared memory segment]

If a basic raw-byte allocation is needed from a shared memory segment, for
example, to implement top-level inter-process communications, this class
offers *allocate* and *deallocate* functions. The allocation function
comes with throwing and no throwing versions. Throwing version throws 
boost::interprocess::bad_alloc (which derives from std::bad_alloc)if there is no
more memory and the non-throwing version returns 0 pointer.

[c++]

   //Front-end that allocates portions of a shared memory segment
   //with the default shared memory segment management algorithm
   managed_shared_memory shmalloc;

   //Create the segment and initialize resources
   shmalloc.create("/MySegment", 65536);

   void* ptr;

   //Allocate 100 bytes of memory from segment, throwing version
   ptr = shmalloc.allocate(100);

   //Deallocate it
   shmalloc.deallocate(ptr);

   //Non throwing version
   ptr = shmalloc.allocate(100, std::nothrow);

   //Deallocate it
   shmalloc.deallocate(ptr);

[endsect]

[section:segment_offset Obtaining offsets to identify data]

The class also offers conversions between absolute addresses that belong to 
the segment and the offset of that address regarding to the base mapping address 
of the segment, so that offsets can be used as keys between processes
to identify shared memory buffers. 

[c++]

	//Process A obtains the offset of the address
	std::ptrdiff_t offset = segment.get_offset_from_address(processA_address);
	//Process A sends this address using IPC
	//
	//Process B obtains the address of the offset (which can be 
	//different if segments were mapped with different base addresses)
	void * processB_address = segment.get_address_from_offset(offset);

[endsect]


[section:allocation_types Object construction function family]

When constructing objects in shared memory associated with a name, the user has a varied
function family to "construct" or "construct if not found" objects. Interprocess can construct
a single object or an array of objects. The array can be constructed with the same 
parameters for all objects or we can define each parameter from a list of iterators:

[c++]

   /*!Allocates and constructs an object of type MyType (throwing version) */
   MyType *ptr = managed_shared_memory.construct<MyType>("Name") (par1, par2...);

   /*!Allocates and constructs an array of objects of type MyType (throwing version) 
     Each object receives the same parameters (par1, par2, ...)*/
   MyType *ptr = managed_shared_memory.construct<MyType>("Name")[count](par1, par2...);

   /*!Tries to find a previously created object. If not present, allocates 
      and constructs an object of type MyType (throwing version) */
   MyType *ptr = managed_shared_memory.find_or_construct<MyType>("Name") (par1, par2...);

   /*!Tries to find a previously created object. If not present, allocates and 
      constructs an array of objects of type MyType (throwing version). Each object 
      receives the same parameters (par1, par2, ...)*/
   MyType *ptr = managed_shared_memory.find_or_construct<MyType>("Name")[count](par1, par2...);

   /*!Allocates and constructs an array of objects of type MyType (throwing version) 
     Each object receives parameters returned with the expression (*it1++, *it2++,... )*/
   MyType *ptr = managed_shared_memory.construct_it<MyType>("Name")[count](it1, it2...);

   /*!Tries to find a previously created object. If not present, allocates and constructs 
      an array of objects of type MyType (throwing version).  Each object receives  
      parameters returned with the expression (*it1++, *it2++,... ) */
   MyType *ptr = managed_shared_memory.find_or_construct_it<MyType>("Name")[count](it1, it2...);

   /*!Tries to find a previously created object. Returns a pointer to the object and the 
      count (if it is not an array, returns 1). If not present, the returned pointer is 0*/
   std::pair<MyType *,std::size_t> ret = managed_shared_memory.find<MyType>("Name");

   /*!Destroys the created object, returns false if not present*/
   bool destroyed = managed_shared_memory.destroy<MyType>("Name");

   /*!Destroys the created object via pointer*/
   managed_shared_memory.destroy_ptr(ptr);

All these functions have a non-throwing version, that 
is invoked with an additional parameter std::nothrow. 
For example, for simple object construction:

[c++]

   /*!Allocates and constructs an object of type MyType (no throwing version) */
   MyType *ptr = managed_shared_memory.construct<MyType>("Name", std::nothrow) (par1, par2...);

[endsect]

[section:anonymous Anonymous instance construction]

Sometimes, the user doesn't want to create objects associated with a name. For this purpose,
Interprocess can create anonymous objects in shared memory. All named object construction functions
are available to construct anonymous objects. To allocate an anonymous objects, the user
must use "boost::interprocess::anonymous_instance" object instead of a name:

[c++]

   MyType *ptr = managed_shared_memory.construct<MyType>(anonymous_instance) (par1, par2...);
   //Other construct variants can also be used (including non-throwing ones)
   //We can only destroy the anonymous object via pointer
   managed_shared_memory.destroy_ptr(ptr);

Find functions have no sense here, since many anonymous objects can be created in
the same memory segment. We can only destroy the anonymous object via pointer.

[endsect]

[section:unique Unique instance construction]

Sometimes, the user wants to emulate a singleton in shared memory. Obviously, 
as shared memory is constructed at run-time, the user must construct and destroy
this object explicitly. But how can the user be sure that the object is the only
object of its type in the shared memory segment? This can be emulated using
a named object and checking if it is present before trying to create one, but
all processes must agree in the object's name, that can also conflict with
other existing names.

To solve this, Interprocess offers a "unique object" creation in shared memory.
Only one instance of a class can be created in a shared memory segment using this service,
so it makes easier the emulation of singleton-like objects across processes, for example,
to design pooled, shared memory allocators. The object can be searched using the type 
of the class as a key. 

[c++]

   // Construct
   MyType *ptr = managed_shared_memory.construct<MyType>(unique_instance) (par1, par2...);
   // Find it
   std::pair<MyType *,std::size_t> ret = managed_shared_memory.find<MyType>(unique_instance);
   // Destroy it
   managed_shared_memory.destroy<MyType>(unique_instance);
   // Other construct and find variants can also be used (including non-throwing ones)

[c++]

   // We can also destroy the unique object via pointer
   MyType *ptr = managed_shared_memory.construct<MyType>(unique_instance) (par1, par2...);
   managed_shared_memory.destroy_ptr(ptr);


The find function obtains a pointer to the only object of type T that can be created
using this unique_instance mechanism. 

[endsect]

[section:synchronization Synchronization guarantees]

One of the features of named/anonymous/unique allocations/searches/destructions is that
they are *atomic*. Named allocations use the synchronization scheme defined by the
template parameter MemoryAlgorithm::mutex_family. So that two processes can call:

[c++]

   MyType *ptr = managed_shared_memory.find_or_construct<MyType>("Name")[count](par1, par2...);
   
at the same time, but only one process will create the object and the other will 
obtain a pointer to the created object.

Raw allocation using `allocate()` can be called also safely while executing 
named/anonymous/unique allocations, just like when programming a multithreaded 
application inserting an object in a interprocess_mutex-protected map does not block other threads
from calling new[] while the map thread is searching the place where it has to insert the
new object. The synchronization does happen when once the map finds the correct place
it has to allocate raw memory to insert the value.

This means that if we create a lot of named objects, while doing a new creation/search
we only block other creation/searches from other processes but we don't block another 
process if that process is inserting elements in a shared memory vector.

[endsect]

[section:index_types Index types for name/object mappings]

As seen, basic_managed_shared_memory, when creating named objects, stores the name/object
relation in an index. The index is a map with the name of the object as a key and
a pointer to the object as the mapped type. The default specializations, *managed_shared_memory* 
and *wmanaged_shared_memory*, use *flat_map_index* as the index type.

Each index has its own characteristics, like search-time, insertion time, deletion time, 
memory use, and memory allocation patterns. Interprocess offers 3 index types right now:

* *boost::interprocess::flat_map_index*: Based on boost::interprocess::flat_map, an ordered 
   vector similar to Loki library's AssocVector class, offers great search time and
   minimum memory use. But the vector must be reallocated when is full, so all data
   must be copied to the new buffer. Ideal when insertions are mainly in initialization
   time and in run-time we just need searches.

* *boost::interprocess::map_index*: Based on boost::interprocess::map, a shared memory version of
   std::map. Since it's a node based container, it has no reallocations, the tree
   must be just    rebalanced sometimes. Offers equilibrated insertion/deletion/search
   times with more overhead per node comparing to *boost::interprocess::flat_map_index*.
   Ideal when searches/insertions/deletions are in random order.

* *boost::interprocess::null_index*: This index is for people using basic_managed_shared_memory
   just for raw memory buffer allocations and they don't make use of named/unique 
   allocations. This class is just empty and saves some space and compilation time.

To create a *basic_managed_shared_memory* using *boost::interprocess::map* as the index type we
just must specify *boost::interprocess::map_index* as template parameter:

[c++]

   //This front-end can allocate objects with:
   // -> a wchar_t string as key
   // -> boost::interprocess::simple_seq_fit with process-shared mutexes 
   //       as memory allocation algorithm.
   // -> boost::interprocess::map<...> as the index to store name/object mappings
   typedef boost::interprocess::basic_managed_shared_memory
            <  wchar_t
            ,  boost::interprocess::simple_seq_fit<boost::interprocess::mutex_family, offset_ptr<void> >
            ,  boost::interprocess::map_index
            >  my_managed_shared_memory;

Interprocess plans to offer an *unordered_map* based index as soon as this container is included
in Boost. If these indexes are not enough for you, you can define your own index type.
To know how to do this, go to [link interprocess.custom_indexes Building custom indexes] section.

[endsect]

[endsect]


[section:stl_allocators Interprocess STL compatible allocators]

[section:allocator_introduction Introduction to Interprocess STL compatible allocators]

As seen, Interprocess offers raw memory allocation and object construction in shared memory, but
one of the first user requests is the use of containers in shared memory. To achieve this, Boost 
Interprocess makes use of previous shared memory allocation algorithms to build 2 common memory allocation
schemes: variable size object allocation and fixed size object allocation (segregated storage),
implemented in these allocators: 

* *boost::interprocess::allocator* offers general purpose, variable size allocation.

* *boost::interprocess::node_allocator* offers a segregated storage allocation scheme sharing a common
  pool between all instances of the class node_allocator placed in the same fixed size memory 
  segment, so memory usage is optimized.

* *boost::interprocess::private_node_allocator* offers a segregated storage allocation scheme where
  each private_node_allocator owns its own pool. This allocator offers faster allocation
  than node_allocator since it avoids synchronization between threads/processes but imposes 
  a higher memory usage. Take in care that the standard does not recommend this private
  per allocator pool.

* *boost::interprocess::cached_node_allocator* offers a segregated storage allocation scheme between
  node_allocator and private_node_allocator. This allocator caches some nodes from the common
  the common pool and stores them privately so that these are quickly available
  without the synchronization overhead for future allocations.


Interprocess STL compatible allocators are configurable via template parameters. The Interprocess allocators
define their `pointer` typedef based on the `void_pointer` typedef of the segment manager
passed as template argument. When this `segment_manager::void_pointer` is a relative pointer, 
the user can place these allocators in shared memory mapped in different base addresses in
several processes.

[endsect]

[section:allocator boost::interprocess::allocator: The shared memory STL compatible allocator]

The *boost::interprocess::allocator* class defines a STL compatible allocator class that 
uses the shared memory management algorithm from the segment to allocate and deallocate memory. 
This allocator is templatized with the allocated type, and the segment manager.

[c++]

   namespace boost::interprocess {

   /*!An STL compatible allocator that uses a segment manager as 
      memory source. The internal pointer type will of the same type (raw, smart) as
      "typename SegmentManager::void_pointer" type. This allows
      placing the allocator in shared memory, memory mapped-files, etc...*/
   template<class T, class SegmentManager>
   class allocator 
   {
      public:

      /*!Returns the segment manager. Never throws*/
      segment_manager* get_segment_manager() const;

      /*!Constructor from the segment manager. Never throws*/
      allocator(segment_manager *segment_mngr);

      //The rest of the interface is the same of std::allocator
   };

   }} //      namespace boost::interprocess {

The class *allocator* must be always initialized with the allocation
algorithm obtained from the segment where you want *boost::interprocess::allocator* 
to allocate memory.


[c++]

   //Alias allocator type with
   //    T=int
   //    SegmentManager = managed_shared_memory::segment_manager
   typedef allocator<int, managed_shared_memory::segment_manager> Allocator;

   //Initialize allocator with the segment manager
   Allocator alloc_inst (segment.get_segment_manager());

The allocator just provides the needed typedefs and forwards all allocation
and deallocation requests to the segment manager passed in the constructor.

[endsect]


[section:node_allocator boost::interprocess::node_allocator: a simple segregated storage between processes]

As seen in the shared memory default algorithm, memory algorithms waste 
some space in management information for each allocation. Sometimes, 
usually for small objects, this is not acceptable. Usually shared 
memory allocators become fragmented under some allocation and 
deallocation schemes, reducing their performance. When allocating 
many objects of the same type, a simple segregated storage becomes 
a fast and space-friendly allocator, as explained in Boost Pool library.

To build normal node allocators, usually a global, thread shared singleton
pool is used for each node size. This is not possible if you try to share 
a node allocator between processes. To achieve this sharing, the *node_allocator* 
uses a unique name to identify the pool shared by all this node_allocators. In the
initialization, a *node_allocator* object searches this unique object in the segment.
If it is not preset, it builds one.  This way, all *node_allocator* objects built
inside a memory segment share a unique memory pool. 

The common segregated storage is not only shared between node_allocators of the
same type, but it is also  shared between all node_allocators that allocate objects 
of the same size, for example, *node_allocator<uint32>* and *node_allocator<float32>*. 
This saves a lot of memory but also imposes an synchronization overhead for each 
node allocation.

The common segregated storage, dynamically created using the unique name explained before,
integrates a reference count so that a node_allocator can know if any other node_allocator 
is attached to the same common segregated storage to allow an ordered common segregated 
storage destruction when the last node_allocator is destroyed.

[c++]

   /*!An STL node allocator that uses a segment manager as memory 
      source. The internal pointer type will of the same type (raw, smart) as
      "typename SegmentManager::void_pointer" type. This allows
      placing the allocator in shared memory, memory mapped-files, etc...
      This node allocator shares a segregated storage between all instances 
      of node_allocator with equal sizeof(T) placed in the same segment 
      group. N is the number of nodes allocated at once when the allocator
      needs runs out of nodes*/*/
   template<class T, std::size_t N, class SegmentManager>
   class node_allocator
   {
    public:

      //No default constructor

      /*!Constructor from a segment manager.
         Can throw boost::interprocess::bad_alloc*/
      node_allocator(SegmentManager *segment_mngr);

      /*!Returns a pointer to the segment manager. Never throws*/
      SegmentManager *get_segment_manager() const;

      /*...*/
      //The rest is the same interface as std::allocator
      /*...*/

The *node_allocator* must be always initialized with the segment 
manager obtained from the segment where you want *node_allocator* to allocate memory.

[c++]

   //Alias allocator type with
   //    T=int
   //    N=64
   //    SegmentManager = managed_shared_memory::segment_manager
   typedef node_allocator<int, 64, managed_shared_memory::segment_manager> NodeAllocator;

   //Initialize allocator instance with the segment manager
   NodeAllocator alloc_inst (segment.get_segment_manager());

All STL compatible containers that want to use this allocation scheme 
must be constructed with an initialized node_allocator so 
that they can allocate the values with the node allocator:

[c++]

   MyIntList mylist(alloc_inst);
   mylist.insert(mylist.begin(), 3);


[endsect]

[section:private_node_allocator boost::interprocess::private_node_allocator: a private segregated storage]

As said, the node_allocator shares a common segregated storage between 
node_allocators that allocate objects of the same size and this optimizes
memory usage. However, it needs a named_shared memory algorithm to use
the unique instance service so that this sharing can be possible. Also
imposes a synchronization overhead per node allocation because of this share.
Sometimes, the named object service is not available (for example, when
building index types for the named object service itself) or the 
synchronization overhead is not acceptable.

So *private_node_allocator* uses the same segregated storage as node_allocator,
but each *private_node_allocator* has its own segregated storage. No synchronization
is used when allocating nodes, so there is far less overhead for an operation
that usually involves just a few pointer operations when allocating and 
deallocating a node.

[c++]

   /*!An STL node allocator that uses a segment manager as memory 
      source. The internal pointer type will of the same type (raw, smart) as
      "typename SegmentManager::void_pointer" type. This allows
      placing the allocator in shared memory, memory mapped-files, etc...
      This allocator has its own node pool. N is the number of nodes allocated 
      at once when the allocator needs runs out of nodes*/*/
   template<class T, std::size_t N, class SegmentManager>
   class private_node_allocator
   {
    public:

      //No default constructor

      /*!Constructor from a segment manager. Never throws*/
      private_node_allocator(SegmentManager *segment_mngr);

      /*!Returns a pointer to the segment manager. Never throws*/
      SegmentManager *get_segment_manager() const;

      /*...*/
      //The rest is the same interface as std::allocator
      /*...*/

Any *private_node_allocator* must be initialized with a pointer 
to the segment manager of the semgment from you want *private_node_allocator* 
to allocate memory:

[c++]

   //Alias allocator type with
   //    T=int
   //    N=64
   //    SegmentManager = managed_shared_memory::segment_manager
   typedef private_node_allocator<int, 64, managed_shared_memory::segment_manager> 
      PrivateNodeAllocator;

   //Initialize allocator instance with the segment manager
   PrivateNodeAllocator alloc_inst (segment.get_segment_manager());

All STL compatible containers that want to use this allocation scheme 
must be constructed with an initialized private_node_allocator so 
that they can allocate the values with the private node allocator:

[c++]

   MyIntList mylist(alloc_inst);
   mylist.insert(mylist.begin(), 3);

[endsect]

[section:cached_node_allocator boost::interprocess::cached_node_allocator: caching nodes to avoid overhead]

The total node sharing of *boost::interprocess::node_allocator* can impose a high overhead for some 
applications and the no synchronization overhead of *boost::interprocess::private_node_allocator*
can impose a unacceptable memory waste for other applications.

To solve this, Interprocess offers an allocator, *boost::interprocess::cached_node_allocator*, that 
allocates nodes from the common pool but caches some of them privately so that following 
allocations have no synchronization overhead. When the cache is full, the allocator 
returns some cached nodes to the common pool, so that they are available to other 
allocators.

[c++]

   /*!An STL node allocator that uses a shared memory management algorithm as memory 
      source and a templatized Ptr as pointer type. Allows placing STL containers in 
      shared memory if Ptr is an offset pointer. This node allocator shares a segregated
      storage between all instances of cached_node_allocator with equal sizeof(T) placed
      in the same fixed size memory segment. But also caches some nodes privately to
      avoid some synchronization overhead.*/

   template<class T, class SegmentManager>
   class cached_node_allocator
   {
    public:

      //No default constructor

      /*!Constructor from a segment manager. Never throws*/
      cached_node_allocator(AllocAlgo_t *segment_mngr);

      /*!Returns a pointer to the segment manager. Never throws*/
      SegmentManager *get_segment_manager() const;

      /*!Sets the new max cached nodes value. This can provoke deallocations
         if "newmax" is less than current cached nodes. Never throws*/
      void set_max_cached_nodes(std::size_t newmax);

      /*!Returns the max cached nodes parameter. Never throws*/
      std::size_t get_max_cached_nodes() const;

      /*...*/
      //The rest is the same interface as std::allocator
      /*...*/

Any *cached_node_allocator* must be initialized with a pointer to a named shared
shared memory allocation algorithm:

[c++]

   //Alias allocator type with
   //    T=int
   //    SegmentManager = managed_shared_memory::segment_manager
   typedef cached_node_allocator<int, managed_shared_memory::segment_manager> 
      CachedNodeAllocator;

   //Initialize allocator instance with algorithm
   CachedNodeAllocator alloc_inst (segment.get_segment_manager());

All STL compatible containers that want to use this allocation scheme 
must be constructed with an initialized cached_node_allocator so 
that they can allocate the values with the cached_node_allocator:

[c++]

   //Change cache size as desired (for example 100 nodes)
   alloc_inst.set_max_cached_nodes(100);

   //Initialize container
   MyIntList mylist(alloc_inst);
   mylist.insert(mylist.begin(), 3);

[endsect]

[section:allocator_swapping Swapping Interprocess STL compatible allocators]

When swapping STL containers, there is an active discussion on what to do with 
the allocators. Some STL implementations, for example Dinkumware from Visual .NET 2003,
make a deep swap of the whole container through a temporary when allocators are not equal.
The [@http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2004/n1599.html proposed resolution]
to container swapping is that allocators should be swapped in a non-throwing way.

Unfortunately, this approach is not valid with shared memory. Using heap allocators, if
Group1 of node allocators share a common segregated storage, and Group2 share another common
segregated storage, a simple pointer swapping is needed to swap an allocator of Group1 and another
allocator of Group2. But when the user wants to swap two shared memory allocators, each one
placed in a different shared memory segment, this is not possible. As generally shared memory
is mapped in different addresses in each process, a pointer placed in one segment can't point
to any object placed in other shared memory segment, since in each process, the distance between
the segments is different. However, if both shared memory allocators are in the same segment,
a non-throwing swap is possible, just like heap allocators.

Until a final resolution is achieved. Interprocess STL compatible allocators implement a non-throwing
swap function that swaps internal pointers. If an allocator placed in a shared memory segment is
swapped with other placed in a different shared memory segment, the result is undefined. But a 
crash is quite sure.

[endsect]

[endsect]


[section:containers_explained Interprocess and containers in shared memory]

[section:stl_container_requirements Container requirements for Interprocess allocators]

Interprocess STL compatible allocators offer a STL compatible allocator interface and 
if they define their internal *pointer* typedef as a relative pointer, they can 
be used to place STL containers in shared memory.

However, as Scott Meyers mentions in his Effective STL 
book, Item 10, ['"Be aware of allocator conventions and 
restrictions"]: 

* ['"the Standard explicitly allows library implementers 
to assume that every allocator's pointer typedef is 
a synonym for T*"]

* ['"the Standard says that an implementation of the STL is 
permitted to assume that all allocator objects of the 
same type are equivalent and always compare equal"]

Obviously, if any STL implementation ignores pointer typedefs, 
no smart pointer can be used as allocator::pointer. If STL 
implementations assume all allocator objects of the same 
type compare equal, it will assume that two allocators, 
each one allocating from a different shared memory segment 
are equal, which is a complete disaster. 

STL container implementations that we want to place in shared 
memory with Interprocess can't make any of these assumptions, so:

* STL containers may not assume that memory allocated with 
  an allocator can be deallocated with other allocators of 
  the same type. All allocators objects must compare equal 
  only if memory allocated with one object can be deallocated 
  with the other one, and this can only tested with 
  operator==() at run-time.

* Containers' internal pointers should be of the type allocator::pointer 
  and containers may not assume allocator::pointer is a raw pointer.

* All objects must be constructed-destroyed via 
  allocator::construct and allocator::destroy functions.

[endsect]

[section:containers STL containers in shared memory]

Unfortunately, some STL implementations use raw pointers
for internal data and ignore allocator pointer typedefs 
and others suppose at some point that the allocator::typedef 
is T*. This is because in practice,
there wasn't need of allocators with a pointer typedef 
different from T* for pooled/node memory
allocators.

Until STL implementations handle allocator::pointer typedefs
in a generic way, Interprocess offers the following classes:

* *boost:interprocess::vector* is the implementation of std::vector ready for the shared memory.
        
* *boost:interprocess::deque* is the implementation of std::deque ready for the shared memory.
        
* *boost:interprocess::list* is the implementation of std::list ready for the shared memory.

* *boost:interprocess::slist* is the implementation of SGI's slist container (singly linked list) ready for the shared memory.
        
* *boost:interprocess::set/multiset/map/multimap* family is the implementation of 
   std::set/multiset/map/multimap family ready for the shared memory.
        
* *boost:interprocess::flat_set/flat_multiset/flat_map/flat_multimap* classes are the 
   adaptation and extension of Andrei Alexandrescu's famous AssocVector class 
   from Loki library, ready for the shared memory. These classes offer the same 
   functionality as std::set/multiset/map/multimap implemented with an ordered vector, 
   which has faster lookups than the standard ordered associative containers 
   based on red-black trees, but slower insertions.
        
* *boost:interprocess::basic_string* is the implementation of std::basic_string ready for 
   the shared memory. It's implemented using a vector-like contiguous storage, so
   it has fast c_string conversion and can be used with the 
   [link interprocess.vectorstream vectorstream] iostream formatting classes.
        
All these containers have the same default arguments as standard 
containers and they can be used with other, non-shared memory 
allocators (std::allocator, or boost::pool_allocator, for example). 

To place any of these containers in shared memory, we must define
the allocator template parameter with a shared memory allocator
so that the container allocates the values in the shared memory.
To place the container itself in shared memory, we construct it
in shared memory just like any other object with Interprocess:

[c++]

   #include <boost/interprocess/containers/vector.hpp>
   #include <boost/interprocess/managed_shared_memory.hpp>

   int main ()
   {
      using namespace boost::interprocess;

      //Shared memory front-end that is able to construct objects
      //associated with a c-string
      managed_shared_memory segment;

      //Create the memory segment and initialize resources
      if(!segment.create("/MySharedMemory",  //segment name
                         65536)){            //segment size in bytes
         return -1;
      }

      //Alias an STL-like allocator of ints that allocates ints from the segment
      typedef allocator<int, managed_shared_memory::segment_manager> 
         ShmemAllocator;

      //Alias a vector that uses the previous STL-like allocator
      typedef vector<int, ShmemAllocator> MyVector;

      int initVal[]        = {0, 1, 2, 3, 4, 5, 6 };
      const int *begVal    = initVal;
      const int *endVal    = initVal + sizeof(initVal)/sizeof(initVal[0]);

      //Initialize the STL-like allocator
      const ShmemAllocator alloc_inst (segment.get_segment_manager());

      //Construct the vector in the shared memory segment with the STL-like allocator 
      //from a range of iterators
      MyVector *myvector = 
         segment.construct<MyVector>
           ("MyVector")/*object name*/
           (begVal     /*first ctor parameter*/,
            endVal     /*second ctor parameter*/, 
            alloc_inst /*third ctor parameter*/); 

      //Use vector as your want
      std::sort(myvector->rbegin(), myvector->rend());
      // . . .
      //When done, destroy and delete vector from the segment
      segment.destroy<MyVector>("MyVector");
      return 0;
   }


These containers also show how easy is to create/modify 
an existing container making possible to place it in shared memory.

[endsect]

[section:where_allocate Where is this being allocated?]

Interprocess containers are placed in shared memory/memory mapped files, etc... using two 
mechanisms *at the same time*:

* Interprocess construct<>, find_or_construct<>... functions. These functions place a c++
  object in the shared memory/memory mapped file. But this places only the object,
  but *not* the memory that this object may allocate dynamically.

* Shared memory allocators. These allow allocating shared memory/memory mapped file
  portions so that containers can allocate dynamically fragments of memory to store
  new inserted elements.

This means that to place *any* Interprocess container (including Interprocess strings) in 
shared memory/memory mapped file all containers *must*:

* Define their template allocator parameter to a shared memory one.

* Every container constructor must take a shared memory allocator as parameter.

* You must use construct<>/find_or_construct<>... functions to place the container
  in shared memory.

If you do the first two points but you don't use construct<>/find_or_construct<> 
you are creating a container placed *only* in your process but that allocates memory 
for contained types from shared memory/memory mapped file.

Let's see an example:

[/doc_where_allocate.cpp]

[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <boost/interprocess/containers/vector.hpp>
   #include <boost/interprocess/containers/string.hpp>
   #include <boost/interprocess/allocators/allocator.hpp>

   int main ()
   {
      using namespace boost::interprocess;
      //Typedefs
      typedef allocator<char, managed_shared_memory::segment_manager> 
         CharAllocator;
      typedef basic_string<char, std::char_traits<char>, CharAllocator>
         MyShmString;
      typedef allocator<MyShmString, managed_shared_memory::segment_manager>
         StringAllocator;      
      typedef vector<MyShmString, StringAllocator>
         MyShmStringVector;

      //Open shared memory
      managed_shared_memory shm;
      shm.create("myshm", 10000);

      //Create allocators
      CharAllocator     charallocator  (shm.get_segment_manager());
      StringAllocator   stringallocator(shm.get_segment_manager());

      //This string is in only in this process (the pointer pointing to the
      //buffer that will hold the text is not in shared memory). 
      //But the buffer that will hold "this is my text" is allocated from 
      //shared memory
      MyShmString mystring(charallocator);
      mystring = "this is my text";

      //This vector is only in this process (the pointer pointing to the
      //buffer that will hold the MyShmString-s is not in shared memory). 
      //But the buffer that will hold 10 MyShmString-s is allocated from 
      //shared memory using StringAllocator. Since strings use a shared 
      //memory allocator (CharAllocator) the 10 buffers that hold 
      //"this is my text" text are also in shared memory.
      MyShmStringVector myvector(stringallocator);
      myvector.insert(myvector.begin(), 10, mystring);

      //This vector is fully constructed in shared memory. All pointers
      //and buffers are constructed in the same shared memory segment
      //This vector can be safely accessed from other processes.
      MyShmStringVector *myshmvector = 
         shm.construct<MyShmStringVector>("myshmvector")(stringallocator);
      myshmvector->insert(myshmvector->begin(), 10, mystring);

      //Destroy vector. This will free all strings that the vector contains
      shm.destroy_ptr(myshmvector);
      return 0;
   }

[endsect]

[endsect]


[section:customizing_boost_interprocess Customizing Interprocess]

[section:custom_interprocess_alloc Writing a new shared memory allocation algorithm]

Interprocess by default, uses a simple, space-friendly allocation algorithm implemented
by the class simple_seq_fit:

[section:simple_seq_fit simple_seq_fit: Default shared memory management algorithm]

The algorithm is a variation of sequential fit using singly 
linked list of free memory buffers. The algorithm is based 
on the article about shared memory titled 
[@http://home.earthlink.net/~joshwalker1/writing/SharedMemory.html ['"Taming Shared Memory"] ]. 
The algorithm is as follows:

The shared memory is divided in blocks of free shared memory, 
each one with some control data and several bytes of memory 
ready to be used. The control data contains a pointer (in 
our case offset_ptr) to the next free block and the size of 
the block. The allocator consists of a singly linked list 
of free blocks, ordered by address. The last block, points 
always to the first block:

[c++]

   simple_seq_fit  extra    free_block  1         free_block  2         free_block  3    
                   header   block_ctrl    usr     block_ctrl    usr     block_ctrl    usr
    ____________   _____   ___________________   ___________________   ___________________ 
   |            | |     | |             |     | |             |     | |             |     |
   | free | ctrl| |extra| | next | size | mem | | next | size | mem | | next | size | mem |
   |____________| |_____| |_____________|_____| |_____________|_____| |_____________|_____|
         |                 |   |                 |    |                 |  |               
         |__>__>__>__> _> _|   |__>__>__>__>__>__|    |__>__>__>__>__>__|  |              
                           |                                               | 
                           |_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_<_|


When a user requests N bytes of memory, the allocator 
traverses the free block list looking for a block large 
enough. If the "mem" part of the block has the same 
size as the requested memory, we erase the block from 
the list and return a pointer to the "mem" part of the 
block. If the "mem" part size is bigger than needed, 
we split the block in two blocks, one of the requested 
size and the other with remaining size. Now, we take 
the block with the exact size, erase it from list and 
give it to the user.

When the user deallocates a block, we traverse the list (remember 
that the list is ordered), and search its place depending on 
the block address. Once found, we try to merge the block with 
adjacent blocks if possible.

To ease implementation, the size of the free memory block 
is measured in multiples of "basic_size" bytes.  The basic 
size will be the size of the control block aligned to 
machine most restrictive alignment.

[c++]

   /*!This class implements the simple sequential fit algorithm with a simply
      linked list of free buffers.*/
   template<class MutexFamily, class VoidPointer>
   class simple_seq_fit : private boost::noncopyable
   {
    private:

      /*!Block control stucture*/
      struct block_ctrl
      {
         /*!Offset pointer to the next block. This pointer
            can't be null, since it's a diff pointer.*/
         offset_ptr<block_ctrl, offset_1_null_ptr>    next;
         /*!This block's memory size (including block_ctrl 
            header) in BasicSize units*/
         std::size_t                                  size;
      };

      /*...*/  
   
    public:
      /*!Shared interprocess_mutex family used for the rest of the interprocess framework*/
      typedef MutexFamily                          mutex_family;
      /*!the pointer type to be used for the rest of the interprocess framework*/
      typedef VoidPointer                          void_pointer;

    public:
      /*!Constructor. "size" is the total size of the fixed size memory segment, 
         "extra_hdr_bytes" indicates the extra bytes after the sizeof(simple_seq_fit)
         that the allocator should not use at all.*/
      simple_seq_fit           (std::size_t size, std::size_t extra_hdr_bytes);
      /*!Obtains the minimium size needed by the algorithm*/
      static std::size_t get_min_size (std::size_t extra_hdr_bytes);
      /*!Allocates bytes, returns 0 if there is not more memory*/
      void* allocate            (std::size_t nbytes);
      /*!Deallocates previously allocated bytes*/
      void   deallocate          (void *adr);
      /*!Returns the size of the memory segment*/
      std::size_t get_size()  const;
      /*!Increases managed memory in extra_size bytes more*/
      void grow(std::size_t extra_size);
      /*...*/  
   };

Let's explain these structs:

* *simple_seq_fit* is the main control block of the allocator. 

* The *extra_hdr_bytes* memory comes just after simple_seq_fit object. 
  This memory will be used by other classes to write more control 
  data at fixed position.

* *block_ctrl* is the structure which controls a free block 
  in memory. It contains the size of the free block (in aligned 
  sizeof (block_ctrl) units, called basic_size, as we've 
  said before) and an offset pointer to the next free block 
  in the shared memory segment. The number of bytes returned 
  by the allocator will be multiple of basic_size bytes to 
  maintain the alignment requirements.

[endsect]

[section:custom_alloc_algo How to implement you own algorithm]

If the default algorithm does not satisfy user requirements, 
it's easy to provide different algorithms like bitmapping or 
more advanced segregated lists to meet requirements. The characteristics
of your own algorithm:

* It shouldn't have any virtual function or virtual inheritance or
  any indirect base class with virtual function or inheritance.

* I has to implement the same public functions and typedefs of 
simple_seq_fit.

Let's see the public typedefs to define:

[c++]

   typedef /* . . . */ void_pointer;
   typedef /* . . . */ mutex_family;

The `void_pointer` typedef specifies the pointer type to be used in 
the Interprocess framework that uses the algorithm. For example, if we define

[c++]

   typedef void * void_pointer;

all Interprocess framework using this algorithm will use raw pointers as members.
But if we define:

[c++]

   typedef offset_ptr<void> void_pointer;

then all Interprocess framework will use relative pointers.

The `mutex_family` is an structure containing typedefs 
for different interprocess_mutex types to be used in the Interprocess 
framework. For example the defined

[c++]

   struct mutex_family
   {
      typedef boost::interprocess::interprocess_mutex                 mutex_t;
      typedef boost::interprocess::interprocess_recursive_mutex       recursive_mutex_t;
   };

defines all interprocess_mutex types using boost::interprocess interprocess_mutex types. The 
user can specify the desired interprocess_mutex family.

[c++]

   typedef mutex_family mutex_family;

The new algorithm (let's call it *my_algorithm*) must implement the all the functions
that boost::interprocess::simple_seq_fit class offers:

* The *my_algorithm* constructor must take 2 arguments: 
   * *size* indicates the total size of the managed memory segment, and
     the *my_algorithm* object will be always constructed a at offset 0 
     of the memory segment. 
 
   * The *extra_hdr_bytes* parameter indicates the number of bytes after
     the offset sizeof(*my_algorithm*) that *my_algorithm* can't use at all. This extra
     bytes will be used to store additional data that should not be overwritten.
     So, *my_algorithm* will be placed at address XXX of the memory segment, and will
     manage the *[XXX + sizeof(my_algorithm) + extra_hdr_bytes, XXX + size)* range of
     the segment.

* The *get_min_size()* function should return the minimum space the algorithm 
  needs to be valid with the passed *extra_hdr_bytes* parameter. This function will 
  be used to check if the memory segment is big enough to place the algorithm there.

* The *allocate()* function must return 0 if there is no more available memory. 
  The memory returned by *my_algorithm*
  must be aligned to the most restrictive memory alignment of the system, for example,
  to the value returned by *boost::alignment_of<boost::detail::max_align>::value*.
  This function should be executed with the synchronization capabilities offered
  by `typename mutex_family::mutex_t` interprocess_mutex. That means, that if we define 
  `typedef mutex_family mutex_family;` then this function should offer
  the same synchronization as if it was surrounded by a interprocess_mutex lock/unlock.
  Normally, this is implemented using a member mutex_family::mutex_t, but it could
  be done using atomic instructions or lock free algorithms.

* The *deallocate()* function must make the returned buffer available for new 
  allocations. This function should offer the same synchronization as `allocate()`.

* The *size()* function will return the passed *size* parameter in the constructor. 
  So, *my_algorithm* should store the size internally.

* The *grow()* function will expand the managed memory by *my_algorithm* in *extra_size* 
  bytes. So *size()* function should return the updated size,
  and the new managed memory range will be (if the address where the algorithm is
  constructed is XXX): *[XXX + sizeof(my_algorithm) + extra_hdr_bytes, XXX + old_size + extra_size)*.
  This function should offer the same synchronization as `allocate()`.

That's it. Now we can create new front-ends that use our new algorithm:

[c++]

   //Front-end to allocate named (c-string) objects
   //using special algorithm
   basic_managed_shared_memory<char, 
                            ,my_algorithm
                            ,flat_map_index>  
      my_managed_shared_memory;

[endsect]

[endsect]

[section:custom_allocators Building custom STL compatible allocators for Interprocess]

If provided STL-like allocators don't satisfy user needs, the user 
can use another STL compatible allocator and use basic shared 
memory allocation functions and named shared memory functions. 
The user can this way implement more suitable allocation 
schemes on top of basic shared memory allocation schemes, 
just like more complex allocators are built on top of 
new/delete functions.

When using a shared memory front-end, the *get_segment_manager()* 
function returns a pointer to the segment manager. With this pointer,
the raw memory and named shared memory allocation functions can be 
called directly:

[c++]

   //A named shared memory object creation fron-end
   managed_shared_memory segment;

   //Create the shared memory segment and initialize resources
   segment.create("/MySharedMemory",//segment name
                  65536);           //segment size in bytes
                  
   //Obtain the segment manager
   managed_shared_memory::segment_manager *segment_mngr 
      = segment.get_segment_manager();

   //With the segment manager, now we have access to all allocation functions
   segment_mngr->deallocate(segment_mngr->allocate(32));
   segment_mngr->construct<int>("My_Int")[32](0);
   segment_mngr->destroy<int>("My_Int");

   //Initialize the custom, shared memory STL compatible 
   //allocator with the segment manager
   MySTLAllocator<int> stl_alloc(segment_mngr);

   //Alias a new vector type that uses the custom STL compatible allocator
   typedef std::vector<int, MySTLAllocator<int> > MyVect;

   //Construct the vector in shared memory with allocator as constructor parameter
   segment.construct<MyVect>("MyVect_instance")(stl_alloc);

The user can create another STL compatible allocator that uses this pointer to access
to all shared memory named/raw object management functions. Interprocess STL compatible
allocators are based on this approach. *Remember* that shared memory STL-like allocators
should define their *pointer* typedef as the same pointer family as 
segment_manager::void_pointer typedef. This means that if segment_manager::void_pointer is
offset_ptr<void> the MySTLAllocator<int> should define pointer as offset_ptr<int>. The
reason for this is that allocators are members of containers, and if want to put
the container in shared memory, the allocator should be ready for that.

If the user wants to optimize further allocator usage in Interprocess node containers, he can 
change the common allocator::construct function from:

[c++]

   void construct(pointer ptr, const value_type &value);

to this one:

[c++]

   template<class Convertible>
   void construct(pointer ptr, const Convertible &value)

and define a specialization of `boost::interprocess::has_convertible_construct<...>` 
defined in `<boost/interprocess/detail/utilities.hpp>` file:

[c++]

   namespace boost{ namespace interprocess{ 

   template<class T, class SegmentManager>
   struct has_convertible_construct
      <my_allocator<T, SegmentManager> >
   {
      enum {   value = true };
   };

   }} //namespace boost{ namespace interprocess{ 

Using this optimization, Interprocess node containers will just store one allocator instance
instead of 2, because nodes could be constructed from the value type directly.

[endsect]

[section:custom_indexes Building custom indexes]

The named shared memory object allocation algorithm uses a name/buffer index to
speed up object searching and creation. Default specializations of 
basic_managed_shared_memory, use boost::interprocess::flat_map as index.

However, the index type can be chosen via template parameter, so that
the user can define its own index type if he needs that. To construct
a new index type, the user must create a class with the following guidelines:

* The interface of the index must follow the common public interface of std::map
  and future std::unordered_map including public typedefs. 
  The value_type typedef can be of type:

[c++]

   std::pair<key_type, mapped_type> 

or 

[c++]

   std::pair<const key_type, mapped_type>


so that ordered arrays or deques can be used as index types. 
Some known classes following this basic interface are boost::unordered_map, 
boost::interprocess::flat_map and boost::interprocess::map.

* The class must be a class template taking only a traits struct of this type:

[c++]

   struct index_traits
   {
      typedef /*...*/   key_type;
      typedef /*...*/   mapped_type;
      typedef /*...*/   segment_manager;
   };


[c++]

   template <class IndexTraits>
   class my_index_type;

The key_type typedef of the passed index_traits will be a instantiation of the following class:
            
[c++]

   /*!The key of the the named allocation information index. Stores a to
      a null string and the length of the string to speed up sorting*/
   template<...>
   struct index_key
   {
      typedef /*...*/                              char_type;
      typedef /*...*/                              const_char_ptr_t;

      //Pointer to the object's name
      const_char_ptr_t                             mp_str;

      //Length of the name buffer (null NOT included)
      std::size_t                                  m_len;

      /*!Constructor of the key*/
      index_key (const CharT *name, std::size_t length);

      /*!Less than function for index ordering*/
      bool operator < (const index_key & right) const;

      /*!Equal to function for index ordering*/
      bool operator == (const index_key & right) const;
   };

The mapped_type is not directly modified by the customized index but it is needed to 
define the index type. The *segment_manager* will be the type of the segment manager
that provides memory allocation.
            
* The constructor of the customized index type must take a pointer to segment_manager
  as constructor argument:

[c++]

   constructor(segment_manager *alloc);

* The index must provide a memory reservation function, that optimizes the index if the 
  user knows the number of elements to be inserted in the index:

[c++]

   void reserve(std::size_t n);

For example, the default index type flat_map_index based in boost::interprocess::flat_map 
is just defined as:

[c++]

   namespace boost { namespace interprocess {

   /*!Helper class to define typedefs from IndexTraits*/
   template <class MapConfig>
   struct flat_map_index_aux
   {
      typedef typename MapConfig::key_type            key_type;
      typedef typename MapConfig::mapped_type         mapped_type;
      typedef typename MapConfig::segment_manager     segment_manager;
      typedef std::less<key_type>                     key_less;
      typedef std::pair<key_type, mapped_type>        value_type;
      typedef allocator<value_type, segment_manager>  allocator_type;
      typedef flat_map<key_type, mapped_type,
                       key_less, allocator_type>      index_t;
   };

   /*!Index type based in flat_map. Just derives from flat_map and
      defines the interface needed by the shared named object creation class*/
   template <class MapConfig>
   class flat_map_index
      //Derive class from map specialization
      : public flat_map_index_aux<MapConfig>::index_t
   {
      typedef flat_map_index_aux<MapConfig>        index_aux;
      typedef typename index_aux::index_t          base_type;
      typedef typename index_aux::segment_manager  segment_manager;

      public:
      /*!Constructor. Takes a pointer to the
         segment manager. Can throw*/
      flat_map_index(segment_manager *segment_mngr)
         : base_type(typename index_aux::key_less(),
                     typename index_aux::allocator_type(segment_mngr))
      {}

      /*!This reserves memory to optimize the insertion of n
         elements in the index*/
      void reserve(std::size_t n)
      {  base_type::reserve(n);  }
   };

   }}   //namespace boost { namespace interprocess

If the user is defining a node container based index (a container whose iterators 
are not invalidated when inserting or erasing other elements), Interprocess can optimize
named object destruction when destructing via pointer. Interprocess can store an iterator
next to the object and this way, instead of using the name of the object to erase 
the index entry, it uses the iterator, which is a faster way. So if you are creating
a new node container based index (for example, a tree), you should define an
specialization of `boost::interprocess::is_node_index<...>` defined in 
`<boost/interprocess/detail/utilities.hpp>`:

[c++]

   /*!Trait classes to detect if an index is a node
      index. This allows more efficient operations
      when deallocating named objects.*/
   template<class MapConfig>
   struct is_node_index
      <my_index<MapConfig> >
   {
      enum {   value = true };
   };

Interprocess also defines other index types:

* [*boost::map_index] uses *boost::interprocess::map* as index type.

* [*boost::null_index] that uses an dummy index type if the user just needs
  anonymous allocations and want's to save some space and class instantations.

To define a new front-end that uses the new index:

[c++]

   /*!Defines the named shared object allocation with a c-string as 
      a key, the simple sequential fit algorithm (with process-shared mutexes)
      as raw shared memory management algorithm and a custom index*/
   typedef 
      basic_managed_shared_memory < 
                                 char, 
                                 simple_seq_fit<mutex_family>,
                                 my_index_type
                                >  
      my_managed_shared_memory;

[endsect]

[endsect]


[section:beyond_shared_memory Beyond shared memory]

Interprocess offers shared memory management, and allows placing STL compatible 
containers and allocators. It offers raw memory allocation and
anonymous and named object creation.

Shared memory management is mainly a fixed size buffer management, so several
Interprocess services could be reused to use other non-shared memory fixed size buffers. 
These services include STL compatible containers, STL compatible allocators, named object creation, etc...

Applications for Interprocess services using non-shared memory buffers:

* Create and use STL compatible containers and allocators, in systems with no dynamic memory

* Build complex, easily serializable databases in a single buffer:

   * To share data between threads

   * To save and load information from/to files.

* Duplicate information (containers, allocators, etc...) just copying the contents of one buffer to another one.

* Send complex information and objects/databases using serial/inter-process/network communications.

* Data persistence through memory-mapped files.

To help with this management, Interprocess provides some useful classes, 
with the same functionality as *basic_managed_shared_memory*:

[section:user_buffer_interprocess Constructing all Interprocess objects in a user provided buffer]

Sometimes, the user wants to create simple objects, STL compatible containers, STL compatible
strings and more, all in a single buffer. This buffer could be a big static buffer, 
a memory-mapped auxiliary device or any other user buffer.

This would allow a easy serialization, since we just have copy the buffer to duplicate
all the objects created in the original buffer, and this includes complex objects like
maps, lists or any user classes. Interprocess offers classes to handle user provided buffers
that allow the same functionality as shared memory classes:

[c++]

   //Named object creation front-end
   //All objects are constructed in a a user provided buffer
   template <
               class CharType, 
               class MemoryAlgorithm, 
               template<class IndexConfig> class IndexType
            >
   class basic_managed_external_buffer;

   //Named object creation front-end
   //All objects are constructed in a a user provided buffer
   //   Names are c-strings, 
   //   Default memory management algorithm(simple_seq_fit with no mutexes)
   //   Name-object mappings are stored in the default index type (flat_map)
   typedef basic_managed_external_buffer < 
      char, 
      simple_seq_fit<null_mutex_family>, offset_ptr<void> ,
      flat_map_index
      >  managed_external_buffer;

   //Named object creation front-end
   //All objects are constructed in a a user provided buffer
   //   Names are wide-strings, 
   //   Default memory management algorithm(simple_seq_fit with no mutexes)
   //   Name-object mappings are stored in the default index type (flat_map)
   typedef basic_managed_external_buffer< 
      wchar_t, 
      simple_seq_fit<null_mutex_family, offset_ptr<void> >,
      flat_map_index
      >  wmanaged_external_buffer;
   
Let's see an example of the use of these classes:

[c++]

   //Create the user memory who will store all objects
   const int memsize = 65536;
   static char static_buffer [memsize];

   //Named (wide-string) new capable user mem front-end
   wmanaged_external_buffer objects_in_user_memory;

   //Initialize the static buffer and initialize resources
   objects_in_user_memory.create(static_buffer, memsize);

   //We optimize resources to create 100 named objects in the static buffer
   objects_in_user_memory.reserve_named_objects(100);

   //Alias <integer, 64 element per chunk> node allocator type
   //This allocator will allocate memory inside the static buffer
   typedef wmanaged_external_buffer::node_allocator_type
      <int, 64>::type node_allocator_t;

   //Alias a STL compatible list to be constructed in the static buffer
   typedef boost::interprocess::list<int, node_allocator_t>    MyBufferList;

   //The list must be initialized with the allocator
   MyBufferList *list = objects_in_user_memory.construct<MyBufferList>(L"MyList")
                           (objects_in_user_memory.get_segment_manager());

   //All objects created with objects_in_user_memory will be stored in the static_buffer!

   //Destroy the whole list from the static buffer
   objects_in_user_memory.destroy<MyBufferList>(L"MyList");

Interprocess STL compatible allocators can also be used to place STL 
compatible containers in the user segment.

[endsect]

[section:heap_buffer_interprocess Interprocess machinery in heap memory]

The use of heap memory (new/delete) to obtain a buffer where the user wants to store all 
his data is very common, so Interprocess provides some specialized 
classes that work exclusively with heap memory. 

These are the classes:

[c++]

   //Named object creation front-end
   //All objects are constructed in a single buffer allocated via new[]
   template <
               class CharType, 
               class MemoryAlgorithm, 
               template<class IndexConfig> class IndexType
            >
   class basic_managed_heap_memory;

   //Named object creation front-end
   //All objects are constructed in a single buffer allocated via new[]
   //   Names are c-strings, 
   //   Default memory management algorithm(simple_seq_fit with no mutexes)
   //   Name-object mappings are stored in the default index type (flat_map)
   typedef basic_managed_heap_memory < 
      char, 
      simple_seq_fit<null_mutex_family, void*>,
      flat_map_index
      >  managed_heap_memory;

   //Named object creation front-end
   //All objects are constructed in a single buffer allocated via new[]
   //   Names are wide-strings, 
   //   Default memory management algorithm(simple_seq_fit with no mutexes)
   //   Name-object mappings are stored in the default index type (flat_map)
   typedef basic_managed_heap_memory< 
      wchar_t, 
      simple_seq_fit<null_mutex_family, void*>,
      flat_map_index
      >  wmanaged_heap_memory;

and the use is exactly the same as before, except that memory is created by the front-end 
itself using dynamic (new/delete) memory:

[c++]

   //Create the heap memory who will store all objects
   const int memsize = 65536;

   //Named new capable heap mem front-end
   wmanaged_heap_memory objects_in_heap_memory;

   //Create a dynamic buffer of size "memsize" and initialize resources
   objects_in_heap_memory.create(memsize);

   //We optimize resources to create 100 named objects in the dynamic buffer
   objects_in_heap_memory.reserve_named_objects(100);

   //Alias <integer, 64 element per chunk> node allocator type
   //This allocator will allocate memory inside the dynamic buffer
   typedef wmanaged_heap_memory::node_allocator_type
      <int, 64 >::type node_allocator_t;

   //Alias a STL compatible list to be constructed in the dynamic buffer
   typedef boost::interprocess::list<int, node_allocator_t>    MyHeapList;

   //The list must be initialized with the allocator
   //since it has no default constructor
   MyHeapList *heaplist = objects_in_heap_memory.construct<MyHeapList>(L"MyList")
                           (objects_in_heap_memory.get_segment_manager());

   //All objects created with objects_in_user_memory will be stored in the static_buffer!

   //Destroy the whole list from the dynamic buffer
   objects_in_heap_memory.destroy<MyHeapList>(L"MyList");

[*basic_managed_heap_memory] also offers a `grow(std::size_t extra_bytes)` function that
tries to resize internal heap memory so that we have room for more objects. 
But *be careful*, if memory is reallocated, the old buffer will be copied into 
the new one so all the objects will be binary-copied to the new buffer. 
To be able to use this function, all pointers constructed in the heap buffer that
point to objects in the heap buffer must be offset pointers and all objects should be
binary copiable. Otherwise, the result is undefined. Here is an example:

[c++]

   #include <boost/interprocess/containers/list.hpp>
   #include <boost/interprocess/managed_heap_memory.hpp>
   #include <boost/interprocess/allocators/allocator.hpp>
   #include <cstddef>

   using namespace boost::interprocess;
   typedef list<int, allocator<int, managed_heap_memory::segment_manager> > MyList;

   int main ()
   {
      managed_heap_memory heap_memory;

      //We will create a buffer of 1000 bytes to store a list
      heap_memory.create(1000);
      MyList * mylist = heap_memory.construct<MyList>("MyList")
                           (heap_memory.get_segment_manager());

      //Obtain offset, that identifies the list in the buffer
      std::ptrdiff_t list_offset = heap_memory.get_offset_from_address(mylist);

      //Fill list until there is no more memory in the buffer
      try{
         while(1) {
            mylist->insert(mylist->begin(), 0);
         }
      }
      catch(const bad_alloc &){
         //memory is full
      }
      //Let's obtain the size of the list
      std::size_t old_size = mylist->size();

      //To make the list bigger, let's increase the heap buffer
      //in 1000 bytes more.
      heap_memory.grow(1000);

      //If memory has been reallocated, the old pointer is invalid, so
      //use previously obtained offset to find the new pointer.
      mylist = static_cast<MyList *>
                  (heap_memory.get_address_from_offset(list_offset));
      
      //Fill list until there is no more memory in the buffer
      try{
         while(1) {
            mylist->insert(mylist->begin(), 0);
         }
      }
      catch(const bad_alloc &){
         //memory is full
      }

      //Let's obtain the new size of the list      
      std::size_t new_size = mylist->size();

      assert(new_size > old_size);

      //Destroy list
      heap_memory.destroy_ptr(mylist);

      return 0;
   }


[endsect]

[section:memory_mapped_interprocess Interprocess with memory-mapped files]

One of the most useful things in operating systems are memory-mapped files, since the
OS user works directly in memory with a big file whose contents are too big to fit in 
memory, and the OS automatically loads, dumps, and synchronizes to memory the current
file contents.

Interprocess can directly work with memory mapped files, so that all objects, containers and 
other Interprocess resources get automatic data persistence support:

[c++]

   //Named object creation front-end
   //All objects are constructed in the memory-mapped file
   template <
               class CharType, 
               class MemoryAlgorithm, 
               template<class IndexConfig> class IndexType
            >
   class basic_managed_mapped_file;

   //Named object creation front-end
   //All objects are constructed in the memory-mapped file
   //   Names are c-strings, 
   //   Default memory management algorithm(simple_seq_fit with no mutexes)
   //   Name-object mappings are stored in the default index type (flat_map)
   typedef basic_managed_mapped_file < 
      char, 
      simple_seq_fit<mutex_family, offset_ptr<void> >,
      flat_map_index
      >  managed_mapped_file;

   //Named object creation front-end
   //All objects are constructed in the memory-mapped file
   //   Names are wide-strings, 
   //   Default memory management algorithm(simple_seq_fit with no mutexes)
   //   Name-object mappings are stored in the default index type (flat_map)
   typedef basic_managed_mapped_file< 
      wchar_t, 
      simple_seq_fit<mutex_family, offset_ptr<void> >,
      flat_map_index
      >  wmanaged_mapped_file;

We can use any Interprocess container, allocator, named object creation, etc... And we have a 
*flush()* function to make sure data is dumped to the file:

[/ interprocess_doc_managed_heap_memory.cpp]

[c++]

   #include <boost/interprocess/managed_mapped_file.hpp>
   #include <boost/interprocess/allocator.hpp>
   #include <boost/interprocess/containers/vector.hpp>

   using namespace boost::interprocess;

   int main ()
   {
      //STL compatible allocator object for memory-mapped file
      typedef allocator<int, managed_mapped_file::segment_manager> allocator_int_t;
      typedef boost::interprocess::vector<int, allocator_int_t > MyVect;

      const int filesize = 65536;
      const char *const fileName = "MyMappedFile";

      //Named allocate capable memory mapped file front-end
      managed_mapped_file file_mapping;

      //Create memory-mapped file and initialize Interprocess machinery
      if(!file_mapping.create(fileName, filesize)){
         return false;
      }

      //Construct the STL compatible allocator with the memory management algorithm
      const allocator_int_t myallocator (file_mapping.get_segment_manager());

      //Construct vector
      MyVect *mfile_vect = file_mapping.construct<MyVect> ("MyVector") (myallocator);

      //Test that vector can be found via name
      if(mfile_vect != file_mapping.find<MyVect>("MyVector").first)
         return -1;

      //Destroy and check it is not present
      file_mapping.destroy<MyVect> ("MyVector");
      if(0 != file_mapping.find<MyVect>("MyVector").first)
         return -1;

      //Construct another vector in the memory-mapped file
      mfile_vect = file_mapping.construct<MyVect> ("MyVector") (myallocator);
      
      //Flush cached data from memory-mapped file to disk
      file_mapping.flush();

      //Close mapped file
      file_mapping.close();

      //Map preexisting file again in memory
      if(!file_mapping.open(fileName)){
         return -1;
      }

      //Check vector is still there
      mfile_vect = file_mapping.find<MyVect>("MyVector").first;
      if(!mfile_vect)
         return -1;

      //Destroy and check it is not present
      file_mapping.destroy_ptr(mfile_vect);
      if(0 != file_mapping.find<MyVect>("MyVector").first)
         return -1;
      return 0;
   }

[*basic_managed_mapped_file] also offers a `grow(std::size_t extra_bytes)` function that
tries to resize the mapped file so that we have room for more objects. 
But *be careful*, the file can be remapped in another base
address. To be able to use this function, all pointers constructed in the mapped file that
point to objects in the mapped file must be offset pointers. [*If `grow()` fails, ] 
[*the mapping can't be recovered] and the file mapping will be closed. You will need 
to call *open()* again to open it with the old size. Here the same example as with
basic_managed_heap_memory, but using memory mapped files:

[/ interprocess_doc_managed_mapped_file.cpp]

[c++]

   #include <boost/interprocess/containers/list.hpp>
   #include <boost/interprocess/managed_mapped_file.hpp>
   #include <boost/interprocess/allocators/allocator.hpp>
   #include <cstddef>

   using namespace boost::interprocess;
   typedef list<int, allocator<int, managed_mapped_file::segment_manager> > MyList;

   int main ()
   {
      managed_mapped_file mfile_memory;

      //We will create a mapped file of 1000 bytes to store a list
      mfile_memory.create("./file_mapping", 1000);
      MyList * mylist = mfile_memory.construct<MyList>("MyList")
                           (mfile_memory.get_segment_manager());

      //Obtain offset, that identifies the list in the buffer
      std::ptrdiff_t list_offset = mfile_memory.get_offset_from_address(mylist);

      //Fill list until there is no more room in the file
      try{
         while(1) {
            mylist->insert(mylist->begin(), 0);
         }
      }
      catch(const bad_alloc &){
         //mapped file is full
      }
      //Let's obtain the size of the list
      std::size_t old_size = mylist->size();

      //To make the list bigger, let's increase the mapped file
      //in 1000 bytes more.
      mfile_memory.grow(1000);

      //If mapping address has changed, the old pointer is invalid,
      //so use previously obtained offset to find the new pointer.
      mylist = static_cast<MyList *>
                  (mfile_memory.get_address_from_offset(list_offset));
      
      //Fill list until there is no more room in the file
      try{
         while(1) {
            mylist->insert(mylist->begin(), 0);
         }
      }
      catch(const bad_alloc &){
         //mapped file is full
      }

      //Let's obtain the new size of the list      
      std::size_t new_size = mylist->size();

      assert(new_size > old_size);

      //Destroy list
      mfile_memory.destroy_ptr(mylist);

      return 0;
   }

[endsect]

[endsect]

[section:streams Direct iostream formatting: vectorstream and bufferstream]

Shared memory, memory-mapped files and all Interprocess mechanisms are focused
on efficiency. The reason why shared memory is used is that it's the
fastest IPC mechanism available. When passing text-oriented messages through
shared memory, there is need to format the message. Obviously C++ offers
the iostream framework for that work.

Some programmers appreciate the iostream safety and design for memory
formatting but feel that the stringstream family is far from efficient not
when formatting, but when obtaining formatted data to a string, or when 
setting the string from which the stream will extract data. An example:

[c++]

   //Some formatting elements
   std::string my_text = "...";
   int number;
   
   //Data reader
   std::istringstream input_processor;
   
   //This makes a copy of the string. If not using a
   //reference counted string, this is a serious overhead.
   input_processor.str(my_text);

   //Extract data
   while(/*...*/){
      input_processor >> number;
   }
   
   //Data writer
   std::ostringstream output_processor;
   
   //Write data
   while(/*...*/){
      output_processor << number;
   }
   
   //This returns a temporary string. Even with return-value
   //optimization this is expensive.
   my_text = input_processor.str();

The problem is even worse if the string is a shared-memory string, because
to extract data, we must copy the data first from shared-memory to a 
std::string and then to a stringstream. To encode data in a shared-memory
string we should copy data from a stringstream to a std::string and then 
to the shared-memory string. 

Because of this overhead, Interprocess offers a way to format memory-strings
(in shared memory, memory mapped files or any other memory segment) that
can avoid all unneeded string copy and memory allocation/deallocation, while
using all iostream facilities. Interprocess *vectorstream* and *bufferstream* implement
vector-based and fixed-size buffer based storage support for iostreams and
all the formatting/locale hard work is done by standard std::basic_streambuf<>
and std::basic_iostream<> classes.

[section:vectorstream Formatting directly in your character vector: vectorstream]

The *vectorstream* class family (*basic_vectorbuf*, *basic_ivectorstream*
,*basic_ovectorstream* and *basic_vectorstream*) is an efficient way to obtain 
formatted reading/writing directly in a character vector. This way, if
a shared-memory vector is used, data is extracted/written from/to the shared-memory
vector, without additional copy/allocation. We can see the declaration of 
basic_vectorbuf and basic_vectorstream here:

[c++]

   /*!A streambuf class that controls the transmission of elements to and from
      a basic_ivectorstream, basic_ovectorstream or basic_vectorstream. 
      It holds a character vector specified by CharVector template parameter
      as its formatting buffer. The vector must have contiguous storage, like 
      std::vector, boost::interprocess::vector or boost::interprocess::basic_string*/
   template <class CharVector, class CharTraits = 
            std::char_traits<typename CharVector::value_type> >
   class basic_vectorbuf 
      : public std::basic_streambuf<typename CharVector::value_type, CharTraits>
   {
      public:
      typedef CharVector                        vector_type;
      typedef typename CharVector::value_type   char_type;
      typedef typename CharTraits::int_type     int_type;
      typedef typename CharTraits::pos_type     pos_type;
      typedef typename CharTraits::off_type     off_type;
      typedef CharTraits                        traits_type;

      /*!Constructor. Throws if vector_type default constructor throws.*/
      explicit basic_vectorbuf(std::ios_base::openmode mode
                                 = std::ios_base::in | std::ios_base::out);

      /*!Constructor. Throws if vector_type(const Parameter &param) throws.*/
      template<class Parameter>
      explicit basic_vectorbuf(const Parameter &param,
                              std::ios_base::openmode mode
                                    = std::ios_base::in | std::ios_base::out);
      virtual ~basic_vectorbuf(){}

      /*!Swaps the underlying vector with the passed vector. 
         This function resets the position in the stream.
         Does not throw.*/
      void swap_vector(vector_type &vect);

      /*!Returns a const reference to the internal vector.
         Does not throw.*/
      const vector_type &vector() const;

      /*!Calls resize() method of the internal vector.
         Resets the stream to the first position.
         Throws if the internals vector's resize throws.*/
      void resize(typename vector_type::size_type size);
   };

   /*!A basic_iostream class that holds a character vector specified by CharVector
      template parameter as its formatting buffer. The vector must have
      contiguous storage, like std::vector, boost::interprocess::vector or
      boost::interprocess::basic_string*/
   template <class CharVector, class CharTraits = 
            std::char_traits<typename CharVector::value_type> >
   class basic_vectorstream 
   : public std::basic_iostream<typename CharVector::value_type, CharTraits>

   {
      public:
      typedef CharVector                                                   vector_type;
      typedef typename std::basic_ios
         <typename CharVector::value_type, CharTraits>::char_type          char_type;
      typedef typename std::basic_ios<char_type, CharTraits>::int_type     int_type;
      typedef typename std::basic_ios<char_type, CharTraits>::pos_type     pos_type;
      typedef typename std::basic_ios<char_type, CharTraits>::off_type     off_type;
      typedef typename std::basic_ios<char_type, CharTraits>::traits_type  traits_type;

      /*!Constructor. Throws if vector_type default constructor throws.*/
      basic_vectorstream(std::ios_base::openmode mode 
                        = std::ios_base::in | std::ios_base::out);

      /*!Constructor. Throws if vector_type(const Parameter &param) throws.*/
      template<class Parameter>
      basic_vectorstream(const Parameter &param, std::ios_base::openmode mode
                        = std::ios_base::in | std::ios_base::out);

      ~basic_vectorstream(){}

      //Returns the address of the stored stream buffer.
      basic_vectorbuf<CharVector, CharTraits>* rdbuf() const;

      /*!Swaps the underlying vector with the passed vector. 
         This function resets the position in the stream.
         Does not throw.*/
      void swap_vector(vector_type &vect);

      /*!Returns a const reference to the internal vector.
         Does not throw.*/
      const vector_type &vector() const;

      /*!Calls resize() method of the internal vector.
         Resets the stream to the first position.
         Throws if the internals vector's resize throws.*/
      void resize(typename vector_type::size_type size);
   };

The vector type is templatized, so that we can use any type of vector:
*std::vector*, *boost::interprocess::vector*.... But the storage must be *contiguous*,
we can't use a deque. We can even use *boost::interprocess::basic_string*, since it has a 
vector interface and it has contiguous storage. *We can't use std::string*, because 
although some std::string implementation are vector-based, others can have 
optimizations and reference-counted implementations.

The user can obtain a const reference to the internal vector using 
`vector_type vector() const` function and he also can swap the internal vector
with an external one calling `void swap_vector(vector_type &vect)`. 
The swap function resets the stream position.
This functions allow efficient methods to obtain the formatted data avoiding
all allocations and data copies. 

Let's see an example to see how to use vectorstream:

[c++]

   #include <boost/interprocess/containers/vector.hpp>
   #include <boost/interprocess/containers/string.hpp>
   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <boost/interprocess/streams/vectorstream.hpp>
   #include <iterator>
   
   using namespace boost::interprocess;

   typedef allocator<int, managed_shared_memory::segment_manager> 
      IntAllocator;
   typedef allocator<char, managed_shared_memory::segment_manager> 
      CharAllocator;
   typedef vector<int, IntAllocator>   MyVector;
   typedef basic_string
      <char, std::char_traits<char>, CharAllocator>   MyString;
   typedef basic_vectorstream<MyString>               MyVectorStream;

   int main ()
   {
      //Create shared memory
      managed_shared_memory segment;
      if(!segment.create("/MySharedMemory",  //segment name
                         65536)){            //segment size in bytes
         return -1;
      }

      //Construct shared memory vector
      MyVector *myvector = 
         segment.construct<MyVector>("MyVector")
         (IntAllocator(segment.get_segment_manager()));

      //Fill vector
      myvector->reserve(100);
      for(int i = 0; i < 100; ++i){
         myvector->push_back(i);
      }

      //Create the vectorstream. To create the internal shared memory
      //basic_string we need to pass the shared memory allocator as
      //a constructor argument
      MyVectorStream myvectorstream(CharAllocator(segment.get_segment_manager()));

      //Resize the internal string
      myvectorstream.resize(100*5);

      //Write all vector elements as text in the internal string
      //Data will be directly written in shared memory, because
      //internal string's allocator is a shared memory allocator
      for(std::size_t i = 0, max = myvector->size(); i < max; ++i){
         myvectorstream << (*myvector)[i] << std::endl;
      }

      //Auxiliary vector to compare original data
      MyVector *myvector2 =
         segment.construct<MyVector>("MyVector2")
         (IntAllocator(segment.get_segment_manager()));

      //Avoid reallocations
      myvector2->reserve(100);

      //Extract all values from the internal 
      //string directly to a shared memory vector.
      std::istream_iterator<int> it(myvectorstream), itend;
      std::copy(it, itend, std::back_inserter(*myvector2));

      //Compare vectors
      assert(std::equal(myvector->begin(), myvector->end(), myvector2->begin()));

      //Create a copy of the internal string
      MyString stringcopy (myvectorstream.vector());

      //Now we create a new empty shared memory string...
      MyString *mystring = 
         segment.construct<MyString>("MyString")
         (CharAllocator(segment.get_segment_manager()));
   
      //...and we swap vectorstream's internal string
      //with the new one: after this statement mystring
      //will be the owner of the formatted data.
      //No reallocations, no data copies
      myvectorstream.swap_vector(*mystring);

      //Let's compare both strings
      assert(stringcopy == *mystring);

      //Done, destroy and delete vectors and string from the segment
      segment.destroy_ptr(myvector2);
      segment.destroy_ptr(myvector);
      segment.destroy_ptr(mystring);
      return 0;
   }
   
[endsect]

[section:bufferstream Formatting directly in your character buffer: bufferstream]

As seen, vectorstream offers an easy and secure way for efficient iostream
formatting, but many times, we have to read or write formatted data from/to a
fixed size character buffer (a static buffer, a c-string, or any other).
Because of the overhead of stringstream, many developers (specially in 
embedded systems) choose sprintf family. The *bufferstream* classes offer 
iostream interface with direct formatting in a fixed size memory buffer with 
protection against buffer overflows. This is the interface:

   /*!A streambuf class that controls the transmission of elements to and from
      a basic_xbufferstream. The elements are transmitted from a to a fixed
      size buffer*/
   template <class CharT, class CharTraits = std::char_traits<CharT> >
   class basic_bufferbuf 
      : public std::basic_streambuf<CharT, CharTraits>
   {
      public:
      typedef CharT                             char_type;
      typedef typename CharTraits::int_type     int_type;
      typedef typename CharTraits::pos_type     pos_type;
      typedef typename CharTraits::off_type     off_type;
      typedef CharTraits                        traits_type;
      typedef std::basic_streambuf<char_type, traits_type> base_t;

      public:
      /*!Constructor. Does not throw.*/
      explicit basic_bufferbuf(std::ios_base::openmode mode
                               = std::ios_base::in | std::ios_base::out);

      /*!Constructor. Assigns formatting buffer. Does not throw.*/
      explicit basic_bufferbuf(CharT *buffer, std::size_t length, 
                               std::ios_base::openmode mode
                                 = std::ios_base::in | std::ios_base::out);

      /*!Returns the pointer and size of the internal buffer. 
         Does not throw.*/
      std::pair<CharT *, std::size_t> buffer() const;

      /*!Sets the underlying buffer to a new value. Does not throw.*/
      void buffer(CharT *buffer, std::size_t length);
   };

   /*!A basic_iostream class that uses a fixed size character buffer
      as its formatting buffer.*/
   template <class CharT, class CharTraits = std::char_traits<CharT> >
   class basic_bufferstream 
      : public std::basic_iostream<CharT, CharTraits>

   {
      public:                         // Typedefs
      typedef typename std::basic_ios
         <CharT, CharTraits>::char_type          char_type;
      typedef typename std::basic_ios<char_type, CharTraits>::int_type     int_type;
      typedef typename std::basic_ios<char_type, CharTraits>::pos_type     pos_type;
      typedef typename std::basic_ios<char_type, CharTraits>::off_type     off_type;
      typedef typename std::basic_ios<char_type, CharTraits>::traits_type  traits_type;
      
      /*!Constructor. Does not throw.*/
      basic_bufferstream(std::ios_base::openmode mode 
                        = std::ios_base::in | std::ios_base::out);

      /*!Constructor. Assigns formatting buffer. Does not throw.*/
      basic_bufferstream(CharT *buffer, std::size_t length,
                        std::ios_base::openmode mode
                           = std::ios_base::in | std::ios_base::out);

      /*!Returns the address of the stored stream buffer.*/
      basic_bufferbuf<CharT, CharTraits>* rdbuf() const;

      /*!Returns the pointer and size of the internal buffer. 
         Does not throw.*/
      std::pair<CharT *, std::size_t> buffer() const;

      /*!Sets the underlying buffer to a new value. Resets 
         stream position. Does not throw.*/
      void buffer(CharT *buffer, std::size_t length);
   };   

   //Some typedefs to simplify usage
   typedef basic_bufferbuf<char>        bufferbuf;
   typedef basic_bufferstream<char>     bufferstream;
   typedef basic_ibufferstream<char>    ibufferstream;
   typedef basic_obufferstream<char>    obufferstream;

   typedef basic_bufferbuf<wchar_t>     wbufferbuf;
   typedef basic_bufferstream<wchar_t>  wbufferstream;
   typedef basic_ibufferstream<wchar_t> wibufferstream;
   typedef basic_obufferstream<wchar_t> wobufferstream;

While reading from a fixed size buffer, *bufferstream* activates endbit flag if
we try to read an address beyond the end of the buffer. While writing to a
fixed size buffer, *bufferstream* will active the badbit flag if a buffer overflow
is going to happen and disallows writing. This way, the fixed size buffer 
formatting through *bufferstream* is secure and efficient, and offers a good 
alternative to sprintf/sscanf functions. Let's see an example:

[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <boost/interprocess/streams/bufferstream.hpp>
   #include <vector>
   #include <iterator>
   
   using namespace boost::interprocess;

   int main ()
   {
      //Create shared memory
      managed_shared_memory segment;
      if(!segment.create("/MySharedMemory",  //segment name
                         65536)){            //segment size in bytes
         return -1;
      }

      //Fill data
      std::vector<int> data, data2;
      data.reserve(100);
      for(int i = 0; i < 100; ++i){
         data.push_back(i);
      }

      //Allocate a buffer in shared memory to write data
      char *my_cstring = 
         segment.construct<char>("MyCString")[100*5](0);
      bufferstream mybufstream(my_cstring, 100*5);

      //Now write data to the buffer
      for(int i = 0; i < 100; ++i){
         mybufstream << data[i] << std::endl;
      }

      //Check there was no overflow attempt
      assert(mybufstream.good());

      //Extract all values from the shared memory string
      //directly to a vector.
      data2.reserve(100);
      std::istream_iterator<int> it(mybufstream), itend;
      std::copy(it, itend, std::back_inserter(data2));

      //This extraction should have ended will fail error
      //since the numbers formatted in the buffer end
      //before the end of the buffer. (Otherwise it would
      //trigger eofbit)
      assert(mybufstream.fail());

      //Compare data
      assert(std::equal(data.begin(), data.end(), data2.begin()));

      //Clear errors and rewind
      mybufstream.clear();
      mybufstream.seekp(0, std::ios::beg);
      
      //Now write again the data trying to do a buffer overflow
      for(int i = 0; i < 500; ++i){
         mybufstream << data[i] << std::endl;
      }

      //Now make sure badbit is active
      //which means overflow attempt.
      assert(!mybufstream.good());
      assert(mybufstream.bad());
      segment.destroy_ptr(my_cstring);      
      return 0;
   }

As seen, *bufferstream* offers an efficient way to format data without any 
allocation and extra copies. This is very helpful in embedded systems, or
formatting inside time-critical loops, where stringstream extra copies would
be too expensive. Unlike sprintf/sscanf, it has protection against buffer
overflows. As we know, according to the *Technical Report on C++ Performance*, 
it's possible to design efficient iostreams for embedded platforms, so this 
bufferstream class comes handy to format data to stack, static or shared memory
buffers.

[endsect]

[endsect]

[section:interprocess_smart_ptr Interprocess ownership smart pointers]

C++ users know the importance of ownership smart pointers when dealing with resources.
Boost offers a wide range of such type of pointers: `intrusive_ptr<>`,
`scoped_ptr<>`, `shared_ptr<>`...

When building complex shared memory/memory mapped files structures, programmers
would like to use also the advantages of these smart pointers. The problem is that
Boost and C++ TR1 smart pointers are not ready to be used for shared memory. The cause 
is that those smart pointers contain raw pointers and they use virtual functions,
something that is not possible if you want to place your data in shared memory.
The virtual function limitation makes even impossible to achieve the same level of
functionality of Boost and TR1 with Interprocess smart pointers. 

Interprocess ownership smart pointers are mainly "smart pointers contaning smart pointers",
so we can specify the pointer type they contain.

[section:intrusive_ptr Intrusive pointer]

`boost::interprocess::intrusive_ptr<>` is the generalization of `boost::intrusive_ptr<>`
to allow non-raw pointers as intrusive pointer members. As the known 
`boost::intrusive_ptr` we must specify the pointee type but we also must also specify 
the pointer type to be stored in the intrusive_ptr:

[c++]

   /*!The intrusive_ptr class template stores a pointer to an object
      with an embedded reference count. intrusive_ptr is parameterized on
      T (the type of the object pointed to) and VoidPointer(a void pointer type 
      that defines the type of pointer that intrusive_ptr will store).
      intrusive_ptr<T, void *> defines a class with a T* member whereas
      intrusive_ptr<T, offset_ptr<void> > defines a class with a offset_ptr<T> member.
      Relies on unqualified calls to:
       
      void intrusive_ptr_add_ref(T * p);
      void intrusive_ptr_release(T * p);

      with (p != 0)

      The object is responsible for destroying itself.*/
   template<class T, class VoidPointer>
   class intrusive_ptr
   {
      public:
      /*!Provides the type of the internal stored pointer.*/
      typedef typename /*...*/ pointer;
      /*!Provides the type of the stored pointer.*/
      typedef T element_type;

      /*!Constructor. Initializes internal pointer to 0. Does not throw*/
      intrusive_ptr();

      /*!Constructor. Copies pointer and if "p" is not zero and 
         "add_ref" is true calls intrusive_ptr_add_ref(get_pointer(p)).
         Does not throw*/
      intrusive_ptr(const pointer &p, bool add_ref = true);

      /*!Copy constructor. Copies the internal pointer and if "p" is not
         zero calls intrusive_ptr_add_ref(get_pointer(p)). Does not throw*/
      intrusive_ptr(intrusive_ptr const & rhs);

      /*!Constructor from related. Copies the internal pointer and if "p" is not
         zero calls intrusive_ptr_add_ref(get_pointer(p)). Does not throw*/
      template<class U> intrusive_ptr (intrusive_ptr<U, VP> const & rhs);

      /*!Destructor. If internal pointer is not 0, calls
         intrusive_ptr_release(get_pointer(m_ptr)). Does not throw*/
      ~intrusive_ptr();

      /*!Assignment operator. Equivalent to intrusive_ptr(r).swap(*this). 
         Does not throw*/
      intrusive_ptr & operator=(intrusive_ptr const & rhs);

      /*!Assignment from related. Equivalent to intrusive_ptr(r).swap(*this). 
         Does not throw*/
      template<class U> intrusive_ptr & operator= (intrusive_ptr<U, VP> const & rhs);

      /*!Assignment from pointer. Equivalent to intrusive_ptr(r).swap(*this). 
         Does not throw*/
      intrusive_ptr & operator=(pointer rhs);
      
      /*!Returns a reference to the internal pointer. Does not throw*/
      pointer &get();

      /*!Returns a reference to the internal pointer. Does not throw*/
      const pointer &get() const;

      /*!Returns *get(). Does not throw*/
      T & operator*() const;

      /*!Returns *get(). Does not throw*/
      const pointer &operator->() const;

      /*!Returns get(). Does not throw*/
      pointer &operator->();

      operator unspecified_bool_type () const;

      /*!Not operator. Does not throw*/
      bool operator! () const;

      /*!Exchanges the contents of the two smart pointers. Does not throw*/
      void swap(intrusive_ptr & rhs);
   };

So `boost::interprocess::intrusive_ptr<MyClass, void*>` is equivalent to 
`boost::instrusive_ptr<MyClass>`. But if we want to place the intrusive_ptr in 
shared memory we must specify a relative pointer type like 
`boost::interprocess::intrusive_ptr<MyClass, boost::interprocess::offset_ptr<void> >`

[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <boost/interprocess/smart_ptr/intrusive_ptr.hpp>

   using namespace boost::interprocess;

   namespace N {

   //A class that has an internal reference count
   class reference_counted_class
   {
      private:
      //Non-copyable
      reference_counted_class(const reference_counted_class  &);
      //Non-assignable
      reference_counted_class & operator=(const reference_counted_class &);
      //A typedef to save typing
      typedef managed_shared_memory::segment_manager segment_manager;
      //This is the reference count
      unsigned int m_use_count;
      //The segment manager allows deletion from shared memory segment
      offset_ptr<segment_manager> mp_segment_manager;
   
      public:
      //Constructor
      reference_counted_class(segment_manager *s_mngr)
      : m_use_count(0), mp_segment_manager(s_mngr){}
      //Destructor
      ~reference_counted_class(){}

      public:
      //Returns the reference count
      unsigned int use_count() const
      {  return m_use_count;   }
      //Adds a reference
      inline friend void intrusive_ptr_add_ref(reference_counted_class * p)
      {  ++p->m_use_count; }
      //Releases a reference
      inline friend void intrusive_ptr_release(reference_counted_class * p)
      {  if(--p->m_use_count == 0)  p->mp_segment_manager->destroy_ptr(p); }
   };

   }  //namespace N {

   //A class that has an intrusive pointer to reference_counted_class
   class intrusive_ptr_owner
   {
      typedef intrusive_ptr<N::reference_counted_class, 
                            offset_ptr<void> > intrusive_ptr_t;
      intrusive_ptr_t m_intrusive_ptr;

      public:
      //Takes a pointer to the reference counted class
      intrusive_ptr_owner(N::reference_counted_class *ptr) 
         : m_intrusive_ptr(ptr){}
   };

   int main ()
   {
      //Create shared memory
      managed_shared_memory shmem;
      shmem.create("my_shmem", 10000);
      //Create the unique reference counted object in shared memory
      N::reference_counted_class *ref_counted = 
         shmem.construct<N::reference_counted_class>
            ("ref_counted")(shmem.get_segment_manager());
      //Create an array of ten intrusive pointer owners in shared memory
      intrusive_ptr_owner *intrusive_owner_array = 
         shmem.construct<intrusive_ptr_owner>
            (anonymous_instance)[10](ref_counted);
      //Now test that reference count is ten
      if(ref_counted->use_count() != 10)
         return -1;

      //Now destroy the array of intrusive pointer owners
      //This should destroy every intrusive_ptr and because of
      //that reference_counted_class will be destroyed
      shmem.destroy_ptr(intrusive_owner_array);

      //Now the reference counted object should have been destroyed
      if(shmem.find<intrusive_ptr_owner>("ref_counted").first)
         return -1;
      //Success!
      return 0;
   }

[endsect]

[section:scoped_ptr Scoped pointer]

`boost::interprocess::scoped_ptr<>` is the big brother of `boost::scoped_ptr<>`, which
adds a custom deleter to specify how the pointer passed to the scoped_ptr must be destroyed.
Also, the `pointer` typedef of the deleter will specify the pointer type stored by scoped_ptr.

[c++]

   /*!scoped_ptr stores a pointer to a dynamically allocated object. 
      The object pointed to is guaranteed to be deleted, either on destruction
      of the scoped_ptr, or via an explicit reset. The user can avoid this
      deletion using release().
      scoped_ptr is parameterized on T (the type of the object pointed to) and 
      Deleter (the functor to be executed to delete the internal pointer).
      The internal pointer will be of the same pointer type as typename 
      Deleter::pointer type (that is, if typename Deleter::pointer is 
      offset_ptr<void>, the internal pointer will be offset_ptr<T>).*/
   template<class T, class Deleter>
   class scoped_ptr
   {
      public:

      /*!Provides the type of the stored pointer.*/
      typedef T element_type;

      /*!Provides the type of the internal stored pointer.*/
      typedef /*...*/ pointer;

      /*!Constructs a scoped_ptr, storing a copy of p(which can be 0) and d.
         Does not throw.*/
      explicit scoped_ptr(const pointer &p = 0, const Deleter &d = Deleter());

      /*!If the stored pointer is not 0, destroys the object pointed to by the stored pointer. 
         calling the operator() of the stored deleter.*/
      ~scoped_ptr();

      /*!Deletes the object pointed to by the stored pointer and then
         stores a copy of p. Never throws*/
      void reset(const pointer &p = 0);

      /*!Deletes the object pointed to by the stored pointer and then
         stores a copy of p and a copy of d.*/
      void reset(const pointer &p, const Deleter &d);

      /*!Assigns internal pointer as 0 and returns previous pointer. This will
         avoid deletion on destructor*/
      pointer release():

      /*!Returns a reference to the object pointed to by the stored pointer.
         Never throws.*/
      reference operator*() const;

      /*!Returns the internal stored pointer. Never throws*/
      pointer &operator->();

      /*!Returns the internal stored pointer. Never throws.*/
      const pointer &operator->() const;

      /*!Returns the stored pointer. Never throws.*/
      pointer & get();

      /*!Returns the stored pointer. Never throws.*/
      const pointer & get() const;

      /*!Returns true if the stored pointer is 0. Never throws.*/
      bool operator! () const;

      /*!Exchanges the internal pointer and deleter with other scoped_ptr
         Never throws.*/
      void swap(scoped_ptr & b);
   };
   
`scoped_ptr<>` comes handy to implement *rollbacks* with exceptions: if an exception 
is thrown or we call `return` in the scope of `scoped_ptr<>` the deleter is
automatically called so that *the deleter can be considered as a rollback* function.
If all goes well, we call `release()` member function to avoid rollback when
the `scoped_ptr` goes out of scope.

[c++]

   #include <boost/interprocess/managed_shared_memory.hpp>
   #include <boost/interprocess/smart_ptr/scoped_ptr.hpp>

   using namespace boost::interprocess;

   class my_class
   {};

   class my_exception
   {};

   //A functor that destroys the shared memory object
   template<class T>
   class deleter
   {
      private:
      //A typedef to save typing
      typedef managed_shared_memory::segment_manager segment_manager;
      //This deleter is created in the stack, not in shared memory,
      //so we can use raw pointers
      segment_manager *mp_segment_manager;
   
      public:
      //This typedef will specify the pointer type that
      //scoped_ptr will store
      typedef T *pointer;
      //Constructor
      deleter(segment_manager *s_mngr)
      : mp_segment_manager(s_mngr){}

      void operator()(pointer object_to_delete)
      {  mp_segment_manager->destroy_ptr(object_to_delete);  }
   };

   int main ()
   {
      //Create shared memory
      managed_shared_memory shmem;
      shmem.create("my_shmem", 10000);

      //In the first try, there will be no exceptions
      //in the second try we will throw an exception
      for(int i = 0; i < 2; ++i){
         //Create an object in shared memory
         my_class * my_object = shmem.construct<my_class>("my_object")();
         
         //Since the next shared memory allocation can throw
         //assign it to a scoped_ptr so that if an exception occurs
         //we destroy the object automatically
         deleter<my_class> d(shmem.get_segment_manager());

         try{
            scoped_ptr<my_class, deleter<my_class> > s_ptr(my_object, d);
            //Let's emulate a exception capable operation
            //In the second try, throw an exception
            if(i == 1){
               throw(my_exception());
            }
            //If we have passed the dangerous zone
            //we can release the scoped pointer
            //to avoid destruction
            s_ptr.release();
         }
         catch(const my_exception &){}

         //Here, scoped_ptr is destroyed
         //so it we haven't thrown an exception
         //the object should be there, otherwise, destroyed
         if(i == 0){
            //Make sure the object is alive
            if(!shmem.find<my_class>("my_object").first){
               return -1;
            }
            //Now we can use it and delete it manually
            shmem.destroy<my_class>("my_object");
         }
         else{
            //Make sure the object has been deleted
            if(shmem.find<my_class>("my_object").first){
               return -1;
            }
         }
      }
      return 0;
   }

[endsect]


[endsect]

[section:message_queue Process-shared message queue]

Built above Interprocess operating system wrappers, message_queue class 
offers a classic, priority-capable inter-process message queue. Using this 
queue, two threads from different processes, can send/receive 
messages with many send/receive strategies, like blocking, non-blocking
or timed. 

We can send messages with different priorities and higher priority messages will 
be always received before lower priority ones. 

The implementation of this class shows how Interprocess primitives can be used to
construct more complex inter-process communication mechanism, like queues,
pipes, etc...

[section:shared_message_queue_int The interface]

The interface provides functions to create, open or create, or only open the queue.
It also provices 3 send and receive functions: blocking, non-blocking and timed, and
some functions to obtain the message queue's parameters like the maximum number of 
messages in the queue and the maximum size of any message.

[c++]

   /*!A class that allows sending messages between processes.*/
   class message_queue
   {
    public:
      /*!Result types when sending or receiving messages*/
      enum result_t  { 
                     ok, 
                     internal_error, 
                     empty, 
                     full, 
                     too_small_buffer, 
                     timeout,  
                     too_big_buffer, 
                     };

      /*!Constructor. Never throws*/
      message_queue();

      /*!Destructor. Calls close. Never throws*/
      ~message_queue(); 

      /*!Creates a process shared message queue with name "name". For this message queue,
         the maximum number of messages will be "max_num_msg" and the maximum message size
         will be "max_msg_size". If queue was previously created or there are no free 
         resources, the function returns false. Never throws*/
      bool create(const char *name, std::size_t max_num_msg, std::size_t max_msg_size);

      /*!Opens or creates a process shared message queue with name "name". 
         If the queue is created, the maximum number of messages will be "max_num_msg" 
         and the maximum message size will be "max_msg_size". If queue was previously 
         created the queue will be opened and "max_num_msg" and "max_msg_size" parameters
         are ignored. If there are no free resources, the function returns false. Never throws*/
      bool open_or_create(const char *name, std::size_t max_num_msg, std::size_t max_msg_size);

      /*!Opens a previously created process shared message queue with name "name". 
         If the was not previously created or there are no free resources, the 
         function returns false. Never throws*/
      bool open(const char *name);

      /*!Sends a message stored in buffer "buffer" with size "buffer_size" in the 
         message queue with priority "priority". If the message queue is full
         the sender is blocked. Returns "ok" if message is placed in the message
         queue, "internal_error" if message queue is corrupted, or "too_big_buffer"
         if parameter "buffer_size" is bigger than the maximum message size allowed
         in the queue. Never throws*/
      result_t send    (const void *buffer,     std::size_t buffer_size, 
                        unsigned int priority);

      /*!Sends a message stored in buffer "buffer" with size "buffer_size" in the 
         message queue with priority "priority". If the message queue is full
         the sender is not blocked. Returns "ok" if message is placed in the message
         queue, "internal_error" if message queue is corrupted, "too_big_buffer"
         if parameter "buffer_size" is bigger than the maximum message size allowed
         in the queue and "full" if message queue is full and message can't be
         placed there. Never throws*/
      result_t try_send    (const void *buffer,     std::size_t buffer_size, 
                            unsigned int priority);

      /*!Sends a message stored in buffer "buffer" with size "buffer_size" in the 
         message queue with priority "priority". If the message queue is full
         the sender is retries until time "abs_time" is reached. Returns "ok" if message 
         is placed in the message queue, "internal_error" if message queue is corrupted, 
         "too_big_buffer" if parameter "buffer_size" is bigger than the maximum message 
         size allowed in the queue and "timeout" if message can't be placed and time 
         "abs_time" is reached. Never throws*/
      result_t timed_send    (const void *buffer,     std::size_t buffer_size, 
                              unsigned int priority,  const boost::posix_time::ptime &abs_time);

      /*!Receives a message from the message queue. The message is stored in buffer 
         "buffer", which has size "buffer_size". The received message has size 
         "recvd_size" and priority "priority". If the message queue is empty
         the receiver is blocked. Returns "ok" if a message is received from the 
         message queue, "internal_error" if message queue is corrupted, or 
         "too_small_buffer" if parameter "buffer_size" is smaller than the maximum 
         message size allowed in the queue. Never throws*/
      result_t receive (void *buffer,           std::size_t buffer_size, 
                        std::size_t &recvd_size,unsigned int &priority);

      /*!Receives a message from the message queue. The message is stored in buffer 
         "buffer", which has size "buffer_size". The received message has size 
         "recvd_size" and priority "priority". If the message queue is empty
         the receiver is not blocked. Returns "ok" if a message is received from the 
         message queue, "internal_error" if message queue is corrupted, 
         "too_small_buffer" if parameter "buffer_size" is smaller than the maximum 
         message size allowed in the queue or "empty" is message queue is empty. 
         Never throws*/
      result_t try_receive (void *buffer,           std::size_t buffer_size, 
                            std::size_t &recvd_size,unsigned int &priority);

      /*!Receives a message from the message queue. The message is stored in buffer 
         "buffer", which has size "buffer_size". The received message has size 
         "recvd_size" and priority "priority". If the message queue is empty
         the receiver retries until time "abs_time" is reached. Returns "ok" if a message is
         received from the message queue, "internal_error" if message queue is 
         corrupted, "too_small_buffer" if parameter "buffer_size" is smaller than the 
         maximum message size allowed in the queue or "timeout" is message queue is 
         empty. Never throws*/
      result_t timed_receive (void *buffer,           std::size_t buffer_size, 
                              std::size_t &recvd_size,unsigned int &priority,
                              const boost::posix_time::ptime &abs_time);

      /*!Closes the message queue and frees resources. A new message queu can be opened
         after close() is called. Never throws*/
      void close();

      /*!Returns the maximum number of messages allowed by the queue. The message
         queue must be opened or created previously. Otherwise, returns 0. 
         Never throws*/
      std::size_t get_max_num_msg() const;

      /*!Returns the maximum size of message allowed by the queue. The message
         queue must be opened or created previously. Otherwise, returns 0. 
         Never throws*/
      std::size_t get_max_msg_size() const;
   };

The message queue is destroyed when the last process connected to the queue closes
the connection calling *close()*.

[endsect]

[section:shared_message_queue_ex Example: Serializing a database through the message queue]

The following example shows how a message queue can be used to serialize a whole
database constructed in a buffer using Interprocess machinery, so that the database
is duplicated in another buffer:

[c++]
   
   //This test creates a in memory data-base using Interprocess machinery and 
   //serializes it through a message queue. Then rebuilds the data-base in 
   //another buffer and checks it against the original data-base
   bool test_serialize_db()
   {
      //Shared memory queues
      message_queue mq1, mq2;

      //Typedef data to create a Interprocess map   
      typedef std::pair<const std::size_t, std::size_t> MyPair;
      typedef std::less<std::size_t>   MyLess;
      typedef node_allocator<MyPair, 64, managed_external_buffer::segment_manager> 
         node_allocator_t;
      typedef map<std::size_t, 
                  std::size_t, 
                  std::less<std::size_t>, 
                  node_allocator_t>
                  MyMap;

      //Some constants
      const std::size_t BufferSize  = 4096;
      const std::size_t MaxMsgSize  = 100;

      //Allocate two memory buffers from heap using vector<char>
      std::vector<char> buffer1(BufferSize, 0), buffer2(BufferSize, 0);

      //Create the message-queue
      if(!mq1.create("message_queue", 1, MaxMsgSize)){
         return false;
      }

      //Open previously created message-queue simulating other process
      if(!mq2.open("message_queue")){
         return false;
      }

      //interprocess machinery to manage previously allocated buffer1 and buffer2
      managed_external_buffer db1, db2;      

      //Create Interprocess machinery in the first buffer
      if(!db1.create(&buffer1[0], buffer1.size())){
         return false;
      }

      //Construct the map in the first buffer
      MyMap *map1 = db1.construct<MyMap>("MyMap")
                                        (MyLess(), 
                                         db1.get_segment_manager());
      if(!map1)
         return false;

      //Fill map1 until is full 
      try{
         std::size_t i = 0;
         while(1){
            (*map1)[i] = i;
            ++i;
         }
      }
      catch(boost::interprocess::bad_alloc &){}

      //Data control data sending through the message queue
      std::size_t sent = 0;
      std::size_t recvd = 0;
      std::size_t total_recvd = 0;
      unsigned int priority;

      //Send whole first buffer through the mq1, read it 
      //through mq2 to the second buffer
      while(1){
         //Send a fragment of buffer1 through mq1
         std::size_t bytes_to_send = MaxMsgSize < (BufferSize - sent) ? 
                                       MaxMsgSize : (BufferSize - sent);
         switch(mq1.send(&buffer1[sent], bytes_to_send, 0)){
            case message_queue::ok:
               sent += bytes_to_send;         
            break;

            default:
               return false;
         }
         //Receive the fragment through mq2 to buffer2
         switch(mq2.receive(&buffer2[total_recvd], BufferSize - recvd, 
                           recvd,                 priority)){   
            case message_queue::ok:
               total_recvd += recvd; 
            break;

            default:
               return false;
         }

         //Check if we have received all the buffer
         if(total_recvd == BufferSize){
            break;
         }
      }
      
      //We don't need message queues anymore
      mq1.close();
      mq2.close();
       
      //The second buffer will contain a copy of the buffer1 
      //map so let's open Interprocess machinery in the second buffer  
      if(!db2.open(&buffer2[0], BufferSize)){
         return false;
      }

      //Let's find the map
      std::pair<MyMap *, std::size_t> ret = db2.find<MyMap>("MyMap");
      MyMap *map2 = ret.first;

      //Check if we have found it
      if(!map2){
         return false;
      }

      //Check if it is a single variable (not an array)
      if(ret.second != 1){
         return false;
      }

      //Now let's compare size
      if(map1->size() != map2->size()){
         return false;
      }

      //Now let's compare all db values
      for(std::size_t i = 0, num_elements = map1->size(); i < num_elements; ++i){
         if((*map1)[i] != (*map2)[i]){
            return false;
         }
      }
      
      //Destroy maps from db-s
      db1.destroy_ptr(map1);
      db2.destroy_ptr(map2);

      db1.close();
      db2.close();

      return true;
   }

[endsect]

[endsect]

[section:architecture Interprocess architecture and internals]

[section:basic_guidelines Basic guidelines]

When building Interprocess architecture, I took some basic guidelines that can be
resumed in these points:

*  Interprocess should be portable at least in UNIX and Windows systems. That means
   I've tried to unify not only interfaces but also behaviour. This is why
   Interprocess does not support (for the moment) the file-like (unlink, etc..) behaviour 
   of Unix shared memory or supposes no fixed address mappings. 

*  Interprocess inter-process synchronization primitives should be equal to thread 
   synchronization primitives. That's why Interprocess synchronization primitives 
   are based in Boost Thread's interface.

*  Interprocess architecture should be modular, customizable but efficient. That's why
   I took templates approach and I made memory algorithms, index types, interprocess_mutex
   types and other classes templatizable.

*  Interprocess architecture should allow the same concurrency as thread based programming.
   This is why there are different mutual exclusion levels so that a process can 
   concurrently allocate raw memory when expanding a shared memory vector while another
   process can be safely searching a named object.

*  Interprocess containers know nothing about Interprocess. All specific behaviour is contained
   in the STL-like allocators. That allows STL vendors to slightly modify 
   (or better said, generalize) their standard container implementations and obtain
   a fully std::allocator and boost::interprocess::allocator compatible container. This also
   make Interprocess containers compatible with standard algorithms.

Interprocess is built above 3 basic classes: a *memory algorithm* a *segment manager* and
an *front-end*:

[endsect]

[section:architecture_memory_algorithm The memory algorithm]

The *memory algorithm* is an object that is placed in the first bytes of a 
shared memory/memory mapped file segment. The *memory algorithm* can return 
portions of that segment to users marking them as used and the user can return those
portions to the memory manager so that the memory manager mark them as free
again. There is an exception though, some bytes after the memory algorithm
object end, are reserved and can't be used for this dynamic allocation.
This "reserved" zone will be used to place other additional objects
in a known place.

To sum up, a *memory algorithm* has the same mission as malloc/free of
standard C library, but it just can returns portions of the segment
where it is placed. The layout of a memory segment would be:

[c++]

   Layout of the memory segment:
    ____________ __________ ____________________________________________  
   |            |          |                                            | 
   |   memory   | reserved |  The memory algorithm will return portions | 
   | algorithm  |          |  of the rest of the segment.               | 
   |____________|__________|____________________________________________| 


The memory algorithm takes care of memory synchronizations, just like malloc/free
guarantees that two threads can call malloc/free at the same time. This is usually
achieved placing a process-shared interprocess_mutex as a member of the memory algorithm. Take 
in care that the memory algorithm knows *nothing* about the segment (if it is
shared memory, a shared memory file, etc.). For the memory algorithm the segment 
is just a fixed size memory buffer.

The *memory manager* is also a configuration point for the rest of the Interprocess 
framework since it defines two basic types as member typedefs:

[c++]

   typedef /*implementation dependent*/ void_pointer;
   typedef /*implementation dependent*/ mutex_family;


The `void_pointer` typedef defines the pointer type that will be used in the Interprocess
framework (segment manager, allocators, containers). If the memory algorithm is ready
to be placed in a shared memory/mapped file mapped in different base addresses, this
pointer type will be defined as offset_ptr<void> or a similar relative pointer. 
If the memory algorithm will be used just with fixed address shared 
memory/memory mapped file, void_pointer can be defined as `void*`.

The rest of the interface of a Interprocess *memory manager* is described in 
[link interprocess.custom_interprocess_alloc Writing a new shared memory allocation algorithm] 
section. As memory algorithm examples, you can see the implementations
[@../../../../boost/interprocess/mem_algo/simple_seq_fit.hpp  boost::interprocess::simple_seq_fit] or
[@../../../../boost/interprocess/mem_algo/seq_fit.hpp  boost::interprocess::seq_fit] classes.

[endsect]

[section:architecture_segment_manager The segment manager]

The *segment manager*, is an object also placed in the first bytes of the
memory segment (shared memory, memory mapped file), that offers more sofisticated 
services built above the *memory algorithm*. How can *both* the segment manager 
and memory algorithm be placed in the beginning of the segment? That's 
because the segment manager *owns* the memory algorithm: The
truth is that the memory algorithm is *embedded* in the segment manager:


[c++]

   The layout of segment manager:
    _______ _________________
   |       |         |       |
   | some  | memory  | other |<- The memory algorithm considers 
   |members|algorithm|members|   "other members" as reserved memory, so
   |_______|_________|_______|   it does not use it for dynamic allocation.
   |_________________________|____________________________________________
   |                         |                                            |
   |    segment manager      |  The memory algorithm will return portions |
   |                         |  of the rest of the segment.               |
   |_________________________|____________________________________________|


The segment manager initializes the memory algorithm and tells the memory 
manager that it should not use the memory where the rest of the 
segment manager's member are placed for dynamic allocations. The 
other members of the *segment manager* are *a recursive interprocess_mutex*
(described by the memory algorithm's *mutex_family* typedef member),
and *two indexes (maps)*: one to make named allocations, and another one to 
make "unique instance" allocations. 

*  The first index is a map with a pointer to a c-string (the name of the named object) 
   as a key and a structure with information of the dynamically allocated object
   (the most importants being the address and the size of the object). 

*  The second index is used to implement "unique instances" 
   and is basically the same as the first index, 
   but the name of the object comes from a `typeid(T).name()` operation.

The memory needed to store [name pointer, object information] pairs in the index is 
allocated also via the *memory algorithm*, so we can tell that internal indexes
are just like ordinary user objects built in the segment. The rest of the memory
to store the name of the object, the object itself, and meta-data for 
destruction/deallocation is allocated using the *memory algorithm* in a single
`allocate()` call.

As seen, the segment manager knows *nothing* about shared memory/memory mapped files. 
The segment segment manager itself does not allocate portions of the segment, 
it just asks the *memory algorithm* to allocate the needed memory from the rest 
of the segment. The *segment manager* is a class built above the memory algorithm 
that offers named object construction, unique instance constructions, and many
other services.

The *segment manager* is implemented in Interprocess in 
[@../../../../boost/interprocess/detail/segment_manager.hpp boost::interprocess::detail::segment_manager]
class.

[c++]

   template<class CharType 
           ,class MemoryAlgorithm
           ,template<class IndexConfig> class IndexType>
   class segment_manager;

As seen, the segment manager is quite generic: we can specify the char type to be
used to identify named objects, we can specify the memory algorithm that will
control dynamically the portions of the memory segment, and we can specify 
also the index type that will store the [name pointer, object information] mapping.
We can construct our own index types as explained in
[link interprocess.custom_indexes Building custom indexes] section.

[endsect]

[section:architecture_front_end Interprocess front-ends]

The Interprocess front-ends are classes that construct the shared memory/memory mapped file, 
place there the segment manager and forward the user requests to the segment manager. 
For example, *boost::interprocess::basic_managed_shared_memory<...>* is a Interprocess front-end
that works with shared memory. *boost::interprocess::basic_managed_mapped_file<...>* works
with memory mapped files, etc...

Basically, the interface of a Interprocess front-end is the same as the *segment manager*
but it also offers functions to open, create, open_or_create or shared 
memory/memory-mapped files segments, initialize all needed resources 
and they store a pointer to the segment manager. Interprocess front-ends are not built in
shared memory or memory mapped files.

Apart from this, front-ends offer specific functions: front-ends for memory mapped files
offer functions to flush memory contents to the file, heap memory front-ends offer
functions to expand the memory, etc...

Most of the functions of Interprocess front-ends can be shared between all front-ends, since
many times they just forward the functions to the segment manager. Because of this,
in Interprocess all front-ends derive from a common class that implements memory-independent
(shared memory, memory mapped files) functions:
[@../../../../boost/interprocess/detail/managed_memory_impl.hpp 
boost::interprocess::detail::basic_managed_memory_impl]

Deriving from this class, Interprocess implements several front-ends, for different memory backends:

* [@../../../../boost/interprocess/managed_shared_memory.hpp boost::interprocess::basic_managed_shared_memory] (for shared memory),
* [@../../../../boost/interprocess/managed_mapped_file.hpp boost::interprocess::basic_managed_mapped_file] (for memory mapped files),
* [@../../../../boost/interprocess/managed_heap_memory.hpp boost::interprocess::basic_managed_heap_memory] (for heap allocated memory),
* [@../../../../boost/interprocess/managed_external_buffer.hpp boost::interprocess::basic_managed_external_buffer] (for user provided memory buffer),

[endsect]

[section:architecture_allocators Interprocess allocators]

The Interprocess STL-like allocators are fairly simple and follow the usual C++ allocator
approach. Normally, allocators for STL containers are based above new/delete operators
and above those, they implement pools, arenas and other allocation tricks.

In Interprocess allocators, the approach is similar, but all allocators are based on the
*segment manager*. The segment manager is the only one that provides from simple
memory allocation to named object creations. Interprocess allocators always store a pointer
to the segment manager, so that they can obtain memory from the segment or share
a common pool between allocators.

As you can imagine, the member pointers of the allocator are not a raw pointers, but
pointer types defined by the `segment_manager::void_pointer` type. Apart from this,
the `pointer` typedef of Interprocess allocators is also of the same type of
`segment_manager::void_pointer`.

This means that if our allocation algorithm defines `void_pointer` as 
`offset_ptr<void>`, `boost::interprocess::allocator<T>` will store an `offset_ptr<segment_manager>`
to point to the segment manager and the `boost::interprocess::allocator<T>::pointer` type will
be `offset_ptr<T>`. This way, Interprocess allocators can be placed in the same memory as
the segment manager, that is, shared memory, memory mapped files, etc...

Interprocess implements basically two allocator approaches: normal and pooled. All pooled
allocators share most of the implementation. This common implementation is in 
[@../../../../boost/interprocess/allocators/detail/node_pool.hpp boost::interprocess::detail::private_node_pool
and boost::interprocess::detail::node_pool] classes.

[endsect]

[section:architecture_containers Interprocess containers]

Interprocess containers are standard conforming counterparts of STL containers in boost::interprocess
namespace, but with these little details:

*  Interprocess STL containers don't assume that memory allocated with 
   an allocator can be deallocated with other allocator of 
   the same type. They always compare allocators with `operator==()`
   to know if this is possible. If allocators are equal Interprocess containers optimize
   swapping and similar operations, if not, they use alternative approaches.

*  The pointers of the internal structures of the Interprocess containers are of the 
   same type the `pointer` type defined by the allocator of the container.

*  All objects are constructed-destroyed via allocator::construct and 
   allocator::destroy functions.

[endsect]

[endsect]

[section:performance Performance of Interprocess]

This section tries to explain the performance characteristics of Interprocess, so that
you can optimize Interprocess usage if you need more performance.

[section:performance_allocations Performance of memory allocations]

You can have two types of raw memory allocations in Interprocess:

*  Explicit: The user calls `allocate()` and  `deallocate()` funcions of
   managed_shared_memory/managed_mapped_file... front-end classes. This call is 
   translated to a `MemoryAlgorithm::allocate()` function, which means that you 
   will need just the time that the memory algorithm associated with the front-end
   needs to allocate data. 

*  Implicit: For example, you are using boost::interprocess::allocator<> in shared memory
   containers. This allocator calls the same `MemoryAlgorithm::allocate()` than the
   explicit method, *every* time a vector/string has to reallocate its buffer, or *every*
   time you insert an object in a node container.

If you see that allocation is a bottleneck in your application, you have
these alternatives:

*  If you use map/set associative containers, try using flat_map family instead
   of map family if you mainly do searches and the insertion/removal is mainly done
   in an initialization phase. The overhead is now when the ordered vector has to
   reallocate its storage and move data. You can also call the `reserve()` method
   of these containers when you know beforehand how much data you will insert.
   However in these containers iterators are invalidated in insertions so this
   substitution is only effective in some applications.
  
*  Use a Interprocess pooled allocator for node containers, because pooled allocators
   call `allocate()` only when the pool runs out of nodes. This is pretty
   efficient (much more than the current default general-purpose algorithm)
   and this can save a lot of memory. See 
   [link interprocess.stl_allocators Interprocess STL compatible allocators] to compare
   the Interprocess node allocators and their trade-offs.

*  Write your own memory algorithm. If you have experience with memory allocation
   and an algorithm is better suited than the default for your application
   you can specify it in all Interprocess front-ends. See the section
   [link interprocess.custom_interprocess_alloc Writing a new shared memory allocation algorithm]
   to know how to do this. If you think its better than the default one for
   general-purpose applications, be polite and donate it to Interprocess to make it default!

[endsect]

[section:performance_named_allocation Performance of named allocations]

Interprocess allows the same paralelism as two threads writing to common data, except when
the user creates/searches named/unique objects. The steps when creating a named object
are these:

*  Lock a recursive interprocess_mutex (so that you can make named allocations inside the 
   constructor of the object to be created).

*  Try to insert the [name pointer, object information] in the name/object index.
   This lookup has to assure that the name has not been used before.
   This is achieved calling `insert()` function in the index. So the time this
   requires is dependent on the index type (ordered vector, tree, hash...).
   This can require a call to the memory algorithm allocation function if
   the index has to be reallocated, it's a node allocator, uses pooled allocations...

*  Allocate a single buffer to hold the name of the object, the object itself,
   and meta-data for destruction (number of objects, etc...).

*  Call the constructors of the object being created. If it's an array, one
   construtor per array element.

*  Unlock the recursive interprocess_mutex.

The steps when destroying a named object using the name (`destroy<T>(name)`) are these:

*  Lock a recursive interprocess_mutex .

*  Search in the index the data associated to that name. Copy information and
   erase data. This is done using `find(const key_type &)` and `erase(iterator)`
   members of the index. This can require element reordering if the index is a
   balanced tree, an ordered vector...

*  Call the destructor of the object (many if it's an array).

*  Deallocate the memory using the allocation algorithm.

*  Unlock the recursive interprocess_mutex.

The steps when destroying a named object using the pointer (`destroy_ptr(T *ptr)`)
are these:

*  Lock a recursive interprocess_mutex .

*  Depending on the index type, this can be different:

   *  If the index is a node index, (marked with boost::interprocess::is_node_index
      specialization): Take the iterator stored near the object and call
      `erase(iterator)`. This can require element reordering if the index is a
      balanced tree, an ordered vector...

   *  If it's not an node index: Take the name stored near the object and erase
      the index entry calling `erase(const key &). This can require element reordering if the index is a
      balanced tree, an ordered vector...
      
*  Call the destructor of the object (many if it's an array).

*  Deallocate the memory using the allocation algorithm.

*  Unlock the recursive interprocess_mutex.

If you see that you the performance is not good enough you have these alternatives:

*  Maybe the problem is that the lock time is too big and it hurts paralelism.
   Try to reduce the number of named objects in the global index and if your
   application serves several clients try to build a new segment for each one
   instead of using a global common one.

*  Write your own memory algorithm. See the section
   [link interprocess.custom_interprocess_alloc Writing a new shared memory allocation algorithm]
   to know how to do this.

*  Use another Interprocess index type if you feel the default one is not fast enough.
   If you are not still satisfied, write your own index type. See 
   [link interprocess.custom_indexes Building custom indexes] for this.

*  Destruction via pointer is at least as fast as using name and can be faster.
   So if your problem is that you make at lot of named destructions, try to use
   the pointer. If the index is a node index you can save some time.
   
[endsect]

[endsect]

[section:open_issues Open Issues]

In this section open design issues are described. These should be closed
during the review process. Some issues are related to (perhaps) soon to be 
changed Boost Thread interface, so those will require consensus with Boost
Threads's mantainers and users.

[section:open_names Class names]

Name suggestions for class names are also welcome if people find the current 
ones don't express well their functionality.

[endsect]

[section:open_objectnames Names of Interprocess basic resources]

Currently Interprocess does not guarantee their own namespace for all named basic Interprocess 
objects (shared_memory, file_mapping, named_semaphore...), so that we can't create
a named interprocess_semaphore and a shared memory called "MyName".

If this approach is considered harmful, during the review process we should
reach an agreement about naming conventions.

[endsect]

[section:open_time Time management should be changed]

Interprocess implements the same interface as Boost Thread with timed methods
in synchronization primitives, like mutexes and interprocess_condition variables.
Boost Thread uses boost::xtime functions and since in single threaded
processes we can't use Boost Thread headers, Interprocess duplicates these
functions with boost::interprocess::xtime.

However, boost::xtime was supossed to be a temporary solution until
a general Boost time framework was developed. Interprocess should follow
Boost Thread's path and there are two ways to solve this:

* Don't forbid using xtime with single threaded processes.
* Port timed functions from Boost Thread and Interprocess to Boost Date_Time
  if Date_Time provides the needed resolution for real-time programming.

[endsect]

[section:open_sync Interface of synchronization primitives and Boost Thread]

Interprocess mutexes and conditions implements the same interface as Boost Thread,
but this interface has some restrictions:

* Boost Thread's scoped locks can't be used with Interprocess, leading to duplication.
* Boost Thread's read_write_mutex implementation seems to hurt performance and
  some have requested a simpler implementation.
* The process-shared message queue should have the same interface as a
  future thread-shared message queue Boost Thread could have.
  
Some personal suggestions about improving interprocess_mutex and interprocess_condition's interface:

* Implement public lock(), unlock(), etc... functions for mutexes. Using
  scoped_locks should be optional. This can convert scoped_locks in general
  locking classes that can lock any *lockable* object. Some standard proposals
  seem to go this route.

* Implement read_write_mutex using with a simpler interface, without scheduling
  issues (just like POSIX standard). This will help performance and we can
  implement read_write_mutex using efficient atomic primitives.

* Design a simple message queue interface that can be used for both inter-thread
  and inter-process communications.
  
All these issues require coordination with Boost Thread users and developers.

[endsect]

[endsect]

[section:future_improvements Future Improvements...]

There are some Interprocess features that I would like to implement and
some Interprocess code that can be much better. Let's see some ideas:

[section:win32_sync Win32 synchronization is too basic]

Win32 version of shared mutexes and shared conditions are based on
"spin and wait" atomic instructions. This leads to poor performance
and does not manage any issues like priority inversions. 
We would need very serious help from threading 
experts on this. And I'm not sure that 
this can be achieved in user-level software. Posix based implementations
use PTHREAD_PROCESS_SHARED attribute to place mutexes in shared memory, so
there are no such problems. I'm not aware of any implementation that 
simulates PTHREAD_PROCESS_SHARED attribute for Win32. We should be able
to construct these primitives in memory mapped files, so that we can 
get filesystem persistence just like with POSIX primitives.

[endsect]

[section:default_algorithm Default allocation algorithm can be improved]

The default memory management algorithm used by Interprocess to manage the
fixed size memory segment is a "first fit" algorithm. This could be changed
to a "best fit" algorithm to try to minimize fragmentation, but this would 
hurt performance if a list is used to mantain the free memory portions.
This can be solved with a tree-like free memory management, so that we can
search the best portion in logarithmic time. And we have to implement the
tree inside the given segment wasting minimum space. This seems complicated, 
but with the help of an intrusive tree implementation this can be achieved.

Suggestions and help from memory management experts are welcome!

[endsect]

[section:future_objectnames Use of wide character names on Interprocess basic resources]

Currently Interprocess only allows *char* based names for basic synchronization objects. 
However, several operating systems use *wchar_t* names for resources 
(mapped files, for example). 
In the future Interprocess should try to present a portable narrow/wide char interface.
To do this, it would be useful to have a boost wstring <-> string conversion 
utilities to translate resource names (escaping needed characters
that can conflict with OS names) in a portable way. It would be interesting also 
the use of *boost::filesystem* paths to avoid operating system specific issues.

[endsect]

[section:future_security Security attributes]

Interprocess does not define security attributes for shared memory and synchronization
objects. Standard C++ also ignores security attributes with files so adding
security attributes would require some serious work.

[endsect]

[section:future_ipc Future inter-process communications]

Interprocess offers a process-shared message queue based on Interprocess primitives
like mutexes and conditions. I would want to develop more mechanisms, like
stream-oriented named fifo so that we can use it with a iostream-interface
wrapper (we can imitate Unix pipes).

C++ needs more complex mechanisms and it would be nice to have a stream and
datagram oriented PF_UNIX-like mechanism in C++. And for very fast inter-process 
remote calls Solaris doors is an interesting alternative to implement
for C++. But the work to implement PF_UNIX-like sockets and doors would
be huge. Any network expert volunteer?

[endsect]

[section:future_containers Unordered associative containers and other containers]

We should be able to construct boost::unordered_xxx family in shared memory,
so that there is no code duplication in boost. So Interprocess should cooperate with
boost container developers instead of duplicating effort writing it's own containers.

A very interesting project is making *boost::multi_index* ready for shared memory. This
could be a good basis for memory mapped data-bases. The work to achieve this, 
however, can be huge. It would be interesting a collaboration with *Intrusive* library
to achieve shared memory intrusive containers.

[endsect]

[endsect]

[section:thanks_to Thanks to...]

Many people have contributed with ideas and revisions, so this is the place to
thank them:

* Thanks to all people who have shown interest in the library and have downloaded
  and tested the snapshots.

* Thanks to [*Francis Andre] and [*Anders Hybertz] for their ideas and suggestions. 
  Many of them are not implemented yet but I hope to include them when library gets some stability.

* Thanks to [*Hiang Swee Chiang], [*Phil Endecott], [*Rene Rivera],
  [*Harold Pirtle], [*Paul Ryan] [*Shumin Wu], [*Michal Wozniak], [*Peter Johnson]
  and [*Kim Barrett] for their bug fixes and library testing.

* Thanks to [*Martin Adrian] who suggested the use of Interprocess framework for user defined buffers.

* Thanks to [*Synge Todo] for his boostbook-doxygen patch to improve Interprocess documentation.

* Thanks to [*Olaf Krzikalla] for his Intrusive library. I have taken some ideas to 
  improve red black tree implementation from his library.
      
* Thanks to [*Daniel James] for his unordered_map/set family and his help with allocators.
  His great unordered implementation has been a reference to design exception safe containers.  

* Thanks to [*Howard Hinnant] for his patience explaining allocator swapping and showing me
  new "moving" concepts with future rvalue references. Kill those temporaries!

* Thanks to [*Pavel Vozenilek] for his continuous review process, suggestions, code and 
  help. He is the major supporter of Interprocess library. The library has grown with his
  many and great advices.

* And finally, thank you to all Boosters. *Long live to C++!*

[endsect]

[section:changes Changes...]

[section:changes_shmem_00_92 Changes in Shmem 0.92...]

* Solved bugs in flat_xxx insert functions.
* Solved ambiguous windows native function calls with some header orderings.
* Changed named_mutex to support scoped_lock.
* Added missing <exceptions.hpp> include in named_mutex.
* Added get_type and get_name functions to front-ends.

[endsect]

[endsect]

[section:references References and interesting links]

Some useful references about C++ language, C++ internals, shared memory, 
allocators and containers, I've used to design Interprocess.

[section:references_books Books]

* Great book about multithreading, and POSIX: [*['"Programming with Posix Threads"]],
  [*David R. Butenhof]

* The UNIX inter-process bible: [*['"UNIX Network Programming, Volume 2: Interprocess Communications"]],
  [*W. Richard Stevens]

* Current STL allocator issues: [*['"Effective STL"]], [*Scott Meyers]

* My C++ bible: [*['"Thinking in C++, Volume 1 & 2"]], [*Bruce Eckel and Chuck Allison]

* The book every C++ programmer should read: [*['"Inside the C++ Object Model"]], [*Stanley B. Lippman]

* A must-read: [*['"ISO/IEC TR 18015: Technical Report on C++ Performance"]], [*ISO WG21-SC22 members.]

[endsect]

[section:references_links Links]

* A framework to put STL in shared memory: [@http://allocator.sourceforge.net/ ['"A C++ Standard Allocator for the Standard Template Library"] ]. 

* A design for instantiating C++ objects in shared memory: [@http://www.cs.ubc.ca/local/reading/proceedings/cascon94/htm/english/abs/hon.htm ['"Using objects in shared memory for C++ application"] ].

* A shared memory allocator and relative pointer: [@http://home.earthlink.net/~joshwalker1/writing/SharedMemory.html ['"Taming Shared Memory"] ].


[endsect]

[endsect]

[/xinclude interprocess.doxygen.boostbook]

