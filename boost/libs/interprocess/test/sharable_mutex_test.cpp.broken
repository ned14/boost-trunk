// Copyright (C) 2001-2003
// William E. Kempf
//
// Permission to use, copy, modify, distribute and sell this software
// and its documentation for any purpose is hereby granted without fee,
// provided that the above copyright notice appear in all copies and
// that both that copyright notice and this permission notice appear
// in supporting documentation.  William E. Kempf makes no representations
// about the suitability of this software for any purpose.
// It is provided "as is" without express or implied warranty.
//////////////////////////////////////////////////////////////////////////////
//
// (C) Copyright Ion Gaztañaga 2005-2006. Distributed under the Boost
// Software License, Version 1.0. (See accompanying file
// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
//
// See http://www.boost.org/libs/interprocess for documentation.
//
//////////////////////////////////////////////////////////////////////////////

#include <boost/interprocess/detail/config_begin.hpp>
#include <boost/interprocess/detail/workaround.hpp>

#include <boost/thread/thread.hpp>
#include <boost/thread/xtime.hpp>
#include <boost/date_time/posix_time/ptime.hpp>
#include <boost/interprocess/sync/interprocess_sharable_mutex.hpp>
#include <boost/interprocess/sync/sharable_lock.hpp>
#include <boost/interprocess/sync/scoped_lock.hpp>
#include <iostream>
#include <assert.h>
#include "util.hpp"

namespace {

template<typename SM>
void plain_exclusive(void *arg, SM &sm)
{
   data<SM> *pdata = (data<SM> *) arg;
   boost::interprocess::scoped_lock<SM> l(sm);
   boost::thread::sleep(xsecs(3*BaseSeconds));
   shared_val += 10;
   pdata->m_value = shared_val;
}

template<typename SM>
void plain_shared(void *arg, SM &sm)
{
   data<SM> *pdata = (data<SM> *) arg;
   boost::interprocess::sharable_lock<SM> l(sm);
   pdata->m_value = shared_val;
}

template<typename SM>
void try_exclusive(void *arg, SM &sm)
{
   data<SM> *pdata = (data<SM> *) arg;
   boost::interprocess::scoped_lock<SM> l(sm, boost::interprocess::dont_lock);
   if (l.try_lock()){
      boost::thread::sleep(xsecs(3*BaseSeconds));
      shared_val += 10;
      pdata->m_value = shared_val;
   }
}

template<typename SM>
void try_shared(void *arg, SM &sm)
{
   data<SM> *pdata = (data<SM> *) arg;
   boost::interprocess::sharable_lock<SM> l(sm, boost::interprocess::dont_lock);
   if (l.try_lock()){
      pdata->m_value = shared_val;
   }
}

template<typename SM>
void timed_exclusive(void *arg, SM &sm)
{
   data<SM> *pdata = (data<SM> *) arg;
   boost::posix_time::ptime pt(delay(pdata->m_secs));
   boost::interprocess::scoped_lock<SM> 
      l (sm, boost::interprocess::dont_lock);
   if (l.timed_lock(pt)){
      boost::thread::sleep(xsecs(3*BaseSeconds));
      shared_val += 10;
      pdata->m_value = shared_val;
   }
}

template<typename SM>
void timed_shared(void *arg, SM &sm)
{
   data<SM> *pdata = (data<SM> *) arg;
   boost::posix_time::ptime pt(delay(pdata->m_secs));
   boost::interprocess::sharable_lock<SM> 
      l(sm, boost::interprocess::dont_lock);
   if (l.timed_lock(pt)){
      pdata->m_value = shared_val;
   }
}

template<typename SM>
void test_plain_sharable_mutex(SM &sm)
{
   shared_val = 0;
   data<SM> s1(1,sm);
   data<SM> s2(2,sm);
   data<SM> e1(1,sm);
   data<SM> e2(2,sm);

   // Writer one launches, holds the lock for 3*BaseSeconds seconds.
   boost::thread tw1(thread_adapter<SM>(plain_exclusive,&e1,sm));

   // Writer two launches, tries to grab the lock, "clearly"
   //  after Writer one will already be holding it.
   boost::thread::sleep(xsecs(1*BaseSeconds));
   boost::thread tw2(thread_adapter<SM>(plain_exclusive,&e2,sm));

   // Reader one launches, "clearly" after writer two, and "clearly"
   //   while writer 1 still holds the lock
   boost::thread::sleep(xsecs(1*BaseSeconds));
   boost::thread tr1(thread_adapter<SM>(plain_shared,&s1,sm));
   boost::thread tr2(thread_adapter<SM>(plain_shared,&s2,sm));

   tr2.join();
   tr1.join();
   tw2.join();
   tw1.join();

   if (sm.get_policy() == boost::interprocess::interprocess_sharable_mutex::exclusive_priority)
   {
      assert(e1.m_value == 10);
      assert(e2.m_value == 20);
      assert(s1.m_value == 20);   // Readers get in after 2nd writer
      assert(s2.m_value == 20);
   }
   else if (sm.get_policy() == boost::interprocess::interprocess_sharable_mutex::sharable_priority)
   {
      assert(e1.m_value == 10);
      assert(e2.m_value == 20);
      assert(s1.m_value == 10);   // Readers get in before 2nd writer
      assert(s2.m_value == 10);
   }
   else if (sm.get_policy() == boost::interprocess::interprocess_sharable_mutex::no_priority){
      //We can only assure that the first will be the writer
      assert(e1.m_value == 10);
      //A that we will execute all
      assert(s1.m_value == 20 || s2.m_value == 20 || e2.m_value == 20);
   }
/*
   else if (sm.get_policy() == boost::interprocess::read_write_scheduling_policy::alternating_many_reads)
   {
      assert(e1.m_value == 10);
      assert(e2.m_value == 20);
      assert(s1.m_value == 10);   // Readers get in before 2nd writer
      assert(s2.m_value == 10);
   }
   else if (sm.get_policy() == boost::interprocess::interprocess_sharable_mutex::alternating_priority)
   {
      assert(e1.m_value == 10);
      assert(e2.m_value == 20);

      // One Reader gets in before 2nd writer, but we can't tell
      // which reader will "win", so just check their sum.
      assert((s1.m_value + s2.m_value == 30));
   }*/
}

template<typename SM>
void test_try_sharable_mutex(SM &sm)
{
   data<SM> s1(1,sm);
   data<SM> e1(2,sm);
   data<SM> e2(3,sm);

   // We start with some specialized tests for "try" behavior

   shared_val = 0;

   // Writer one launches, holds the lock for 3*BaseSeconds seconds.

   boost::thread tw1(thread_adapter<SM>(try_exclusive,&e1,sm));

   // Reader one launches, "clearly" after writer #1 holds the lock
   //   and before it releases the lock.
   boost::thread::sleep(xsecs(1*BaseSeconds));
   boost::thread tr1(thread_adapter<SM>(try_shared,&s1,sm));

   // Writer two launches in the same timeframe.
   boost::thread tw2(thread_adapter<SM>(try_exclusive,&e2,sm));

   tw2.join();
   tr1.join();
   tw1.join();

   assert(e1.m_value == 10);
   assert(s1.m_value == -1);        // Try would return w/o waiting
   assert(e2.m_value == -1);        // Try would return w/o waiting
}

template<typename SM>
void test_timed_sharable_mutex(SM &sm)
{
   data<SM> s1(1,sm,1*BaseSeconds);
   data<SM> s2(2,sm,3*BaseSeconds);
   data<SM> e1(3,sm,3*BaseSeconds);
   data<SM> e2(4,sm,1*BaseSeconds);

   // We begin with some specialized tests for "timed" behavior

   shared_val = 0;

   // Writer one will hold the lock for 3*BaseSeconds seconds.
   boost::thread tw1(thread_adapter<SM>(timed_exclusive,&e1,sm));

   boost::thread::sleep(xsecs(1*BaseSeconds));
   // Writer two will "clearly" try for the lock after the readers
   //  have tried for it.  Writer will wait up 1*BaseSeconds seconds for the lock.
   //  This write will fail.
   boost::thread tw2(thread_adapter<SM>(timed_exclusive,&e2,sm));

   // Readers one and two will "clearly" try for the lock after writer
   //   one already holds it.  1st reader will wait 1*BaseSeconds seconds, and will fail
   //   to get the lock.  2nd reader will wait 3*BaseSeconds seconds, and will get
   //   the lock.

   boost::thread tr1(thread_adapter<SM>(timed_shared,&s1,sm));
   boost::thread tr2(thread_adapter<SM>(timed_shared,&s2,sm));

   tw1.join();
   tr1.join();
   tr2.join();
   tw2.join();

   assert(e1.m_value == 10);
   assert(s1.m_value == -1);
   assert(s2.m_value == 10);
   assert(e2.m_value == -1);
}

} // namespace

int main ()
{
   using namespace boost::interprocess;
   int i;
   const int NumTest = 3;

   for(i = 0;
       i < static_cast<int>(interprocess_sharable_mutex::max_priority);
       ++i)
   {
      int j;
      interprocess_sharable_mutex sh_mutex
         (static_cast<interprocess_sharable_mutex::sharable_mutex_policy>(i));

      for(j = 0; j < NumTest; ++j){
         std::cout << "plain test, policy=" << i << " retry=" << j << "\n";
         test_plain_sharable_mutex(sh_mutex);
      }

      for(j = 0; j < NumTest; ++j){
         std::cout << "try test, policy=" << i << " retry=" << j << "\n";
         test_try_sharable_mutex(sh_mutex);
      }

      for(j = 0; j < NumTest; ++j){
         std::cout << "timed test, policy=" << i << " retry=" << j << "\n";
         test_timed_sharable_mutex(sh_mutex);
      }
   }
   return 0;
}

#include <boost/interprocess/detail/config_end.hpp>
