<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Boost.Function</title>
  </head>

  <body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080">

  <h1><IMG SRC="../../c++boost.gif" WIDTH="276" HEIGHT="86">Header &lt;<a HREF="../../boost/function.hpp">boost/function.hpp</a>&gt;</h1>

<p> The header &lt;<a HREF="../../boost/function.hpp">boost/function.hpp</a>&gt; includes a family of class templates that are function object wrappers. The notion is similar to a generalized callback. It shares features with function pointers in that both define a call interface (e.g., a function taking two integer arguments and returning a floating-point value) through which some implementation can be called, and the implementation that is invoked may change throughout the course of the program.

<p> Generally, any place in which a function pointer would be used to defer a call or make a callback, Boost.Function can be used instead to allow the user greater flexibility in the implementation of the target. Targets can be any 'compatible' function object (or function pointer), meaning that the arguments to the interface designated by Boost.Function can be converted to the arguments of the target function object.

<ul>
  <li><a href="#header">Header <code>&lt;boost/function.hpp&gt;</code> synopsis</a></li>
  <li><a href="#function_base">Class <code>function_base</code></a></li>
  <li><a href="#functionN">Class template <code>function<i>N</i></code></a></li>
  <li><a href="#function">Class template <code>function</code></a></li>
  <li><a href="#operations">Operations on function object wrappers</a></li>
  <li><a href="#usage">Basic usage</a>
     <ul>
       <li>Free functions</li>
       <li>Member functions</li>
     </ul>
    </li>
  <li><a href="#family">The <code>function</code> family</a></li>
  <li><a href="#advanced">Advanced usage</a>
    <ul>
      <li><a href="#policies">Policies</a></li>
      <li><a href="#mixins">Mixins</a></li>
      <li><a href="#allocators">Allocators</a></li>
      <li><a href="#synchronizing">Example: Synchronized functions</a></li>
   </ul>
  </li>
  <li><a href="#vspointers">Boost.Function vs. Function Pointers</a></li>
  <li><a href="#performance">Performance</a></li>
  <li><a href="#portability">Portability</a></li>
  <li><a href="#design">Design rationale</a></li>
  <li><a href="#acknowledgements">Acknowledgements</a></li>
  <li><a href="faq.html">Frequently Asked Questions</a></li>
</ul>


<h2><a name="header">Header <code>&lt;boost/function.hpp&gt;</code> synopsis</a></h2>
<p> Here <code><i>MAX_ARGS</i></code> is an implementation-defined constant that defines the maximum number of function arguments supported by Boost.Function and will be at least 10. The <code><i>MAX_ARGS</i></code> constant referred to in this document need not have any direct representation in the library.

<pre>
namespace boost {
  class function_base
  {
    bool empty() const;
    operator bool() const;
  };

  // For <i>N</i> in [0, <i>MAX_ARGS</i>]
  template&lt;typename ResultType,
           typename Arg1,
	   typename Arg2,
           <i>...</i>
           typename Arg<i>N</i>,
	   typename Policy    = empty_function_policy,
	   typename Mixin     = empty_function_mixin,
	   typename Allocator = std::allocator&lt;function_base&gt; &gt;
  class function<i>N</i> : public function_base, public Mixin
  {
    typedef ResultType result_type;
    typedef Policy     policy_type;
    typedef Mixin      mixin_type;
    typedef Allocator  allocator_type;

    typedef Arg1 argument_type;        <i>// If N == 1</i>

    typedef Arg1 first_argument_type;  <i>// If N == 2</i>
    typedef Arg2 second_argument_type; <i>// If N == 2</i>

    <i>// Construction</i>
    function<i>N</i>();
    function<i>N</i>(const function<i>N</i>&);
    template&lt;typename F&gt; function<i>N</i>(const F&);
    
    <i>// Assignment</i>
    function<i>N</i>& operator=(const function<i>N</i>&);
    template&lt;typename F&gt; function<i>N</i>& operator=(const F&);
    void set(const function<i>N</i>&);
    template&lt;typename F&gt; void set(const F&);
    void swap(function<i>N</i>&);
    void clear();

    <i>// Invocation</i>
    result_type operator()(Arg1 a1, Arg2 a2, <i>...</i>, Arg<i>N</i> a<i>N</i>);
    result_type operator()(Arg1 a1, Arg2 a2, <i>...</i>, Arg<i>N</i> a<i>N</i>) const;
  };

  template&lt;typename ResultType,
           typename Arg1,
	   typename Arg2,
           <i>...</i>
	   typename Arg<i>N</i>,
           typename Policy,
           typename Mixin,
           typename Allocator&gt;
  inline void swap(const function&lt;Arg1, Arg2, <i>...</i>Arg<i>N</i>, Policy, Mixin, Allocator&gt;&,
                   const function&lt;Arg1, Arg2, <i>...</i>Arg<i>N</i>, Policy, Mixin, Allocator&gt;&);

  // For any <i>N</i> in [0, <i>MAX_ARGS</i>]
  template&lt;typename ResultType,
           typename Arg1,
	   typename Arg2,
           <i>...</i>
           typename Arg<i>N</i>,
           typename Arg<i>N+1</i> = <i>implementation-defined</i>,
           typename Arg<i>N+2</i> = <i>implementation-defined</i>,
	   <i>...</i>
	   typename Arg<i>MAX_ARGS</i> = <i>implementation-defined</i>&gt;
  class function : public function<i>N</i>&lt;Arg1, Arg2, <i>...</i>, Arg<i>N</i>&gt;
  {
    <i>// Construction</i>
    function();
    function(const function&);
    function<i>N</i>(const function<i>N</i>&);
    template&lt;typename F&gt; function<i>N</i>(const F&);
    
    <i>// Assignment</i>
    function& operator=(const function&);
    function<i>N</i>& operator=(const function<i>N</i>&);
    template&lt;typename F&gt; function& operator=(const F&);
    void set(const function&);
    void set(const function<i>N</i>&);
    template&lt;typename F&gt; void set(const F&);
  };

  template&lt;typename ResultType,
           typename Arg1,
	   typename Arg2,
           <i>...</i>
	   typename Arg<i>MAX_ARGS</i>&gt;
  inline void swap(const function&lt;Arg1, Arg2, <i>...</i>Arg<i>MAX_ARGS</i>&gt;&,
                   const function&lt;Arg1, Arg2, <i>...</i>Arg<i>MAX_ARGS</i>&gt;&);
}	   
</pre>

<h2><a name="function_base">Class <code>function_base</code></a></h2>
<p> Class <code>function_base</code> is the common base class for all Boost.Function objects. Objects of type <code>function_base</code> may not be created directly. 

<p> <code>bool empty() const</code>
<ul>
  <li><b>Returns</b>: <code>true</code> if the function object has a target, <code>false</code> otherwise.</li>
  <li><b>Throws</b>: will not throw.</li>
  <li><b>Complexity</b>: constant.</li>
</ul>

<p> <code>operator bool() const</code>
<ul>
  <li><b>Returns</b>: <code>!empty()</code></li>
  <li><b>Throws</b>: will not throw.</li>
  <li><b>Complexity</b>: constant.</li>
</ul>

<h2><a name="functionN">Class template <code>function<i>N</i></code></a></h2>
<p> Class template <code>function<i>N</i></code> is actually a family of related classes <code>function0</code>, <code>function1</code>, etc., up to some implementation-defined maximum. In this context, <code><i>N</i></code> refers to the number of parameters and <code>f</code> refers to the implicit object parameter.

<p> <code>function<i>N</i>();</code>
<ul>
  <li><b>Postconditions</b>: <code>f.empty()</code>.</li>
  <li><b>Throws</b>: will not throw.</li>
  <li><b>Complexity</b>: constant.</li>
</ul>

<p> <code>function<i>N</i>(const function<i>N</i>& g);</code>
<ul>
  <li><b>Postconditions</b>: <code>f</code> contains a copy of the <code>g</code>'s target, if it has one, or is empty if <code>g.empty()</code>. The mixin for the <code>f</code> is copy-constructed from the mixin of <code>g</code>.</li>
  <li><b>Complexity</b>: constant.</li>
</ul>

<p> <code>template&lt;typename F&gt; function<i>N</i>(const F& g);</code>
<ul>
  <li><b>Requires</b>: <code>g</code> is a compatible function object.</li>
  <li><b>Postconditions</b>: <code>f</code> targets a copy of <code>g</code>.</li>
  <li><b>Complexity</b>: constant.</li>
  <li><b>Rationale</b>: <code>g</code> is a reference-to-<code>const</code> because it is a portable, efficient, and concise way to accept any function object or function pointer. In the case of a function pointer, the type of <code>g</code> is reference-to-<code>const</code> pointer-to-function.</li>
</ul>

<p> <code>function<i>N</i>& operator=(const function<i>N</i>& g);</code>
<ul>
  <li><b>Postconditions</b>: <code>f</code> targets a copy of <code>g</code>'s target, if it has one, or is empty if <code>g.empty()</code>. The mixin for <code>f</code> is assigned the value of the mixin for <code>g</code>.</li>
  <li><b>Returns</b>: <code>*this</code>.</li>
  <li><b>Throws</b>: TBD: Should meet strong guarantee, but doesn't yet.</li>
  <li><b>Complexity</b>: constant.</li>
</ul>

<p> <code>template&lt;typename F&gt; function<i>N</i>& operator=(const F& g);</code>
<ul>
  <li><b>Requires</b>: <code>g</code> is a compatible function object.</li>
  <li><b>Postconditions</b>: <code>f</code> targets a copy of <code>g</code>.</li>
  <li><b>Returns</b>: <code>*this</code>.</li>
  <li><b>Throws</b>: TBD: Should meet strong guarantee, but doesn't yet.</li>
  <li><b>Complexity</b>: constant.</li>
  <li><b>Rationale</b>: <code>g</code> is a reference-to-<code>const</code> because it is a portable, efficient, and concise way to accept any function object or function pointer. In the case of a function pointer, the type of <code>g</code> is reference-to-<code>const</code> pointer-to-function.</li>
</ul>

<p> <code>void set(const function<i>N</i>& g);</code>
<ul>
  <li><b>Effects</b>: <code>*this = g</code>.</li>
</ul>

<p> <code>template&lt;typename F&gt; void set(const F&);</code>
<ul>
  <li><b>Effects</b>: <code>*this = g</code>.</li>
</ul>

<p> <code>void swap(function<i>N</i>& g);</code>
<ul>
  <li><b>Effects</b>: interchanges the targets of <code>f</code> and <code>g</code>.</li>
  <li><b>Throws</b>: will not throw.</li>
  <li><b>Complexity</b>: constant.</li>
</ul>

<p> <code>void clear(); </code>
<ul>
  <li><b>Effects</b>: If <code>!empty()</code>, deallocates current target.</li>
  <li><b>Postconditions</b>: <code>empty()</code>.</li>
  <li><b>Complexity</b>: constant.</li>
</ul>

<p> <code> result_type operator()(Arg1 a1, Arg2 a2, <i>...</i>, Arg<i>N</i> a<i>N</i>);</code>
<ul>
  <li><b>Requires</b>: <code>!empty()</code>.</li>
  <li><b>Effects</b>: <i>target</i> is the underlying function target. It is not <code>const</code> or <code>volatile</code> qualified.
    <ol>
      <li><code>policy_type policy;</code></li>
      <li><code>policy.precall(this);</code></li>
      <li><code><i>target</i>(a1, a2, <i>...</i>, a<i>N</i>);</code></li>
      <li><code>policy.postcall(this);</code></li>
    </ol>
  <li><b>Returns</b>: the value returned by <i>target</i>.</li>
  <li><b>Complexity</b>: constant.</li>
</ul>

<p> <code> result_type operator()(Arg1 a1, Arg2 a2, <i>...</i>, Arg<i>N</i> a<i>N</i>) const;</code>
<ul>
  <li><b>Requires</b>: <code>!empty()</code>.</li>
  <li><b>Effects</b>: <i>const-target</i> is the underlying function target. It is <code>const</code> qualified but not <code>volatile</code> qualified.
    <ol>
      <li><code>policy_type policy;</code></li>
      <li><code>policy.precall(this);</code></li>
      <li><code><i>const-target</i>(a1, a2, <i>...</i>, a<i>N</i>);</code></li>
      <li><code>policy.postcall(this);</code></li>
    </ol>
  <li><b>Returns</b>: the value returned by <i>const-target</i>.</li>
  <li><b>Complexity</b>: constant.</li>
</ul>

<h2><a name="function">Class template <code>function</code></a></h2>
<p> Class template <code>function</code> is a thin wrapper around the numbered class templates <code>function0</code>, <code>function1</code>, etc. It accepts up to <i>MAX_ARGS</i> arguments, but when passed <i>N</i> arguments it will derive from <code>function<i>N</i></code> specialized with the arguments it receives.

<p> The semantics of all operations in class template <code>function</code> are equivalent to that of the underlying <code>function<i>N</i></code> object, although additional member functions are required to allow proper copy construction and copy assignment of <code>function</code> objects.

<h2><a name="operations">Operations on function object wrappers</a></h2>
<p>
<pre>
template&lt;typename ResultType,
         typename Arg1,
	 typename Arg2,
         <i>...</i>
	 typename Arg<i>N</i>,
         typename Policy,
         typename Mixin,
         typename Allocator&gt;
inline void swap(const function&lt;Arg1, Arg2, <i>...</i>Arg<i>N</i>, Policy, Mixin, Allocator&gt;& f,
                 const function&lt;Arg1, Arg2, <i>...</i>Arg<i>N</i>, Policy, Mixin, Allocator&gt;& g);
</pre>
<ul>
  <li><b>Effects</b>: <code>f.swap(g);</code></li>
</ul>

<p>
<pre>
template&lt;typename ResultType,
         typename Arg1,
	 typename Arg2,
         <i>...</i>
	 typename Arg<i>MAX_ARGS</i>&gt;
inline void swap(const function&lt;Arg1, Arg2, <i>...</i>Arg<i>MAX_ARGS</i>&gt;& f,
                 const function&lt;Arg1, Arg2, <i>...</i>Arg<i>MAX_ARGS</i>&gt;& g);
</pre>
<ul>
  <li><b>Effects</b>: <code>f.swap(g);</code></li>
</ul>

<h2><a name="usage">Basic usage</a></h2>
<p> A wrapper is defined simply by specializing a <code>function</code> object with the desired return type and argument types. Any number of arguments may be supplied, up to some implementation-defined limit (10 is the default maximum). The following declares a function object wrapper <code>f</code> that takes two <code>int</code> parameters and returns a <code>float</code>:
<pre>
boost::function&lt;float, int, int&gt; f;
</pre>

<p> By default, function object wrappers are empty, so we can create a 
function object to assign to <code>f</code>:
<pre>
struct int_div { float operator()(int x, int y) const { return ((float)x)/y; }; };
f = int_div();
</pre>

<p> Now we can use <code>f</code> to execute the underlying function object
<code>int_div</code>:
<pre>
  std::cout << f(5, 3) << std::endl;
</pre>

<p> We are free to assign any compatible function object to <code>f</code>. If <code>int_div</code> had been declared to take two <code>long</code> operands,
the implicit conversions would have been applied without any user interference.

<p> Invoking a function object wrapper that does not actually contain a function object is a precondition violation. We can check for an empty function object wrapper by querying its <code>empty()</code> method or, more succinctly, by using it in a boolean context: if it evaluates true, it contains a function object target, i.e.,
<pre>
  if (f)
    std::cout << f(5, 3) << std::endl;
  else
    std::cout << "f has no target" << std::endl;
</pre>

<p> We can clear out a function target using the <code>clear()</code> member functor. 

<h3>Free functions</h3>
<p> Free function pointers can be considered singleton function objects with const function call operators, and can therefore be directly used with the function object wrappers:
<pre>
  float mul_ints(int x, int y) { return ((float)x) * y; }
  f = &mul_ints;
</pre>

<h3>Member functions</h3>
<a name="member_func">
<p> In many systems, callbacks often call to member functions of a particular
object. Handling argument binding is beyond the scope of Boost.Function. However, there are several libraries that perform 'argument binding', including
<ul>
  <li> The C++ Standard library. Using <code>std::bind1st</code> and <code>std::mem_fun</code> together one can bind the object of a pointer-to-member function for use with Boost.Function:
<pre>
  struct X {
    int foo(int);
  };

  boost::function&lt;int, int&gt; f;
  X x;
  f = std::bind1st(std::mem_fun(&X::foo), &x);

  f(5); // Call x.foo(5)</pre></li>

  <li><a href="http://lambda.cs.utu.fi/">The Lambda library</a>. This library provides a powerful composition mechanism to construct function objects that uses very natural C++ syntax. Lambda requires a compiler that is reasonably conformant to the C++ standard. Note that it is not a Boost library.</li>

  <li>Peter Dimov's <a href="http://groups.yahoo.com/group/boost/files/bind/bind.hpp">bind</a> library. It has a smaller scope than the Lambda Library but is more tolerant of broken compilers. It is an unreviewed library in development.</li>
</ul>

<h2><a name="family">The <code>function</code> family</a></h2>
<p> The header &lt;<a HREF="../../boost/function.hpp">boost/function.hpp</a>&gt; defines the primary entry point to the function object wrappers, the class template <code>boost::function</code>. This class template is essentially a thin wrapper around a set of similar numbered function object wrappers, <code>boost::function0</code>, <code>boost::function1</code>, etc., where the number indicates the number of arguments passed to the function object target. The declaration of <code>f</code> above could also be written as:
<pre>
boost::function2&lt;float, int, int&gt; f;
</pre>

<p> The numbered class templates contain most of the implementation and are each distinct class templates. They may be helpful if used in shared libraries, where the number of arguments supported by Boost.Function may change between revisions. Additionally, some compilers (e.g., Microsoft Visual C++ 6.0) have been known to be incapable of compiling <code>boost::function</code> in some instances but are able to handle the numbered variants.

<h2><a name="advanced">Advanced usage</a></h2>
<p> The <code>boost::function</code> family supports additional customization by means of policies, mixins, and allocators. The specific usage of each of these will be explained in later sections, but they share a common problem: how to replace each default with your own version. 

<p> With <code>boost::function</code> it is not so clear, because support for an arbitrary number of parameters means that it is impossible to specify just the last parameter, but not 5 of the parameters in between. Therefore, <code>boost::function</code> doubles as a generative interface for the underlying numbered class templates that uses named template parameters. For instance, to specify both a policy and an allocator for a function object wrapper <code>f</code> taking an <code>int</code> and returning an <code>int</code>, use:
<pre>
  function&lt;int, int&gt;::policy&lt;MyPolicy&gt;::allocator&lt;MyAllocator&gt;::type f;
</pre>

<p> The named template parameters <code>policy</code>, <code>mixin</code> and <code>allocator</code> each take one template parameter (the replacement class) and may be nested as above to generate a function object wrapper. The <code>::type</code> at the end accesses the actual type that fits the given properties.

<h3><a name="policies">Policies</a></h3>
<p> Policies define what happens directly before and directly after an invocation of a function object target is made. A policy must have two member functions, <code>precall</code> and <code>postcall</code>, each of which must be able to accept a <code>const</code> function object wrapper pointer. The following policy will print "before" prior to execution and "after" afterwards:

<pre>
struct print_policy {
  void precall(const boost::function_base*) { std::cout << "before"; }
  void postcall(const boost::function_base*) { std::cout << "after"; }
};
</pre>

<p> A new instance of the policy class will be created prior to calling the function object target and will be preserved until after the call has returned. Therefore, for any invocation the <code>precall</code> and <code>postcall</code> will be executed on the same policy class instance; however, policy class instances will not be kept between target invocations.

<p> Policies are further <a href="http://www.boost.org/more/generic_programming.html#policy">described</a> in the Boost discussion on <a href="http://www.boost.org/more/generic_programming.html">generic programming techniques</a>.

<h3><a name="mixins">Mixins</a></h3>
<p> The function object wrappers allow any class to be "mixed in" as a base class. This allows extra members and/or functionality to be included by the user. This can be used, for instance, to overcome the limitations of policies by storing data between invocations in a base class instead of in a <code>static</code> member of a policy class. 

<h3><a name="allocators">Allocators</a></h3>
<p> The function object wrappers allow the user to specify a new allocator to handle the cloning of function object targets (when the wrappers are copied). The allocators used are the same as the C++ standard library allocators. The wrappers assume the allocators are stateless, and will create a new instance each time they are used (because they are rebound very often). This shares the semantics of most standard library implementations, and is explicitly allowed by the C++ standard.

<h3><a name="synchronizing">Example: Synchronized callbacks</a></h3>
<p> Synchronization of callbacks in a multithreaded environment is extremely important. Using mixins and policies, a Boost.Function object may implement its own synchronization policy that ensures that only one thread can be in the callback function at any given point in time.

<p> We will use the prototype Boost.Threads library for its <code>recursive_mutex</code>. Since the mutex is on a per-callback basis, we will add a mutex to the <code>boost::function</code> by mixin it in with this mixin class:
<pre>
class SynchronizedMixin {
  mutable boost::recursive_mutex mutex;
};
</pre>

<p> Next, we create a policy that obtains a lock before the target is called (via the <code>precall</code> function) and releases the lock after the target has been called (via the <code>postcall</code> function):

<pre>
class SynchronizedPolicy {
  std::auto_ptr&lt;boost::recursive_mutex::lock&gt; lock;

  void precall(const SynchronizedMixin* f) 
  {
    lock.reset(new boost::recursive_mutex::lock(f->mutex));
  }

  void postcall(const SynchronizedMixin* f)
  {
    lock.reset();
  }
};
</pre>

<p>The use of <code>std::auto_ptr</code> ensures that the lock will be destroyed (and therefore released) if an exception is thrown by the target function. Now we can use the policy and mixin together to create a synchronized callback:

<pre>
boost::function2&lt;float, int, int, SynchronizedPolicy, SynchronizedMixin&gt; f;
</pre>

<h2><a name="vspointers">Boost.Function vs. Function Pointers</a></h2>
<p>Boost.Function has several advantages over function pointers, namely:

<ul>
   <li>Boost.Function allows arbitrary compatible function objects to be targets (instead of requiring an exact function signature).</li>
   <li>Boost.Function may be used with argument-binding and other function object construction libraries.</li>
   <li>Boost.Function has predictible debug behavior when an empty function object is called. </li>
   <li>Boost.Function can be adapted to perform operations before and after each call, allowing, for instance, synchronization primitives to be made part of the function type.</li>
</ul>

And, of course, function pointers have several advantages over Boost.Function:

<ul>
    <li> Function pointers are smaller (the size of one pointer instead of three) </li>
    <li> Function pointers are faster (Boost.Function may require two calls through function pointers) </li>
    <li> Function pointers are backward-compatible with C libraries.</li>
    <li> More readable error messages. </li>
</ul>


<p> The above two lists were adapted from comments made by Darin Adler.

<h2><a name="performance">Performance</a></h2>
<h3>Function object wrapper size</h3>
<p> Function object wrappers will be the size of two function pointers plus one function pointer or data pointer (whichever is larger). On common 32-bit platforms, this amounts to 12 bytes per wrapper. Additionally, the function object target will be allocated on the heap.

<h3>Copying efficiency</h3>
<p> Copying function object wrappers requires allocating member for a copy of the function object target. The default allocator may be replaced with a faster custom allocator if the cost of this cloning becomes prohibitive.

<h3>Invocation efficiency</h3>
<p> With a properly inlining compiler, an invocation of a function object requires one call through a function pointer. If the call is to a free function pointer, an additional call must be made to that function pointer (unless the compiler has very powerful interprocedural analysis).

<h2><a name="portability">Portability</a></h2>
<p> The function object wrappers have been designed to be as portable as possible, and to support many compilers even when they do not support the C++ standard well. The following compilers have passed all of the testcases included with <code>boost::function</code>.
<ul>
  <li>GCC 2.95.3</li>
  <li>GCC 3.0</li>
  <li>SGI MIPSpro 7.3.0</li>
  <li>Borland C++ 5.5.1</li>
  <li>Comeau C++ 4.2.45.2</li>
  <li>Metrowerks Codewarrior 6.1</li>
</ul>

<p> The following compilers work with <code>boost::function</code>, but have some problems:
<ul>
  <li>Microsoft Visual C++ 6.0 (service pack 5): allocators not supported, some problems with <code>boost::function</code> class template (numbered variants seem to work)</li>
  <li>Intel C++ 5.0: allocators not supported</li>
</ul>

<p> If your compiler is not listed, there is a small set of tests to stress the capabilities of the <code>boost::function</code> library. A standards-compliant compiler should compile the code without any modifications, but if you find you run into problems please submit a bug report.

<h2><a name="design">Design rationale</a></h2>
<h3>Combatting virtual function bloat</h3>
<p> The use of virtual functions tends to cause 'code bloat' on many compilers. When a class contains a virtual function, it is necessary to emit an additional function that classifies the type of the object. It has been our experience that these auxiliary functions increase the size of the executable significantly when many <code>boost::function</code> objects are used. 

<p> In Boost.Function, an alternative but equivalent approach was taken using free functions instead of virtual functions. The Boost.Function object essentially holds two pointers to make a valid target call: a void pointer to the function object it contains and a void pointer to an "invoker" that can call the function object, given the function pointer. This invoker function performs the argument and return value conversions Boost.Function provides. A third pointer points to a free function called the "manager", which handles the cloning and destruction of function objects. The scheme is typesafe because the only functions that actually handle the function object, the invoker and the manager, are instantiated given the type of the function object, so they can safely cast the incoming void pointer (the function object pointer) to the appropriate type.

<p> A compiler with strong interprocedural analysis could significantly reduce the overhead associated with virtual function calls such that the alternative used by Boost.Function is less efficient. No compiler has yet been found where this is true, but when it does occur the BOOST_FUNCTION_USE_VIRTUAL_FUNCTIONS macro can be defined to revert to the simpler implementation based on virtual functions.

<h2><a name="acknowledgements">Acknowledgements</a></h2>
<p> Many people were involved in the construction of this library. William Kempf, Jesse Jones and Karl Nelson were all extremely helpful in isolating an interface and scope for the library. John Maddock managed the formal review, and many reviewers gave excellent comments on interface, implementation, and documentation. 

    <hr>
    <address><a href="mailto:gregod@cs.rpi.edu">Doug Gregor</a></address>
  </body>
</html>