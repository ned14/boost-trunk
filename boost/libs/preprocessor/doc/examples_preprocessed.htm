<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>Boost.Preprocessor - Tutorial examples preprocessed</title>
</head>
<body bgcolor="#FFFFFF" link="#0000ff" vlink="#800080">
<table border="0" cellpadding="7" cellspacing="0" width="100%" summary=
    "header">
  <tr> 
    <td valign="top" width="300"> 
      <h3><a href="../../../index.htm"><img height="86" width="277" alt="C++ Boost" src="../../../c++boost.gif" border="0"></a></h3>
    </td>
    <td valign="top"> 
      <h1 align="center">Boost.Preprocessor</h1>
      <h2 align="center">Tutorial examples preprocessed</h2>
    </td>
  </tr>
</table>
<hr>

<p>The following code snippets were produced by actually preprocessing the code 
  snippets of the tutorial. After preprocessing the code was reformatted manually.</p>

<hr>
<p><strong><a name="Local Macro"></a><a href="tutorial.htm#Local Macro">EXAMPLE</a>:</strong> 
  Use a Local Macro to avoid small scale repetition</p>

<blockquote>
  <pre>template&lt;class T, int n&gt;
vec&lt;T,n&gt;&
  operator +=
  ( vec&lt;T,n&gt;&
      lhs
  , const vec&lt;T,n&gt;&
      rhs
  )
{ for (int i=0; i&lt;n; ++i)
    lhs(i) += rhs(i);
  return lhs;
}

template&lt;class T, int n&gt;
vec&lt;T,n&gt;&
  operator -=
  ( vec&lt;T,n&gt;&
      lhs
  , const vec&lt;T,n&gt;&
      rhs
  )
{ for (int i=0; i&lt;n; ++i)
    lhs(i) -= rhs(i);
  return lhs;
}

template&lt;class T, int n&gt;
vec&lt;T,n&gt;&
  operator *=
  ( vec&lt;T,n&gt;&
      lhs
  , const vec&lt;T,n&gt;&
      rhs
  )
{ for (int i=0; i&lt;n; ++i)
    lhs(i) *= rhs(i);
  return lhs;
}

template&lt;class T, int n&gt;
vec&lt;T,n&gt;&
  operator /=
  ( vec&lt;T,n&gt;&
      lhs
  , const vec&lt;T,n&gt;&
      rhs
  )
{ for (int i=0; i&lt;n; ++i)
    lhs(i) /= rhs(i);
  return lhs;
}
</pre>
</blockquote>

<hr>
<p><strong><a name="UNUSED"></a><a href="tutorial.htm#UNUSED">EXAMPLE</a>:</strong> 
  Use BOOST_PP_EMPTY() as an unused parameter in Local Macro instantiations</p>

<blockquote>
  <pre>template&lt;class base&gt;
typename implement_subscript_using_begin_subscript&lt;base&gt;::value_type&
  implement_subscript_using_begin_subscript&lt;base&gt;::operator[]
  ( index_type
      i
  )
{ return base::begin()[i];
}

template&lt;class base&gt;
const typename implement_subscript_using_begin_subscript&lt;base&gt;::value_type&
  implement_subscript_using_begin_subscript&lt;base&gt;::operator[]
  ( index_type
      i
  ) const
{ return base::begin()[i];
}
</pre>
</blockquote>

<hr>
<p><b><a name="CAT"></a><a href="tutorial.htm#CAT">EXAMPLE:</a></b> Use BOOST_PP_CAT instead of ## when necessary</p>

<blockquote>
  <pre>enum
{ static_check_152 = (sizeof(int) &lt;= sizeof(long)) ? 1 : -1
};
typedef char
  static_assert_152
  [ static_check_152
  ];
</pre>
</blockquote>
<hr>
<p><b><a name="STRINGIZE"></a><a href="tutorial.htm#STRINGIZE">EXAMPLE:</a></b> Use BOOST_PP_STRINGIZE instead of # whenever necessary</p>
<blockquote>
  <pre>#pragma message("examples.cpp" "(" "20" ") : " "TBD!")</pre>
</blockquote>
<hr>
<p><strong><a name="ENUM_PARAMS"></a><a href="tutorial.htm#ENUM_PARAMS">EXAMPLE</a>:</strong> 
  Use:</p>
<ul>
  <li> BOOST_PP_ENUM_PARAMS,</li>
  <li> BOOST_PP_ENUM_PARAMS_WITH_A_DEFAULT,</li>
  <li> BOOST_PP_ENUM_PARAMS_WITH_DEFAULTS,</li>
  <li> BOOST_PP_ENUM_SHIFTED_PARAMS, or</li>
  <li>BOOST_PP_REPEAT, and</li>
  <li> BOOST_PP_COMMA_IF</li>
</ul>
<p>to avoid O(N) repetition on lists in general</p>
<blockquote>
  <pre>struct make_type_list_end;

template
&lt; class T0=make_type_list_end
, class T1=make_type_list_end
, class T2=make_type_list_end
, class T3=make_type_list_end
, class T4=make_type_list_end
, class T5=make_type_list_end
, class T6=make_type_list_end
, class T7=make_type_list_end
&gt;
struct make_type_list
{
private:
  enum
  { end = is_same&lt;T0,make_type_list_end&gt;::value
  };
public:
  typedef typename
    type_if
    &lt; end
    , type_cons_empty
    , type_cons
      &lt; T0
      , typename
        type_inner_if
        &lt; end
        , type_identity&lt;end&gt;
        , make_type_list
          &lt; T1
          , T2
          , T3
          , T4
          , T5
          , T6
          , T7
          &gt;
        &gt;::type
      &gt;
    &gt;::type type;
};
</pre>
</blockquote>

<hr>
<p><strong><a name="Token Look-Up"></a><a href="tutorial.htm#Token Look-Up">EXAMPLE</a>:</strong> 
  Use BOOST_PP_REPEAT and a Token Look-Up Function to eliminate categorical 
  repetition</p>

<blockquote>
  <pre>catch (bool t)
{ report_typeid(t);
  report_value(t);
}
catch (char t)
{ report_typeid(t);
  report_value(t);
}
catch (signed char t)
{ report_typeid(t);
  report_value(t);
}
catch (unsigned char t)
{ report_typeid(t);
  report_value(t);
}
catch (short t)
{ report_typeid(t);
  report_value(t);
}
catch (unsigned short t)
{ report_typeid(t);
  report_value(t);
}
catch (int t)
{ report_typeid(t);
  report_value(t);
}
catch (unsigned int t)
{ report_typeid(t);
  report_value(t);
}
catch (long t)
{ report_typeid(t);
  report_value(t);
}
catch (unsigned long t)
{ report_typeid(t);
  report_value(t);
}
catch (float t)
{ report_typeid(t);
  report_value(t);
}
catch (double t)
{ report_typeid(t);
  report_value(t);
}
catch (long double t)
{ report_typeid(t);
  report_value(t);
}
</pre>
</blockquote>

<hr>
<p><strong><a name="2ND_REPEAT"></a><a href="tutorial.htm#2ND_REPEAT">EXAMPLE</a>:</strong> 
  Use BOOST_PP_REPEAT_2ND to avoid O(N*N) repetition</p>

<blockquote>
  <pre>vec()
{
}
vec(T a0)
{ (*this)[0] = a0;
}
vec(T a0, T a1)
{ (*this)[0] = a0;
  (*this)[1] = a1;
}
vec(T a0, T a1, T a2)
{ (*this)[0] = a0;
  (*this)[1] = a1;
  (*this)[2] = a2;
}
vec(T a0, T a1, T a2, T a3)
{ (*this)[0] = a0;
  (*this)[1] = a1;
  (*this)[2] = a2;
  (*this)[3] = a3;
}
vec(T a0, T a1, T a2, T a3, T a4)
{ (*this)[0] = a0;
  (*this)[1] = a1;
  (*this)[2] = a2;
  (*this)[3] = a3;
  (*this)[4] = a4;
}
vec(T a0, T a1, T a2, T a3, T a4, T a5)
{ (*this)[0] = a0;
  (*this)[1] = a1;
  (*this)[2] = a2;
  (*this)[3] = a3;
  (*this)[4] = a4;
  (*this)[5] = a5;
}
vec(T a0, T a1, T a2, T a3, T a4, T a5, T a6)
{ (*this)[0] = a0;
  (*this)[1] = a1;
  (*this)[2] = a2;
  (*this)[3] = a3;
  (*this)[4] = a4;
  (*this)[5] = a5;
  (*this)[6] = a6;
}
vec(T a0, T a1, T a2, T a3, T a4, T a5, T a6, T a7)
{ (*this)[0] = a0;
  (*this)[1] = a1;
  (*this)[2] = a2;
  (*this)[3] = a3;
  (*this)[4] = a4;
  (*this)[5] = a5;
  (*this)[6] = a6;
  (*this)[7] = a7;
}
</pre>
</blockquote>

<p> 
<hr>
<p><a name="IF"></a><a href="tutorial.htm#IF"><b>EXAMPLE:</b></a> 
  Use BOOST_PP_IF to implement special case for the first element</p>

<blockquote> 
  <pre>false == false;
true == true;
</pre>
</blockquote>

<p> 
<hr>

<p><a name="Arithmetic"></a><a href="tutorial.htm#Arithmetic"><B>EXAMPLE:</B></a> Use arithmetic, logical and comparison operations when necessary</p>

<blockquote> 
  <pre>S, E0, E1
E0, S, E1
E0, E1, S
BAD PARAMS FOR SPECIAL_NUMBERED_LIST! E0, E1, E2, S</pre>
</blockquote>

<hr>
<p>Revised 
  <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan -->
  <!--webbot bot="Timestamp" endspan i-checksum="39359" -->
</p>
<p><i>&copy; Copyright <a href="http://www.housemarque.com">Housemarque Oy</a> 2002</i></p>

<p><i>Permission to copy, use, modify, sell and distribute this document is granted
provided this copyright notice appears in all copies. This document is provided
"as is" without express or implied warranty, and with no claim as to its suitability
for any purpose.</i></p>
</body>
</html>
