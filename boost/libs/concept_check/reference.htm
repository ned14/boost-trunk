
<h2><a name="reference">Reference</a></h2>

  <OL>
  <LI><a href="#functions">Functions</a></LI>
  <LI><a href="#classes">Classes</a></LI>
  <LI><a href="#basic-concepts">Basic Concept Checking Classes</a></LI>
  <LI><a href="#iterator-concepts">Iterator Concept Checking Classes</a></LI>
  <LI><a href="#function-object-concepts">Function Object Concept Checking Classes</a></LI>
  <LI><a href="#container-concepts">Container Concept Checking Classes</a></LI>
  <LI><a href="#basic-archetype">Basic Archetype Classes</a></LI>
  <LI><a href="#iterator-archetype">Iterator Archetype Classes</a></LI>
  <LI><a href="#function-object-archetype">Function Object Archetype Classes</a></LI>
  <LI><a href="#container-archetype">Container Archetype Classes</a></LI>
  </OL>

<h3><a name="functions">Functions</a></h3>

<pre>
  template &lt;class Concept&gt;
  void function_requires();
</pre>

<h3><a name="classes">Classes</a></h3>
<pre>
  template &lt;class Concept&gt;
  struct class_requires {
    typedef ... check;
  };
</pre>

<pre>
  // Make sure that <i>Type1</i> and <i>Type2</i> are exactly the same type.
  // If they are not, then the nested typedef for <tt>type</tt> will
  // not exist and cause a compiler error.
  template &lt;class Type1, class Type2&gt;
  struct require_same {
    typedef ... type;
  };
  // usage example
  typedef typedef require_same<int,int>::type req1; // this will compile OK
  typedef typedef require_same<int,float>::type req1; // this will cause a compiler error
</pre>

<h3><a name="basic-concepts">Basic Concept Checking Classes</a></h3>

<pre>
  template &lt;class T&gt; struct Integer_concept; // Is T a built-in integer type?
  template &lt;class T&gt; struct SignedIntegerConcept; // Is T a built-in signed integer type?
  template &lt;class X, class Y&gt; struct ConvertibleConcept; // Is X convertible to Y?
  template &lt;class T&gt; struct AssignableConcept;
  template &lt;class T&gt; struct DefaultConstructibleConcept;
  template &lt;class T&gt; struct CopyConstructibleConcept;
  template &lt;class T&gt; struct BooleanConcept;
  template &lt;class T&gt; struct EqualityComparableConcept;
  // Is class T equality comparable on the left side with type Left?
  template &lt;class T, class Left&gt; struct LeftEqualityComparableConcept;
  template &lt;class T&gt; struct LessThanComparableConcept;
</pre>

<h3><a name="iterator-concepts">Iterator Concept Checking Classes</a></h3>

<pre>
  template &lt;class Iter&gt; struct TrivialIteratorConcept;
  template &lt;class Iter&gt; struct Mutable_TrivialIteratorConcept;
  template &lt;class Iter&gt; struct InputIteratorConcept;
  template &lt;class Iter, class T&gt; struct OutputIteratorConcept;
  template &lt;class Iter&gt; struct ForwardIteratorConcept;
  template &lt;class Iter&gt; struct Mutable_ForwardIteratorConcept;
  template &lt;class Iter&gt; struct BidirectionalIteratorConcept;
  template &lt;class Iter&gt; struct Mutable_BidirectionalIteratorConcept;
  template &lt;class Iter&gt; struct RandomAccessIteratorConcept;
  template &lt;class Iter&gt; struct Mutable_RandomAccessIteratorConcept;
</pre>

<h3><a name="function-object-concepts">Function Object Concept Checking Classes</a></h3>

<pre>
  template &lt;class Func, class Return&gt; struct GeneratorConcept;
  template &lt;class Func, class Return, class Arg&gt; struct UnaryFunctionConcept;
  template &lt;class Func, class Return, class First, class Second&gt; struct BinaryFunctionConcept;
  template &lt;class Func, class Arg&gt; struct UnaryPredicateConcept;
  template &lt;class Func, class First, class Second&gt; struct BinaryPredicateConcept;
  template &lt;class Func, class First, class Second&gt; struct Const_BinaryPredicateConcept {;
</pre>

<h3><a name="container-concepts">Container Concept Checking Classes</a></h3>

<pre>
  template &lt;class C&gt; struct ContainerConcept;
  template &lt;class C&gt; struct Mutable_ContainerConcept;

  template &lt;class C&gt; struct ForwardContainerConcept;
  template &lt;class C&gt; struct Mutable_ForwardContainerConcept;

  template &lt;class C&gt; struct ReversibleContainerConcept;
  template &lt;class C&gt; struct Mutable_ReversibleContainerConcept;

  template &lt;class C&gt; struct RandomAccessContainerConcept;
  template &lt;class C&gt; struct Mutable_RandomAccessContainerConcept;

  template &lt;class C&gt; struct SequenceConcept;
  template &lt;class C&gt; struct FrontInsertionSequenceConcept;
  template &lt;class C&gt; struct BackInsertionSequenceConcept;

  template &lt;class C&gt; struct AssociativeContainerConcept;
  template &lt;class C&gt; struct UniqueAssociativeContainerConcept;
  template &lt;class C&gt; struct MultipleAssociativeContainerConcept;
  template &lt;class C&gt; struct SimpleAssociativeContainerConcept;
  template &lt;class C&gt; struct PairAssociativeContainerConcept;
  template &lt;class C&gt; struct SortedAssociativeContainerConcept;
</pre>


<h3><a name="basic-archetype">Basic Archetype Classes</a></h3>

<pre>
  class null_archetype; // A type that models no concepts.
  template &lt;class Base = null_archetype&gt; class default_constructible_archetype;
  template &lt;class Base = null_archetype&gt; class assignable_archetype;
  template &lt;class Base = null_archetype&gt; class copy_constructible_archetype;
  template &lt;class Left, class Base = null_archetype&gt; class left_equality_comparable_archetype;
  template &lt;class Base = null_archetype&gt; class equality_comparable_archetype;
  template &lt;class T, class Base = null_archetype&gt; class convertible_to_archetype;
</pre>

<h3><a name="iterator-archetype">Iterator Archetype Classes</a></h3>

<pre>
  template &lt;class ValueType&gt; class trivial_iterator_archetype;
  template &lt;class ValueType&gt; class mutable_trivial_iterator_archetype;
  template &lt;class ValueType&gt; class input_iterator_archetype;
  template &lt;class ValueType&gt; class forward_iterator_archetype;
  template &lt;class ValueType&gt; class bidirectional_iterator_archetype;
  template &lt;class ValueType&gt; class random_access_iterator_archetype;
</pre>

<h3><a name="function-object-archetype">Function Object Archetype Classes</a></h3>

<pre>
  template &lt;class Arg, class Return&gt; class unary_function_archetype;
  template &lt;class Arg1, class Arg2, class Return&gt; class binary_function_archetype;
  template &lt;class Arg&gt; class predicate_archetype;
  template &lt;class Arg1, class Arg2&gt; class binary_predicate_archetype;
</pre>

<h3><a name="container-archetype">Container Archetype Classes</a></h3>

<pre>
UNDER CONSTRUCTION
</pre>

