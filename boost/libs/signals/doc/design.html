<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Boost.Signals Design</title>
  </head>

  <body bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080">

  <h1><IMG SRC="../../../c++boost.gif" WIDTH="276" HEIGHT="86" ALT="Boost">Boost.Signals Design</h1>

<p> This document describes the high-level design of the Boost.Signals
library. An additional document describes the <a
href="design_rationale.html">design rationale</a>.

<h2>Table of Contents</h2>
<ul>
  <li><a href="#type_erasure">Type Erasure</a></li>
  <li><a href="#connection"><code>connection</code> class</a></li>
  <li><a href="#slot_call_iterator">Slot Call Iterator</a></li>
  <li><a href="#visit_each"><code>visit_each</code> function template</a></li>
</ul>

<h2><a name="type_erasure">Type Erasure</a></h2>
<p> Type erasure is used extensively within the Boost.Signals library
to reduce the amount of code generated by template
instantiation. Each signal must manage a list of slots and their
associated connections, along with a <code>std::map</code> to map from
slot names to their associated connections. However, instantiating
this map for every token type, and perhaps within each translation
unit (for some popular template instantiation strategies) increase
compile time overhead and space overhead.

<p> To combat this so-called "template bloat", we use <a
href="../../function/index.html">Boost.Function</a> and <a
href="../../any/index.html">Boost.Any</a> to store unknown types and
operations. Then, all of the code for handling the list of slots and
the mapping from named slots to connections is factored into the class
<a
href="../../../boost/signals/signal_base.hpp"><code>signal_base</code></a>
that deals exclusively with the <code>any</code> and
<code>function</code> objects, hiding the actual implementations using
the well-known pimpl idiom. The actual <a
href="reference/signalN.html"><code>signal<em>N</em></code></a> class
templates deal only with code that will change depending on the number
of arguments or which is inherently template-dependent (such as
connection).

<h2><a name="connection"><code>connection</code> class</a></h2>
<p> The <code>connection</code> class is central to the behavior of
the Boost.Signals library. It is the only entity within the
Boost.Signals system that has knowledge of all objects that are
associated by a given connection. To be specific, the
<code>connection</code> class itself is merely a thin wrapper over a
<a href="../../libs/smart_ptr/index.htm"><code>shared_ptr</code></a>
to a <code>basic_connection</code> object.

<p> <code>connection</code> objects are stored by all participants in
the Signals system: each <a
href="reference/trackable.html"><code>trackable</code></a> object
contains a list of <code>connection</code> objects describing all
connections it is a part of; similarly, all signals contain a set of
pairs that define a slot. The pairs consist of a slot function object
(generally a <a href="../../function/index.html">Boost.Function</a>
object) and a <code>connection</code> object (that will disconnect on
destruction). Finally, the mapping from slot groups to slots is based
on the key value in a <code>std::multimap</code> (the stored data in
the <code>std::multimap</code> is the slot pair).

<h2><a name="slot_call_iterator">Slot Call Iterator</a></h2>
<p> The slot call iterator is conceptually a stack of iterator
      adaptors that modify the behavior of the underlying iterator
      through the list of slots. The following table describes the
      type and behavior of each iterator adaptor required. Note that
      this is only a conceptual model: the implementation collapses
      all these layers into a single iterator adaptor because several
      popular compilers failed to compile the implementation of the
      conceptual model.

<table border=1>
<tr>
  <th><center>Iterator Adaptor</center></th>
  <th>Purpose</th>
</tr>
<tr>
  <td><center>Slot List Iterator</center></td>
  <td>An iterator through the list of slots connected to a signal. The
      <code>value_type</code> of this iterator will be
            <code>std::pair&lt;any, connection&gt;</code>, where the
            <code>any</code> contains an instance of the slot function
            type.</td>
</tr>
<tr>
  <td><center>Filter Iterator Adaptor</center></td>
  <td>This filtering iterator adaptor filters out slots that have been
            disconnected, so we never see a disconnected slot in later
            stages.</td>
            
</tr>
<tr>
  <td><center>Projection Iterator Adaptor</center></td>
  <td>The projection iterator adaptor returns a reference to the first
            member of the pair that constitutes a connected slot
            (e.g., just the <code>boost::any</code> object that holds
            the slot function).</td>
</tr>
<tr>
  <td><center>Transform Iterator Adaptor</center></td>
  <td>This transform iterator adaptor performs an
            <code>any_cast</code> to extract a reference to the slot
            function with the appropriate slot function type.</td>
</tr>
<tr>
  <td><center>Transform Iterator Adaptor</center></td>
  <td>This transform iterator adaptor calls the function object
            returned by dereferencing the underlying iterator with
            the set of arguments given to the signal itself, and
            returns the result of that slot call.</td>
</tr>

<tr>
  <td><center>Input Caching Iterator Adaptor</center></td>
  <td>This iterator adaptor caches the result of dereferencing the
            underlying iterator. Therefore, dereferencing this
            iterator multiple times will only result in the underlying
            iterator being dereferenced once; thus, a slot can only be
            called once but its result can be used multiple times.</td>
</tr>
<tr><td colspan=2><center>Slot Call Iterator</center></td</tr>
</table>

<h2><a name="visit_each"><code>visit_each</code> function template</a></h2>
<p> The <a href="reference/visit_each.html"><code>visit_each</code></a>
      function template is a mechanism for discovering objects that
      are stored within another object. Function template
      <code>visit_each</code> takes three arguments: an object to
      explore, a visitor function object that is invoked with each
      subobject, and the <code>int</code> 0. </p>

<p> The third parameter is merely a temporary solution to the
      widespread lack of proper function template partial
      ordering. The primary <code>visit_each</code> function template
      specifies this third parameter type to be <code>long</code>,
      whereas any user specializations must specify their third
      parameter to be of type <code>int</code>. Thus, even though a
      broken compiler cannot tell the ordering between, e.g., a
      match against a parameter <code>T</code> and a parameter
      <code>A&lt;T&gt;</code>, it can determine that the conversion
      from the integer 0 to <code>int</code> is better than the
      conversion to <code>long</code>. The ordering determined by this
      conversion thus achieves partial ordering of the function
      templates in a limited, but successful, way. The following
      example illustrates the use of this technique:</p>
<pre>
template&lt;typename&gt; class A {};
template&lt;typename T&gt; void foo(T, long);
template&lt;typename T&gt; void foo(A&lt;T&gt;, int);
A&lt;T&gt; at;
foo(at, 0);
</pre>

    <p> In this example, we assume that our compiler can not tell that
      <code>A&lt;T&gt;</code> is a better match than <code>T</code>,
      and therefore assume that the function templates cannot be
      ordered based on that parameter. Then the conversion from 0 to
      <code>int</code> is better than the conversion from 0 to
      <code>long</code>, and the second function template is chosen. </p>
    <hr>
    <address><a href="http://www.cs.rpi.edu/~gregod">Doug Gregor</a></address>
<!-- Created: Fri Jul 13 10:57:20 EDT 2001 -->
<!-- hhmts start -->
Last modified: Fri Oct 11 05:40:53 EDT 2002
<!-- hhmts end -->
  </body>
</html>