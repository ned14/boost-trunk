<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Boost Char Separator</title>
<!--
  -- Copyright © John Bandela and Jeremy Siek 2001-2002
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Jeremy Siek makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000EE"
vlink="#551A8B" alink="#FF0000">

<p><img src="../../c++boost.gif" alt="C++ Boost" width="277"
height="86"> <br>
</p>

<h1>
char_separator&lt;Char, Traits&gt;
</h1>

<p>
The char_separator class breaks a sequence of characters into tokens
based on the character delimiters. A delimiter character can either be
kept or dropped. A kept delimiter shows up as an output token, whereas
a dropped delimiter does not. If unspecified, punctuation characters
are used as the kept delimiters, and whitespace charactors are used as
the dropped delimiters.
</p>

<p>
The <tt>char_separator</tt> class is used in conjunction with the <a
href="token_iterator.htm"><tt>token_iterator</tt></a> or <a
href="tokenizer.htm"><tt>tokenizer</tt></a> to perform tokenizing.
</p>

<h2>Examples</h2>

<p>
This first examples shows how to use <tt>char_separator</tt> as a
replacement for the <tt>strtok()</tt> function. We've specified three
character delimiters, and they will not show up as output tokens.
</p>

<blockquote>
<pre>// char_sep_example_1.cpp
#include &lt;iostream&gt;
#include &lt;boost/tokenizer.hpp&gt;
#include &lt;string&gt;

int main()
{
  std::string str = &quot;;;Hello|world||-foo--bar;yow;baz|&quot;;
  typedef boost::tokenizer&lt;boost::char_separator&lt;char&gt; &gt; 
    tokenizer;
  boost::char_separator&lt;char&gt; sep(&quot;-;|&quot;);
  tokenizer tokens(str, sep);
  for (tokenizer::iterator tok_iter = tokens.begin();
       tok_iter != tokens.end(); ++tok_iter)
    std::cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; *tok_iter &lt;&lt; &quot;&gt; &quot;;
  std::cout &lt;&lt; &quot;\n&quot;;
  return EXIT_SUCCESS;
}
</pre>
</blockquote>
The output is:
<blockquote>
<pre>
&lt;Hello&gt; &lt;world&gt; &lt;foo&gt; &lt;bar&gt; &lt;yow&gt; &lt;baz&gt; 
</pre>
</blockquote>


<p>
The next example shows tokenizing with two dropped delimiters '-' and
';' and a single kept delimiter '|'. We also specify that we want to
have empty tokens show up in the output when two delimiters are next
to each other.
</p>

<blockquote>
<pre>// char_sep_example_2.cpp
#include &lt;iostream&gt;
#include &lt;boost/tokenizer.hpp&gt;
#include &lt;string&gt;

int main()
{
    std::string str = &quot;;;Hello|world||-foo--bar;yow;baz|&quot;;
    typedef boost::tokenizer&lt;boost::char_separator&lt;char&gt; &gt; 
        tokenizer;
    boost::char_separator&lt;char&gt; sep(&quot;-;&quot;,&quot;|&quot;, boost::keep_empty_tokens);
    tokenizer tokens(str, sep);
    for (tokenizer::iterator tok_iter = tokens.begin();
         tok_iter != tokens.end(); ++tok_iter)
      std::cout &lt;&lt; &quot;&lt;&quot; &lt;&lt; *tok_iter &lt;&lt; &quot;&gt; &quot;;
    std::cout &lt;&lt; &quot;\n&quot;;
    return EXIT_SUCCESS;
}
</pre>
</blockquote>
The output is:
<blockquote>
<pre>
&lt;&gt; &lt;&gt; &lt;Hello&gt; &lt;|&gt; &lt;world&gt; &lt;|&gt; &lt;&gt; &lt;|&gt; &lt;&gt; &lt;foo&gt; &lt;&gt; &lt;bar&gt; &lt;yow&gt; &lt;baz&gt; &lt;|&gt; &lt;&gt;
</pre>
</blockquote>


<h2>Template parameters</h2>

<P>
<table border>
<TR>
<th>Parameter</th><th>Description</th><th>Default</th>
</tr>

<TR><TD><TT>Char</TT></TD>
<TD>The type of elements within a token, typically <tt>char</tt>.</TD>
<TD>&nbsp;</TD>
</TR>

<TR><TD><TT>Traits</TT></TD>
<TD>The <tt>char_traits</tt> for the character type.</TD>
<TD><tt>char_traits&lt;char&gt;</tt></TD>
</TR>

</table>

<h2>Model of</h2>

<a href="tokenizerfunction.htm">Tokenizer Function</a>


<h2>Members</h2>

<hr>
<pre>
explicit char_separator(const Char* dropped_delims = 0,
                        const Char* kept_delims = 0,
                        empty_token_policy empty_tokens = drop_empty_tokens)
</pre>

<p>
This creates a <tt>char_separator</tt> object, which can then be used
to create a <a href="token_iterator.htm"><tt>token_iterator</tt></a>
or <a href="tokenizer.htm"><tt>tokenizer</tt></a> to perform
tokenizing. The <tt>dropped_delims</tt> and <tt>kept_delims</tt> are
strings of characters where each character is used as delimiter during
tokenizing. Whenever a delimiter is seen in the input sequence, the
current token is finished, and a new token begins.

The delimiters in <tt>dropped_delims</tt> do not show up as tokens in
the output whereas the delimiters in <tt>kept_delims</tt> do show up
as tokens.  If <tt>dropped_delims == 0</tt> then the function
<tt>std::isspace()</tt> is used to identify dropped delimiters.  If
<tt>kept_delims == 0</tt> then the function <tt>std::ispunct()</tt> is
used to identify kept delimiters. If <tt>empty_tokens</tt> is
<tt>drop_empty_tokens</tt>, then empty tokens (when two delimiters
appear next to each other) will not show up in the output. If
<tt>empty_tokens</tt> is <tt>keep_empty_tokens</tt> then empty tokens
will show up in the output.
</p>

<hr>

<pre>
template &lt;typename InputIterator, typename Token&gt;
bool operator()(InputIterator&amp; next, InputIterator end, Token&amp; tok)
</pre>

<p>
This function is called by the <a
href="token_iterator.htm"><tt>token_iterator</tt></a> to perform
tokenizing. The user typically does not call this function directly.
</p>


<hr>

<p>© Copyright Jeremy Siek and John R. Bandela 2001-2002. Permission
to copy, use, modify, sell and distribute this document is granted
provided this copyright notice appears in all copies. This document is
provided &quot;as is&quot; without express or implied warranty, and
with no claim as to its suitability for any purpose.</p>
</body>
</html>
