<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Boost Tokenizer Policy</title>
<!--
  -- Copyright (c) Jeremy Siek 2000
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Jeremy Siek makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000EE"
vlink="#551A8B" alink="#FF0000">

<p><img src="../../c++boost.gif" alt="C++ Boost" width="277"
height="86"> <br>
</p>

<h1><a name="tokenizer-class"></a> </h1>

<pre>
tokenizer_policy&lt;Type, <a href="TokenizerFunction.htm">TkFunc</a>&gt;
detail::tokenizer_base&lt;Iterator&gt;</pre>

<p>&nbsp;</p>

<p>The <tt>tokenizer_policy</tt> class provides a policy class
for <tt>iterator_adapter</tt> that allows it to parse an input
range (typically a range of characters) into a sequece of <tt>Type</tt>
objects (typically string) . The base type for the adapted
iterator is tokenizer_base&lt;Iterator&gt; where Iterator is the
iterator type of the input range. The bulk of the tokenizing work
is not done in this class, but is left up to the <tt>TkFunc</tt>.
The <a href="punct_space_separator.htm"><tt>punct_space_separator</tt></a>
function object breaks up a sequence of characters based on
punctuation and white space</p>

<h3>Example</h3>
<div dir="ltr">

<pre>using namespace std;
using namespace boost;
const string test_string = &quot;This,,is, a.test..&quot;;


// Use the bare iterator adaptor version
punct_space_separator&lt;char&gt; tkfun;
copy(make_token_iterator&lt;string&gt;(test_string.begin(),test_string.end(),tkfun)
	,make_token_iterator&lt;string&gt;(test_string.end(),test_string.end(),tkfun),
	ostream_iterator&lt;string&gt;(cout,&quot;|&quot;));
cout &lt;&lt; &quot;\n&quot;;
</pre>
</div><div dir="ltr">

<pre>The output is </pre>
</div>

<pre>This|is|a|test|
</pre>

<h3>Template Parameters</h3>

<table border="1">
    <tr>
        <th>Parameter</th>
        <th>Description</th>
    </tr>
    <tr>
        <td><tt>Iterator</tt></td>
        <td>The iterator type for the input range. </td>
    </tr>
    <tr>
        <td><tt>TkFunc</tt></td>
        <td>The function object that finds the next token. This
        type must be a model of <a href="TokenizerFunction.htm">TokenizerFunction</a>.</td>
    </tr>
    <tr>
        <td><tt>Token</tt></td>
        <td>The type of the token objects that are produced. The
        type must be DefaultConstructible and must have an <tt>assign()</tt>
        function that takes an iterator range.</td>
    </tr>
</table>

<h3>Model of</h3>

<p>The adapted iterator will be either an Input Iterator or a
Forward Iterator, depending on whether the Iterator type of the
input range is an Input Iterator or not.</p>

<h3>Where Defined</h3>

<p><a href="../boost/tokenizer.hpp"><tt>boost/tokenizer_policy.hpp</tt></a>
</p>

<p>&nbsp;</p>

<h3>Generator</h3>

<pre>template &lt;class Type, class Iterator, class TkFunc&gt;
class token_iterator_generator
</pre>

<h3>Creator Function</h3>

<pre>template&lt;class Type, class Iterator, class TkFunc &gt;
token_iterator_generator&lt;Type,Iterator,TkFunc&gt;::type 
make_token_iterator(Iterator begin, Iterator end,const TkFunc&amp; fun){

</pre>

<p>To use this function, you have to specify the Type of the
token object (typically string). For example</p>

<pre>token_iterator_generator&lt;std::string&gt;(...)</pre>

<p>&nbsp;</p>

<p>&nbsp;</p>

<hr>

<h3>See Also</h3>

<p><tt>tokenizer</tt></p>

<p><tt>token_iterator</tt></p>

<p><a href="token_separator.htm"><tt>token_separator</tt></a> </p>

<pre>iterator_adaptor</pre>
</body>
</html>
