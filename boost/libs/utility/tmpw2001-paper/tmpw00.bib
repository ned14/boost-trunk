


@InProceedings{TMPW00:Eisenecker,
        AUTHOR = "Ulrich W. Eisenecker and Frank Blinn and Krzysztof Czarnecki",
        TITLE = "A Solution to the Constructor-Problem of Mixin-Based Programming in {C++}",
        BOOKTITLE = "First Workshop on {C++} Template Programming,
          Erfurt, Germany",
        MONTH = "October 10",
        YEAR = "2000",
        URL = "http://oonumerics.org/tmpw00/",
        ABSTRACT = 
"Mixin-Based Programming in C++ is a powerful programming style
based on the parameterized inheritance idiom and the composition
of C++ templates. Type expressions describing specific inheritance
hierarchies can be composed either automatically using generative
programming idioms in C++ or manually. Unfortunately, the mixin-based
C++ programming techniques published to date do not adequately support
optional and alternative mixin classes with constructors expecting
varying numbers of arguments, which are common in practice. This
is because the varying base class constructors do not provide a
uniform interface on which the constructors of the derived classes
could rely. This paper discusses several partial solutions to this
problem that were proposed to date and presents a new, complete
solution. The new solution uses generative programming techniques to
automatically generate the appropriate constructors, and this way it
avoids the overhead and clumsiness of instantiating composed mixin
classes in the client code using the partial solutions. In fact,
the new solution allows users to instantiate automatically composed
mixin classes with the simplicity of instantiating concrete classes
from traditional class hierarchies. Finally, the new solution does
not suffer from the scalability problems of the partial solutions."
}


@InProceedings{TMPW00:Berti,
        AUTHOR = "Guntram Berti",
        TITLE = "Generic Components for Grid Data Structures and Algorithms with {C++}",
        BOOKTITLE = "First Workshop on {C++} Template Programming,
          Erfurt, Germany",
        MONTH = "October 10",
        YEAR = "2000",
        URL = "http://oonumerics.org/tmpw00/",
        ABSTRACT = 
"Grids are fundamental data structures for representing
 geometric structures or their subdivisions.  We propose a strategy
 for decoupling algorithms working on grids from the details of
 grid representations, using a generic programming approach in C++.
 Functionality of grid data structures is captured by a small set of
 primitives, divided into combinatorial and geometric ones.  Special
 attention is paid to the generic implementation of grid functions, which
 correspond to the notion of mappings from grid elements (e. g. vertices)
 to entities of a given type.  Experiments indicate that the overhead
 of the generic formulation is low and can be completely eliminated in
 some cases."
}


@InProceedings{TMPW00:Veldhuizen,
        AUTHOR = "Todd L. Veldhuizen",
        TITLE = "Five compilation models for {C++} templates",
        BOOKTITLE = "First Workshop on {C++} Template Programming,
          Erfurt, Germany",
        MONTH = "October 10",
        YEAR = "2000",
        URL = "http://oonumerics.org/tmpw00/",
        ABSTRACT = 
"This paper proposes an alternate structure for C++ compilers.
Type analysis is removed from the compiler and replaced with a
`type system library' which is treated as source code by the
compiler.  Type computations are embedded in the intermediate
language of the compiler, and partial evaluation is used to drive
type analysis and template instantiation.  By making simple changes to
the behavior of the partial evaluator, a wide range of compilation
models is achieved, each with a distinct tradeoff of compile time, code
size, and code speed.  These models range from pure dynamic typing --
ideal for scripting C++ -- to profile-directed template instantiation.
This approach may solve several serious problems in compiling C++:
it achieves separate compilation of templates, allows template
code to be distributed in binary form by deferring template instantiation
until run time, and reduces the code bloat associated with
templates."
}


@InProceedings{TMPW00:Baus,
        AUTHOR = "Christopher Baus and Thomas Becker",
        TITLE = "Custom Iterators for the {STL}",
        BOOKTITLE = "First Workshop on {C++} Template Programming,
          Erfurt, Germany",
        MONTH = "October 10",
        YEAR = "2000",
        URL = "http://oonumerics.org/tmpw00/",
        ABSTRACT = 
"We discuss several kinds of custom iterators for use with the STL
that are substantially different from the iterators that come with
the STL. We present class templates that implement these custom
iterators in a generic manner."
}


@InProceedings{TMPW00:Weiser,
        AUTHOR = "Martin Weiser and Gary Powell",
        TITLE = "The {View Template Library}",
        BOOKTITLE = "First Workshop on {C++} Template Programming,
          Erfurt, Germany",
        MONTH = "October 10",
        YEAR = "2000",
        URL = "http://oonumerics.org/tmpw00/",
        ABSTRACT = 
"Views are container adaptors providing access to different
on the fly generated representations of the data in the container they
are applied to. The concept fits nicely into the framework defined by
the STL.  This paper explains design, usage, and implementation of the
View Template Library, the currently most advanced implementation of
the views concept."
}


@InProceedings{TMPW00:Striegnitz,
        AUTHOR = "J{\"o}rg Striegnitz and Stephen A. Smith",
        TITLE = "An Expression Template aware Lambda Function",
        BOOKTITLE = "First Workshop on {C++} Template Programming,
          Erfurt, Germany",
        MONTH = "October 10",
        YEAR = "2000",
        URL = "http://oonumerics.org/tmpw00/",
        ABSTRACT = 
"Template libraries such as the STL contain several generic algorithms
that expect functions as arguments and thereby cause frequent use of
function objects. User-defined function objects are awkward because
they must be declared as a class in namespace scope before they may
be used. In this paper, we describe a lambda function for C++, which
allows users to define function objects on the fly, without writing class
declarations. We show that, by using expression templates, the lambda
function can be implemented without hurting the runtime performance of a
program. Expression templates can also help to overcome the performance
penalties that may arise when using expressions over user-defined
types. Thus, we based our approach on PETE which is a framework
that simplifies the addition of expression template functionality to
user-defined classes."
}




@InProceedings{TMPW00:McNamara,
        AUTHOR = "Brian McNamara and Yannis Smaragdakis",
        TITLE = "Static Interfaces in {C++}",
        BOOKTITLE = "First Workshop on {C++} Template Programming,
          Erfurt, Germany",
        MONTH = "October 10",
        YEAR = "2000",
        URL = "http://oonumerics.org/tmpw00/",
        ABSTRACT = 
"We present an extensible framework for defining and
using ``static interfaces'' in C++. Static interfaces are especially
useful as constraints on template parameters. That is, in addition to the
usual template $class T$, template definitions can specify that T ``isa''
Foo, for some static interface named Foo. These ``isa-constraints'' can be
based on either inheritance (named conformance: T publicly inherits Foo),
members (structural conformance: T has these member functions with these
signatures), or both. The constraint mechanism imposes no space or time
overheads at runtime; virtual functions are conspicuously absent from
our framework.

We demonstrate two key utilities of static interfaces. First,
constraints enable better error messages with template code. By applying
static interfaces as constraints, instantiating a template with the
wrong type is an error that can be caught at the instantiation point,
rather than later (typically in the bowels of the implementation).
Authors of template classes and template functions can also dispatch
``custom error messages'' to report named constraint violations by
clients, making debugging easier. We show examples of the improvement of
error messages when constraints are applied to STL code. 

Second, constraints enable automatic compile-time dispatch of different
implementations of class or function templates based on the named
conformance properties of the template types. For example, $Set<T>$ can be
written to automatically choose the most efficient implementation: use a
hashtable implementation if ``T isa Hashable'', or else a binary search
tree if ``T isa LessThanComparable'' , or else a linked-list if merely ``T
isa EqualityComparable''. This dispatch can be completely hidden from
clients of Set, who just use $Set<T>$ as usual."
}


@InProceedings{TMPW00:Siek,
        AUTHOR = "Jeremy Siek and Andrew Lumsdaine",
        TITLE = "Concept Checking: Binding Parametric Polymorphism in {C++}",
        BOOKTITLE = "First Workshop on {C++} Template Programming,
          Erfurt, Germany",
        MONTH = "October 10",
        YEAR = "2000",
        URL = "http://oonumerics.org/tmpw00/",
        ABSTRACT = 
"Generic programming in C++ is characterized by the use of template
  parameters to represent abstract data types (or ``concepts'').
  However, the C++ language itself does not provide a mechanism for
  explicitly handling concepts.  As a result, it can be difficult to
  insure that a concrete type meets the requirements of the concept it
  is supposed to represent.  Error messages resulting from incorrect
  use of a concrete type can be particularly difficult to decipher.
  In this paper we present techniques to check parameters in generic
  C++ libraries.  Our techniques use standard C++ and introduce no
  run-time overhead."
}


@InProceedings{TMPW00:Kuehl,
        AUTHOR = "Dietmar K{\"u}hl",
        TITLE = "{STL} and {OO} Don't Easily Mix",
        BOOKTITLE = "First Workshop on {C++} Template Programming,
          Erfurt, Germany",
        MONTH = "October 10",
        YEAR = "2000",
        URL = "http://oonumerics.org/tmpw00/",
        ABSTRACT = 
"The STL is a powerful tool for many kinds of processing. Unfortunately,
using polymorphic objects with the STL seems not to work: Polymorphic
objects stored in STL containers either get sliced (i.e. only the base
part is copied or assigned but not the derived part) or, when storing
pointers to them instead, are not destroyed.  Applying algorithms to
such containers often results in the wrong thing or complex predicate
objects are needed.  This article shows how to overcome at least some
of these problems using some adaptors and also outlines a possible
implementation of STL for better integration with polymorphic objects.
The improved integration just acknowledges the distinction between the
object and the entity used to maintain it."
}


@InProceedings{TMPW00:Eichelberger,
        AUTHOR = "H. Eichelberger and J. Wolff v. Gudenberg",
        TITLE = "{UML} Description of the {STL}",
        BOOKTITLE = "First Workshop on {C++} Template Programming,
          Erfurt, Germany",
        MONTH = "October 10",
        YEAR = "2000",
        URL = "http://oonumerics.org/tmpw00/eichelberger.pdf",
        ABSTRACT = 
"In this paper we show how  the specification of the
Standard Template Library STL and its implementation can be described
by UML diagrams. We define appropriate stereotypes to
describe STL concepts like containers, iterators, function
objects and global algorithms. For the graphical description of the
implementation of the STL we extend the UML metamodel."
}

