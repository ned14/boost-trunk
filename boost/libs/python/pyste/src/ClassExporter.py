import exporters
from Exporter import Exporter
from declarations import *
from enumerate import enumerate
from settings import *
from CodeUnit import CodeUnit
from EnumExporter import EnumExporter


#==============================================================================
# ClassExporter
#==============================================================================
class ClassExporter(Exporter):
    'Generates boost.python code to export a class declaration'
    

    def __init__(self, info, parser_tail=None):
        Exporter.__init__(self, info, parser_tail)
        # sections of code
        self.sections = {}
        # template: each item in the list is an item into the class_<...> 
        # section.
        self.sections['template'] = []  
        # constructor: each item in the list is a parameter to the class_ 
        # constructor, like class_<C>(...)
        self.sections['constructor'] = []
        # inside: everything within the class_<> statement        
        self.sections['inside'] = []        
        # scope: items outside the class statement but within its scope.
        # scope* s = new scope(class<>());
        # ...
        # delete s;
        self.sections['scope'] = []
        # declarations: outside the BOOST_PYTHON_MODULE macro
        self.sections['declaration'] = []
        self.sections['include'] = []
        # a list of Method instances
        self.methods = []
        # a list of Constructor instances
        self.constructors = []
        # a dict of methodname => _WrapperVirtualMethod instances
        self.virtual_wrappers = {}
        # a list of code units, generated by nested declarations
        self.nested_codeunits = []


    def ScopeName(self):
        return _ID(self.class_.FullName()) + '_scope'


    def Name(self):
        return self.class_.FullName()


    def SetDeclarations(self, declarations):
        Exporter.SetDeclarations(self, declarations)
        decl = self.GetDeclaration(self.info.name)
        if isinstance(decl, Typedef):
            self.class_ = decl.type
            if not self.info.rename:
                self.info.rename = decl.name
        else:
            self.class_ = decl
        self.public_members = \
            [x for x in self.class_.members if x.visibility == Scope.public]
        
        
    def Order(self):
        '''Return the TOTAL number of bases that this class has, including the
        bases' bases.  Do this because base classes must be instantialized
        before the derived classes in the module definition.  
        '''
        
        def BasesCount(classname):
            decl = self.GetDeclaration(classname)
            bases = [x.name for x in decl.bases]
            total = 0
            for base in bases:
                total += BasesCount(base)
            return len(bases) + total

        return BasesCount(self.class_.FullName())
                
    
    def Export(self, codeunit, exported_names):
        self.GetMethods()
        self.ExportBasics()
        self.ExportBases(exported_names)
        self.ExportConstructors()
        self.ExportVariables()
        self.ExportMethods()
        self.GenerateVirtualWrapper()
        self.ExportOperators()
        self.ExportNestedClasses(exported_names)
        self.ExportNestedEnums()
        self.Write(codeunit)


    def Write(self, codeunit):
        indent = self.INDENT
        boost_ns = namespaces.python
        pyste_ns = namespaces.pyste
        code = ''
        # begin a scope for this class if needed
        nested_codeunits = self.nested_codeunits
        needs_scope = self.sections['scope'] or nested_codeunits
        if needs_scope:
            scope_name = self.ScopeName()
            code += indent + boost_ns + 'scope* %s = new %sscope(\n' %\
                (scope_name, boost_ns)
        # export the template section
        template_params = ', '.join(self.sections['template'])
        code += indent + boost_ns + 'class_< %s >' % template_params
        # export the constructor section
        constructor_params = ', '.join(self.sections['constructor'])
        code += '(%s)\n' % constructor_params
        # export the inside section
        in_indent = indent*2
        for line in self.sections['inside']:
            code += in_indent + line + '\n' 
        # write the scope section and end it
        if not needs_scope:
            code += indent + ';\n'
        else:
            code += indent + ');\n'
            for line in self.sections['scope']:
                code += indent + line + '\n'
            # write the contents of the nested classes
            for nested_unit in nested_codeunits:
                code += '\n' + nested_unit.Section('module')
            # close the scope
            code += indent + 'delete %s;\n' % scope_name
            
        # write the code to the module section in the codeunit        
        codeunit.Write('module', code + '\n')
        
        # write the declarations to the codeunit        
        declarations = '\n'.join(self.sections['declaration'])
        for nested_unit in nested_codeunits:
            declarations += nested_unit.Section('declaration')
        if declarations:
            codeunit.Write('declaration', declarations + '\n')

        # write the includes to the codeunit
        includes = '\n'.join(self.sections['include'])
        for nested_unit in nested_codeunits:
            includes += nested_unit.Section('include')
        if includes:
            codeunit.Write('include', includes)


    def Add(self, section, item):
        'Add the item into the corresponding section'
        self.sections[section].append(item.strip())

        
    def ExportBasics(self):
        'Export the name of the class and its class_ statement'
        self.Add('template', self.class_.FullName())
        name = self.info.rename or self.class_.name
        self.Add('constructor', '"%s"' % name)
        
        
    def ExportBases(self, exported_names):
        'Expose the bases of the class into the template section'        
        bases = self.class_.bases
        bases_list = []
        for base in bases:
            if base.visibility == Scope.public and base.name in exported_names:
                bases_list.append(base.name)
        if bases_list:
            code = namespaces.python + 'bases< %s > ' % \
                (', '.join(bases_list))
            self.Add('template', code)        


    def ExportConstructors(self):
        '''Exports all the public contructors of the class, plus indicates if the 
        class is noncopyable.
        '''
        py_ns = namespaces.python
        indent = self.INDENT
        
        def init_code(cons):
            'return the init<>() code for the given contructor'
            param_list = [p.FullName() for p in cons.parameters]
            min_params_list = param_list[:cons.minArgs]
            max_params_list = param_list[cons.minArgs:]
            min_params = ', '.join(min_params_list)
            max_params = ', '.join(max_params_list)
            init = py_ns + 'init< '
            init += min_params
            if max_params:
                if min_params:
                    init += ', '
                init += py_ns + ('optional< %s >' % max_params)
            init += ' >()'    
            return init
        
        constructors = [x for x in self.public_members if isinstance(x, Constructor)]
        self.constructors = constructors[:]
        if not constructors:
            # declare no_init
            self.Add('constructor', py_ns + 'no_init') 
        else:
            # write one of the constructors to the class_ constructor        
            self.Add('constructor', init_code(constructors.pop(0)))
            # write the rest to the inside section, using def()
            for cons in constructors:
                code = '.def(%s)' % init_code(cons) 
                self.Add('inside', code)
        # check if the class is copyable
        if not self.class_.HasCopyConstructor() or self.class_.abstract:
            self.Add('template', namespaces.boost + 'noncopyable')
            
        
    def ExportVariables(self):
        'Export the variables of the class, both static and simple variables'
        vars = [x for x in self.public_members if isinstance(x, Variable)]
        for var in vars:
            if self.info[var.name].exclude: 
                continue
            name = self.info[var.name].rename or var.name
            fullname = var.FullName() 
            if var.static:
                code = '%s->attr("%s") = %s;' % (self.ScopeName(), name, fullname)
                self.Add('scope', code)            
            else:
                if var.type.const:
                    def_ = '.def_readonly'
                else:
                    def_ = '.def_readwrite'
                code = '%s("%s", &%s)' % (def_, name, fullname)
                self.Add('inside', code)


    def GetMethods(self):
        'fill self.methods with a list of Method instances'
        # get a list of all methods
        def IsValid(m):
            'Returns true if the given method is exportable by this routine'
            ignore = (Constructor, ClassOperator, Destructor)
            return isinstance(m, Method) and not isinstance(m, ignore)        
        
        self.methods = [x for x in self.public_members if IsValid(x)]

            

    printed_policy_warnings = {}
    
    def CheckPolicy(self, m):
        'Warns the user if this method needs a policy'            
        def IsString(type):
            return type.const and type.name == 'char' and isinstance(type, PointerType)
        needs_policy = isinstance(m.result, (ReferenceType, PointerType))
        if IsString(m.result):
            needs_policy = False
        has_policy = self.info[m.name].policy is not None
        if needs_policy and not has_policy:
            warning = '---> Error: Method "%s" needs a policy.' % m.FullName()
            if warning not in self.printed_policy_warnings:
                print warning
                print 
                self.printed_policy_warnings[warning] = 1
            
    
    def ExportMethods(self):
        'Export all the methods of the class'        
            
        def OverloadName(m):
            'Returns the name of the overloads struct for the given method'
            
            return _ID(m.FullName()) + ('_overloads_%i_%i' % (m.minArgs, m.maxArgs))
        
        declared = {}
        def DeclareOverloads(m):
            'Declares the macro for the generation of the overloads'
            if m.virtual:
                func = self.virtual_wrappers[m.PointerDeclaration()].DefaultName()
            else:
                func = m.name
            code = 'BOOST_PYTHON_MEMBER_FUNCTION_OVERLOADS(%s, %s, %i, %i)\n'
            code = code % (OverloadName(m), func, m.minArgs, m.maxArgs)
            if code not in declared:
                declared[code] = True
                self.Add('declaration', code)


        def Pointer(m):
            'returns the correct pointer declaration for the method m'
            # check if this method has a wrapper set for him
            wrapper = self.info[method.name].wrapper
            if wrapper:
                return '&' + wrapper.FullName()
            # if this method is virtual, return the pointers to the class and its wrapper
            if m.virtual:
                return self.virtual_wrappers[m.PointerDeclaration()].Pointer()
            # return normal pointers to the methods of the class
            is_unique = self.class_.IsUnique(m.name)
            if is_unique:
                return '&' + method.FullName()
            else:
                return method.PointerDeclaration() 

                
        for method in self.methods:
            if self.info[method.name].exclude:
                continue # skip this method

            name = self.info[method.name].rename or method.name
            # check if this method needs to be wrapped as a virtual method
            if method.virtual:
                wrapper = _WrapperVirtualMethod(self.class_, method, name)
                self.virtual_wrappers[method.PointerDeclaration()] = wrapper
            # abstract methods don't need to be exported
            if method.abstract:
                continue # skip .def declaration for abstract methods 
            # warn the user if this method needs a policy and doesn't have one
            self.CheckPolicy(method)            
            
            # check for policies
            policy = self.info[method.name].policy or ''
            if policy:
                policy = ', %s%s()' % (namespaces.python, policy.Code())
            # check for overloads
            overload = ''
            if method.minArgs != method.maxArgs:
                # add the overloads for this method
                overload_name = OverloadName(method)
                DeclareOverloads(method)
                if not method.virtual:
                    overload = ', %s%s()' % (namespaces.pyste, overload_name)
                else:
                    pyste_ns = namespaces.pyste
                    pointer = self.virtual_wrappers[method.PointerDeclaration()].DefaultPointer()
                    defcode = '.def("%s", %s, %s%s())' % \
                        (name, pointer, pyste_ns, overload_name)
                    self.Add('inside', defcode)
            # build the string to export the method
            pointer = Pointer(method)
            code = '.def("%s", %s' % (name, pointer)
            code += policy
            code += overload
            code += ')'
            self.Add('inside', code)
            # static method
            if method.static:
                code = '.staticmethod("%s")' % name
                self.Add('inside', code)
            # add wrapper code if this method has one
            wrapper = self.info[method.name].wrapper
            if wrapper and wrapper.code:
                self.Add('declaration', wrapper.code)


    def GenerateVirtualWrapper(self):
        'Generate the wrapper to dispatch virtual methods'        
        # check if this class needs a wrapper first
        for m in self.methods:
            if m.virtual:
                break
        else:
            return
        # add the wrapper name to the template section
        wrapper_name = _WrapperName(self.class_)
        self.Add('template', namespaces.pyste + wrapper_name)
        indent = self.INDENT
        method_codes = [x.Code(indent) for x in self.virtual_wrappers.values()]
        body = '\n'.join(method_codes)
        # generate the class code
        class_name = self.class_.FullName()
        code = 'struct %s: %s\n' % (wrapper_name, class_name)
        code += '{\n'
        # generate constructors
        for cons in self.constructors:
            params, param_names, param_types = _ParamsInfo(cons)
            if params:
                params = ', ' + params
            cons_code = indent + '%s(PyObject* self_%s):\n' % (wrapper_name, params)
            cons_code += indent*2 + '%s(%s), self(self_) {}\n\n' % \
                (class_name, ', '.join(param_names))
            code += cons_code
        code += body + '\n'
        code += indent + 'PyObject* self;\n'
        code += '};\n'
        self.Add('declaration', code) 


    # operators natively supported by boost
    BOOST_SUPPORTED_OPERATORS = '+ - * / % ^ & ! ~ | < > == != <= >= << >> && || += -='\
        '*= /= %= ^= &= |= <<= >>='.split()
    # create a map for faster lookup
    BOOST_SUPPORTED_OPERATORS = dict(zip(BOOST_SUPPORTED_OPERATORS, range(len(BOOST_SUPPORTED_OPERATORS))))

    # a dict of operators that are not directly supported by boost, but can be exposed
    # simply as a function with a special signature
    BOOST_RENAME_OPERATORS = {
        '()' : '__call__',
    }

    # converters which has a special name in python
    SPECIAL_CONVETERS = {
        'double' : '__float__',
        'float' : '__float__',
        'int' : '__int__',
    }
        
    
    def ExportOperators(self):
        'Export all member operators and free operators related to this class'
        
        def GetFreeOperators():
            'Get all the free (global) operators related to this class'
            operators = []
            for decl in self.declarations:
                if isinstance(decl, Operator):
                    # check if one of the params is this class
                    for param in decl.parameters:
                        if param.name == self.class_.FullName():
                            operators.append(decl)
                            break
            return operators

        def GetOperand(param):
            'Returns the operand of this parameter (either "self", or "other<type>")'
            if param.name == self.class_.FullName():
                return namespaces.python + 'self'
            else:
                return namespaces.python + ('other< %s >()' % param.name)


        def HandleSpecialOperator(operator):
            # gatter information about the operator and its parameters
            result_name = operator.result.name                        
            param1_name = ''
            if operator.parameters:
                param1_name = operator.parameters[0].name
                
            # check for str
            ostream = 'basic_ostream'
            is_str = result_name.find(ostream) != -1 and param1_name.find(ostream) != -1
            if is_str:
                namespace = namespaces.python + 'self_ns::'
                self_ = namespaces.python + 'self'
                return '.def(%sstr(%s))' % (namespace, self_)

            # is not a special operator
            return None
                

        
        frees = GetFreeOperators()
        members = [x for x in self.public_members if type(x) == ClassOperator]
        all_operators = frees + members
        operators = [x for x in all_operators if not self.info['operator'][x.name].exclude]
        
        for operator in operators:
            # gatter information about the operator, for use later
            wrapper = self.info['operator'][operator.name].wrapper
            if wrapper:
                pointer = '&' + wrapper.FullName()
                if wrapper.code:
                    self.Add('declaration', wrapper.code)
            elif isinstance(operator, ClassOperator) and self.class_.IsUnique(operator.name):
                pointer = '&' + operator.FullName()
            else:
                pointer = operator.PointerDeclaration()                 
            rename = self.info['operator'][operator.name].rename

            # check if this operator will be exported as a method
            export_as_method = wrapper or rename or operator.name in self.BOOST_RENAME_OPERATORS
            
            # check if this operator has a special representation in boost
            special_code = HandleSpecialOperator(operator)
            has_special_representation = special_code is not None
            
            if export_as_method:
                # export this operator as a normal method, renaming or using the given wrapper
                if not rename:
                    if wrapper:
                        rename = wrapper.name
                    else:
                        rename = self.BOOST_RENAME_OPERATORS[operator.name]
                policy = ''
                policy_obj = self.info['operator'][operator.name].policy
                if policy_obj:
                    policy = ', %s()' % policy_obj.Code() 
                self.Add('inside', '.def("%s", %s%s)' % (rename, pointer, policy))
            
            elif has_special_representation:
                self.Add('inside', special_code)
                
            elif operator.name in self.BOOST_SUPPORTED_OPERATORS:
                # export this operator using boost's facilities
                op = operator
                is_unary = isinstance(op, Operator) and len(op.parameters) == 1 or\
                           isinstance(op, ClassOperator) and len(op.parameters) == 0
                if is_unary:
                    self.Add('inside', '.def( %s%sself )' % \
                        (operator.name, namespaces.python))
                else:
                    # binary operator
                    if len(operator.parameters) == 2:
                        left_operand = GetOperand(operator.parameters[0])
                        right_operand = GetOperand(operator.parameters[1])
                    else:
                        left_operand = namespaces.python + 'self'
                        right_operand = GetOperand(operator.parameters[0])
                    self.Add('inside', '.def( %s %s %s )' % \
                        (left_operand, operator.name, right_operand))

        # export the converters.
        # export them as simple functions with a pre-determined name

        converters = [x for x in self.public_members if type(x) == ConverterOperator]
        
        def ConverterMethodName(converter):
            result_fullname = converter.result.name
            # extract the last name from the full name
            result_name = _ID(result_fullname.split('::')[-1])
            return 'to_' + result_name
            
        for converter in converters:
            info = self.info['operator'][converter.result.name]
            # check if this operator should be excluded
            if info.exclude:
                continue
            
            special_code = HandleSpecialOperator(converter)
            if info.rename or not special_code:
                # export as method
                name = info.rename or ConverterMethodName(converter)
                if self.class_.IsUnique(converter.name):
                    pointer = '&' + converter.FullName()
                else:
                    pointer = converter.PointerDeclaration()
                policy_code = ''
                if info.policy:
                    policy_code = ', %s()' % info.policy.Code()
                self.Add('inside', '.def("%s", %s%s)' % (name, pointer, policy_code))
                    
            elif special_code:
                self.Add('inside', special_code)



    def ExportNestedClasses(self, exported_names):
        nested_classes = [x for x in self.public_members if isinstance(x, NestedClass)]
        for nested_class in nested_classes:
            nested_info = self.info[nested_class.name]
            nested_info.include = self.info.include
            nested_info.name = nested_class.FullName()
            exporter = ClassExporter(nested_info)
            exporter.SetDeclarations(self.declarations + [nested_class])
            codeunit = CodeUnit(None)
            exporter.Export(codeunit, exported_names)
            self.nested_codeunits.append(codeunit)


    def ExportNestedEnums(self):
        nested_enums = [x for x in self.public_members if isinstance(x, ClassEnumeration)]
        for enum in nested_enums:
            enum_info = self.info[enum.name]
            enum_info.include = self.info.include
            enum_info.name = enum.FullName()
            exporter = EnumExporter(enum_info)
            exporter.SetDeclarations(self.declarations + [enum])
            codeunit = CodeUnit(None)
            exporter.Export(codeunit, None)
            self.nested_codeunits.append(codeunit)
            

            

def _ID(name):
    'Returns the name as a valid identifier'
    for invalidchar in ('::', '<', '>', ' ', ','):
        name = name.replace(invalidchar, '_') 
    # avoid duplications of '_' chars
    names = [x for x in name.split('_') if x]
    return '_'.join(names)


#==============================================================================
# Virtual Wrapper utils
#==============================================================================

def _WrapperName(class_):
    return _ID(class_.FullName()) + '_Wrapper'


def _ParamsInfo(m):
    param_names = ['p%i' % i for i in range(len(m.parameters))]
    param_types = [x.FullName() for x in m.parameters]
    params = ['%s %s' % (t, n) for t, n in zip(param_types, param_names)]
    for i, p in enumerate(m.parameters):
        if p.default is not None:
            #params[i] += '=%s' % p.default
            params[i] += '=%s' % (p.name + '()')
    params = ', '.join(params) 
    return params, param_names, param_types

            
class _WrapperVirtualMethod(object):
    'Holds information about a virtual method that will be wrapped'

    def __init__(self, class_, method, rename):
        self.method = method
        if rename is None:
            rename = method.name
        self.rename = rename 
        self.class_ = class_


    def DefaultName(self):
        return 'default_' + self.method.name


    def DefaultPointer(self):
        ns = namespaces.pyste
        wrapper_name = _WrapperName(self.class_)
        default_name = self.DefaultName()
        fullname = '%s%s::%s' % (ns, wrapper_name, default_name)
        if self.class_.IsUnique(self.method.name):
            return '&%s' % fullname
        else:
            # the method is not unique, so we must specify the entire signature with it
            param_list = [x.FullName() for x in self.method.parameters]
            params = ', '.join(param_list)            
            result = self.method.result.FullName()
            signature = '%s (%s%s::*)(%s)' % (result, ns, wrapper_name, params) 
            return '(%s)%s' % (signature, fullname)
            

    def Pointer(self):
        '''Returns the "pointer" declaration for this method, ie, the contents
        of the .def after the method name (.def("name", <pointer>))'''
        ns = namespaces.pyste
        default_name = self.DefaultName()
        name = self.method.name
        class_name = self.class_.FullName()
        wrapper = ns + _WrapperName(self.class_)
        if self.class_.IsUnique(self.method.name):
            return '&%s::%s, &%s::%s' % (class_name, name, wrapper, default_name)
        else:
            # the method is not unique, so we must specify the entire signature with it
            param_list = [x.FullName() for x in self.method.parameters]
            params = ', '.join(param_list)            
            result = self.method.result.FullName()
            default_sig = '%s (%s::*)(%s)' % (result, wrapper, params)
            normal_sig = '%s (%s::*)(%s)' % (result, class_name, params)
            return '(%s)%s::%s, (%s)%s::%s' % \
                (normal_sig, class_name, name, default_sig, wrapper, default_name)


    def Code(self, indent):
        params, param_names, param_types = _ParamsInfo(self.method)
        result = self.method.result.FullName()
        return_ = 'return '
        if result == 'void':
            return_ = ''
        param_names = ', '.join(param_names)
        class_name = self.class_.FullName()
        method_name = self.method.name
        default_name = self.DefaultName()
        # constantness
        const = ''
        if self.method.const:
            const = 'const '
        code = ''
        # create default_method if this method has a default implementation
        if not self.method.abstract:
            default_sig = '%s %s(%s) %s' % (result, default_name, params, const)
            body = '{ %s%s::%s(%s); } ' % \
                (return_, class_name, method_name, param_names)
            code += indent + default_sig + body + '\n' 
        # create normal method        
        normal_sig = '%s %s(%s) %s' % (result, method_name, params, const)
        if param_names:
            param_names = ', ' + param_names  
        body = '{ %s%scall_method< %s >(self, "%s"%s); }' % \
            (return_, namespaces.python, result, self.rename, param_names)
        code += indent + normal_sig + body + '\n'
        
        return code
                
        
    
