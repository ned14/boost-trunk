#
# To run all tests quietly: jam test
# To run all tests with verbose output: jam -sPYTHON_TEST_ARGS=-v test
#
subproject libs/python/test ;

# bring in the rules for python
SEARCH on python.jam = $(BOOST_BUILD_PATH) ;
include python.jam ;
# bring in rules for testing
SEARCH on testing.jam = $(BOOST_BUILD_PATH) ;
include testing.jam ;

# Convenience rule makes declaring tests faster
rule bpl-test ( name ? : files * : requirements * )
{
    files ?= $(name).py $(name).cpp ;

    local modules ;
    local py ;
    for local f in $(files)
    {
        if $(f:S) = .py
        {
            if $(py)
            {
                EXIT too many python drivers specified: "$(py)" "$(f)" ;
            }
            py = $(f) ;
        }
    }

    name ?= $(py:S=) ;

    for local f in $(files)
    {
        if $(f:S) != .py
        {
            local m = $(f:S=) ;

            if $(m) = $(py:S=)
            {
                m = $(name) ;

                if $(m) = $(py:S=)
                {
                    m = $(m)_ext ;
                }
            }
            extension $(m) : $(f) <dll>../build/boost_python : $(requirements) ;
            modules += $(m) ;
        }
    }

    boost-python-runtest $(name) : $(py) <pyd>$(modules) ;
}

bpl-test minimal ;
bpl-test args ;
bpl-test numpy ;
bpl-test enum ;
bpl-test docstring ;
bpl-test exception_translator ;
bpl-test pearu1 : test_cltree.py cltree.cpp ;
bpl-test try : newtest.py m1.cpp m2.cpp ;
bpl-test builtin_converters : test_builtin_converters.py test_builtin_converters.cpp ;
bpl-test test_pointer_adoption ;
bpl-test operators ;
bpl-test callbacks ;
bpl-test defaults ;

bpl-test object ;
bpl-test list ;
bpl-test long ;
bpl-test dict ;
bpl-test tuple ;
bpl-test str ;

bpl-test virtual_functions ;
bpl-test back_reference ;
bpl-test implicit ;
bpl-test data_members ;

bpl-test bienstman1 ;
bpl-test bienstman2 ;
bpl-test bienstman3 ;

# A bug in the Win32 intel compilers causes compilation of one of our
# tests to take forever when debug symbols are enabled. This rule
# turns them off when added to the requirements section
rule turn-off-intel-debug-symbols ( toolset variant : properties * )
{
    if $(NT) && [ MATCH (.*intel.*) : $(toolset) ]
    {
        properties = [ difference $(properties) : <debug-symbols>on ] <debug-symbols>off ;
    }
    return $(properties) ;
}
  
bpl-test multi_arg_constructor
  : # files
  : # requirements
  turn-off-intel-debug-symbols ; # debug symbols slow the build down too much

bpl-test iterator : iterator.py iterator.cpp input_iterator.cpp ;

bpl-test extract ;

bpl-test pickle1 ;
bpl-test pickle2 ;
bpl-test pickle3 ;

bpl-test nested ;

if $(TEST_BIENSTMAN_NON_BUGS)
{
    bpl-test bienstman4 ;
    bpl-test bienstman5 ;
}

# --- unit tests of library components ---

local UNIT_TEST_PROPERTIES = $(PYTHON_PROPERTIES) <define>BOOST_PYTHON_SUPPRESS_REGISTRY_INITIALIZATION
  [ difference $(PYTHON_PROPERTIES) : <define>BOOST_PYTHON_DYNAMIC_LIB ] <define>BOOST_PYTHON_STATIC_LIB ;

run indirect_traits_test.cpp ;
run destroy_test.cpp ;
run pointer_type_id_test.cpp  <lib>../../test/build/test_exec_monitor : : : $(UNIT_TEST_PROPERTIES) ;
run member_function_cast.cpp ;
run bases.cpp ;
run if_else.cpp ;
run pointee.cpp ;
run result.cpp ;

compile string_literal.cpp ;
compile borrowed.cpp : $(UNIT_TEST_PROPERTIES) ;
compile object_manager.cpp : $(UNIT_TEST_PROPERTIES) ;

run upcast.cpp  <lib>../../test/build/test_exec_monitor
  : # command-line args
  : # input files
  : $(UNIT_TEST_PROPERTIES)
    ;

run select_holder.cpp  <lib>../../test/build/test_exec_monitor
  : # command-line args
  : # input files
  : $(UNIT_TEST_PROPERTIES)
    ;


run select_from_python_test.cpp ../src/converter/type_id.cpp  <lib>../../test/build/test_exec_monitor
  : # command-line args
  : # input files
  : $(UNIT_TEST_PROPERTIES)
    ;

run select_arg_to_python_test.cpp ../src/converter/type_id.cpp  <lib>../../test/build/test_exec_monitor
  : # command-line args
  : # input files
  : $(UNIT_TEST_PROPERTIES)
    ;

if $(TEST_EXPECTED_FAILURES)
{
    compile-fail ./raw_pyobject_fail1.cpp : $(PYTHON_PROPERTIES) ;
    compile-fail ./raw_pyobject_fail2.cpp : $(PYTHON_PROPERTIES) ;
    compile-fail ./object_fail1.cpp : $(PYTHON_PROPERTIES) ;
}


