<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE library PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
     "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<library
    id="xpressive"
    name="Boost.Xpressive"
    dirname="xpressive"
    last-revision="$Date$" 
    xmlns:xi="http://www.w3.org/2001/XInclude">
  <libraryinfo>
    <author>
      <firstname>Eric</firstname>
      <surname>Niebler</surname>
    </author>

    <copyright>
      <year>2003</year>
      <year>2004</year>
      <holder>Eric Niebler</holder>
    </copyright>

    <legalnotice>
      <para>
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        <ulink url="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)
    
      </para>
    </legalnotice>

    <librarypurpose>
      Regular expressions that can be expressed as strings or as expression templates,
        and that can refer to other regular expressions by value or by reference.
        </librarypurpose>

    <librarycategory name="category:string-text"></librarycategory>

  </libraryinfo>

  <title>Boost.Xpressive</title>



<section id="boost_xpressive.preface">
<title>Preface</title>
<blockquote><para><emphasis>Wife:</emphasis>      It's a floor wax!<sbr/>

  <emphasis>Husband:</emphasis>   No, it's a dessert topping!<sbr/>

  <emphasis>Announcer:</emphasis> Stop! You're both right. It's a floor wax <emphasis>and</emphasis> a dessert topping!</para></blockquote><blockquote><para><emphasis role="bold"><emphasis>-- Saturday Night Live</emphasis></emphasis></para></blockquote><anchor id="preface.description" /><bridgehead renderas="sect2">Description</bridgehead><para>
xpressive is an advanced, object-oriented regular expression template library for C++.
Regular expressions can be written as strings that are parsed at run-time, or as expression
templates that are parsed at compile-time. Regular expressions can refer to each other and
to themselves recursively, allowing you to build arbitrarily complicated grammars out of
them.</para>
<anchor id="preface.motivation" /><bridgehead renderas="sect2">Motivation</bridgehead><para>
If you need to manipulate text in C++, you have typically had two disjoint options: a regular
expression engine or a parser generator. Regular expression engines (like <ulink url="../../libs/regex">Boost.Regex</ulink>) are powerful
and flexible; patterns are represented as strings which can be specified at runtime. However,
that means that syntax errors are likewise not detected until runtime. Also, regular expressions
are ill-suited to advanced text processing tasks such as matching balanced, nested tags. Those
tasks have traditionally been handled by parser generators (like the <ulink url="http://spirit.sourceforge.net">Spirit Parser Framework</ulink>). These
beasts are more powerful but less flexible. They generally don't allow you to arbitrarily modify
your grammar rules on the fly. In addition, they don't have the exhaustive backtracking semantics
of regular expressions, which can make it more challenging to author some types of patterns.</para>
<para>
xpressive brings these two approaches seamlessly together and occupies a unique niche in the
world of C++ text processing. With xpressive, you can choose to use it much as you would use
<ulink url="../../libs/regex">Boost.Regex</ulink>, representing regular expressions as strings. Or you can use it as you would use <ulink url="http://spirit.sourceforge.net">Spirit</ulink>,
writing your regexes as C++ expressions, enjoying all the benefits of an embedded language
dedicated to text manipulation. What's more, you can mix the two to get the benefits of
both, writing regular expression <emphasis>grammars</emphasis> in which some of the regular expressions are 
statically bound -- hard-coded and syntax<emphasis role="strikethrough">checked by the compiler -</emphasis> and others are dynamically
bound and specified at runtime. These regular expressions can refer to each other recursively,
matching patterns in strings that ordinary regular expressions cannot.</para>
<anchor id="preface.influences_and_related_work" /><bridgehead renderas="sect2">Influences and Related Work</bridgehead><para>
The design of xpressive's interface has been strongly influenced by John Maddock's
<ulink url="../../libs/regex">Boost.Regex</ulink> library and his <ulink url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1429.htm">proposal</ulink>
to add regular expressions to the Standard Library. I also drew a great deal of
inspiration from Joel de Guzman's <ulink url="http://spirit.sourceforge.net">Spirit Parser Framework</ulink>, which served as the model
for static xpressive. Other sources of inspiration are the <ulink url="http://www.perl.com/pub/a/2002/06/04/apo5.html">Perl 6</ulink> redesign and <ulink url="http://research.microsoft.com/projects/greta">GRETA</ulink>.</para>
</section>
<section id="xpressive.user_s_guide">
<title>User's Guide</title>
<para>
This section describes how to use xpressive to accomplish text manipulation and
parsing tasks. If you are looking for detailed information regarding specific
components in xpressive, check the <link linkend="xpressive.reference">Reference</link> section.</para>

<section id="boost_xpressive.user_s_guide.introduction">
<title>Introduction</title>
<anchor id="user_s_guide.introduction.what_is_xpressive_" /><bridgehead renderas="sect2">What is xpressive?</bridgehead><para>
xpressive is an object-oriented regular expression library. Regular expressions
(regexes) can be written as strings that are parsed dynamically at runtime
(dynamic regexes), or as expression templates that are parsed at compile-time
(static regexes). Dynamic regexes have the advantage that they can be accepted
from the user as input at runtime or read from an initialization file. Static
regexes have several advantages. Since they are C++ expressions instead of
strings, they can be syntax-checked at compile-time. Also, they can refer to
other regexes and to themselves, giving static regexes the power
of context-free grammars. Finally, since they are statically bound,
the compiler can generate faster code for static regexes.</para>
<para>
xpressive's dual nature is unique and powerful. Static xpressive is a bit
like the <ulink url="http://spirit.sourceforge.net">Spirit Parser Framework</ulink>. Like <ulink url="http://spirit.sourceforge.net">Spirit</ulink>, you can build grammars with
static regexes using expression templates. (Unlike <ulink url="http://spirit.sourceforge.net">Spirit</ulink>, xpressive does
exhaustive backtracking, trying every possibility to find a match for your
pattern.) Dynamic xpressive is a bit like <ulink url="../../libs/regex">Boost.Regex</ulink>. In fact,
xpressive's interface should be familiar to anyone who has used <ulink url="../../libs/regex">Boost.Regex</ulink>.
xpressive's innovation comes from allowing you to mix and match static and
dynamic regexes in the same program, and even in the same expression! You
can embed a dynamic regex in a static regex, and the dynamic regex will
participate fully in the search, back-tracking as needed to make the match
succeed.</para>
<anchor id="user_s_guide.introduction.hello__world_" /><bridgehead renderas="sect2">Hello, world!</bridgehead><para>
Enough theory. Let's have a look at <emphasis>Hello World</emphasis>, xpressive style:</para>
<programlisting>
<literal>
<phrase role="preprocessor">#include</phrase><phrase role="special"> &lt;</phrase><phrase role="identifier">iostream</phrase><phrase role="special">&gt;</phrase><phrase role="preprocessor">
#include</phrase><phrase role="special"> &lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">/</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase><phrase role="keyword">

using</phrase><phrase role="keyword"> namespace</phrase><phrase role="identifier"> boost</phrase><phrase role="special">::</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">;</phrase><phrase role="keyword">

int</phrase><phrase role="identifier"> main</phrase><phrase role="special">()</phrase><phrase role="special">
{</phrase><phrase role="identifier">
    std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="identifier"> hello</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;hello world!&quot;</phrase><phrase role="special"> );</phrase><phrase role="identifier">

    sregex</phrase><phrase role="identifier"> rex</phrase><phrase role="special"> =</phrase><phrase role="identifier"> sregex</phrase><phrase role="special">::</phrase><phrase role="identifier">compile</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;(\\w+) (\\w+)!&quot;</phrase><phrase role="special"> );</phrase><phrase role="identifier">
    smatch</phrase><phrase role="identifier"> what</phrase><phrase role="special">;</phrase><phrase role="keyword">

    if</phrase><phrase role="special">(</phrase><phrase role="identifier"> regex_match</phrase><phrase role="special">(</phrase><phrase role="identifier"> hello</phrase><phrase role="special">,</phrase><phrase role="identifier"> what</phrase><phrase role="special">,</phrase><phrase role="identifier"> rex</phrase><phrase role="special"> )</phrase><phrase role="special"> )</phrase><phrase role="special">
    {</phrase><phrase role="identifier">
        std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="identifier"> what</phrase><phrase role="special">[</phrase><phrase role="number">0</phrase><phrase role="special">]</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="char"> '\n'</phrase><phrase role="special">;</phrase><phrase role="comment"> // whole match
</phrase><phrase role="identifier">        std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="identifier"> what</phrase><phrase role="special">[</phrase><phrase role="number">1</phrase><phrase role="special">]</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="char"> '\n'</phrase><phrase role="special">;</phrase><phrase role="comment"> // first capture
</phrase><phrase role="identifier">        std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="identifier"> what</phrase><phrase role="special">[</phrase><phrase role="number">2</phrase><phrase role="special">]</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="char"> '\n'</phrase><phrase role="special">;</phrase><phrase role="comment"> // second capture
</phrase><phrase role="special">    }</phrase><phrase role="keyword">

    return</phrase><phrase role="number"> 0</phrase><phrase role="special">;</phrase><phrase role="special">
}</phrase>
</literal>
</programlisting>
<para>
This program outputs the following:</para>
<programlisting><literal>hello world!
hello
world
</literal></programlisting><para>
The first thing you'll notice about the code is that all the types in xpressive live in
the <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">xpressive</phrase></code> namespace.</para>
<informaltable frame="all">
<?dbhtml table-width="74%" ?>
<tgroup cols="1">
<tbody>
<row>
<entry role="blurb">
<inlinemediaobject><imageobject><imagedata fileref="images/note.png"></imagedata></imageobject></inlinemediaobject> Most of the rest of the examples in this document will leave off the
<code><phrase role="keyword">using</phrase><phrase role="keyword"> namespace</phrase><phrase role="identifier"> boost</phrase><phrase role="special">::</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">;</phrase></code> directive. Just pretend it's there.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>
Next, you'll notice the type of the regular expression object is <code><phrase role="identifier">sregex</phrase></code>. If you are familiar
with <ulink url="../../libs/regex">Boost.Regex</ulink>, this is different than what you are used to. The &quot;<code><phrase role="identifier">s</phrase></code>&quot; in &quot;<code><phrase role="identifier">sregex</phrase></code>&quot; stands for
&quot;<code><phrase role="identifier">string</phrase></code>&quot;, indicating that this regex can be used to find patterns in <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase></code> objects.
I'll discuss this difference and its implications in detail later.</para>
<para>
Notice how the regex object is initialized:</para>
<programlisting>
<literal>
<phrase role="identifier">sregex</phrase><phrase role="identifier"> rex</phrase><phrase role="special"> =</phrase><phrase role="identifier"> sregex</phrase><phrase role="special">::</phrase><phrase role="identifier">compile</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;(\\w+) (\\w+)!&quot;</phrase><phrase role="special"> );</phrase>
</literal>
</programlisting>
<para>
To create a regular expression object from a string, you must call a factory method such as
<literal><methodname alt="boost::xpressive::compile">basic_regex::compile()</methodname></literal>. This is another area in which xpressive differs from
other object-oriented regular expression libraries. Other libraries encourage you to think of
a regular expression as a kind of string on steroids. In xpressive, regular expressions are not
strings; they are little programs in a domain-specific language. Strings are only one <emphasis>representation</emphasis>
of that language. Another representation is an expression template. For example, the above line of code
is equivalent to the following:</para>
<programlisting>
<literal>
<phrase role="identifier">sregex</phrase><phrase role="identifier"> rex</phrase><phrase role="special"> =</phrase><phrase role="special"> (</phrase><phrase role="identifier">s1</phrase><phrase role="special">=</phrase><phrase role="special"> +</phrase><phrase role="identifier">_w</phrase><phrase role="special">)</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="char"> ' '</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="special"> (</phrase><phrase role="identifier">s2</phrase><phrase role="special">=</phrase><phrase role="special"> +</phrase><phrase role="identifier">_w</phrase><phrase role="special">)</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="char"> '!'</phrase><phrase role="special">;</phrase>
</literal>
</programlisting>
<para>
This describes the same regular expression, except it uses the domain-specific embedded language
defined by static xpressive.</para>
<para>
As you can see, static regexes have a syntax that is noticeably different than standard Perl
syntax. That is because we are constrained by C++'s syntax. The biggest difference is the use
of <code><phrase role="special">&gt;&gt;</phrase></code> to mean &quot;followed by&quot;. For instance, in Perl you can just put sub-expressions next
to each other:</para>
<programlisting>
<literal>
<phrase role="identifier">abc</phrase>
</literal>
</programlisting>
<para>
But in C++, there must be an operator separating sub-expressions:</para>
<programlisting>
<literal>
<phrase role="identifier">a</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> b</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> c</phrase>
</literal>
</programlisting>
<para>
In Perl, parentheses <code><phrase role="special">()</phrase></code> have special meaning. They group, but as a side-effect they also create
back-references like <literal>$1</literal> and <literal>$2</literal>. In C++, there is no way to overload parentheses to give them
side-effects. To get the same effect, we use the special <code><phrase role="identifier">s1</phrase></code>, <code><phrase role="identifier">s2</phrase></code>, etc. tokens. Assign to
one to create a back-reference (known as a sub-match in xpressive).</para>
<para>
You'll also notice that the one-or-more repetition operator <code><phrase role="special">+</phrase></code> has moved from postfix
to prefix position. That's because C++ doesn't have a postfix <code><phrase role="special">+</phrase></code> operator. So:</para>
<programlisting>
<literal>
<phrase role="string">&quot;\\w+&quot;</phrase>
</literal>
</programlisting>
<para>
is the same as:</para>
<programlisting>
<literal>
<phrase role="special">+</phrase><phrase role="identifier">_w</phrase>
</literal>
</programlisting>
<para>
We'll cover all the other differences <link linkend="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes">later</link>.</para>
</section>
<section id="boost_xpressive.user_s_guide.installing_xpressive">
<title>Installing xpressive</title>
<anchor id="user_s_guide.installing_xpressive.getting_xpressive" /><bridgehead renderas="sect2">Getting xpressive</bridgehead><para>
There are two ways to get xpressive. The first is by downloading xpressive.zip at the
<ulink url="http://www.boost-consulting.com/vault/index.php?directory=Strings%20-%20Text%20Processing">Boost Sandbox File Vault</ulink> in the &quot;Strings - Text Processing&quot; directory. In addition to
the source code and the Boost license, this archive contains a copy of this documentation in
PDF format.</para>
<para>
The second way is through anonymous CVS via the boost-sandbox project on SourceForge.net. Just
go to <ulink url="http://sf.net/projects/boost-sandbox">http://sf.net/projects/boost-sandbox</ulink> and follow the instructions there for
anonymous CVS access.</para>
<anchor id="user_s_guide.installing_xpressive.building_with_xpressive" /><bridgehead renderas="sect2">Building with xpressive</bridgehead><para>
xpressive is a header-only template library, which means you don't need to alter your build scripts
or link to any separate lib file to use it. All you need to do is <code><phrase role="preprocessor">#include</phrase><phrase role="special"> &lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">/</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase></code>.
If you are only using static regexes, you can improve compile times by only including <code><phrase role="identifier">xpressive_static</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase></code>.
Likewise, you can include <code><phrase role="identifier">xpressive_dynamic</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase></code> if you only plan on using dynamic regexes.</para>
<anchor id="user_s_guide.installing_xpressive.requirements" /><bridgehead renderas="sect2">Requirements</bridgehead><para>
xpressive depends on Boost. You can download the latest version of the Boost
libraries from <ulink url="http://boost.org">http://boost.org</ulink>. xpressive requires Boost version 1.31 or higher.</para>
<anchor id="user_s_guide.installing_xpressive.supported_compilers" /><bridgehead renderas="sect2">Supported Compilers</bridgehead><para>
xpressive is an advanced template library, and it needs excellent compiler support. Currently, xpressive
has only been tested on the following compilers:</para>
<itemizedlist>
<listitem>
Visual C++ .NET 2003 (7.1)
</listitem><listitem>
GNU C++ 3.3.3
</listitem>
</itemizedlist><para>
If you experience problems using xpressive with a different compiler, don't hesitate to send mail to
eric at boost-consulting dot com.</para>
<informaltable frame="all">
<?dbhtml table-width="74%" ?>
<tgroup cols="1">
<tbody>
<row>
<entry role="blurb">
<inlinemediaobject><imageobject><imagedata fileref="images/note.png"></imagedata></imageobject></inlinemediaobject> Please send any questions, comments and bug reports to eric at boost-consulting dot com.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="boost_xpressive.user_s_guide.quick_start">
<title>Quick Start</title>
<para>
Let's assume that you have already decided to use xpressive, but that you don't know where to begin.
It turns out you don't need to know much to start being productive with xpressive. Let's begin with
the nickel tour of the types and algorithms xpressive provides.</para>
<informaltable frame="all">
<bridgehead renderas="sect4"><phrase role="table-title">xpressive's Tool-Box</phrase></bridgehead>
<tgroup cols="2">
<thead><row><entry>Tool</entry><entry>Description</entry></row>
</thead>
<tbody>
<row><entry><literal><classname alt="boost::xpressive::basic_regex">basic_regex&lt;&gt;</classname></literal></entry><entry>Contains a compiled regular expression. <literal><classname alt="boost::xpressive::basic_regex">basic_regex&lt;&gt;</classname></literal> is the most important type in xpressive. Everything you do with xpressive will begin with creating an object of type <literal><classname alt="boost::xpressive::basic_regex">basic_regex&lt;&gt;</classname></literal>.</entry></row>
<row><entry><literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal>, <literal><classname alt="boost::xpressive::sub_match">sub_match&lt;&gt;</classname></literal></entry><entry><literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> contains the results of a <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal> or <literal><functionname alt="boost::xpressive::regex_search">regex_search()</functionname></literal> operation. It acts like a vector of <literal><classname alt="boost::xpressive::sub_match">sub_match&lt;&gt;</classname></literal> objects. A <literal><classname alt="boost::xpressive::sub_match">sub_match&lt;&gt;</classname></literal> object contains a marked sub-expression (also known as a back-reference in Perl). It is basically just a pair of iterators representing the begin and end of the marked sub-expression.</entry></row>
<row><entry><literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal></entry><entry>Checks to see if a string matches a regex. For <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal> to succeed, the <emphasis>whole string</emphasis> must match the regex, from beginning to end. If you give <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal> a <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal>, it will write into it any marked sub-expressions it finds.</entry></row>
<row><entry><literal><functionname alt="boost::xpressive::regex_search">regex_search()</functionname></literal></entry><entry>Searches a string to find a sub-string that matches the regex. <literal><functionname alt="boost::xpressive::regex_search">regex_search()</functionname></literal> will try to find a match at every position in the string, starting at the beginning, and stopping when it finds a match or when the string is exhausted. As with <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal>, if you give <literal><functionname alt="boost::xpressive::regex_search">regex_search()</functionname></literal> a <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal>, it will write into it any marked sub-expressions it finds.</entry></row>
<row><entry><literal><functionname alt="boost::xpressive::regex_replace">regex_replace()</functionname></literal></entry><entry>Given an input string, a regex, and a substitution string, <literal><functionname alt="boost::xpressive::regex_replace">regex_replace()</functionname></literal> builds a new string by replacing those parts of the input string that match the regex with the substitution string. The substitution string can contain references to marked sub-expressions.</entry></row>
<row><entry><literal><classname alt="boost::xpressive::regex_iterator">regex_iterator&lt;&gt;</classname></literal></entry><entry>An STL-compatible iterator that makes it easy to find all the places in a string that match a regex. Dereferencing a <literal><classname alt="boost::xpressive::regex_iterator">regex_iterator&lt;&gt;</classname></literal> returns a <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal>. Incrementing a <literal><classname alt="boost::xpressive::regex_iterator">regex_iterator&lt;&gt;</classname></literal> finds the next match.</entry></row>
<row><entry><literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal></entry><entry>Like <literal><classname alt="boost::xpressive::regex_iterator">regex_iterator&lt;&gt;</classname></literal>, except dereferencing a <literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal> returns a string. By default, it will return the whole sub-string that the regex matched, but it can be configured to return any or all of the marked sub-expressions one at a time, or even the parts of the string that <emphasis>didn't</emphasis> match the regex.</entry></row>
<row><entry><literal><classname alt="boost::xpressive::regex_compiler">regex_compiler&lt;&gt;</classname></literal></entry><entry>A factory for <literal><classname alt="boost::xpressive::basic_regex">basic_regex&lt;&gt;</classname></literal> objects. It &quot;compiles&quot; a string into a regular expression. You will not usually have to deal directly with <literal><classname alt="boost::xpressive::regex_compiler">regex_compiler&lt;&gt;</classname></literal> because the <literal><classname alt="boost::xpressive::basic_regex">basic_regex&lt;&gt;</classname></literal> class has a factory method that uses <literal><classname alt="boost::xpressive::regex_compiler">regex_compiler&lt;&gt;</classname></literal> internally. But if you need to do anything fancy like create a <literal><classname alt="boost::xpressive::basic_regex">basic_regex&lt;&gt;</classname></literal> object with a different <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">locale</phrase></code>, you will need to use a <literal><classname alt="boost::xpressive::regex_compiler">regex_compiler&lt;&gt;</classname></literal> explicitly.</entry></row>
</tbody>
</tgroup>
</informaltable>
<para>
Now that you know a bit about the tools xpressive provides, you can pick the right tool for you
by answering the following two questions:</para>
<orderedlist>
<listitem>
What <emphasis>iterator</emphasis> type will you use to traverse your data?
</listitem><listitem>
What do you want to <emphasis>do</emphasis> to your data?
</listitem>
</orderedlist><anchor id="user_s_guide.quick_start.know_your_iterator_type" /><bridgehead renderas="sect2">Know Your Iterator Type</bridgehead><para>
Most of the classes in xpressive are templates that are parameterized on the iterator type.
xpressive defines some common typedefs to make the job of choosing the right types easier.
You can use the table below to find the right types based on the type of your iterator.</para>
<informaltable frame="all">
<bridgehead renderas="sect4"><phrase role="table-title">xpressive Typedefs vs. Iterator Types</phrase></bridgehead>
<tgroup cols="5">
<thead><row><entry></entry><entry>std::string::const_iterator</entry><entry>char const *</entry><entry>std::wstring::const_iterator</entry><entry>wchar_t const *</entry></row>
</thead>
<tbody>
<row><entry><literal><classname alt="boost::xpressive::basic_regex">basic_regex&lt;&gt;</classname></literal></entry><entry><code><phrase role="identifier">sregex</phrase></code></entry><entry><code><phrase role="identifier">cregex</phrase></code></entry><entry><code><phrase role="identifier">wsregex</phrase></code></entry><entry><code><phrase role="identifier">wcregex</phrase></code></entry></row>
<row><entry><literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal></entry><entry><code><phrase role="identifier">smatch</phrase></code></entry><entry><code><phrase role="identifier">cmatch</phrase></code></entry><entry><code><phrase role="identifier">wsmatch</phrase></code></entry><entry><code><phrase role="identifier">wcmatch</phrase></code></entry></row>
<row><entry><literal><classname alt="boost::xpressive::regex_compiler">regex_compiler&lt;&gt;</classname></literal></entry><entry><code><phrase role="identifier">sregex_compiler</phrase></code></entry><entry><code><phrase role="identifier">cregex_compiler</phrase></code></entry><entry><code><phrase role="identifier">wsregex_compiler</phrase></code></entry><entry><code><phrase role="identifier">wcregex_compiler</phrase></code></entry></row>
<row><entry><literal><classname alt="boost::xpressive::regex_iterator">regex_iterator&lt;&gt;</classname></literal></entry><entry><code><phrase role="identifier">sregex_iterator</phrase></code></entry><entry><code><phrase role="identifier">cregex_iterator</phrase></code></entry><entry><code><phrase role="identifier">wsregex_iterator</phrase></code></entry><entry><code><phrase role="identifier">wcregex_iterator</phrase></code></entry></row>
<row><entry><literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal></entry><entry><code><phrase role="identifier">sregex_token_iterator</phrase></code></entry><entry><code><phrase role="identifier">cregex_token_iterator</phrase></code></entry><entry><code><phrase role="identifier">wsregex_token_iterator</phrase></code></entry><entry><code><phrase role="identifier">wcregex_token_iterator</phrase></code></entry></row>
</tbody>
</tgroup>
</informaltable>
<para>
You should notice the systematic naming convention. Many of these types are used together, so the
naming convention helps you to use them consistently. For instance, if you have a <code><phrase role="identifier">sregex</phrase></code>, you
should also be using a <code><phrase role="identifier">smatch</phrase></code>.</para>
<para>
If you are not using one of those four iterator types, then you can use the templates directly and
specify your iterator type.</para>
<anchor id="user_s_guide.quick_start.know_your_task" /><bridgehead renderas="sect2">Know Your Task</bridgehead><para>
Do you want to find a pattern once? Many times? Search and replace? xpressive has tools for all
that and more. Below is a quick reference:</para>
<informaltable frame="all">
<bridgehead renderas="sect4"><phrase role="table-title">Tasks and Tools</phrase></bridgehead>
<tgroup cols="2">
<thead><row><entry>To do this ...</entry><entry>Use this ...</entry></row>
</thead>
<tbody>
<row><entry><inlinemediaobject><imageobject><imagedata fileref="images/tip.png"></imagedata></imageobject></inlinemediaobject> <link linkend="user_s_guide.examples.see_if_a_whole_string_matches_a_regex">See if a whole string matches a regex</link></entry><entry>The <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal> algorithm</entry></row>
<row><entry><inlinemediaobject><imageobject><imagedata fileref="images/tip.png"></imagedata></imageobject></inlinemediaobject> <link linkend="user_s_guide.examples.see_if_a_string_contains_a_sub_string_that_matches_a_regex">See if a string contains a sub-string that matches a regex</link></entry><entry>The <literal><functionname alt="boost::xpressive::regex_search">regex_search()</functionname></literal> algorithm</entry></row>
<row><entry><inlinemediaobject><imageobject><imagedata fileref="images/tip.png"></imagedata></imageobject></inlinemediaobject> <link linkend="user_s_guide.examples.replace_all_sub_strings_that_match_a_regex">Replace all sub-strings that match a regex</link></entry><entry>The <literal><functionname alt="boost::xpressive::regex_replace">regex_replace()</functionname></literal> algorithm</entry></row>
<row><entry><inlinemediaobject><imageobject><imagedata fileref="images/tip.png"></imagedata></imageobject></inlinemediaobject> <link linkend="user_s_guide.examples.find_all_the_sub_strings_that_match_a_regex_and_step_through_them_one_at_a_time">Find all the sub-strings that match a regex and step through them one at a time</link></entry><entry>The <literal><classname alt="boost::xpressive::regex_iterator">regex_iterator&lt;&gt;</classname></literal> class</entry></row>
<row><entry><inlinemediaobject><imageobject><imagedata fileref="images/tip.png"></imagedata></imageobject></inlinemediaobject> <link linkend="user_s_guide.examples.split_a_string_into_tokens_that_each_match_a_regex">Split a string into tokens that each match a regex</link></entry><entry>The <literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal> class</entry></row>
<row><entry><inlinemediaobject><imageobject><imagedata fileref="images/tip.png"></imagedata></imageobject></inlinemediaobject> <link linkend="user_s_guide.examples.split_a_string_using_a_regex_as_a_delimiter">Split a string using a regex as a delimiter</link></entry><entry>The <literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal> class</entry></row>
</tbody>
</tgroup>
</informaltable>
<para>
These algorithms and classes are described in excruciating detail in the Reference section.</para>
<informaltable frame="all">
<?dbhtml table-width="74%" ?>
<tgroup cols="1">
<tbody>
<row>
<entry role="blurb">
<inlinemediaobject><imageobject><imagedata fileref="images/tip.png"></imagedata></imageobject></inlinemediaobject> Try clicking on a task in the table above to see a complete example
program that uses xpressive to solve that particular task.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="xpressive.user_s_guide.creating_a_regex_object">
<title>Creating a Regex Object</title>
<para>
When using xpressive, the first thing you'll do is create a <literal><classname alt="boost::xpressive::basic_regex">basic_regex&lt;&gt;</classname></literal> object. This section goes
over the nuts and bolts of building a regular expression in the two dialects xpressive supports: static
and dynamic.</para>

<section id="boost_xpressive.user_s_guide.creating_a_regex_object.static_regexes">
<title>Static Regexes</title>
<anchor id="user_s_guide.creating_a_regex_object.static_regexes.overview" /><bridgehead renderas="sect2">Overview</bridgehead><para>
The feature that really sets xpressive apart from other C/C++ regular expression libraries is the ability
to author a regular expression using C++ expressions. xpressive achieves this through operator overloading,
using a technique called <emphasis>expression templates</emphasis> to embed a mini-language dedicated to text manipulation
within C++. These &quot;static regexes&quot; have many advantages over their string-based brethren. In particular,
static regexes:</para>
<itemizedlist>
<listitem>
are syntax-checked at compile-time; they will never fail at run-time due to a syntax error.
</listitem><listitem>
can naturally refer to other C++ data and code, including other regexes, making it possible to
  build grammars out of regular expressions and bind user-defined actions that execute when parts
  of your regex match.
</listitem><listitem>
are statically bound for better inlining and optimization. Static regexes require no state tables,
  virtual functions, byte-code or calls through function pointers that cannot be resolved at compile
  time.
</listitem><listitem>
are not limited to searching for patterns in strings. You can declare a static regex that finds
  patterns in an array of integers, or records, or anything really.
</listitem>
</itemizedlist><para>
Since we compose static regexes using C++ expressions, we are constrained by the rules for legal C++ expressions.
Unfortunately, that means that &quot;classic&quot; regular expression syntax cannot always be mapped cleanly into C++. Rather, we
map the regex <emphasis>constructs</emphasis>, picking new syntax that is legal C++.</para>
<anchor id="user_s_guide.creating_a_regex_object.static_regexes.construction_and_assignment" /><bridgehead renderas="sect2">Construction and Assignment</bridgehead><para>
You create a static regex by assigning one to an object of type <literal><classname alt="boost::xpressive::basic_regex">basic_regex&lt;&gt;</classname></literal>. (You can use the table in the
<link linkend="user_s_guide.quick_start.know_your_iterator_type">Quick Start</link> to pick the right <literal><classname alt="boost::xpressive::basic_regex">basic_regex&lt;&gt;</classname></literal> typedef for the iterator
type you will use.) For instance, the following defines a regex that can be used to find patterns in objects
of type <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase></code>:</para>
<programlisting>
<literal>
<phrase role="identifier">sregex</phrase><phrase role="identifier"> re</phrase><phrase role="special"> =</phrase><phrase role="char"> '$'</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="special"> +</phrase><phrase role="identifier">_d</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="char"> '.'</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> _d</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> _d</phrase><phrase role="special">;</phrase>
</literal>
</programlisting>
<para>
Assignment works similarly.</para>
<anchor id="user_s_guide.creating_a_regex_object.static_regexes.character_and_string_literals" /><bridgehead renderas="sect2">Character and String Literals</bridgehead><para>
In static regexes, character and string literals match themselves. For instance, in the regex above, <code><phrase role="char">'$'</phrase></code> and <code><phrase role="char">'.'</phrase></code>
match the characters <code><phrase role="char">'$'</phrase></code> and <code><phrase role="char">'.'</phrase></code> respectively. Don't be confused by the fact that <literal>$</literal> and <literal>.</literal> are meta-characters
in Perl. In xpressive, literals always represent themselves.</para>
<para>
When using literals in static regexes, you must take care that at least one operand is not a literal. For instance,
the following are <emphasis>not</emphasis> valid regexes:</para>
<programlisting>
<literal>
<phrase role="identifier">sregex</phrase><phrase role="identifier"> re1</phrase><phrase role="special"> =</phrase><phrase role="char"> 'a'</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="char"> 'b'</phrase><phrase role="special">;</phrase><phrase role="comment">         // ERROR!
</phrase><phrase role="identifier">sregex</phrase><phrase role="identifier"> re2</phrase><phrase role="special"> =</phrase><phrase role="special"> +</phrase><phrase role="char">'a'</phrase><phrase role="special">;</phrase><phrase role="comment">               // ERROR!
</phrase></literal>
</programlisting>
<para>
The two operands to the binary <code><phrase role="special">&gt;&gt;</phrase></code> operator are both literals, and the operand of the unary <code><phrase role="special">+</phrase></code> operator is also a literal,
so these statements will call the native C++ binary right-shift and unary plus operators, respectively.
That's not what we want. To get operator overloading to kick in, at least one operand must be a user-defined type. We can use
xpressive's <code><phrase role="identifier">as_xpr</phrase><phrase role="special">()</phrase></code> helper function to &quot;taint&quot; an expression with regex-ness, forcing operator overloading to find the
correct operators. The two regexes above should be written as:</para>
<programlisting>
<literal>
<phrase role="identifier">sregex</phrase><phrase role="identifier"> re1</phrase><phrase role="special"> =</phrase><phrase role="identifier"> as_xpr</phrase><phrase role="special">(</phrase><phrase role="char">'a'</phrase><phrase role="special">)</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="char"> 'b'</phrase><phrase role="special">;</phrase><phrase role="comment"> // OK
</phrase><phrase role="identifier">sregex</phrase><phrase role="identifier"> re2</phrase><phrase role="special"> =</phrase><phrase role="special"> +</phrase><phrase role="identifier">as_xpr</phrase><phrase role="special">(</phrase><phrase role="char">'a'</phrase><phrase role="special">);</phrase><phrase role="comment">       // OK
</phrase></literal>
</programlisting>
<anchor id="user_s_guide.creating_a_regex_object.static_regexes.sequencing_and_alternation" /><bridgehead renderas="sect2">Sequencing and Alternation</bridgehead><para>
As you've probably already noticed, sub-expressions in static regexes must be separated by the sequencing operator, <code><phrase role="special">&gt;&gt;</phrase></code>.
You can read this operator as &quot;followed by&quot;.</para>
<programlisting>
<literal>
<phrase role="identifier">sregex</phrase><phrase role="identifier"> re</phrase><phrase role="special"> =</phrase><phrase role="char"> 'a'</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> _d</phrase><phrase role="special">;</phrase><phrase role="comment"> // Match an 'a' followed by a digit
</phrase></literal>
</programlisting>
<para>
Alternation works just as it does in Perl with the <code><phrase role="special">|</phrase></code> operator. You can read this operator as &quot;or&quot;. For example:</para>
<programlisting>
<literal>
<phrase role="identifier">sregex</phrase><phrase role="identifier"> re</phrase><phrase role="special"> =</phrase><phrase role="special"> +(</phrase><phrase role="identifier"> _d</phrase><phrase role="special"> |</phrase><phrase role="identifier"> _w</phrase><phrase role="special"> );</phrase><phrase role="comment"> // match a digit character or a word character one or more times
</phrase></literal>
</programlisting>
<anchor id="user_s_guide.creating_a_regex_object.static_regexes.grouping_and_captures" /><bridgehead renderas="sect2">Grouping and Captures</bridgehead><para>
In Perl, parentheses <code><phrase role="special">()</phrase></code> have special meaning. They group, but as a side-effect they also
create back<emphasis role="strikethrough">references like $1 and $2. In C++, parentheses only group -</emphasis> there is no way to
give them side-effects. To get the same effect, we use the special <code><phrase role="identifier">s1</phrase></code>, <code><phrase role="identifier">s2</phrase></code>, etc. tokens.
Assigning to one creates a back-reference. You can then use the back-reference later in your
expression, like using <literal>\1</literal> and <literal>\2</literal> in Perl. For example, consider the following regex,
which finds matching HTML tags:</para>
<programlisting>
<literal>
<phrase role="string">&quot;&lt;(\\w+)&gt;.*?&lt;/\\1&gt;&quot;</phrase>
</literal>
</programlisting>
<para>
In static xpressive, this would be:</para>
<programlisting>
<literal>
<phrase role="char">'&lt;'</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="special"> (</phrase><phrase role="identifier">s1</phrase><phrase role="special">=</phrase><phrase role="special"> +</phrase><phrase role="identifier">_w</phrase><phrase role="special">)</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="char"> '&gt;'</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="special"> -*</phrase><phrase role="identifier">_</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="string"> &quot;&lt;/&quot;</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> s1</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="char"> '&gt;'</phrase>
</literal>
</programlisting>
<para>
Notice how you capture a back-reference by assigning to <code><phrase role="identifier">s1</phrase></code>, and then you use <code><phrase role="identifier">s1</phrase></code>
later in the pattern to find the matching end tag.</para>
<informaltable frame="all">
<?dbhtml table-width="74%" ?>
<tgroup cols="1">
<tbody>
<row>
<entry role="blurb">
<inlinemediaobject><imageobject><imagedata fileref="images/tip.png"></imagedata></imageobject></inlinemediaobject> <emphasis role="bold">Grouping without capturing a back-reference</emphasis>
<sbr/>
<sbr/>

In xpressive, if you just want grouping without capturing a back-reference, you can just
use <code><phrase role="special">()</phrase></code> without <code><phrase role="identifier">s1</phrase></code>. That is the equivalent of Perl's <code><phrase role="special">(?:)</phrase></code> non-capturing grouping
construct.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<anchor id="user_s_guide.creating_a_regex_object.static_regexes.case_insensitivity_and_internationalization" /><bridgehead renderas="sect2">Case-Insensitivity and Internationalization</bridgehead><para>
Perl lets you make part of your regular expression case-insensitive by using the <code><phrase role="special">(?</phrase><phrase role="identifier">i</phrase><phrase role="special">:)</phrase></code> pattern
modifier. xpressive also has a case-insensitivity pattern modifier, called <code><phrase role="identifier">icase</phrase></code>. You can use it
as follows:</para>
<programlisting>
<literal>
<phrase role="identifier">sregex</phrase><phrase role="identifier"> re</phrase><phrase role="special"> =</phrase><phrase role="string"> &quot;this&quot;</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> icase</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;that&quot;</phrase><phrase role="special"> );</phrase>
</literal>
</programlisting>
<para>
In this regular expression, <code><phrase role="string">&quot;this&quot;</phrase></code> will be matched exactly, but <code><phrase role="string">&quot;that&quot;</phrase></code> will be matched irrespective
of case.</para>
<para>
Case-insensitive regular expressions raise the issue of internationalization: how should case-insensitive
character comparisons be evaluated? Also, many character classes are locale-specific. Which characters
are matched by <code><phrase role="identifier">digit</phrase></code> and which are matched by <code><phrase role="identifier">alpha</phrase></code>? The answer depends on the <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">locale</phrase></code> object
the regular expression object is using. By default, all regular expression objects use the global locale.
You can override the default by using the <code><phrase role="identifier">imbue</phrase><phrase role="special">()</phrase></code> pattern modifier, as follows:</para>
<programlisting>
<literal>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">locale</phrase><phrase role="identifier"> my_locale</phrase><phrase role="special"> =</phrase><phrase role="comment"> /* initialize a std::locale object */</phrase><phrase role="special">;</phrase><phrase role="identifier">
sregex</phrase><phrase role="identifier"> re</phrase><phrase role="special"> =</phrase><phrase role="identifier"> imbue</phrase><phrase role="special">(</phrase><phrase role="identifier"> my_locale</phrase><phrase role="special"> )(</phrase><phrase role="special"> +</phrase><phrase role="identifier">alpha</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="special"> +</phrase><phrase role="identifier">digit</phrase><phrase role="special"> );</phrase>
</literal>
</programlisting>
<para>
This regular expression will evaluate <code><phrase role="identifier">alpha</phrase></code> and <code><phrase role="identifier">digit</phrase></code> according to <code><phrase role="identifier">my_locale</phrase></code>.</para>
<anchor id="user_s_guide.creating_a_regex_object.static_regexes.static_xpressive_syntax_cheat_sheet" /><bridgehead renderas="sect2">Static xpressive Syntax Cheat Sheet</bridgehead><para>
The table below lists the familiar regex constructs and their equivalents in static
xpressive.</para>
<informaltable frame="all">
<bridgehead renderas="sect4"><phrase role="table-title">Perl syntax vs. Static xpressive syntax</phrase></bridgehead>
<tgroup cols="3">
<thead><row><entry>Perl</entry><entry>Static xpressive</entry><entry>Meaning</entry></row>
</thead>
<tbody>
<row><entry><literal>.</literal></entry><entry><code><phrase role="identifier">_</phrase></code></entry><entry>any character (assuming Perl's /s modifier).</entry></row>
<row><entry><literal>ab</literal></entry><entry><code><phrase role="identifier">a</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> b</phrase></code></entry><entry>sequencing of <literal>a</literal> and <literal>b</literal> sub-expressions.</entry></row>
<row><entry><literal>a|b</literal></entry><entry><code><phrase role="identifier">a</phrase><phrase role="special"> |</phrase><phrase role="identifier"> b</phrase></code></entry><entry>alternation of <literal>a</literal> and <literal>b</literal> sub-expressions.</entry></row>
<row><entry><literal>(a)</literal></entry><entry><code><phrase role="special">(</phrase><phrase role="identifier">s1</phrase><phrase role="special">=</phrase><phrase role="identifier"> a</phrase><phrase role="special">)</phrase></code></entry><entry>group and capture a back-reference.</entry></row>
<row><entry><literal>(?:a)</literal></entry><entry><code><phrase role="special">(</phrase><phrase role="identifier">a</phrase><phrase role="special">)</phrase></code></entry><entry>group and do not capture a back-reference.</entry></row>
<row><entry><literal>\1</literal></entry><entry><code><phrase role="identifier">s1</phrase></code></entry><entry>a previously captured back-reference.</entry></row>
<row><entry><literal>a*</literal></entry><entry><code><phrase role="special">*</phrase><phrase role="identifier">a</phrase></code></entry><entry>zero or more times, greedy.</entry></row>
<row><entry><literal>a+</literal></entry><entry><code><phrase role="special">+</phrase><phrase role="identifier">a</phrase></code></entry><entry>one or more times, greedy.</entry></row>
<row><entry><literal>a?</literal></entry><entry><code><phrase role="special">!</phrase><phrase role="identifier">a</phrase></code></entry><entry>zero or one time, greedy.</entry></row>
<row><entry><literal>a{n,m}</literal></entry><entry><code><phrase role="identifier">repeat</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">n</phrase><phrase role="special">,</phrase><phrase role="identifier">m</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">a</phrase><phrase role="special">)</phrase></code></entry><entry>between <literal>n</literal> and <literal>m</literal> times, greedy.</entry></row>
<row><entry><literal>a*?</literal></entry><entry><code><phrase role="special">-*</phrase><phrase role="identifier">a</phrase></code></entry><entry>zero or more times, non-greedy.</entry></row>
<row><entry><literal>a+?</literal></entry><entry><code><phrase role="special">-+</phrase><phrase role="identifier">a</phrase></code></entry><entry>one or more times, non-greedy.</entry></row>
<row><entry><literal>a??</literal></entry><entry><code><phrase role="special">-!</phrase><phrase role="identifier">a</phrase></code></entry><entry>zero or one time, non-greedy.</entry></row>
<row><entry><literal>a{n,m}?</literal></entry><entry><code><phrase role="special">-</phrase><phrase role="identifier">repeat</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">n</phrase><phrase role="special">,</phrase><phrase role="identifier">m</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">a</phrase><phrase role="special">)</phrase></code></entry><entry>between <literal>n</literal> and <literal>m</literal> times, non-greedy.</entry></row>
<row><entry><literal>^</literal></entry><entry><code><phrase role="identifier">bos</phrase></code></entry><entry>beginning of sequence assertion.</entry></row>
<row><entry><literal>$</literal></entry><entry><code><phrase role="identifier">eos</phrase></code></entry><entry>end of sequence assertion.</entry></row>
<row><entry><literal>\b</literal></entry><entry><code><phrase role="identifier">_b</phrase></code></entry><entry>word boundary assertion.</entry></row>
<row><entry><literal>\B</literal></entry><entry><code><phrase role="special">~</phrase><phrase role="identifier">_b</phrase></code></entry><entry>not word boundary assertion.</entry></row>
<row><entry><literal>\n</literal></entry><entry><code><phrase role="identifier">_n</phrase></code></entry><entry>literal newline.</entry></row>
<row><entry><literal>.</literal></entry><entry><code><phrase role="special">~</phrase><phrase role="identifier">_n</phrase></code></entry><entry>any character except a literal newline (without Perl's /s modifier).</entry></row>
<row><entry><literal>\r?\n</literal></entry><entry><code><phrase role="identifier">_ln</phrase></code></entry><entry>logical newline.</entry></row>
<row><entry><literal>(?![\r\n]).</literal></entry><entry><code><phrase role="special">~</phrase><phrase role="identifier">_ln</phrase></code></entry><entry>any single character not a logical newline.</entry></row>
<row><entry><literal>\w</literal></entry><entry><code><phrase role="identifier">_w</phrase></code></entry><entry>a word character, equivalent to set[alnum | '_'].</entry></row>
<row><entry><literal>\W</literal></entry><entry><code><phrase role="special">~</phrase><phrase role="identifier">_w</phrase></code></entry><entry>not a word character, equivalent to ~set[alnum | '_'].</entry></row>
<row><entry><literal>\d</literal></entry><entry><code><phrase role="identifier">_d</phrase></code></entry><entry>a digit character.</entry></row>
<row><entry><literal>\D</literal></entry><entry><code><phrase role="special">~</phrase><phrase role="identifier">_d</phrase></code></entry><entry>not a digit character.</entry></row>
<row><entry><literal>\s</literal></entry><entry><code><phrase role="identifier">_s</phrase></code></entry><entry>a space character.</entry></row>
<row><entry><literal>\S</literal></entry><entry><code><phrase role="special">~</phrase><phrase role="identifier">_s</phrase></code></entry><entry>not a space character.</entry></row>
<row><entry><literal>[:alnum:]</literal></entry><entry><code><phrase role="identifier">alnum</phrase></code></entry><entry>an alph-numeric character.</entry></row>
<row><entry><literal>[:alpha:]</literal></entry><entry><code><phrase role="identifier">alpha</phrase></code></entry><entry>an alphabetic character.</entry></row>
<row><entry><literal>[:blank:]</literal></entry><entry><code><phrase role="identifier">blank</phrase></code></entry><entry>a horizontal white-space character.</entry></row>
<row><entry><literal>[:cntrl:]</literal></entry><entry><code><phrase role="identifier">cntrl</phrase></code></entry><entry>a control character.</entry></row>
<row><entry><literal>[:digit:]</literal></entry><entry><code><phrase role="identifier">digit</phrase></code></entry><entry>a digit character.</entry></row>
<row><entry><literal>[:graph:]</literal></entry><entry><code><phrase role="identifier">graph</phrase></code></entry><entry>a graphable character.</entry></row>
<row><entry><literal>[:lower:]</literal></entry><entry><code><phrase role="identifier">lower</phrase></code></entry><entry>a lower-case character.</entry></row>
<row><entry><literal>[:print:]</literal></entry><entry><code><phrase role="identifier">print</phrase></code></entry><entry>a printing character.</entry></row>
<row><entry><literal>[:punct:]</literal></entry><entry><code><phrase role="identifier">punct</phrase></code></entry><entry>a punctuation character.</entry></row>
<row><entry><literal>[:space:]</literal></entry><entry><code><phrase role="identifier">space</phrase></code></entry><entry>a white-space character.</entry></row>
<row><entry><literal>[:upper:]</literal></entry><entry><code><phrase role="identifier">upper</phrase></code></entry><entry>an upper-case character.</entry></row>
<row><entry><literal>[:xdigit:]</literal></entry><entry><code><phrase role="identifier">xdigit</phrase></code></entry><entry>a hexadecimal digit character.</entry></row>
<row><entry><literal>[0-9]</literal></entry><entry><code><phrase role="identifier">range</phrase><phrase role="special">(</phrase><phrase role="char">'0'</phrase><phrase role="special">,</phrase><phrase role="char">'9'</phrase><phrase role="special">)</phrase></code></entry><entry>characters in range <code><phrase role="char">'0'</phrase></code> through <code><phrase role="char">'9'</phrase></code>.</entry></row>
<row><entry><literal>[abc]</literal></entry><entry><code><phrase role="identifier">as_xpr</phrase><phrase role="special">(</phrase><phrase role="char">'a'</phrase><phrase role="special">)</phrase><phrase role="special"> |</phrase><phrase role="char"> 'b'</phrase><phrase role="special"> |</phrase><phrase role="char">'c'</phrase></code></entry><entry>characters <code><phrase role="char">'a'</phrase></code>, <code><phrase role="char">'b'</phrase></code>, or <code><phrase role="char">'c'</phrase></code>.</entry></row>
<row><entry><literal>[abc]</literal></entry><entry><code><phrase role="special">(</phrase><phrase role="identifier">set</phrase><phrase role="special">=</phrase><phrase role="char"> 'a'</phrase><phrase role="special">,</phrase><phrase role="char">'b'</phrase><phrase role="special">,</phrase><phrase role="char">'c'</phrase><phrase role="special">)</phrase></code></entry><entry><emphasis>same as above</emphasis></entry></row>
<row><entry><literal>[0-9abc]</literal></entry><entry><code><phrase role="identifier">set</phrase><phrase role="special">[</phrase><phrase role="identifier"> range</phrase><phrase role="special">(</phrase><phrase role="char">'0'</phrase><phrase role="special">,</phrase><phrase role="char">'9'</phrase><phrase role="special">)</phrase><phrase role="special"> |</phrase><phrase role="char"> 'a'</phrase><phrase role="special"> |</phrase><phrase role="char"> 'b'</phrase><phrase role="special"> |</phrase><phrase role="char"> 'c'</phrase><phrase role="special"> ]</phrase></code></entry><entry>characters <code><phrase role="char">'a'</phrase></code>, <code><phrase role="char">'b'</phrase></code>, <code><phrase role="char">'c'</phrase></code> or  in range <code><phrase role="char">'0'</phrase></code> through <code><phrase role="char">'9'</phrase></code>.</entry></row>
<row><entry><literal>[0-9abc]</literal></entry><entry><code><phrase role="identifier">set</phrase><phrase role="special">[</phrase><phrase role="identifier"> range</phrase><phrase role="special">(</phrase><phrase role="char">'0'</phrase><phrase role="special">,</phrase><phrase role="char">'9'</phrase><phrase role="special">)</phrase><phrase role="special"> |</phrase><phrase role="special"> (</phrase><phrase role="identifier">set</phrase><phrase role="special">=</phrase><phrase role="char"> 'a'</phrase><phrase role="special">,</phrase><phrase role="char">'b'</phrase><phrase role="special">,</phrase><phrase role="char">'c'</phrase><phrase role="special">)</phrase><phrase role="special"> ]</phrase></code></entry><entry><emphasis>same as above</emphasis></entry></row>
<row><entry><literal>[^abc]</literal></entry><entry><code><phrase role="special">~(</phrase><phrase role="identifier">set</phrase><phrase role="special">=</phrase><phrase role="char"> 'a'</phrase><phrase role="special">,</phrase><phrase role="char">'b'</phrase><phrase role="special">,</phrase><phrase role="char">'c'</phrase><phrase role="special">)</phrase></code></entry><entry>not characters <code><phrase role="char">'a'</phrase></code>, <code><phrase role="char">'b'</phrase></code>, or <code><phrase role="char">'c'</phrase></code>.</entry></row>
<row><entry><literal>(?i:<emphasis>stuff</emphasis>)</literal></entry><entry><code><phrase role="identifier">icase</phrase><phrase role="special">(</phrase></code><literal><emphasis>stuff</emphasis></literal><code><phrase role="special">)</phrase></code></entry><entry>match <emphasis>stuff</emphasis> disregarding case.</entry></row>
<row><entry><literal>(?&gt;<emphasis>stuff</emphasis>)</literal></entry><entry><code><phrase role="identifier">keep</phrase><phrase role="special">(</phrase></code><literal><emphasis>stuff</emphasis></literal><code><phrase role="special">)</phrase></code></entry><entry>independent sub-expression, match <emphasis>stuff</emphasis> and turn off backtracking.</entry></row>
<row><entry><literal>(?=<emphasis>stuff</emphasis>)</literal></entry><entry><code><phrase role="identifier">before</phrase><phrase role="special">(</phrase></code><literal><emphasis>stuff</emphasis></literal><code><phrase role="special">)</phrase></code></entry><entry>positive look-ahead assertion, match if before <emphasis>stuff</emphasis> but don't include <emphasis>stuff</emphasis> in the match.</entry></row>
<row><entry><literal>(?!<emphasis>stuff</emphasis>)</literal></entry><entry><code><phrase role="special">~</phrase><phrase role="identifier">before</phrase><phrase role="special">(</phrase></code><literal><emphasis>stuff</emphasis></literal><code><phrase role="special">)</phrase></code></entry><entry>negative look-ahead assertion, match if not before <emphasis>stuff</emphasis>.</entry></row>
<row><entry><literal>(?&lt;=<emphasis>stuff</emphasis>)</literal></entry><entry><code><phrase role="identifier">after</phrase><phrase role="special">(</phrase></code><literal><emphasis>stuff</emphasis></literal><code><phrase role="special">)</phrase></code></entry><entry>positive look-behind assertion, match if after <emphasis>stuff</emphasis> but don't include <emphasis>stuff</emphasis> in the match. (<emphasis>stuff</emphasis> must be constant-width.)</entry></row>
<row><entry><literal>(?&lt;!<emphasis>stuff</emphasis>)</literal></entry><entry><code><phrase role="special">~</phrase><phrase role="identifier">after</phrase><phrase role="special">(</phrase></code><literal><emphasis>stuff</emphasis></literal><code><phrase role="special">)</phrase></code></entry><entry>negative look-behind assertion, match if not after <emphasis>stuff</emphasis>. (<emphasis>stuff</emphasis> must be constant-width.)</entry></row>
</tbody>
</tgroup>
</informaltable>
<para>
<sbr/>
</para>
</section>
<section id="boost_xpressive.user_s_guide.creating_a_regex_object.dynamic_regexes">
<title>Dynamic Regexes</title>
<anchor id="user_s_guide.creating_a_regex_object.dynamic_regexes.overview" /><bridgehead renderas="sect2">Overview</bridgehead><para>
Static regexes are dandy, but sometimes you need something a bit more ... dynamic. Imagine you are developing
a text editor with a regex search/replace feature. You need to accept a regular expression from the end user
as input at run-time. There should be a way to parse a string into a regular expression. That's what xpressive's
dynamic regexes are for. They are built from the same core components as their static counterparts, but they
are late-bound so you can specify them at run-time.</para>
<anchor id="user_s_guide.creating_a_regex_object.dynamic_regexes.construction_and_assignment" /><bridgehead renderas="sect2">Construction and Assignment</bridgehead><para>
There are two ways to create a dynamic regex: with the <literal><methodname alt="boost::xpressive::compile">basic_regex::compile()</methodname></literal>
function or with the <literal><classname alt="boost::xpressive::regex_compiler">regex_compiler&lt;&gt;</classname></literal> class template. Use <literal><methodname alt="boost::xpressive::compile">basic_regex::compile()</methodname></literal>
if you want the default locale, syntax and semantics. Use <literal><classname alt="boost::xpressive::regex_compiler">regex_compiler&lt;&gt;</classname></literal> if you need to
specify a different locale, or if you need more control over the regex syntax and semantics than the
<literal><enumname alt="boost::xpressive::regex_constants::syntax_option_type">syntax_option_type</enumname></literal> enumeration gives you. <emphasis>(Editor's note: in xpressive v1.0, <literal><classname alt="boost::xpressive::regex_compiler">regex_compiler&lt;&gt;</classname></literal> does not support
customization of the dynamic regex syntax and semantics. It will in v2.0.)</emphasis></para>
<para>
Here is an example of using <code><phrase role="identifier">basic_regex</phrase><phrase role="special">&lt;&gt;::</phrase><phrase role="identifier">compile</phrase><phrase role="special">()</phrase></code>:</para>
<programlisting>
<literal>
<phrase role="identifier">sregex</phrase><phrase role="identifier"> re</phrase><phrase role="special"> =</phrase><phrase role="identifier"> sregex</phrase><phrase role="special">::</phrase><phrase role="identifier">compile</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;this|that&quot;</phrase><phrase role="special">,</phrase><phrase role="identifier"> regex_constants</phrase><phrase role="special">::</phrase><phrase role="identifier">icase</phrase><phrase role="special"> );</phrase>
</literal>
</programlisting>
<para>
Here is the same example using <literal><classname alt="boost::xpressive::regex_compiler">regex_compiler&lt;&gt;</classname></literal>:</para>
<programlisting>
<literal>
<phrase role="identifier">sregex_compiler</phrase><phrase role="identifier"> compiler</phrase><phrase role="special">;</phrase><phrase role="identifier">
sregex</phrase><phrase role="identifier"> re</phrase><phrase role="special"> =</phrase><phrase role="identifier"> compiler</phrase><phrase role="special">.</phrase><phrase role="identifier">compile</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;this|that&quot;</phrase><phrase role="special">,</phrase><phrase role="identifier"> regex_constants</phrase><phrase role="special">::</phrase><phrase role="identifier">icase</phrase><phrase role="special"> );</phrase>
</literal>
</programlisting>
<para>
<literal><methodname alt="boost::xpressive::compile">basic_regex::compile()</methodname></literal> is implemented in terms of <literal><classname alt="boost::xpressive::regex_compiler">regex_compiler&lt;&gt;</classname></literal>.</para>
<anchor id="user_s_guide.creating_a_regex_object.dynamic_regexes.dynamic_xpressive_syntax" /><bridgehead renderas="sect2">Dynamic xpressive Syntax</bridgehead><para>
Since the dynamic syntax is not constrained by the rules for valid C++ expressions, we are free to use familiar
syntax for dynamic regexes. For this reason, the syntax used by xpressive for dynamic regexes follows the
lead set by John Maddock's <ulink url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1429.htm">proposal</ulink>
to add regular expressions to the Standard Library. It is essentially the syntax standardized by
<ulink url="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">ECMAScript</ulink>, with minor changes
in support of internationalization.</para>
<para>
Since the syntax is documented exhaustively elsewhere, I will simply refer you to the existing standards, rather
than duplicate the specification here.</para>
<anchor id="user_s_guide.creating_a_regex_object.dynamic_regexes.customizing_dynamic_xpressive_syntax" /><bridgehead renderas="sect2">Customizing Dynamic xpressive Syntax</bridgehead><para>
xpressive v1.0 has limited support for the customization of dynamic regex syntax. The only customization allowed
is what can be specified via the <literal><enumname alt="boost::xpressive::regex_constants::syntax_option_type">syntax_option_type</enumname></literal> enumeration.</para>
<informaltable frame="all">
<?dbhtml table-width="74%" ?>
<tgroup cols="1">
<tbody>
<row>
<entry role="blurb">
I have planned some future work in this area for v2.0, however. xpressive's design allows for powerful mechanisms
to customize the dynamic regex syntax. First, since the concept of &quot;regex&quot; is separated from the concept of
&quot;regex compiler&quot;, it will be possible to offer multiple regex compilers, each of which accepts a different syntax.
Second, since xpressive allows you to build grammars using static regexes, it should be possible to build a
dynamic regex parser out of static regexes! Then, new dynamic regex grammars can be created by cloning an existing
regex grammar and modifying or disabling individual grammar rules to suit your needs.
</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<anchor id="user_s_guide.creating_a_regex_object.dynamic_regexes.internationalization" /><bridgehead renderas="sect2">Internationalization</bridgehead><para>
As with static regexes, dynamic regexes support internationalization by allowing you to specify a different
<code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">locale</phrase></code>. To do this, you must use <literal><classname alt="boost::xpressive::regex_compiler">regex_compiler&lt;&gt;</classname></literal>. The <literal><classname alt="boost::xpressive::regex_compiler">regex_compiler&lt;&gt;</classname></literal> class has an <code><phrase role="identifier">imbue</phrase><phrase role="special">()</phrase></code> function.
After you have imbued a <literal><classname alt="boost::xpressive::regex_compiler">regex_compiler&lt;&gt;</classname></literal> object with a custom <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">locale</phrase></code>, all regex objects compiled by
that <literal><classname alt="boost::xpressive::regex_compiler">regex_compiler&lt;&gt;</classname></literal> will use that locale. For example:</para>
<programlisting>
<literal>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">locale</phrase><phrase role="identifier"> my_locale</phrase><phrase role="special"> =</phrase><phrase role="comment"> /* initialize your locale object here */</phrase><phrase role="special">;</phrase><phrase role="identifier">
sregex_compiler</phrase><phrase role="identifier"> compiler</phrase><phrase role="special">;</phrase><phrase role="identifier">
compiler</phrase><phrase role="special">.</phrase><phrase role="identifier">imbue</phrase><phrase role="special">(</phrase><phrase role="identifier"> my_locale</phrase><phrase role="special"> );</phrase><phrase role="identifier">
sregex</phrase><phrase role="identifier"> re</phrase><phrase role="special"> =</phrase><phrase role="identifier"> compiler</phrase><phrase role="special">.</phrase><phrase role="identifier">compile</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;\\w+|\\d+&quot;</phrase><phrase role="special"> );</phrase>
</literal>
</programlisting>
<para>
This regex will use <code><phrase role="identifier">my_locale</phrase></code> when evaluating the intrinsic character sets <code><phrase role="string">&quot;\\w&quot;</phrase></code> and <code><phrase role="string">&quot;\\d&quot;</phrase></code>.</para>
</section></section>
<section id="boost_xpressive.user_s_guide.matching_and_searching">
<title>Matching and Searching</title>
<anchor id="user_s_guide.matching_and_searching.overview" /><bridgehead renderas="sect2">Overview</bridgehead><para>
Once you have created a regex object, you can use the <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal> and <literal><functionname alt="boost::xpressive::regex_search">regex_search()</functionname></literal> algorithms to find patterns
in strings. This page covers the basics of regex matching and searching. In all cases, if you are familiar with
how <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal> and <literal><functionname alt="boost::xpressive::regex_search">regex_search()</functionname></literal> in the <ulink url="../../libs/regex">Boost.Regex</ulink> library work, xpressive's versions work the same way.</para>
<anchor id="user_s_guide.matching_and_searching.seeing_if_a_string_matches_a_regex" /><bridgehead renderas="sect2">Seeing if a String Matches a Regex</bridgehead><para>
The <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal> algorithm checks to see if a regex matches a given input.</para>
<informaltable frame="all">
<?dbhtml table-width="74%" ?>
<tgroup cols="1">
<tbody>
<row>
<entry role="blurb">
<inlinemediaobject><imageobject><imagedata fileref="images/caution.png"></imagedata></imageobject></inlinemediaobject> The <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal> algorithm will only report success if the regex matches the <emphasis>whole input</emphasis>,
from beginning to end. If the regex matches only a part of the input, <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal> will return false. If you
want to search through the string looking for sub-strings that the regex matches, use the <literal><functionname alt="boost::xpressive::regex_search">regex_search()</functionname></literal>
algorithm.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>
The input can be a <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase></code>, a C-style null-terminated string or a pair of iterators. In all cases,
the type of the iterator used to traverse the input sequence must match the iterator type used to declare
the regex object. (You can use the table in the <link linkend="user_s_guide.quick_start.know_your_iterator_type">Quick Start</link> to
find the correct regex type for your iterator.)</para>
<programlisting>
<literal>
<phrase role="identifier">cregex</phrase><phrase role="identifier"> cre</phrase><phrase role="special"> =</phrase><phrase role="special"> +</phrase><phrase role="identifier">_w</phrase><phrase role="special">;</phrase><phrase role="comment">  // this regex can match C-style strings
</phrase><phrase role="identifier">sregex</phrase><phrase role="identifier"> sre</phrase><phrase role="special"> =</phrase><phrase role="special"> +</phrase><phrase role="identifier">_w</phrase><phrase role="special">;</phrase><phrase role="comment">  // this regex can match std::strings
</phrase><phrase role="keyword">
if</phrase><phrase role="special">(</phrase><phrase role="identifier"> regex_match</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;hello&quot;</phrase><phrase role="special">,</phrase><phrase role="identifier"> cre</phrase><phrase role="special"> )</phrase><phrase role="special"> )</phrase><phrase role="comment">              // OK
</phrase><phrase role="special">    {</phrase><phrase role="comment"> /*...*/</phrase><phrase role="special"> }</phrase><phrase role="keyword">

if</phrase><phrase role="special">(</phrase><phrase role="identifier"> regex_match</phrase><phrase role="special">(</phrase><phrase role="identifier"> std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">(</phrase><phrase role="string">&quot;hello&quot;</phrase><phrase role="special">),</phrase><phrase role="identifier"> sre</phrase><phrase role="special"> )</phrase><phrase role="special"> )</phrase><phrase role="comment"> // OK
</phrase><phrase role="special">    {</phrase><phrase role="comment"> /*...*/</phrase><phrase role="special"> }</phrase><phrase role="keyword"> 

if</phrase><phrase role="special">(</phrase><phrase role="identifier"> regex_match</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;hello&quot;</phrase><phrase role="special">,</phrase><phrase role="identifier"> sre</phrase><phrase role="special"> )</phrase><phrase role="special"> )</phrase><phrase role="comment">              // ERROR! iterator mis-match!
</phrase><phrase role="special">    {</phrase><phrase role="comment"> /*...*/</phrase><phrase role="special"> }</phrase>
</literal>
</programlisting>
<para>
The <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal> algorithm optionally accepts a <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> struct as an out parameter. If given, the <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal>
algorithm fills in the <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> struct with information about which parts of the regex matched which
parts of the input.</para>
<programlisting>
<literal>
<phrase role="identifier">cmatch</phrase><phrase role="identifier"> what</phrase><phrase role="special">;</phrase><phrase role="identifier">
cregex</phrase><phrase role="identifier"> cre</phrase><phrase role="special"> =</phrase><phrase role="special"> +(</phrase><phrase role="identifier">s1</phrase><phrase role="special">=</phrase><phrase role="identifier"> _w</phrase><phrase role="special">);</phrase><phrase role="comment">

// store the results of the regex_match in &quot;what&quot;
</phrase><phrase role="keyword">if</phrase><phrase role="special">(</phrase><phrase role="identifier"> regex_match</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;hello&quot;</phrase><phrase role="special">,</phrase><phrase role="identifier"> what</phrase><phrase role="special">,</phrase><phrase role="identifier"> cre</phrase><phrase role="special"> )</phrase><phrase role="special"> )</phrase><phrase role="special">
{</phrase><phrase role="identifier">
    std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="identifier"> what</phrase><phrase role="special">[</phrase><phrase role="number">1</phrase><phrase role="special">]</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="char"> '\n'</phrase><phrase role="special">;</phrase><phrase role="comment"> // prints &quot;o&quot;
</phrase><phrase role="special">}</phrase>
</literal>
</programlisting>
<para>
The <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal> algorithm also optionally accepts a <literal><enumname alt="boost::xpressive::regex_constants::match_flag_type">match_flag_type</enumname></literal> bitmask. With <literal><enumname alt="boost::xpressive::regex_constants::match_flag_type">match_flag_type</enumname></literal>, you can
control certain aspects of how the match is evaluated. See the <literal><enumname alt="boost::xpressive::regex_constants::match_flag_type">match_flag_type</enumname></literal> reference for a complete list
of the flags and their meanings.</para>
<programlisting>
<literal>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="identifier"> str</phrase><phrase role="special">(</phrase><phrase role="string">&quot;hello&quot;</phrase><phrase role="special">);</phrase><phrase role="identifier">
sregex</phrase><phrase role="identifier"> sre</phrase><phrase role="special"> =</phrase><phrase role="identifier"> bol</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="special"> +</phrase><phrase role="identifier">_w</phrase><phrase role="special">;</phrase><phrase role="comment">

// match_not_bol means that &quot;bol&quot; should not match at [begin,begin)
</phrase><phrase role="keyword">if</phrase><phrase role="special">(</phrase><phrase role="identifier"> regex_match</phrase><phrase role="special">(</phrase><phrase role="identifier"> str</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier"> str</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase><phrase role="identifier"> sre</phrase><phrase role="special">,</phrase><phrase role="identifier"> regex_constants</phrase><phrase role="special">::</phrase><phrase role="identifier">match_not_bol</phrase><phrase role="special"> )</phrase><phrase role="special"> )</phrase><phrase role="special">
{</phrase><phrase role="comment">
    // should never get here!!!
</phrase><phrase role="special">}</phrase>
</literal>
</programlisting>
<para>
Click <link linkend="user_s_guide.examples.see_if_a_whole_string_matches_a_regex">here</link> to see a complete example program that
shows how to use <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal>. And check the <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal> reference to see a complete list of the available
overloads.</para>
<anchor id="user_s_guide.matching_and_searching.searching_for_matching_sub_strings" /><bridgehead renderas="sect2">Searching for Matching Sub-Strings</bridgehead><para>
Use <literal><functionname alt="boost::xpressive::regex_search">regex_search()</functionname></literal> when you want to know if an input sequence contains a sub-sequence that a regex matches.
<literal><functionname alt="boost::xpressive::regex_search">regex_search()</functionname></literal> will try to match the regex at the beginning of the input sequence and scan forward in the
sequence until it either finds a match or exhausts the sequence.</para>
<para>
In all other regards, <literal><functionname alt="boost::xpressive::regex_search">regex_search()</functionname></literal> behaves like <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal> <emphasis>(see above)</emphasis>. In particular, it can operate on <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase></code>,
C-style null-terminated strings or iterator ranges. The same care must be taken to ensure that the iterator
type of your regex matches the iterator type of your input sequence. As with <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal>, you can optionally
provide a <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> struct to receive the results of the search, and a <literal><enumname alt="boost::xpressive::regex_constants::match_flag_type">match_flag_type</enumname></literal> bitmask to 
control how the match is evaluated.</para>
<para>
Click <link linkend="user_s_guide.examples.see_if_a_string_contains_a_sub_string_that_matches_a_regex">here</link> to see a complete
example program that shows how to use <literal><functionname alt="boost::xpressive::regex_search">regex_search()</functionname></literal>. And check the <literal><functionname alt="boost::xpressive::regex_search">regex_search()</functionname></literal> reference to see a complete
list of the available overloads.</para>
</section>
<section id="boost_xpressive.user_s_guide.accessing_results">
<title>Accessing Results</title>
<anchor id="user_s_guide.accessing_results.overview" /><bridgehead renderas="sect2">Overview</bridgehead><para>
Sometimes, it is not enough to know simply whether a <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal> or <literal><functionname alt="boost::xpressive::regex_search">regex_search()</functionname></literal> was successful or not. If
you pass an object of type <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> to <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal> or <literal><functionname alt="boost::xpressive::regex_search">regex_search()</functionname></literal>, then after the algorithm has completed
successfully the <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> will contain extra information about which parts of the regex matched which parts
of the sequence. In Perl, these sub-sequences are called <emphasis>back-references</emphasis>, and they are stored in the variables
<literal>$1</literal>, <literal>$2</literal>, etc. In xpressive, they are objects of type <literal><classname alt="boost::xpressive::sub_match">sub_match&lt;&gt;</classname></literal>, and they are stored in the <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal>
structure, which acts as a vector of <literal><classname alt="boost::xpressive::sub_match">sub_match&lt;&gt;</classname></literal> objects.</para>
<anchor id="user_s_guide.accessing_results.match_results" /><bridgehead renderas="sect2">match_results</bridgehead><para>
So, you've passed a <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> object to a regex algorithm, and the algorithm has succeeded. Now you want
to examine the results. Most of what you'll be doing with the <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> object is indexing into it to access
its internally stored <literal><classname alt="boost::xpressive::sub_match">sub_match&lt;&gt;</classname></literal> objects, but there are a few other things you can do with a <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal>
object besides.</para>
<para>
The table below shows how to access the information stored in a <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> object named <code><phrase role="identifier">what</phrase></code>.</para>
<informaltable frame="all">
<bridgehead renderas="sect4"><phrase role="table-title">match_results&lt;&gt; Accessors</phrase></bridgehead>
<tgroup cols="2">
<thead><row><entry>Accessor</entry><entry>Effects</entry></row>
</thead>
<tbody>
<row><entry><code><phrase role="identifier">what</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">()</phrase></code></entry><entry>Returns the number of sub-matches, which is always greater than zero after a successful match because the full match is stored in the zero-th sub-match.</entry></row>
<row><entry><code><phrase role="identifier">what</phrase><phrase role="special">[</phrase><phrase role="identifier">n</phrase><phrase role="special">]</phrase></code></entry><entry>Returns the <emphasis>n</emphasis>-th sub-match.</entry></row>
<row><entry><code><phrase role="identifier">what</phrase><phrase role="special">.</phrase><phrase role="identifier">length</phrase><phrase role="special">(</phrase><phrase role="identifier">n</phrase><phrase role="special">)</phrase></code></entry><entry>Returns the length of the <emphasis>n</emphasis>-th sub-match. Same as <code><phrase role="identifier">what</phrase><phrase role="special">[</phrase><phrase role="identifier">n</phrase><phrase role="special">].</phrase><phrase role="identifier">length</phrase><phrase role="special">()</phrase></code>.</entry></row>
<row><entry><code><phrase role="identifier">what</phrase><phrase role="special">.</phrase><phrase role="identifier">position</phrase><phrase role="special">(</phrase><phrase role="identifier">n</phrase><phrase role="special">)</phrase></code></entry><entry>Returns the offset into the input sequence at which the <emphasis>n</emphasis>-th sub-match begins.</entry></row>
<row><entry><code><phrase role="identifier">what</phrase><phrase role="special">.</phrase><phrase role="identifier">str</phrase><phrase role="special">(</phrase><phrase role="identifier">n</phrase><phrase role="special">)</phrase></code></entry><entry>Returns a <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_string</phrase><phrase role="special">&lt;&gt;</phrase></code> constructed from the <emphasis>n</emphasis>-th sub-match. Same as <code><phrase role="identifier">what</phrase><phrase role="special">[</phrase><phrase role="identifier">n</phrase><phrase role="special">].</phrase><phrase role="identifier">str</phrase><phrase role="special">()</phrase></code>.</entry></row>
<row><entry><code><phrase role="identifier">what</phrase><phrase role="special">.</phrase><phrase role="identifier">prefix</phrase><phrase role="special">()</phrase></code></entry><entry>Returns a <literal><classname alt="boost::xpressive::sub_match">sub_match&lt;&gt;</classname></literal> object which represents the sub-sequence from the beginning of the input sequence to the start of the full match.</entry></row>
<row><entry><code><phrase role="identifier">what</phrase><phrase role="special">.</phrase><phrase role="identifier">suffix</phrase><phrase role="special">()</phrase></code></entry><entry>Returns a <literal><classname alt="boost::xpressive::sub_match">sub_match&lt;&gt;</classname></literal> object which represents the sub-sequence from the end of the full match to the end of the input sequence.</entry></row>
<row><entry><code><phrase role="identifier">what</phrase><phrase role="special">.</phrase><phrase role="identifier">regex_id</phrase><phrase role="special">()</phrase></code></entry><entry>Returns the <code><phrase role="identifier">regex_id</phrase></code> of the <literal><classname alt="boost::xpressive::basic_regex">basic_regex&lt;&gt;</classname></literal> object that was last used with this <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> object.</entry></row>
</tbody>
</tgroup>
</informaltable>
<para>
There is more you can do with the <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> object, but that will be covered when we talk about
<link linkend="boost_xpressive.user_s_guide.grammars_and_nested_matches">Grammars and Nested Matches</link>.</para>
<anchor id="user_s_guide.accessing_results.sub_match" /><bridgehead renderas="sect2">sub_match</bridgehead><para>
When you index into a <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> object, you get back a <literal><classname alt="boost::xpressive::sub_match">sub_match&lt;&gt;</classname></literal> object. A <literal><classname alt="boost::xpressive::sub_match">sub_match&lt;&gt;</classname></literal> is basically a pair
of iterators. It is defined like this:</para>
<programlisting>
<literal>
<phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword"> class</phrase><phrase role="identifier"> BidirectionalIterator</phrase><phrase role="special"> &gt;</phrase><phrase role="keyword">
struct</phrase><phrase role="identifier"> sub_match</phrase><phrase role="special">
    :</phrase><phrase role="identifier"> std</phrase><phrase role="special">::</phrase><phrase role="identifier">pair</phrase><phrase role="special">&lt;</phrase><phrase role="identifier"> BidirectionalIterator</phrase><phrase role="special">,</phrase><phrase role="identifier"> BidirectionalIterator</phrase><phrase role="special"> &gt;</phrase><phrase role="special">
{</phrase><phrase role="keyword">
    bool</phrase><phrase role="identifier"> matched</phrase><phrase role="special">;</phrase><phrase role="comment">
    // ...
</phrase><phrase role="special">};</phrase>
</literal>
</programlisting>
<para>
Since it inherits publicaly from <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">pair</phrase><phrase role="special">&lt;&gt;</phrase></code>, <literal><classname alt="boost::xpressive::sub_match">sub_match&lt;&gt;</classname></literal> has <code><phrase role="identifier">first</phrase></code> and <code><phrase role="identifier">second</phrase></code> data members of type
<code><phrase role="identifier">BidirectionalIterator</phrase></code>. These are the beginning and end of the sub-sequence this <literal><classname alt="boost::xpressive::sub_match">sub_match&lt;&gt;</classname></literal> represents.
<literal><classname alt="boost::xpressive::sub_match">sub_match&lt;&gt;</classname></literal> also has a Boolean <code><phrase role="identifier">matched</phrase></code> data member, which is true if this <literal><classname alt="boost::xpressive::sub_match">sub_match&lt;&gt;</classname></literal> participated in the full
match.</para>
<para>
The following table shows how you might access the information stored in a <literal><classname alt="boost::xpressive::sub_match">sub_match&lt;&gt;</classname></literal> object called <code><phrase role="identifier">sub</phrase></code>.</para>
<informaltable frame="all">
<bridgehead renderas="sect4"><phrase role="table-title">sub_match&lt;&gt; Accessors</phrase></bridgehead>
<tgroup cols="2">
<thead><row><entry>Accessor</entry><entry>Effects</entry></row>
</thead>
<tbody>
<row><entry><code><phrase role="identifier">sub</phrase><phrase role="special">.</phrase><phrase role="identifier">length</phrase><phrase role="special">()</phrase></code></entry><entry>Returns the length of the sub-match. Same as <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">distance</phrase><phrase role="special">(</phrase><phrase role="identifier">sub</phrase><phrase role="special">.</phrase><phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">sub</phrase><phrase role="special">.</phrase><phrase role="identifier">second</phrase><phrase role="special">)</phrase></code>.</entry></row>
<row><entry><code><phrase role="identifier">sub</phrase><phrase role="special">.</phrase><phrase role="identifier">str</phrase><phrase role="special">()</phrase></code></entry><entry>Returns a <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_string</phrase><phrase role="special">&lt;&gt;</phrase></code> constructed from the sub-match. Same as <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_string</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">char_type</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">sub</phrase><phrase role="special">.</phrase><phrase role="identifier">first</phrase><phrase role="special">,</phrase><phrase role="identifier">sub</phrase><phrase role="special">.</phrase><phrase role="identifier">second</phrase><phrase role="special">)</phrase></code>.</entry></row>
<row><entry><code><phrase role="identifier">sub</phrase><phrase role="special">.</phrase><phrase role="identifier">compare</phrase><phrase role="special">(</phrase><phrase role="identifier">str</phrase><phrase role="special">)</phrase></code></entry><entry>Performs a string comparison between the sub-match and <code><phrase role="identifier">str</phrase></code>, where <code><phrase role="identifier">str</phrase></code> can be a <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_string</phrase><phrase role="special">&lt;&gt;</phrase></code>, C-style null-terminated string, or another sub-match. Same as <code><phrase role="identifier">sub</phrase><phrase role="special">.</phrase><phrase role="identifier">str</phrase><phrase role="special">().</phrase><phrase role="identifier">compare</phrase><phrase role="special">(</phrase><phrase role="identifier">str</phrase><phrase role="special">)</phrase></code>.</entry></row>
</tbody>
</tgroup>
</informaltable>
<anchor id="user_s_guide.accessing_results._inlinemediaobject__imageobject__imagedata_fileref__images_caution_png____imagedata___imageobject___inlinemediaobject__results_invalidation__inlinemediaobject__imageobject__imagedata_fileref__images_caution_png____imagedata___imageobject___inlinemediaobject_" /><bridgehead renderas="sect2"><inlinemediaobject><imageobject><imagedata fileref="images/caution.png"></imagedata></imageobject></inlinemediaobject> Results Invalidation <inlinemediaobject><imageobject><imagedata fileref="images/caution.png"></imagedata></imageobject></inlinemediaobject></bridgehead><para>
Results are stored as iterators into the input sequence. Anything which invalidates
the input sequence will invalidate the match results. For instance, if you match a <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase></code> object,
the results are only valid until your next call to a non-const member function of that <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase></code> object.
After that, the results held by the <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> object are invalid. Don't use them!</para>
</section>
<section id="boost_xpressive.user_s_guide.string_substitutions">
<title>String Substitutions</title>
<para>
Regular expressions are not only good for searching text; they're good at <emphasis>manipulating</emphasis> it. And one of the most
common text manipulation tasks is search-and-replace. xpressive provides the <literal><functionname alt="boost::xpressive::regex_replace">regex_replace()</functionname></literal> algorithm for
searching and replacing.</para>
<anchor id="user_s_guide.string_substitutions.regex_replace__" /><bridgehead renderas="sect2">regex_replace()</bridgehead><para>
Performing search-and-replace using <literal><functionname alt="boost::xpressive::regex_replace">regex_replace()</functionname></literal> is simple. All you need is an input sequence, a regex object,
and a format string. There are two versions of the <literal><functionname alt="boost::xpressive::regex_replace">regex_replace()</functionname></literal> algorithm. The first accepts the input
sequence as <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_string</phrase><phrase role="special">&lt;&gt;</phrase></code> and returns the result in a new <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_string</phrase><phrase role="special">&lt;&gt;</phrase></code>. The second accepts
the input sequence as a pair of iterators, and writes the result into an output iterator. Below are examples of
each.</para>
<programlisting>
<literal>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="identifier"> input</phrase><phrase role="special">(</phrase><phrase role="string">&quot;This is his face&quot;</phrase><phrase role="special">);</phrase><phrase role="identifier">
sregex</phrase><phrase role="identifier"> re</phrase><phrase role="special"> =</phrase><phrase role="identifier"> as_xpr</phrase><phrase role="special">(</phrase><phrase role="string">&quot;his&quot;</phrase><phrase role="special">);</phrase><phrase role="comment">                // find all occurrences of &quot;his&quot; ...
</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="identifier"> format</phrase><phrase role="special">(</phrase><phrase role="string">&quot;her&quot;</phrase><phrase role="special">);</phrase><phrase role="comment">                // ... and replace them with &quot;her&quot;

// use the version of regex_replace() that operates on strings
</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="identifier"> output</phrase><phrase role="special"> =</phrase><phrase role="identifier"> regex_replace</phrase><phrase role="special">(</phrase><phrase role="identifier"> input</phrase><phrase role="special">,</phrase><phrase role="identifier"> re</phrase><phrase role="special">,</phrase><phrase role="identifier"> format</phrase><phrase role="special"> );</phrase><phrase role="identifier">
std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="identifier"> output</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="char"> '\n'</phrase><phrase role="special">;</phrase><phrase role="comment">

// use the version of regex_replace() that operates on iterators
</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="keyword"> char</phrase><phrase role="special"> &gt;</phrase><phrase role="identifier"> out_iter</phrase><phrase role="special">(</phrase><phrase role="identifier"> std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> );</phrase><phrase role="identifier">
regex_replace</phrase><phrase role="special">(</phrase><phrase role="identifier"> out_iter</phrase><phrase role="special">,</phrase><phrase role="identifier"> input</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier"> input</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase><phrase role="identifier"> re</phrase><phrase role="special">,</phrase><phrase role="identifier"> format</phrase><phrase role="special"> );</phrase>
</literal>
</programlisting>
<para>
The above program prints out the following:</para>
<programlisting><literal>Ther is her face
Ther is her face
</literal></programlisting><para>
Notice that <emphasis>all</emphasis> the occurrences of <code><phrase role="string">&quot;his&quot;</phrase></code> have been replaced with <code><phrase role="string">&quot;her&quot;</phrase></code>.</para>
<para>
Click <link linkend="user_s_guide.examples.replace_all_sub_strings_that_match_a_regex">here</link> to see a complete
example program that shows how to use <literal><functionname alt="boost::xpressive::regex_replace">regex_replace()</functionname></literal>. And check the <literal><functionname alt="boost::xpressive::regex_replace">regex_replace()</functionname></literal> reference
to see a complete list of the available overloads.</para>
<anchor id="user_s_guide.string_substitutions.the_format_string" /><bridgehead renderas="sect2">The Format String</bridgehead><para>
As with Perl, you can refer to sub-matches in the format string. The table below shows the escape sequences
xpressive recognizes in the format string.</para>
<informaltable frame="all">
<bridgehead renderas="sect4"><phrase role="table-title">Format Escape Sequences</phrase></bridgehead>
<tgroup cols="2">
<thead><row><entry>Escape Sequence</entry><entry>Meaning</entry></row>
</thead>
<tbody>
<row><entry><literal>$1</literal></entry><entry>the first sub-match</entry></row>
<row><entry><literal>$2</literal></entry><entry>the second sub-match (etc.)</entry></row>
<row><entry><literal>$&amp;</literal></entry><entry>the full match</entry></row>
<row><entry><literal>$`</literal></entry><entry>the match prefix</entry></row>
<row><entry><literal>$'</literal></entry><entry>the match suffix</entry></row>
<row><entry><literal>$$</literal></entry><entry>a literal <code><phrase role="char">'$'</phrase></code> character</entry></row>
</tbody>
</tgroup>
</informaltable>
<para>
Any other sequence beginning with <code><phrase role="char">'$'</phrase></code> simply represents itself. For example, if the format string were
<code><phrase role="string">&quot;$a&quot;</phrase></code> then <code><phrase role="string">&quot;$a&quot;</phrase></code> would be inserted into the output sequence.</para>
<anchor id="user_s_guide.string_substitutions.replace_options" /><bridgehead renderas="sect2">Replace Options</bridgehead><para>
The <literal><functionname alt="boost::xpressive::regex_replace">regex_replace()</functionname></literal> algorithm takes an optional bitmask parameter to control the formatting. The
possible values of the bitmask are:</para>
<informaltable frame="all">
<bridgehead renderas="sect4"><phrase role="table-title">Format Flags</phrase></bridgehead>
<tgroup cols="2">
<thead><row><entry>Flag</entry><entry>Meaning</entry></row>
</thead>
<tbody>
<row><entry><code><phrase role="identifier">format_first_only</phrase></code></entry><entry>Only replace the first match, not all of them.</entry></row>
<row><entry><code><phrase role="identifier">format_no_copy</phrase></code></entry><entry>Don't copy the parts of the input sequence that didn't match the regex to the output sequence.</entry></row>
<row><entry><code><phrase role="identifier">format_literal</phrase></code></entry><entry>Treat the format string as a literal; that is, don't recognize any escape sequences.</entry></row>
</tbody>
</tgroup>
</informaltable>
<para>
These flags live in the <code><phrase role="identifier">regex_constants</phrase></code> namespace.</para>
</section>
<section id="boost_xpressive.user_s_guide.string_splitting_and_tokenization">
<title>String Splitting and Tokenization</title>
<para>
<literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal> is the Ginsu knife of the text manipulation world. It slices! It dices! This section describes
how to use the highly-configurable <literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal> to chop up input sequences.</para>
<anchor id="user_s_guide.string_splitting_and_tokenization.overview" /><bridgehead renderas="sect2">Overview</bridgehead><para>
You initialize a <literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal> with an input sequence, a regex, and some optional configuration parameters.
The <literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal> will use <literal><functionname alt="boost::xpressive::regex_search">regex_search()</functionname></literal> to find the first place in the sequence that the regex matches. When
dereferenced, the <literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal> returns a <emphasis>token</emphasis> in the form of a <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_string</phrase><phrase role="special">&lt;&gt;</phrase></code>. Which string it returns
depends on the configuration parameters. By default it returns a string corresponding to the full match, but it could also
return a string corresponding to a particular marked sub-expression, or even the part of the sequence that <emphasis>didn't</emphasis> match.
When you increment the <literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal>, it will move to the next token. Which token is next depends on the configuration
parameters. It could simply be a different marked sub-expression in the current match, or it could be part or all of the
next match. Or it could be the part that <emphasis>didn't</emphasis> match.</para>
<para>
As you can see, <literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal> can do a lot. That makes it hard to describe, but some examples should make it clear.</para>
<anchor id="user_s_guide.string_splitting_and_tokenization.example_1__simple_tokenization" /><bridgehead renderas="sect2">Example 1: Simple Tokenization</bridgehead><para>
This example uses <literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal> to chop a sequence into a series of tokens consisting of words.</para>
<programlisting>
<literal>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="identifier"> input</phrase><phrase role="special">(</phrase><phrase role="string">&quot;This is his face&quot;</phrase><phrase role="special">);</phrase><phrase role="identifier">
sregex</phrase><phrase role="identifier"> re</phrase><phrase role="special"> =</phrase><phrase role="special"> +</phrase><phrase role="identifier">_w</phrase><phrase role="special">;</phrase><phrase role="comment">                      // find a word

// iterate over all the words in the input
</phrase><phrase role="identifier">sregex_token_iterator</phrase><phrase role="identifier"> begin</phrase><phrase role="special">(</phrase><phrase role="identifier"> input</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier"> input</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase><phrase role="identifier"> re</phrase><phrase role="special"> ),</phrase><phrase role="identifier"> end</phrase><phrase role="special">;</phrase><phrase role="comment">

// write all the words to std::cout
</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier"> std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special"> &gt;</phrase><phrase role="identifier"> out_iter</phrase><phrase role="special">(</phrase><phrase role="identifier"> std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">,</phrase><phrase role="string"> &quot;\n&quot;</phrase><phrase role="special"> );</phrase><phrase role="identifier">
std</phrase><phrase role="special">::</phrase><phrase role="identifier">copy</phrase><phrase role="special">(</phrase><phrase role="identifier"> begin</phrase><phrase role="special">,</phrase><phrase role="identifier"> end</phrase><phrase role="special">,</phrase><phrase role="identifier"> out_iter</phrase><phrase role="special"> );</phrase>
</literal>
</programlisting>
<para>
This program displays the following:</para>
<programlisting><literal>This
is
his
face
</literal></programlisting><anchor id="user_s_guide.string_splitting_and_tokenization.example_2__simple_tokenization__reloaded" /><bridgehead renderas="sect2">Example 2: Simple Tokenization, Reloaded</bridgehead><para>
This example also uses <literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal> to chop a sequence into a series of tokens consisting of words,
but it uses the regex as a delimiter. When we pass a <code><phrase role="special">-</phrase><phrase role="number">1</phrase></code> as the last parameter to the <literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal> 
constructor, it instructs the token iterator to consider as tokens those parts of the input that <emphasis>didn't</emphasis>
match the regex.</para>
<programlisting>
<literal>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="identifier"> input</phrase><phrase role="special">(</phrase><phrase role="string">&quot;This is his face&quot;</phrase><phrase role="special">);</phrase><phrase role="identifier">
sregex</phrase><phrase role="identifier"> re</phrase><phrase role="special"> =</phrase><phrase role="special"> +</phrase><phrase role="identifier">_s</phrase><phrase role="special">;</phrase><phrase role="comment">                      // find white space

// iterate over all non-white space in the input. Note the -1 below:
</phrase><phrase role="identifier">sregex_token_iterator</phrase><phrase role="identifier"> begin</phrase><phrase role="special">(</phrase><phrase role="identifier"> input</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier"> input</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase><phrase role="identifier"> re</phrase><phrase role="special">,</phrase><phrase role="special"> -</phrase><phrase role="number">1</phrase><phrase role="special"> ),</phrase><phrase role="identifier"> end</phrase><phrase role="special">;</phrase><phrase role="comment">

// write all the words to std::cout
</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier"> std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special"> &gt;</phrase><phrase role="identifier"> out_iter</phrase><phrase role="special">(</phrase><phrase role="identifier"> std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">,</phrase><phrase role="string"> &quot;\n&quot;</phrase><phrase role="special"> );</phrase><phrase role="identifier">
std</phrase><phrase role="special">::</phrase><phrase role="identifier">copy</phrase><phrase role="special">(</phrase><phrase role="identifier"> begin</phrase><phrase role="special">,</phrase><phrase role="identifier"> end</phrase><phrase role="special">,</phrase><phrase role="identifier"> out_iter</phrase><phrase role="special"> );</phrase>
</literal>
</programlisting>
<para>
This program displays the following:</para>
<programlisting><literal>This
is
his
face
</literal></programlisting><anchor id="user_s_guide.string_splitting_and_tokenization.example_3__simple_tokenization__revolutions" /><bridgehead renderas="sect2">Example 3: Simple Tokenization, Revolutions</bridgehead><para>
This example also uses <literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal> to chop a sequence containing a bunch of dates into a series of
tokens consisting of just the years. When we pass a positive integer <literal><emphasis>N</emphasis></literal> as the last parameter to the
<literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal> constructor, it instructs the token iterator to consider as tokens only the <literal><emphasis>N</emphasis></literal>-th
marked sub-expression of each match.</para>
<programlisting>
<literal>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="identifier"> input</phrase><phrase role="special">(</phrase><phrase role="string">&quot;01/02/2003 blahblah 04/23/1999 blahblah 11/13/1981&quot;</phrase><phrase role="special">);</phrase><phrase role="identifier">
sregex</phrase><phrase role="identifier"> re</phrase><phrase role="special"> =</phrase><phrase role="identifier"> sregex</phrase><phrase role="special">::</phrase><phrase role="identifier">compile</phrase><phrase role="special">(</phrase><phrase role="string">&quot;(\\d{2})/(\\d{2})/(\\d{4})&quot;</phrase><phrase role="special">);</phrase><phrase role="comment"> // find a date

// iterate over all the years in the input. Note the 3 below, corresponding to the 3rd sub-expression:
</phrase><phrase role="identifier">sregex_token_iterator</phrase><phrase role="identifier"> begin</phrase><phrase role="special">(</phrase><phrase role="identifier"> input</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier"> input</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase><phrase role="identifier"> re</phrase><phrase role="special">,</phrase><phrase role="number"> 3</phrase><phrase role="special"> ),</phrase><phrase role="identifier"> end</phrase><phrase role="special">;</phrase><phrase role="comment">

// write all the words to std::cout
</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier"> std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special"> &gt;</phrase><phrase role="identifier"> out_iter</phrase><phrase role="special">(</phrase><phrase role="identifier"> std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">,</phrase><phrase role="string"> &quot;\n&quot;</phrase><phrase role="special"> );</phrase><phrase role="identifier">
std</phrase><phrase role="special">::</phrase><phrase role="identifier">copy</phrase><phrase role="special">(</phrase><phrase role="identifier"> begin</phrase><phrase role="special">,</phrase><phrase role="identifier"> end</phrase><phrase role="special">,</phrase><phrase role="identifier"> out_iter</phrase><phrase role="special"> );</phrase>
</literal>
</programlisting>
<para>
This program displays the following:</para>
<programlisting><literal>2003
1999
1981
</literal></programlisting><anchor id="user_s_guide.string_splitting_and_tokenization.example_4__not_so_simple_tokenization" /><bridgehead renderas="sect2">Example 4: Not-So-Simple Tokenization</bridgehead><para>
This example is like the previous one, except that instead of tokenizing just the years, this program
turns the days, months and years into tokens. When we pass an array of integers <literal><emphasis>{I,J,...}</emphasis></literal> as the last
parameter to the <literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal> constructor, it instructs the token iterator to consider as tokens the
<literal><emphasis>I</emphasis></literal>-th, <literal><emphasis>J</emphasis></literal>-th, etc. marked sub-expression of each match.</para>
<programlisting>
<literal>
<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="identifier"> input</phrase><phrase role="special">(</phrase><phrase role="string">&quot;01/02/2003 blahblah 04/23/1999 blahblah 11/13/1981&quot;</phrase><phrase role="special">);</phrase><phrase role="identifier">
sregex</phrase><phrase role="identifier"> re</phrase><phrase role="special"> =</phrase><phrase role="identifier"> sregex</phrase><phrase role="special">::</phrase><phrase role="identifier">compile</phrase><phrase role="special">(</phrase><phrase role="string">&quot;(\\d{2})/(\\d{2})/(\\d{4})&quot;</phrase><phrase role="special">);</phrase><phrase role="comment"> // find a date

// iterate over the days, months and years in the input
</phrase><phrase role="keyword">int</phrase><phrase role="keyword"> const</phrase><phrase role="identifier"> sub_matches</phrase><phrase role="special">[]</phrase><phrase role="special"> =</phrase><phrase role="special"> {</phrase><phrase role="number"> 2</phrase><phrase role="special">,</phrase><phrase role="number"> 1</phrase><phrase role="special">,</phrase><phrase role="number"> 3</phrase><phrase role="special"> };</phrase><phrase role="comment"> // day, month, year
</phrase><phrase role="identifier">sregex_token_iterator</phrase><phrase role="identifier"> begin</phrase><phrase role="special">(</phrase><phrase role="identifier"> input</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier"> input</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase><phrase role="identifier"> re</phrase><phrase role="special">,</phrase><phrase role="identifier"> sub_matches</phrase><phrase role="special"> ),</phrase><phrase role="identifier"> end</phrase><phrase role="special">;</phrase><phrase role="comment">

// write all the words to std::cout
</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier"> std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special"> &gt;</phrase><phrase role="identifier"> out_iter</phrase><phrase role="special">(</phrase><phrase role="identifier"> std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">,</phrase><phrase role="string"> &quot;\n&quot;</phrase><phrase role="special"> );</phrase><phrase role="identifier">
std</phrase><phrase role="special">::</phrase><phrase role="identifier">copy</phrase><phrase role="special">(</phrase><phrase role="identifier"> begin</phrase><phrase role="special">,</phrase><phrase role="identifier"> end</phrase><phrase role="special">,</phrase><phrase role="identifier"> out_iter</phrase><phrase role="special"> );</phrase>
</literal>
</programlisting>
<para>
This program displays the following:</para>
<programlisting><literal>02
01
2003
23
04
1999
13
11
1981
</literal></programlisting><para>
The <code><phrase role="identifier">sub_matches</phrase></code> array instructs the <literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal> to first take the value of the 2nd sub-match, then
the 1st sub-match, and finally the 3rd. Incrementing the iterator again instructs it to use <literal><functionname alt="boost::xpressive::regex_search">regex_search()</functionname></literal> again
to find the next match. At that point, the process repeats -- the token iterator takes the value of the 2nd
sub-match, then the 1st, et cetera.</para>
</section>
<section id="boost_xpressive.user_s_guide.grammars_and_nested_matches">
<title>Grammars and Nested Matches</title>
<anchor id="user_s_guide.grammars_and_nested_matches.overview" /><bridgehead renderas="sect2">Overview</bridgehead><para>
One of the key benefits of representing regexes as C++ expressions is the ability to easily refer to other C++
code and data from within the regex. This enables programming idioms that are not possible with other regular
expression libraries. Of particular note is the ability for one regex to refer to another regex, allowing you
to build grammars out of regular expressions. This section describes how to embed one regex in another by value
and by reference, how regex objects behave when they refer to other regexes, and how to access the tree of results
after a successful parse.</para>
<anchor id="user_s_guide.grammars_and_nested_matches.embedding_a_regex_by_value" /><bridgehead renderas="sect2">Embedding a Regex by Value</bridgehead><para>
The <literal><classname alt="boost::xpressive::basic_regex">basic_regex&lt;&gt;</classname></literal> object has value semantics. When a regex object appears on the right-hand side in the definition
of another regex, it is as if the regex were embedded by value; that is, a copy of the nested regex is stored by
the enclosing regex. The inner regex is invoked by the outer regex during pattern matching. The inner regex
participates fully in the match, back-tracking as needed to make the match succeed.</para>
<para>
Consider a text editor that has a regex-find feature with a whole-word option. You can implement this with
xpressive as follows:</para>
<programlisting>
<literal>
<phrase role="identifier">find_dialog</phrase><phrase role="identifier"> dlg</phrase><phrase role="special">;</phrase><phrase role="keyword">
if</phrase><phrase role="special">(</phrase><phrase role="identifier"> dialog_ok</phrase><phrase role="special"> ==</phrase><phrase role="identifier"> dlg</phrase><phrase role="special">.</phrase><phrase role="identifier">do_modal</phrase><phrase role="special">()</phrase><phrase role="special"> )</phrase><phrase role="special">
{</phrase><phrase role="identifier">
    std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="identifier"> pattern</phrase><phrase role="special"> =</phrase><phrase role="identifier"> dlg</phrase><phrase role="special">.</phrase><phrase role="identifier">get_text</phrase><phrase role="special">();</phrase><phrase role="comment">          // the pattern the user entered
</phrase><phrase role="keyword">    bool</phrase><phrase role="identifier"> whole_word</phrase><phrase role="special"> =</phrase><phrase role="identifier"> dlg</phrase><phrase role="special">.</phrase><phrase role="identifier">whole_word</phrase><phrase role="special">.</phrase><phrase role="identifier">is_checked</phrase><phrase role="special">();</phrase><phrase role="comment"> // did the user select the whole-word option?
</phrase><phrase role="identifier">
    sregex</phrase><phrase role="identifier"> re</phrase><phrase role="special"> =</phrase><phrase role="identifier"> sregex</phrase><phrase role="special">::</phrase><phrase role="identifier">compile</phrase><phrase role="special">(</phrase><phrase role="identifier"> pattern</phrase><phrase role="special"> );</phrase><phrase role="comment">        // try to compile the pattern
</phrase><phrase role="keyword">
    if</phrase><phrase role="special">(</phrase><phrase role="identifier"> whole_word</phrase><phrase role="special"> )</phrase><phrase role="special">
    {</phrase><phrase role="comment">
        // wrap the regex in begin-word / end-word assertions
</phrase><phrase role="identifier">        re</phrase><phrase role="special"> =</phrase><phrase role="identifier"> bow</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> re</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> eow</phrase><phrase role="special">;</phrase><phrase role="special">
    }</phrase><phrase role="comment">

    // ... use re ...
</phrase><phrase role="special">}</phrase>
</literal>
</programlisting>
<para>
Look closely at this line:</para>
<programlisting>
<literal>
<phrase role="comment">// wrap the regex in begin-word / end-word assertions
</phrase><phrase role="identifier">re</phrase><phrase role="special"> =</phrase><phrase role="identifier"> bow</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> re</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> eow</phrase><phrase role="special">;</phrase>
</literal>
</programlisting>
<para>
This line creates a new regex that embeds the old regex by value. Then, the new regex is assigned back to
the original regex. Since a copy of the old regex was made on the right-hand side, this works as you might
expect: the new regex has the behavior of the old regex wrapped in begin- and end-word assertions.</para>
<informaltable frame="all">
<?dbhtml table-width="74%" ?>
<tgroup cols="1">
<tbody>
<row>
<entry role="blurb">
<inlinemediaobject><imageobject><imagedata fileref="images/note.png"></imagedata></imageobject></inlinemediaobject> Note that <code><phrase role="identifier">re</phrase><phrase role="special"> =</phrase><phrase role="identifier"> bow</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> re</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> eow</phrase></code> does <emphasis>not</emphasis> define a recursive regular expression, since regex
objects embed by value by default. The next section shows how to define a recursive regular expression by
embedding a regex by reference.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<anchor id="user_s_guide.grammars_and_nested_matches.embedding_a_regex_by_reference" /><bridgehead renderas="sect2">Embedding a Regex by Reference</bridgehead><para>
If you want to be able to build recursive regular expressions and context-free grammars, embedding a regex
by value is not enough. You need to be able to make your regular expressions self-referential. Most regular
expression engines don't give you that power, but xpressive does.</para>
<informaltable frame="all">
<?dbhtml table-width="74%" ?>
<tgroup cols="1">
<tbody>
<row>
<entry role="blurb">
<inlinemediaobject><imageobject><imagedata fileref="images/note.png"></imagedata></imageobject></inlinemediaobject> The theoretical computer scientists out there will correctly point out that a self-referential
regular expression is not &quot;regular&quot;, so in the strict sense, xpressive isn't really a <emphasis>regular</emphasis> expression engine
at all. But as Larry Wall once said, &quot;the term [regular expression] has grown with the capabilities of our
pattern matching engines, so I'm not going to try to fight linguistic necessity here.&quot;</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>
Consider the following code, which uses the <code><phrase role="identifier">by_ref</phrase><phrase role="special">()</phrase></code> helper to define a recursive regular expression that
matches balanced, nested parentheses:</para>
<programlisting>
<literal>
<phrase role="identifier">sregex</phrase><phrase role="identifier"> parentheses</phrase><phrase role="special">;</phrase><phrase role="identifier">
parentheses</phrase><phrase role="comment">                          // A balanced set of parentheses ...
</phrase><phrase role="special">    =</phrase><phrase role="char"> '('</phrase><phrase role="comment">                            // is an opening parenthesis ...
</phrase><phrase role="special">        &gt;&gt;</phrase><phrase role="comment">                           // followed by ...
</phrase><phrase role="special">         *(</phrase><phrase role="comment">                          // zero or more ...
</phrase><phrase role="identifier">            keep</phrase><phrase role="special">(</phrase><phrase role="special"> +~(</phrase><phrase role="identifier">set</phrase><phrase role="special">=</phrase><phrase role="char">'('</phrase><phrase role="special">,</phrase><phrase role="char">')'</phrase><phrase role="special">)</phrase><phrase role="special"> )</phrase><phrase role="comment">  // of a bunch of things that are not parentheses ...
</phrase><phrase role="special">          |</phrase><phrase role="comment">                          // or ...
</phrase><phrase role="identifier">            by_ref</phrase><phrase role="special">(</phrase><phrase role="identifier">parentheses</phrase><phrase role="special">)</phrase><phrase role="comment">      // a balanced set of parentheses
</phrase><phrase role="special">          )</phrase><phrase role="comment">                          //   (ooh, recursion!) ...
</phrase><phrase role="special">        &gt;&gt;</phrase><phrase role="comment">                           // followed by ...
</phrase><phrase role="char">      ')'</phrase><phrase role="comment">                            // a closing parenthesis
</phrase><phrase role="special">    ;</phrase>
</literal>
</programlisting>
<para>
Matching balanced, nested tags is an important text processing task, and it is one that &quot;classic&quot; regular
expressions cannot do. The <code><phrase role="identifier">by_ref</phrase><phrase role="special">()</phrase></code> helper makes it possible. It allows one regex object to be embedded
in another <emphasis>by reference</emphasis>. Since the right-hand side holds <code><phrase role="identifier">parentheses</phrase></code> by reference, assigning the right-hand
side back to <code><phrase role="identifier">parentheses</phrase></code> creates a cycle, which will execute recursively.</para>
<anchor id="user_s_guide.grammars_and_nested_matches.building_a_grammar" /><bridgehead renderas="sect2">Building a Grammar</bridgehead><para>
Once we allow self-reference in our regular expressions, the genie is out of the bottle and all manner of
fun things are possible. In particular, we can now build grammars out of regular expressions. Let's have
a look at the text-book grammar example: the humble calculator.</para>
<programlisting>
<literal>
<phrase role="identifier">sregex</phrase><phrase role="identifier"> group</phrase><phrase role="special">,</phrase><phrase role="identifier"> factor</phrase><phrase role="special">,</phrase><phrase role="identifier"> term</phrase><phrase role="special">,</phrase><phrase role="identifier"> expression</phrase><phrase role="special">;</phrase><phrase role="identifier">

group</phrase><phrase role="special">       =</phrase><phrase role="char"> '('</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> by_ref</phrase><phrase role="special">(</phrase><phrase role="identifier">expression</phrase><phrase role="special">)</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="char"> ')'</phrase><phrase role="special">;</phrase><phrase role="identifier">
factor</phrase><phrase role="special">      =</phrase><phrase role="special"> +</phrase><phrase role="identifier">_d</phrase><phrase role="special"> |</phrase><phrase role="identifier"> group</phrase><phrase role="special">;</phrase><phrase role="identifier">
term</phrase><phrase role="special">        =</phrase><phrase role="identifier"> factor</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="special"> *((</phrase><phrase role="char">'*'</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> factor</phrase><phrase role="special">)</phrase><phrase role="special"> |</phrase><phrase role="special"> (</phrase><phrase role="char">'/'</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> factor</phrase><phrase role="special">));</phrase><phrase role="identifier">
expression</phrase><phrase role="special">  =</phrase><phrase role="identifier"> term</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="special"> *((</phrase><phrase role="char">'+'</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> term</phrase><phrase role="special">)</phrase><phrase role="special"> |</phrase><phrase role="special"> (</phrase><phrase role="char">'-'</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> term</phrase><phrase role="special">));</phrase>
</literal>
</programlisting>
<para>
The regex <code><phrase role="identifier">expression</phrase></code> defined above does something rather remarkable for a regular expression: it matches
mathematical expressions. For example, if the input string were <code><phrase role="string">&quot;foo 9*(10+3) bar&quot;</phrase></code>, this pattern would
match <code><phrase role="string">&quot;9*(10+3)&quot;</phrase></code>. It only matches well-formed mathematical expressions, where the parentheses are
balanced and the infix operators have two arguments each. Don't try this with just any regular expression
engine!</para>
<informaltable frame="all">
<?dbhtml table-width="74%" ?>
<tgroup cols="1">
<tbody>
<row>
<entry role="blurb">
<inlinemediaobject><imageobject><imagedata fileref="images/note.png"></imagedata></imageobject></inlinemediaobject> There is no way for a dynamic regex to refer to other regexes, so they can only
be used as terminals in a grammar. Use static regexes for non-terminal grammar rules.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<para>
Let's take a closer look at this regular expression grammar. Notice that it is cyclic: <code><phrase role="identifier">expression</phrase></code> is
implemented in terms of <code><phrase role="identifier">term</phrase></code>, which is implemented in terms of <code><phrase role="identifier">factor</phrase></code>, which is implemented in terms
of <code><phrase role="identifier">group</phrase></code>, which is implemented in terms of <code><phrase role="identifier">expression</phrase></code>, closing the loop. In general, the way to define
a cyclic grammar is to forward-declare the regex objects and embed by reference those regular expressions
that have not yet been initialized. In the above grammar, there is only one place where we need to reference
a regex object that has not yet been initialized: the definition of <code><phrase role="identifier">group</phrase></code>. In that place, we use
<code><phrase role="identifier">by_ref</phrase><phrase role="special">()</phrase></code> to embed <code><phrase role="identifier">expression</phrase></code> by reference. In all other places, it is sufficient to embed the other
regex objects by value, since they have already been initialized and their values will not change.</para>
<informaltable frame="all">
<?dbhtml table-width="74%" ?>
<tgroup cols="1">
<tbody>
<row>
<entry role="blurb">
<inlinemediaobject><imageobject><imagedata fileref="images/tip.png"></imagedata></imageobject></inlinemediaobject> <emphasis role="bold">Embed by value if possible</emphasis>
<sbr/>
<sbr/>

In general, prefer embedding regular expressions by value rather than by reference. It
involves one less indirection, making your patterns match a little faster. Besides, value semantics
are simpler and will make your grammars easier to reason about. Don't worry about the expense of &quot;copying&quot;
a regex. Each regex object shares its implementation with all of its copies.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<anchor id="user_s_guide.grammars_and_nested_matches.cyclic_patterns__copying_and_memory_management__oh_my_" /><bridgehead renderas="sect2">Cyclic Patterns, Copying and Memory Management, Oh My!</bridgehead><para>
The calculator example above raises a number of very complicated memory-management issues. Each of the
four regex objects refer to each other, some directly and some indirectly, some by value and some by
reference. What if we were to return one of them from a function and let the others go out of scope?
What becomes of the references? The answer is that the regex objects are internally reference counted,
such that they keep their referenced regex objects alive as long as they need them. So passing a regex
object by value is never a problem, even if it refers to other regex objects that have gone out of scope.</para>
<para>
Those of you who have dealt with reference counting are probably familiar with its Achilles Heel: cyclic
references. If regex objects are reference counted, what happens to cycles like the one created in the
calculator example? Are they leaked? The answer is no, they are not leaked. The <literal><classname alt="boost::xpressive::basic_regex">basic_regex&lt;&gt;</classname></literal> object has some tricky
reference tracking code that ensures that even cyclic regex grammars are cleaned up when the last external
reference goes away. So don't worry about it. Create cyclic grammars, pass your regex objects around and
copy them all you want. It is fast and efficient and guaranteed not to leak or result in dangling references.</para>
<anchor id="user_s_guide.grammars_and_nested_matches.nested_regexes_and_sub_match_scoping" /><bridgehead renderas="sect2">Nested Regexes and Sub-Match Scoping</bridgehead><para>
Nested regular expressions raise the issue of sub-match scoping. If both the inner and outer regex write
to and read from the same sub-match vector, chaos would ensue. The inner regex would stomp on the
sub-matches written by the outer regex. For example, what does this do?</para>
<programlisting>
<literal>
<phrase role="identifier">sregex</phrase><phrase role="identifier"> inner</phrase><phrase role="special"> =</phrase><phrase role="identifier"> sregex</phrase><phrase role="special">::</phrase><phrase role="identifier">compile</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;(.)\\1&quot;</phrase><phrase role="special"> );</phrase><phrase role="identifier">
sregex</phrase><phrase role="identifier"> outer</phrase><phrase role="special"> =</phrase><phrase role="special"> (</phrase><phrase role="identifier">s1</phrase><phrase role="special">=</phrase><phrase role="identifier"> _</phrase><phrase role="special">)</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> inner</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> s1</phrase><phrase role="special">;</phrase>
</literal>
</programlisting>
<para>
The author probably didn't intend for the inner regex to overwrite the sub-match written by the outer
regex. The problem is particularly acute when the inner regex is accepted from the user as input. The
author has no way of knowing whether the inner regex will stomp the sub-match vector or not. This is
clearly not acceptable.</para>
<para>
Instead, what actually happens is that each invocation of a nested regex gets its own scope. Sub-matches
belong to that scope. That is, each nested regex invocation gets its own copy of the sub-match vector to
play with, so there is no way for an inner regex to stomp on the sub-matches of an outer regex. So, for
example, the regex <code><phrase role="identifier">outer</phrase></code> defined above would match <code><phrase role="string">&quot;ABBA&quot;</phrase></code>, as it should.</para>
<anchor id="user_s_guide.grammars_and_nested_matches.nested_results" /><bridgehead renderas="sect2">Nested Results</bridgehead><para>
If nested regexes have their own sub-matches, there should be a way to access them after a successful
match. In fact, there is. After a <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal> or <literal><functionname alt="boost::xpressive::regex_search">regex_search()</functionname></literal>, the <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> struct behaves
like the head of a tree of nested results. The <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> class provides a <code><phrase role="identifier">nested_results</phrase><phrase role="special">()</phrase></code>
member function that returns an ordered sequence of <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> structures, representing the
results of the nested regexes. The order of the nested results is the same as the order in which
the nested regex objects matched.</para>
<para>
Take as an example the regex for balanced, nested parentheses we saw earlier:</para>
<programlisting>
<literal>
<phrase role="identifier">sregex</phrase><phrase role="identifier"> parentheses</phrase><phrase role="special">;</phrase><phrase role="identifier">
parentheses</phrase><phrase role="special"> =</phrase><phrase role="char"> '('</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="special"> *(</phrase><phrase role="identifier"> keep</phrase><phrase role="special">(</phrase><phrase role="special"> +~(</phrase><phrase role="identifier">set</phrase><phrase role="special">=</phrase><phrase role="char">'('</phrase><phrase role="special">,</phrase><phrase role="char">')'</phrase><phrase role="special">)</phrase><phrase role="special"> )</phrase><phrase role="special"> |</phrase><phrase role="identifier"> by_ref</phrase><phrase role="special">(</phrase><phrase role="identifier">parentheses</phrase><phrase role="special">)</phrase><phrase role="special"> )</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="char"> ')'</phrase><phrase role="special">;</phrase><phrase role="identifier">

smatch</phrase><phrase role="identifier"> what</phrase><phrase role="special">;</phrase><phrase role="identifier">
std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="identifier"> str</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;blah blah( a(b)c (c(e)f (g)h )i (j)6 )blah&quot;</phrase><phrase role="special"> );</phrase><phrase role="keyword">

if</phrase><phrase role="special">(</phrase><phrase role="identifier"> regex_search</phrase><phrase role="special">(</phrase><phrase role="identifier"> str</phrase><phrase role="special">,</phrase><phrase role="identifier"> what</phrase><phrase role="special">,</phrase><phrase role="identifier"> parentheses</phrase><phrase role="special"> )</phrase><phrase role="special"> )</phrase><phrase role="special">
{</phrase><phrase role="comment">
    // display the whole match
</phrase><phrase role="identifier">    std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="identifier"> what</phrase><phrase role="special">[</phrase><phrase role="number">0</phrase><phrase role="special">]</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="char"> '\n'</phrase><phrase role="special">;</phrase><phrase role="comment">

    // display the nested results
</phrase><phrase role="identifier">    std</phrase><phrase role="special">::</phrase><phrase role="identifier">for_each</phrase><phrase role="special">(</phrase><phrase role="identifier">
        what</phrase><phrase role="special">.</phrase><phrase role="identifier">nested_results</phrase><phrase role="special">().</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier">
        what</phrase><phrase role="special">.</phrase><phrase role="identifier">nested_results</phrase><phrase role="special">().</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase><phrase role="identifier">
        output_nested_results</phrase><phrase role="special">()</phrase><phrase role="special"> );</phrase><phrase role="special">
}</phrase>
</literal>
</programlisting>
<para>
This program displays the following:</para>
<programlisting><literal>( a(b)c (c(e)f (g)h )i (j)6 )
    (b)
    (c(e)f (g)h )
        (e)
        (g)
    (j)
</literal></programlisting><para>
Here you can see how the results are nested and that they are stored in the order in which they
are found.</para>
<informaltable frame="all">
<?dbhtml table-width="74%" ?>
<tgroup cols="1">
<tbody>
<row>
<entry role="blurb">
<inlinemediaobject><imageobject><imagedata fileref="images/tip.png"></imagedata></imageobject></inlinemediaobject> See the definition of <link linkend="user_s_guide.examples.display_a_tree_of_nested_results">output_nested_results</link> in the
<link linkend="boost_xpressive.user_s_guide.examples">Examples</link> section.</entry>
</row>
</tbody>
</tgroup>
</informaltable>
<anchor id="user_s_guide.grammars_and_nested_matches.filtering_nested_results" /><bridgehead renderas="sect2">Filtering Nested Results</bridgehead><para>
Sometimes a regex will have several nested regex objects, and you want to know which result corresponds
to which regex object. That's where <code><phrase role="identifier">basic_regex</phrase><phrase role="special">&lt;&gt;::</phrase><phrase role="identifier">regex_id</phrase><phrase role="special">()</phrase></code> and <code><phrase role="identifier">match_results</phrase><phrase role="special">&lt;&gt;::</phrase><phrase role="identifier">regex_id</phrase><phrase role="special">()</phrase></code>
come in handy. When iterating over the nested results, you can compare the regex id from the results to
the id of the regex object you're interested in.</para>
<para>
To make this a bit easier, xpressive provides a predicate to make it simple to iterate over just the
results that correspond to a certain nested regex. It is called <code><phrase role="identifier">regex_id_filter_predicate</phrase></code>, and it is
intended to be used with <ulink url="../../libs/iterator/doc/index.html">Boost.Iterator</ulink>. You can use it as follows:</para>
<programlisting>
<literal>
<phrase role="identifier">sregex</phrase><phrase role="identifier"> name</phrase><phrase role="special"> =</phrase><phrase role="special"> +</phrase><phrase role="identifier">alpha</phrase><phrase role="special">;</phrase><phrase role="identifier">
sregex</phrase><phrase role="identifier"> integer</phrase><phrase role="special"> =</phrase><phrase role="special"> +</phrase><phrase role="identifier">_d</phrase><phrase role="special">;</phrase><phrase role="identifier">
sregex</phrase><phrase role="identifier"> re</phrase><phrase role="special"> =</phrase><phrase role="special"> *(</phrase><phrase role="special"> *</phrase><phrase role="identifier">_s</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="special"> (</phrase><phrase role="identifier"> name</phrase><phrase role="special"> |</phrase><phrase role="identifier"> integer</phrase><phrase role="special"> )</phrase><phrase role="special"> );</phrase><phrase role="identifier"> 

smatch</phrase><phrase role="identifier"> what</phrase><phrase role="special">;</phrase><phrase role="identifier">
std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="identifier"> str</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;marsha 123 jan 456 cindy 789&quot;</phrase><phrase role="special"> );</phrase><phrase role="keyword">

if</phrase><phrase role="special">(</phrase><phrase role="identifier"> regex_match</phrase><phrase role="special">(</phrase><phrase role="identifier"> str</phrase><phrase role="special">,</phrase><phrase role="identifier"> what</phrase><phrase role="special">,</phrase><phrase role="identifier"> re</phrase><phrase role="special"> )</phrase><phrase role="special"> )</phrase><phrase role="special">
{</phrase><phrase role="identifier">
    smatch</phrase><phrase role="special">::</phrase><phrase role="identifier">nested_results_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_iterator</phrase><phrase role="identifier"> begin</phrase><phrase role="special"> =</phrase><phrase role="identifier"> what</phrase><phrase role="special">.</phrase><phrase role="identifier">nested_results</phrase><phrase role="special">().</phrase><phrase role="identifier">begin</phrase><phrase role="special">();</phrase><phrase role="identifier">
    smatch</phrase><phrase role="special">::</phrase><phrase role="identifier">nested_results_type</phrase><phrase role="special">::</phrase><phrase role="identifier">const_iterator</phrase><phrase role="identifier"> end</phrase><phrase role="special">   =</phrase><phrase role="identifier"> what</phrase><phrase role="special">.</phrase><phrase role="identifier">nested_results</phrase><phrase role="special">().</phrase><phrase role="identifier">end</phrase><phrase role="special">();</phrase><phrase role="comment">

    // declare filter predicates to select just the names or the integers
</phrase><phrase role="identifier">    sregex_id_filter_predicate</phrase><phrase role="identifier"> name_id</phrase><phrase role="special">(</phrase><phrase role="identifier"> name</phrase><phrase role="special">.</phrase><phrase role="identifier">regex_id</phrase><phrase role="special">()</phrase><phrase role="special"> );</phrase><phrase role="identifier">
    sregex_id_filter_predicate</phrase><phrase role="identifier"> integer_id</phrase><phrase role="special">(</phrase><phrase role="identifier"> integer</phrase><phrase role="special">.</phrase><phrase role="identifier">regex_id</phrase><phrase role="special">()</phrase><phrase role="special"> );</phrase><phrase role="comment">

    // iterate over only the results from the name regex
</phrase><phrase role="identifier">    std</phrase><phrase role="special">::</phrase><phrase role="identifier">for_each</phrase><phrase role="special">(</phrase><phrase role="identifier">
        boost</phrase><phrase role="special">::</phrase><phrase role="identifier">make_filter_iterator</phrase><phrase role="special">(</phrase><phrase role="identifier"> name_id</phrase><phrase role="special">,</phrase><phrase role="identifier"> begin</phrase><phrase role="special">,</phrase><phrase role="identifier"> end</phrase><phrase role="special"> ),</phrase><phrase role="identifier">
        boost</phrase><phrase role="special">::</phrase><phrase role="identifier">make_filter_iterator</phrase><phrase role="special">(</phrase><phrase role="identifier"> name_id</phrase><phrase role="special">,</phrase><phrase role="identifier"> end</phrase><phrase role="special">,</phrase><phrase role="identifier"> end</phrase><phrase role="special"> ),</phrase><phrase role="identifier">
        output_result</phrase><phrase role="special">
        );</phrase><phrase role="identifier">

    std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="char"> '\n'</phrase><phrase role="special">;</phrase><phrase role="comment">

    // iterate over only the results from the integer regex
</phrase><phrase role="identifier">    std</phrase><phrase role="special">::</phrase><phrase role="identifier">for_each</phrase><phrase role="special">(</phrase><phrase role="identifier">
        boost</phrase><phrase role="special">::</phrase><phrase role="identifier">make_filter_iterator</phrase><phrase role="special">(</phrase><phrase role="identifier"> integer_id</phrase><phrase role="special">,</phrase><phrase role="identifier"> begin</phrase><phrase role="special">,</phrase><phrase role="identifier"> end</phrase><phrase role="special"> ),</phrase><phrase role="identifier">
        boost</phrase><phrase role="special">::</phrase><phrase role="identifier">make_filter_iterator</phrase><phrase role="special">(</phrase><phrase role="identifier"> integer_id</phrase><phrase role="special">,</phrase><phrase role="identifier"> end</phrase><phrase role="special">,</phrase><phrase role="identifier"> end</phrase><phrase role="special"> ),</phrase><phrase role="identifier">
        output_result</phrase><phrase role="special">
        );</phrase><phrase role="special">
}</phrase>
</literal>
</programlisting>
<para>
where <code><phrase role="identifier">output_results</phrase></code> is a simple function that takes a <code><phrase role="identifier">smatch</phrase></code> and displays the full match.
Notice how we use the <code><phrase role="identifier">regex_id_filter_predicate</phrase></code> together with <code><phrase role="identifier">basic_regex</phrase><phrase role="special">&lt;&gt;::</phrase><phrase role="identifier">regex_id</phrase><phrase role="special">()</phrase></code> and
<code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">make_filter_iterator</phrase><phrase role="special">()</phrase></code> from the <ulink url="../../libs/iterator/doc/index.html">Boost.Iterator</ulink> to select only those results
corresponding to a particular nested regex. This program displays the following:</para>
<programlisting><literal>marsha
jan
cindy
123
456
789
</literal></programlisting></section>
<section id="boost_xpressive.user_s_guide.localization_and_regex_traits">
<title>Localization and Regex Traits</title>
<anchor id="user_s_guide.localization_and_regex_traits.overview" /><bridgehead renderas="sect2">Overview</bridgehead><para>
Matching a regular expression against a string often requires locale-dependent information. For example,
how are case-insensitive comparisons performed? The locale-sensitive behavior is captured in a traits class.
xpressive provides three traits class templates: <code><phrase role="identifier">cpp_regex_traits</phrase><phrase role="special">&lt;&gt;</phrase></code>, <code><phrase role="identifier">c_regex_traits</phrase><phrase role="special">&lt;&gt;</phrase></code> and <code><phrase role="identifier">null_regex_traits</phrase><phrase role="special">&lt;&gt;</phrase></code>.
The first wraps a <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">locale</phrase></code>, the second wraps the global C locale, and the third is a stub traits type for
use when searching non-character data. All traits templates conform to the
<link linkend="user_s_guide.concepts.traits_requirements">Regex Traits Concept</link>.</para>
<anchor id="user_s_guide.localization_and_regex_traits.setting_the_default_regex_trait" /><bridgehead renderas="sect2">Setting the Default Regex Trait</bridgehead><para>
By default, xpressive uses <code><phrase role="identifier">cpp_regex_traits</phrase><phrase role="special">&lt;&gt;</phrase></code> for all patterns. This causes all regex objects to use
the global <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">locale</phrase></code>. If you compile with <code><phrase role="identifier">BOOST_XPRESSIVE_USE_C_TRAITS</phrase></code> defined, then xpressive will use
<code><phrase role="identifier">c_regex_traits</phrase><phrase role="special">&lt;&gt;</phrase></code> by default.</para>
<anchor id="user_s_guide.localization_and_regex_traits.using_custom_traits_with_dynamic_regexes" /><bridgehead renderas="sect2">Using Custom Traits with Dynamic Regexes</bridgehead><para>
To create a dynamic regex that uses a custom traits object, you must use <literal><classname alt="boost::xpressive::regex_compiler">regex_compiler&lt;&gt;</classname></literal>.
The basic steps are shown in the following example:</para>
<programlisting>
<literal>
<phrase role="comment">// Declare a regex_compiler that uses the global C locale
</phrase><phrase role="identifier">regex_compiler</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">char</phrase><phrase role="keyword"> const</phrase><phrase role="special"> *,</phrase><phrase role="identifier"> c_regex_traits</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">char</phrase><phrase role="special">&gt;</phrase><phrase role="special"> &gt;</phrase><phrase role="identifier"> crxcomp</phrase><phrase role="special">;</phrase><phrase role="identifier">
cregex</phrase><phrase role="identifier"> crx</phrase><phrase role="special"> =</phrase><phrase role="identifier"> crxcomp</phrase><phrase role="special">.</phrase><phrase role="identifier">compile</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;\\w+&quot;</phrase><phrase role="special"> );</phrase><phrase role="comment">

// Declare a regex_compiler that uses a custom std::locale
</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">locale</phrase><phrase role="identifier"> loc</phrase><phrase role="special"> =</phrase><phrase role="comment"> /* ... create a locale here ... */</phrase><phrase role="special">;</phrase><phrase role="identifier">
regex_compiler</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">char</phrase><phrase role="keyword"> const</phrase><phrase role="special"> *,</phrase><phrase role="identifier"> cpp_regex_traits</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">char</phrase><phrase role="special">&gt;</phrase><phrase role="special"> &gt;</phrase><phrase role="identifier"> cpprxcomp</phrase><phrase role="special">(</phrase><phrase role="identifier">loc</phrase><phrase role="special">);</phrase><phrase role="identifier">
cregex</phrase><phrase role="identifier"> cpprx</phrase><phrase role="special"> =</phrase><phrase role="identifier"> cpprxcomp</phrase><phrase role="special">.</phrase><phrase role="identifier">compile</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;\\w+&quot;</phrase><phrase role="special"> );</phrase>
</literal>
</programlisting>
<para>
The <code><phrase role="identifier">regex_compiler</phrase></code> objects act as regex factories. Once they have been imbued with a locale,
every regex object they create will use that locale.</para>
<anchor id="user_s_guide.localization_and_regex_traits.using_custom_traits_with_static_regexes" /><bridgehead renderas="sect2">Using Custom Traits with Static Regexes</bridgehead><para>
If you want a particular static regex to use a different set of traits, you can use the special <code><phrase role="identifier">imbue</phrase><phrase role="special">()</phrase></code>
pattern modifier. For instance:</para>
<programlisting>
<literal>
<phrase role="comment">// Define a regex that uses the global C locale
</phrase><phrase role="identifier">c_regex_traits</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">char</phrase><phrase role="special">&gt;</phrase><phrase role="identifier"> ctraits</phrase><phrase role="special">;</phrase><phrase role="identifier">
sregex</phrase><phrase role="identifier"> crx</phrase><phrase role="special"> =</phrase><phrase role="identifier"> imbue</phrase><phrase role="special">(</phrase><phrase role="identifier">ctraits</phrase><phrase role="special">)(</phrase><phrase role="special"> +</phrase><phrase role="identifier">_w</phrase><phrase role="special"> );</phrase><phrase role="comment">

// Define a regex that uses a customized std::locale
</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">locale</phrase><phrase role="identifier"> loc</phrase><phrase role="special"> =</phrase><phrase role="comment"> /* ... create a locale here ... */</phrase><phrase role="special">;</phrase><phrase role="identifier">
cpp_regex_traits</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">char</phrase><phrase role="special">&gt;</phrase><phrase role="identifier"> cpptraits</phrase><phrase role="special">(</phrase><phrase role="identifier">loc</phrase><phrase role="special">);</phrase><phrase role="identifier">
sregex</phrase><phrase role="identifier"> cpprx1</phrase><phrase role="special"> =</phrase><phrase role="identifier"> imbue</phrase><phrase role="special">(</phrase><phrase role="identifier">cpptraits</phrase><phrase role="special">)(</phrase><phrase role="special"> +</phrase><phrase role="identifier">_w</phrase><phrase role="special"> );</phrase><phrase role="comment">

// A sharthand for above
</phrase><phrase role="identifier">sregex</phrase><phrase role="identifier"> cpprx2</phrase><phrase role="special"> =</phrase><phrase role="identifier"> imbue</phrase><phrase role="special">(</phrase><phrase role="identifier">loc</phrase><phrase role="special">)(</phrase><phrase role="special"> +</phrase><phrase role="identifier">_w</phrase><phrase role="special"> );</phrase>
</literal>
</programlisting>
<para>
The <code><phrase role="identifier">imbue</phrase><phrase role="special">()</phrase></code> pattern modifier must wrap the entire pattern. It is an error to <code><phrase role="identifier">imbue</phrase></code> only
part of a static regex. For example:</para>
<programlisting>
<literal>
<phrase role="comment">// ERROR! Cannot imbue() only part of a regex
</phrase><phrase role="identifier">sregex</phrase><phrase role="identifier"> error</phrase><phrase role="special"> =</phrase><phrase role="identifier"> _w</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> imbue</phrase><phrase role="special">(</phrase><phrase role="identifier">loc</phrase><phrase role="special">)(</phrase><phrase role="identifier"> _w</phrase><phrase role="special"> );</phrase>
</literal>
</programlisting>
<anchor id="user_s_guide.localization_and_regex_traits.searching_non_character_data_with__literal_null_regex_traits__literal_" /><bridgehead renderas="sect2">Searching Non-Character Data With <literal>null_regex_traits</literal></bridgehead><para>
With xpressive static regexes, you are not limitted to searching for patterns in character sequences.
You can search for patterns in raw bytes, integers, or anything that conforms to the
<link linkend="user_s_guide.concepts.chart_requirements">Char Concept</link>. The <code><phrase role="identifier">null_regex_traits</phrase><phrase role="special">&lt;&gt;</phrase></code> makes it simple. It is a
stub implementation of the <link linkend="user_s_guide.concepts.traits_requirements">Regex Traits Concept</link>. It recognizes
no character classes and does no case-sensitive mappings.</para>
<para>
For example, with <code><phrase role="identifier">null_regex_traits</phrase><phrase role="special">&lt;&gt;</phrase></code>, you can write a static regex to find a pattern in a
sequence of integers as follows:</para>
<programlisting>
<literal>
<phrase role="comment">// some integral data to search
</phrase><phrase role="keyword">int</phrase><phrase role="keyword"> const</phrase><phrase role="identifier"> data</phrase><phrase role="special">[]</phrase><phrase role="special"> =</phrase><phrase role="special"> {</phrase><phrase role="number">0</phrase><phrase role="special">,</phrase><phrase role="number"> 1</phrase><phrase role="special">,</phrase><phrase role="number"> 2</phrase><phrase role="special">,</phrase><phrase role="number"> 3</phrase><phrase role="special">,</phrase><phrase role="number"> 4</phrase><phrase role="special">,</phrase><phrase role="number"> 5</phrase><phrase role="special">,</phrase><phrase role="number"> 6</phrase><phrase role="special">};</phrase><phrase role="comment">

// create a null_regex_traits&lt;&gt; object for searching integers ...
</phrase><phrase role="identifier">null_regex_traits</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="special">&gt;</phrase><phrase role="identifier"> nul</phrase><phrase role="special">;</phrase><phrase role="comment">

// imbue a regex object with the null_regex_traits ...
</phrase><phrase role="identifier">basic_regex</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="keyword"> const</phrase><phrase role="special"> *&gt;</phrase><phrase role="identifier"> rex</phrase><phrase role="special"> =</phrase><phrase role="identifier"> imbue</phrase><phrase role="special">(</phrase><phrase role="identifier">nul</phrase><phrase role="special">)(</phrase><phrase role="number">1</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="special"> +((</phrase><phrase role="identifier">set</phrase><phrase role="special">=</phrase><phrase role="number"> 2</phrase><phrase role="special">,</phrase><phrase role="number">3</phrase><phrase role="special">)</phrase><phrase role="special"> |</phrase><phrase role="number"> 4</phrase><phrase role="special">)</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="number"> 5</phrase><phrase role="special">);</phrase><phrase role="identifier">
match_results</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">int</phrase><phrase role="keyword"> const</phrase><phrase role="special"> *&gt;</phrase><phrase role="identifier"> what</phrase><phrase role="special">;</phrase><phrase role="comment">

// search for the pattern in the array of integers ...
</phrase><phrase role="identifier">regex_search</phrase><phrase role="special">(</phrase><phrase role="identifier">data</phrase><phrase role="special">,</phrase><phrase role="identifier"> data</phrase><phrase role="special"> +</phrase><phrase role="number"> 7</phrase><phrase role="special">,</phrase><phrase role="identifier"> what</phrase><phrase role="special">,</phrase><phrase role="identifier"> rex</phrase><phrase role="special">);</phrase><phrase role="identifier">

assert</phrase><phrase role="special">(</phrase><phrase role="identifier">what</phrase><phrase role="special">[</phrase><phrase role="number">0</phrase><phrase role="special">].</phrase><phrase role="identifier">matched</phrase><phrase role="special">);</phrase><phrase role="identifier">
assert</phrase><phrase role="special">(*</phrase><phrase role="identifier">what</phrase><phrase role="special">[</phrase><phrase role="number">0</phrase><phrase role="special">].</phrase><phrase role="identifier">first</phrase><phrase role="special"> ==</phrase><phrase role="number"> 1</phrase><phrase role="special">);</phrase><phrase role="identifier">
assert</phrase><phrase role="special">(*</phrase><phrase role="identifier">what</phrase><phrase role="special">[</phrase><phrase role="number">0</phrase><phrase role="special">].</phrase><phrase role="identifier">second</phrase><phrase role="special"> ==</phrase><phrase role="number"> 6</phrase><phrase role="special">);</phrase>
</literal>
</programlisting>
</section>
<section id="boost_xpressive.user_s_guide.tips_n_tricks">
<title> Tips 'N Tricks</title>
<para>
Squeeze the most performance out of xpressive with these tips and tricks.</para>
<anchor id="user_s_guide.tips_n_tricks.use_static_regexes" /><bridgehead renderas="sect2">Use Static Regexes</bridgehead><para>
On average, static regexes execute about 10 to 15% faster than their
dynamic counterparts. It's worth familiarizing yourself with the static
regex dialect.</para>
<anchor id="user_s_guide.tips_n_tricks.reuse__literal__classname_alt__boost__xpressive__match_results__match_results_lt__gt___classname___literal__objects" /><bridgehead renderas="sect2">Reuse <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> Objects</bridgehead><para>
The <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> object caches dynamically allocated memory. For this
reason, it is far better to reuse the same <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> object if you
have to do many regex searches.</para>
<para>
Caveat: <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> objects are not thread-safe, so don't go wild
reusing them across threads.</para>
<anchor id="user_s_guide.tips_n_tricks.prefer_algorithms_that_take_a__literal__classname_alt__boost__xpressive__match_results__match_results_lt__gt___classname___literal__object" /><bridgehead renderas="sect2">Prefer Algorithms That Take A <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> Object</bridgehead><para>
This is a corollary to the previous tip. If you are doing multiple searches,
you should prefer the regex algorithms that accept a <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> object
over the ones that don't, and you should reuse the same <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> object
each time. If you don't provide a <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal> object, a temporary one
will be created for you and discarded when the algorithm returns. Any
memory cached in the object will be deallocated and will have to be reallocated
the next time.</para>
<anchor id="user_s_guide.tips_n_tricks.prefer_algorithms_that_accept_iterator_ranges_over_null_terminated_strings" /><bridgehead renderas="sect2">Prefer Algorithms That Accept Iterator Ranges Over Null-Terminated Strings</bridgehead><para>
xpressive provides overloads of the <literal><functionname alt="boost::xpressive::regex_match">regex_match()</functionname></literal> and <literal><functionname alt="boost::xpressive::regex_search">regex_search()</functionname></literal>
algorithms that operate on C-style null-terminated strings. You should
prefer the overloads that take iterator ranges. When you pass a
null-terminated string to a regex algorithm, the end iterator is calculated
immediately by calling <code><phrase role="identifier">strlen</phrase></code>. If you already know the length of the string,
you can avoid this overhead by calling the regex algorithms with a <code><phrase role="special">[</phrase><phrase role="identifier">begin</phrase><phrase role="special">,</phrase><phrase role="identifier"> end</phrase><phrase role="special">)</phrase></code>
pair.</para>
<anchor id="user_s_guide.tips_n_tricks.compile_patterns_once_and_reuse_them" /><bridgehead renderas="sect2">Compile Patterns Once And Reuse Them</bridgehead><para>
Compiling a regex (dynamic or static) is more expensive than executing a 
match or search. If you have the option, prefer to compile a pattern into 
a <literal><classname alt="boost::xpressive::basic_regex">basic_regex&lt;&gt;</classname></literal> object once and reuse it rather than recreating it over
and over.</para>
<anchor id="user_s_guide.tips_n_tricks.understand__literal_syntax_option_type__optimize__literal_" /><bridgehead renderas="sect2">Understand <literal>syntax_option_type::optimize</literal></bridgehead><para>
The <code><phrase role="identifier">optimize</phrase></code> flag tells the regex compiler to spend some extra time analyzing
the pattern. It can cause some patterns to execute faster, but it increases
the time to compile the pattern, and often increases the amount of memory
consumed by the pattern. If you plan to reuse your pattern, <code><phrase role="identifier">optimize</phrase></code> is
usually a win. If you will only use the pattern once, don't use <code><phrase role="identifier">optimize</phrase></code>.</para>
<anchor id="user_s_guide.tips_n_tricks.common_pitfalls" /><bridgehead renderas="sect1">Common Pitfalls</bridgehead><para>
Keep the following tips in mind to avoid stepping in potholes with xpressive.</para>
<anchor id="user_s_guide.tips_n_tricks.create_grammars_on_a_single_thread" /><bridgehead renderas="sect2">Create Grammars On A Single Thread</bridgehead><para>
With static regexes, you can create grammars by nesting regexes inside one
another. When compiling the outer regex, both the outer and inner regex objects,
and all the regex objects to which they refer either directly or indirectly, are
modified. For this reason, it's dangerous for global regex objects to participate
in grammars. It's best to build regex grammars from a single thread. Once built,
the resulting regex grammar can be executed from multiple threads without
problems.</para>
<anchor id="user_s_guide.tips_n_tricks.beware_nested_quantifiers" /><bridgehead renderas="sect2">Beware Nested Quantifiers</bridgehead><para>
This is a pitfall common to many regular expression engines. Some patterns can
cause exponentially bad performance. Often these patterns involve one quantified
term nested withing another quantifier, such as <code><phrase role="string">&quot;(a*)*&quot;</phrase></code>, although in many
cases, the problem is harder to spot. Beware of patterns that have nested
quantifiers.</para>
</section>
<section id="boost_xpressive.user_s_guide.concepts">
<title>Concepts</title>
<anchor id="user_s_guide.concepts.chart_requirements" /><bridgehead renderas="sect2">CharT requirements</bridgehead><para>
If type <code><phrase role="identifier">BidiIterT</phrase></code> is used as a template argument to <literal><classname alt="boost::xpressive::basic_regex">basic_regex&lt;&gt;</classname></literal>, then <code><phrase role="identifier">CharT</phrase></code> is
<code><phrase role="identifier">iterator_traits</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">BidiIterT</phrase><phrase role="special">&gt;::</phrase><phrase role="identifier">value_type</phrase></code>. Type <code><phrase role="identifier">CharT</phrase></code> must have a trivial default
constructor, copy constructor, assignment operator, and destructor.  In addition
the following requirements must be met for objects; <code><phrase role="identifier">c</phrase></code> of type <code><phrase role="identifier">CharT</phrase></code>, <code><phrase role="identifier">c1</phrase></code> and <code><phrase role="identifier">c2</phrase></code> of
type <code><phrase role="identifier">CharT</phrase><phrase role="keyword"> const</phrase></code>, and <code><phrase role="identifier">i</phrase></code> of type <code><phrase role="keyword">int</phrase></code>:</para>
<informaltable frame="all">
<bridgehead renderas="sect4"><phrase role="table-title">CharT Requirements</phrase></bridgehead>
<tgroup cols="3">
<thead><row><entry><emphasis role="bold">Expression</emphasis></entry><entry><emphasis role="bold">Return type</emphasis></entry><entry><emphasis role="bold">Assertion / Note / Pre- / Post-condition</emphasis></entry></row>
</thead>
<tbody>
<row><entry><code><phrase role="identifier">CharT</phrase><phrase role="identifier"> c</phrase></code></entry><entry><code><phrase role="identifier">CharT</phrase></code></entry><entry>Default constructor (must be trivial).</entry></row>
<row><entry><code><phrase role="identifier">CharT</phrase><phrase role="identifier"> c</phrase><phrase role="special">(</phrase><phrase role="identifier">c1</phrase><phrase role="special">)</phrase></code></entry><entry><code><phrase role="identifier">CharT</phrase></code></entry><entry>Copy constructor (must be trivial).</entry></row>
<row><entry><code><phrase role="identifier">c1</phrase><phrase role="special"> =</phrase><phrase role="identifier"> c2</phrase></code></entry><entry><code><phrase role="identifier">CharT</phrase></code></entry><entry>Assignment operator (must be trivial).</entry></row>
<row><entry><code><phrase role="identifier">c1</phrase><phrase role="special"> ==</phrase><phrase role="identifier"> c2</phrase></code></entry><entry><code><phrase role="keyword">bool</phrase></code></entry><entry><code><phrase role="keyword">true</phrase></code> if <code><phrase role="identifier">c1</phrase></code> has the same value as <code><phrase role="identifier">c2</phrase></code>.</entry></row>
<row><entry><code><phrase role="identifier">c1</phrase><phrase role="special"> !=</phrase><phrase role="identifier"> c2</phrase></code></entry><entry><code><phrase role="keyword">bool</phrase></code></entry><entry><code><phrase role="keyword">true</phrase></code> if <code><phrase role="identifier">c1</phrase></code> and <code><phrase role="identifier">c2</phrase></code> are not equal.</entry></row>
<row><entry><code><phrase role="identifier">c1</phrase><phrase role="special"> &lt;</phrase><phrase role="identifier"> c2</phrase></code></entry><entry><code><phrase role="keyword">bool</phrase></code></entry><entry><code><phrase role="keyword">true</phrase></code> if the value of <code><phrase role="identifier">c1</phrase></code> is less than <code><phrase role="identifier">c2</phrase></code>.</entry></row>
<row><entry><code><phrase role="identifier">c1</phrase><phrase role="special"> &gt;</phrase><phrase role="identifier"> c2</phrase></code></entry><entry><code><phrase role="keyword">bool</phrase></code></entry><entry><code><phrase role="keyword">true</phrase></code> if the value of <code><phrase role="identifier">c1</phrase></code> is greater than <code><phrase role="identifier">c2</phrase></code>.</entry></row>
<row><entry><code><phrase role="identifier">c1</phrase><phrase role="special"> &lt;=</phrase><phrase role="identifier"> c2</phrase></code></entry><entry><code><phrase role="keyword">bool</phrase></code></entry><entry><code><phrase role="keyword">true</phrase></code> if <code><phrase role="identifier">c1</phrase></code> is less than or equal to <code><phrase role="identifier">c2</phrase></code>.</entry></row>
<row><entry><code><phrase role="identifier">c1</phrase><phrase role="special"> &gt;=</phrase><phrase role="identifier"> c2</phrase></code></entry><entry><code><phrase role="keyword">bool</phrase></code></entry><entry><code><phrase role="keyword">true</phrase></code> if <code><phrase role="identifier">c1</phrase></code> is greater than or equal to <code><phrase role="identifier">c2</phrase></code>.</entry></row>
<row><entry><code><phrase role="identifier">intmax_t</phrase><phrase role="identifier"> i</phrase><phrase role="special"> =</phrase><phrase role="identifier"> c1</phrase></code></entry><entry><code><phrase role="keyword">int</phrase></code></entry><entry>
            <code><phrase role="identifier">CharT</phrase></code> must be convertible to an integral type.
        </entry></row>
<row><entry><code><phrase role="identifier">CharT</phrase><phrase role="identifier"> c</phrase><phrase role="special">(</phrase><phrase role="identifier">i</phrase><phrase role="special">);</phrase></code></entry><entry><code><phrase role="identifier">CharT</phrase></code></entry><entry><code><phrase role="identifier">CharT</phrase></code> must be constructable from an integral type.</entry></row>
</tbody>
</tgroup>
</informaltable>
<anchor id="user_s_guide.concepts.traits_requirements" /><bridgehead renderas="sect2">Traits Requirements</bridgehead><para>
In the following table <code><phrase role="identifier">X</phrase></code> denotes a traits class defining types and functions 
for the character container type <code><phrase role="identifier">CharT</phrase></code>; <code><phrase role="identifier">u</phrase></code> is an object of type <code><phrase role="identifier">X</phrase></code>; <code><phrase role="identifier">v</phrase></code> is an 
object of type <code><phrase role="keyword">const</phrase><phrase role="identifier"> X</phrase></code>; <code><phrase role="identifier">p</phrase></code> is a value of type <code><phrase role="keyword">const</phrase><phrase role="identifier"> CharT</phrase><phrase role="special">*</phrase></code>; <code><phrase role="identifier">I1</phrase></code> and <code><phrase role="identifier">I2</phrase></code> are 
<code><phrase role="identifier">Input</phrase><phrase role="identifier"> Iterators</phrase></code>; <code><phrase role="identifier">c</phrase></code> is a value of type <code><phrase role="keyword">const</phrase><phrase role="identifier"> CharT</phrase></code>; <code><phrase role="identifier">s</phrase></code> is an object of type 
<code><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">string_type</phrase></code>; <code><phrase role="identifier">cs</phrase></code> is an object of type <code><phrase role="keyword">const</phrase><phrase role="identifier"> X</phrase><phrase role="special">::</phrase><phrase role="identifier">string_type</phrase></code>; <code><phrase role="identifier">b</phrase></code> is a value of 
type <code><phrase role="keyword">bool</phrase></code>; <code><phrase role="identifier">i</phrase></code> is a value of type <code><phrase role="keyword">int</phrase></code>; <code><phrase role="identifier">F1</phrase></code> and <code><phrase role="identifier">F2</phrase></code> are values of type <code><phrase role="keyword">const</phrase><phrase role="identifier"> CharT</phrase><phrase role="special">*</phrase></code>; 
<code><phrase role="identifier">loc</phrase></code> is an object of type <code><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">locale_type</phrase></code>; and <code><phrase role="identifier">ch</phrase></code> is an object of <code><phrase role="keyword">const</phrase><phrase role="keyword"> char</phrase></code>.</para>
<informaltable frame="all">
<bridgehead renderas="sect4"><phrase role="table-title">Traits Requirements</phrase></bridgehead>
<tgroup cols="3">
<thead><row><entry>
            <emphasis role="bold">Expression</emphasis>
        </entry><entry>
            <emphasis role="bold">Return type</emphasis>
        </entry><entry>
            <emphasis role="bold">Assertion / Note<sbr/>

                Pre / Post condition</emphasis>
        </entry></row>
</thead>
<tbody>
<row><entry>
            <code><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">char_type</phrase></code>
        </entry><entry>
            <code><phrase role="identifier">CharT</phrase></code>
        </entry><entry>
            The character container type used in the implementation of class template <literal><classname alt="boost::xpressive::basic_regex">basic_regex&lt;&gt;</classname></literal>.
        </entry></row>
<row><entry>
            <code><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">string_type</phrase></code>
        </entry><entry>
            <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_string</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">CharT</phrase><phrase role="special">&gt;</phrase></code> or <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">CharT</phrase><phrase role="special">&gt;</phrase></code>
        </entry><entry>
            
        </entry></row>
<row><entry>
            <code><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">locale_type</phrase></code>
        </entry><entry>
            <emphasis>Implementation defined</emphasis>
        </entry><entry>
            A copy constructible type that represents the locale used by the traits class.
        </entry></row>
<row><entry>
            <code><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">char_class_type</phrase></code>
        </entry><entry>
            <emphasis>Implementation defined</emphasis>
        </entry><entry>
            A bitmask type representing a particular character classification. Multiple 
                values of this type can be bitwise-or'ed together to obtain a new valid value.
        </entry></row>
<row><entry>
            <code><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">hash</phrase><phrase role="special">(</phrase><phrase role="identifier">c</phrase><phrase role="special">)</phrase></code>
        </entry><entry>
            <code><phrase role="keyword">unsigned</phrase><phrase role="keyword"> char</phrase></code>
        </entry><entry>
            Yields a value between <code><phrase role="number">0</phrase></code> and <code><phrase role="identifier">UCHAR_MAX</phrase></code> inclusive.
        </entry></row>
<row><entry>
            <code><phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">widen</phrase><phrase role="special">(</phrase><phrase role="identifier">ch</phrase><phrase role="special">)</phrase></code>
        </entry><entry>
            <code><phrase role="identifier">CharT</phrase></code>
        </entry><entry>
            Widens the specified <code><phrase role="keyword">char</phrase></code> and returns the resulting <code><phrase role="identifier">CharT</phrase></code>.
        </entry></row>
<row><entry>
            <code><phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">in_range</phrase><phrase role="special">(</phrase><phrase role="identifier">r1</phrase><phrase role="special">,</phrase><phrase role="identifier"> r2</phrase><phrase role="special">,</phrase><phrase role="identifier"> c</phrase><phrase role="special">)</phrase></code>
        </entry><entry>
            <code><phrase role="keyword">bool</phrase></code>
        </entry><entry>
            For any characters <code><phrase role="identifier">r1</phrase></code> and <code><phrase role="identifier">r2</phrase></code>, returns <code><phrase role="keyword">true</phrase></code> if <code><phrase role="identifier">r1</phrase><phrase role="special"> &lt;=</phrase><phrase role="identifier"> c</phrase><phrase role="special"> &amp;&amp;</phrase><phrase role="identifier"> c</phrase><phrase role="special"> &lt;=</phrase><phrase role="identifier"> r2</phrase></code>.
                Requires that <code><phrase role="identifier">r1</phrase><phrase role="special"> &lt;=</phrase><phrase role="identifier"> r2</phrase></code>.
        </entry></row>
<row><entry>
            <code><phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">in_range_nocase</phrase><phrase role="special">(</phrase><phrase role="identifier">r1</phrase><phrase role="special">,</phrase><phrase role="identifier"> r2</phrase><phrase role="special">,</phrase><phrase role="identifier"> c</phrase><phrase role="special">)</phrase></code>
        </entry><entry>
            <code><phrase role="keyword">bool</phrase></code>
        </entry><entry>
            For characters <code><phrase role="identifier">r1</phrase></code> and <code><phrase role="identifier">r2</phrase></code>, returns <code><phrase role="keyword">true</phrase></code> if there is some character
                <code><phrase role="identifier">d</phrase></code> for which <code><phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">translate_nocase</phrase><phrase role="special">(</phrase><phrase role="identifier">d</phrase><phrase role="special">)</phrase><phrase role="special"> ==</phrase><phrase role="identifier"> v</phrase><phrase role="special">.</phrase><phrase role="identifier">translate_nocase</phrase><phrase role="special">(</phrase><phrase role="identifier">c</phrase><phrase role="special">)</phrase></code> and
                <code><phrase role="identifier">r1</phrase><phrase role="special"> &lt;=</phrase><phrase role="identifier"> d</phrase><phrase role="special"> &amp;&amp;</phrase><phrase role="identifier"> d</phrase><phrase role="special"> &lt;=</phrase><phrase role="identifier"> r2</phrase></code>. Requires that <code><phrase role="identifier">r1</phrase><phrase role="special"> &lt;=</phrase><phrase role="identifier"> r2</phrase></code>.
        </entry></row>
<row><entry>
            <code><phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">translate</phrase><phrase role="special">(</phrase><phrase role="identifier">c</phrase><phrase role="special">)</phrase></code>
        </entry><entry>
            <code><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">char_type</phrase></code>
        </entry><entry>
            Returns a character such that for any character <code><phrase role="identifier">d</phrase></code> that is to be considered 
                equivalent to <code><phrase role="identifier">c</phrase></code> then <code><phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">translate</phrase><phrase role="special">(</phrase><phrase role="identifier">c</phrase><phrase role="special">)</phrase><phrase role="special"> ==</phrase><phrase role="identifier"> v</phrase><phrase role="special">.</phrase><phrase role="identifier">translate</phrase><phrase role="special">(</phrase><phrase role="identifier">d</phrase><phrase role="special">)</phrase></code>.
        </entry></row>
<row><entry>
            <code><phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">translate_nocase</phrase><phrase role="special">(</phrase><phrase role="identifier">c</phrase><phrase role="special">)</phrase></code>
        </entry><entry>
            <code><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">char_type</phrase></code>
        </entry><entry>
            For all characters <code><phrase role="identifier">C</phrase></code> that are to be considered 
            equivalent to <code><phrase role="identifier">c</phrase></code> when comparisons are to be performed without regard to case, 
            then <code><phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">translate_nocase</phrase><phrase role="special">(</phrase><phrase role="identifier">c</phrase><phrase role="special">)</phrase><phrase role="special"> ==</phrase><phrase role="identifier"> v</phrase><phrase role="special">.</phrase><phrase role="identifier">translate_nocase</phrase><phrase role="special">(</phrase><phrase role="identifier">C</phrase><phrase role="special">)</phrase></code>.
        </entry></row>
<row><entry>
            <code><phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">transform</phrase><phrase role="special">(</phrase><phrase role="identifier">F1</phrase><phrase role="special">,</phrase><phrase role="identifier"> F2</phrase><phrase role="special">)</phrase></code>
        </entry><entry>
            <code><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">string_type</phrase></code>
        </entry><entry>
            Returns a sort key for the character sequence designated by the iterator range 
                <code><phrase role="special">[</phrase><phrase role="identifier">F1</phrase><phrase role="special">,</phrase><phrase role="identifier"> F2</phrase><phrase role="special">)</phrase></code> such that if the character sequence <code><phrase role="special">[</phrase><phrase role="identifier">G1</phrase><phrase role="special">,</phrase><phrase role="identifier"> G2</phrase><phrase role="special">)</phrase></code> sorts before the 
                character sequence <code><phrase role="special">[</phrase><phrase role="identifier">H1</phrase><phrase role="special">,</phrase><phrase role="identifier"> H2</phrase><phrase role="special">)</phrase></code> then <code><phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">transform</phrase><phrase role="special">(</phrase><phrase role="identifier">G1</phrase><phrase role="special">,</phrase><phrase role="identifier"> G2</phrase><phrase role="special">)</phrase><phrase role="special"> &lt;</phrase><phrase role="identifier"> v</phrase><phrase role="special">.</phrase><phrase role="identifier">transform</phrase><phrase role="special">(</phrase><phrase role="identifier">H1</phrase><phrase role="special">,</phrase><phrase role="identifier"> H2</phrase><phrase role="special">)</phrase></code>. 
        </entry></row>
<row><entry>
            <code><phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">transform_primary</phrase><phrase role="special">(</phrase><phrase role="identifier">F1</phrase><phrase role="special">,</phrase><phrase role="identifier"> F2</phrase><phrase role="special">)</phrase></code>
        </entry><entry>
            <code><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">string_type</phrase></code>
        </entry><entry>
            Returns a sort key for the character sequence designated by the iterator range 
                <code><phrase role="special">[</phrase><phrase role="identifier">F1</phrase><phrase role="special">,</phrase><phrase role="identifier"> F2</phrase><phrase role="special">)</phrase></code> such that if the character sequence <code><phrase role="special">[</phrase><phrase role="identifier">G1</phrase><phrase role="special">,</phrase><phrase role="identifier"> G2</phrase><phrase role="special">)</phrase></code> sorts before the 
                character sequence <code><phrase role="special">[</phrase><phrase role="identifier">H1</phrase><phrase role="special">,</phrase><phrase role="identifier"> H2</phrase><phrase role="special">)</phrase></code> when character case is not considered then 
                <code><phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">transform_primary</phrase><phrase role="special">(</phrase><phrase role="identifier">G1</phrase><phrase role="special">,</phrase><phrase role="identifier"> G2</phrase><phrase role="special">)</phrase><phrase role="special"> &lt;</phrase><phrase role="identifier"> v</phrase><phrase role="special">.</phrase><phrase role="identifier">transform_primary</phrase><phrase role="special">(</phrase><phrase role="identifier">H1</phrase><phrase role="special">,</phrase><phrase role="identifier"> H2</phrase><phrase role="special">)</phrase></code>.
        </entry></row>
<row><entry>
            <code><phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">lookup_classname</phrase><phrase role="special">(</phrase><phrase role="identifier">F1</phrase><phrase role="special">,</phrase><phrase role="identifier"> F2</phrase><phrase role="special">)</phrase></code>
        </entry><entry>
            <code><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">char_class_type</phrase></code>
        </entry><entry>
            Converts the character sequence designated by the iterator range <code><phrase role="special">[</phrase><phrase role="identifier">F1</phrase><phrase role="special">,</phrase><phrase role="identifier">F2</phrase><phrase role="special">)</phrase></code> into a 
                bitmask type that can subsequently be passed to <code><phrase role="identifier">isctype</phrase></code>. Values returned from 
                <code><phrase role="identifier">lookup_classname</phrase></code> can be safely bitwise or'ed together. Returns <code><phrase role="number">0</phrase></code> if the 
                character sequence is not the name of a character class recognized by <code><phrase role="identifier">X</phrase></code>. The 
                value returned shall be independent of the case of the characters in the 
                sequence.
        </entry></row>
<row><entry>
            <code><phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">lookup_collatename</phrase><phrase role="special">(</phrase><phrase role="identifier">F1</phrase><phrase role="special">,</phrase><phrase role="identifier"> F2</phrase><phrase role="special">)</phrase></code>
        </entry><entry>
            <code><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">string_type</phrase></code>
        </entry><entry>
            Returns a sequence of characters that represents the collating element 
                consisting of the character sequence designated by the iterator range <code><phrase role="special">[</phrase><phrase role="identifier">F1</phrase><phrase role="special">,</phrase><phrase role="identifier"> F2</phrase><phrase role="special">)</phrase></code>. 
                Returns an empty string if the character sequence is not a valid collating 
                element.
        </entry></row>
<row><entry>
            <code><phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">isctype</phrase><phrase role="special">(</phrase><phrase role="identifier">c</phrase><phrase role="special">,</phrase><phrase role="identifier"> v</phrase><phrase role="special">.</phrase><phrase role="identifier">lookup_classname</phrase><phrase role="special">(</phrase><phrase role="identifier">F1</phrase><phrase role="special">,</phrase><phrase role="identifier"> F2</phrase><phrase role="special">))</phrase></code>
        </entry><entry>
            <code><phrase role="keyword">bool</phrase></code>
        </entry><entry>
            Returns <code><phrase role="keyword">true</phrase></code> if character <code><phrase role="identifier">c</phrase></code> is a member of the character class designated by 
                the iterator range <code><phrase role="special">[</phrase><phrase role="identifier">F1</phrase><phrase role="special">,</phrase><phrase role="identifier"> F2</phrase><phrase role="special">)</phrase></code>, <code><phrase role="keyword">false</phrase></code> otherwise.
        </entry></row>
<row><entry>
            <code><phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">value</phrase><phrase role="special">(</phrase><phrase role="identifier">c</phrase><phrase role="special">,</phrase><phrase role="identifier"> i</phrase><phrase role="special">)</phrase></code>
        </entry><entry>
            <code><phrase role="keyword">int</phrase></code>
        </entry><entry>
            Returns the value represented by the digit <code><phrase role="identifier">c</phrase></code> in base <code><phrase role="identifier">i</phrase></code> if the character <code><phrase role="identifier">c</phrase></code> is a 
                valid digit in base <code><phrase role="identifier">i</phrase></code>; otherwise returns <code><phrase role="special">-</phrase><phrase role="number">1</phrase></code>.<sbr/>

                [Note: the value of <code><phrase role="identifier">i</phrase></code> will only be <code><phrase role="number">8</phrase></code>, <code><phrase role="number">10</phrase></code>, or <code><phrase role="number">16</phrase></code>. -end note]
        </entry></row>
<row><entry>
            <code><phrase role="identifier">u</phrase><phrase role="special">.</phrase><phrase role="identifier">imbue</phrase><phrase role="special">(</phrase><phrase role="identifier">loc</phrase><phrase role="special">)</phrase></code>
        </entry><entry>
            <code><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">locale_type</phrase></code>
        </entry><entry>
            Imbues <code><phrase role="identifier">u</phrase></code> with the locale <code><phrase role="identifier">loc</phrase></code>, returns the previous 
                locale used by <code><phrase role="identifier">u</phrase></code>. 
        </entry></row>
<row><entry>
            <code><phrase role="identifier">v</phrase><phrase role="special">.</phrase><phrase role="identifier">getloc</phrase><phrase role="special">()</phrase></code>
        </entry><entry>
            <code><phrase role="identifier">X</phrase><phrase role="special">::</phrase><phrase role="identifier">locale_type</phrase></code>
        </entry><entry>
            Returns the current locale used by <code><phrase role="identifier">v</phrase></code>. 
        </entry></row>
</tbody>
</tgroup>
</informaltable>
<anchor id="user_s_guide.concepts.acknowledgements" /><bridgehead renderas="sect2">Acknowledgements</bridgehead><para>
This section is adapted from the equivalent page in the <ulink url="../../libs/regex">Boost.Regex</ulink> documentation and from the
<ulink url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1429.htm">proposal</ulink> to add regular expressions to the Standard Library.</para>
</section>
<section id="boost_xpressive.user_s_guide.examples">
<title>Examples</title>
<para>
Below you can find six complete sample programs.
<sbr/>
</para>
<para/><anchor id="user_s_guide.examples.see_if_a_whole_string_matches_a_regex" /><bridgehead renderas="sect4">See if a whole string matches a regex</bridgehead><para>
This is the example from the Introduction. It is reproduced here for your convenience.</para>
<programlisting>
<literal>
<phrase role="preprocessor">#include</phrase><phrase role="special"> &lt;</phrase><phrase role="identifier">iostream</phrase><phrase role="special">&gt;</phrase><phrase role="preprocessor">
#include</phrase><phrase role="special"> &lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">/</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase><phrase role="keyword">

using</phrase><phrase role="keyword"> namespace</phrase><phrase role="identifier"> boost</phrase><phrase role="special">::</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">;</phrase><phrase role="keyword">

int</phrase><phrase role="identifier"> main</phrase><phrase role="special">()</phrase><phrase role="special">
{</phrase><phrase role="identifier">
    std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="identifier"> hello</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;hello world!&quot;</phrase><phrase role="special"> );</phrase><phrase role="identifier">

    sregex</phrase><phrase role="identifier"> rex</phrase><phrase role="special"> =</phrase><phrase role="identifier"> sregex</phrase><phrase role="special">::</phrase><phrase role="identifier">compile</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;(\\w+) (\\w+)!&quot;</phrase><phrase role="special"> );</phrase><phrase role="identifier">
    smatch</phrase><phrase role="identifier"> what</phrase><phrase role="special">;</phrase><phrase role="keyword">

    if</phrase><phrase role="special">(</phrase><phrase role="identifier"> regex_match</phrase><phrase role="special">(</phrase><phrase role="identifier"> hello</phrase><phrase role="special">,</phrase><phrase role="identifier"> what</phrase><phrase role="special">,</phrase><phrase role="identifier"> rex</phrase><phrase role="special"> )</phrase><phrase role="special"> )</phrase><phrase role="special">
    {</phrase><phrase role="identifier">
        std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="identifier"> what</phrase><phrase role="special">[</phrase><phrase role="number">0</phrase><phrase role="special">]</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="char"> '\n'</phrase><phrase role="special">;</phrase><phrase role="comment"> // whole match
</phrase><phrase role="identifier">        std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="identifier"> what</phrase><phrase role="special">[</phrase><phrase role="number">1</phrase><phrase role="special">]</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="char"> '\n'</phrase><phrase role="special">;</phrase><phrase role="comment"> // first capture
</phrase><phrase role="identifier">        std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="identifier"> what</phrase><phrase role="special">[</phrase><phrase role="number">2</phrase><phrase role="special">]</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="char"> '\n'</phrase><phrase role="special">;</phrase><phrase role="comment"> // second capture
</phrase><phrase role="special">    }</phrase><phrase role="keyword">

    return</phrase><phrase role="number"> 0</phrase><phrase role="special">;</phrase><phrase role="special">
}</phrase>
</literal>
</programlisting>
<para>
This program outputs the following:</para>
<programlisting><literal>hello world!
hello
world
</literal></programlisting><para>
<sbr/>

<link linkend="boost_xpressive.user_s_guide.examples">top</link></para>
<para/><anchor id="user_s_guide.examples.see_if_a_string_contains_a_sub_string_that_matches_a_regex" /><bridgehead renderas="sect4">See if a string contains a sub-string that matches a regex</bridgehead><para>
Notice in this example how we use custom <code><phrase role="identifier">mark_tag</phrase></code>s to make the pattern more readable.
We can use the <code><phrase role="identifier">mark_tag</phrase></code>s later to index into the <literal><classname alt="boost::xpressive::match_results">match_results&lt;&gt;</classname></literal>.</para>
<programlisting>
<literal>
<phrase role="preprocessor">#include</phrase><phrase role="special"> &lt;</phrase><phrase role="identifier">iostream</phrase><phrase role="special">&gt;</phrase><phrase role="preprocessor">
#include</phrase><phrase role="special"> &lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">/</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase><phrase role="keyword">

using</phrase><phrase role="keyword"> namespace</phrase><phrase role="identifier"> boost</phrase><phrase role="special">::</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">;</phrase><phrase role="keyword">

int</phrase><phrase role="identifier"> main</phrase><phrase role="special">()</phrase><phrase role="special">
{</phrase><phrase role="keyword">
    char</phrase><phrase role="keyword"> const</phrase><phrase role="special"> *</phrase><phrase role="identifier">str</phrase><phrase role="special"> =</phrase><phrase role="string"> &quot;I was born on 5/30/1973 at 7am.&quot;</phrase><phrase role="special">;</phrase><phrase role="comment">

    // define some custom mark_tags with names more meaningful than s1, s2, etc.
</phrase><phrase role="identifier">    mark_tag</phrase><phrase role="identifier"> day</phrase><phrase role="special">(</phrase><phrase role="number">1</phrase><phrase role="special">),</phrase><phrase role="identifier"> month</phrase><phrase role="special">(</phrase><phrase role="number">2</phrase><phrase role="special">),</phrase><phrase role="identifier"> year</phrase><phrase role="special">(</phrase><phrase role="number">3</phrase><phrase role="special">),</phrase><phrase role="identifier"> delim</phrase><phrase role="special">(</phrase><phrase role="number">4</phrase><phrase role="special">);</phrase><phrase role="comment">

    // this regex finds a date
</phrase><phrase role="identifier">    cregex</phrase><phrase role="identifier"> date</phrase><phrase role="special"> =</phrase><phrase role="special"> (</phrase><phrase role="identifier">month</phrase><phrase role="special">=</phrase><phrase role="identifier"> repeat</phrase><phrase role="special">&lt;</phrase><phrase role="number">1</phrase><phrase role="special">,</phrase><phrase role="number">2</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">_d</phrase><phrase role="special">))</phrase><phrase role="comment">           // find the month ...
</phrase><phrase role="special">               &gt;&gt;</phrase><phrase role="special"> (</phrase><phrase role="identifier">delim</phrase><phrase role="special">=</phrase><phrase role="special"> (</phrase><phrase role="identifier">set</phrase><phrase role="special">=</phrase><phrase role="char"> '/'</phrase><phrase role="special">,</phrase><phrase role="char">'-'</phrase><phrase role="special">))</phrase><phrase role="comment">            // followed by a delimiter ...
</phrase><phrase role="special">               &gt;&gt;</phrase><phrase role="special"> (</phrase><phrase role="identifier">day</phrase><phrase role="special">=</phrase><phrase role="identifier">   repeat</phrase><phrase role="special">&lt;</phrase><phrase role="number">1</phrase><phrase role="special">,</phrase><phrase role="number">2</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">_d</phrase><phrase role="special">))</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> delim</phrase><phrase role="comment">  // and a day followed by the same delimiter ...
</phrase><phrase role="special">               &gt;&gt;</phrase><phrase role="special"> (</phrase><phrase role="identifier">year</phrase><phrase role="special">=</phrase><phrase role="identifier">  repeat</phrase><phrase role="special">&lt;</phrase><phrase role="number">1</phrase><phrase role="special">,</phrase><phrase role="number">2</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">_d</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> _d</phrase><phrase role="special">));</phrase><phrase role="comment">    // and the year.
</phrase><phrase role="identifier">
    cmatch</phrase><phrase role="identifier"> what</phrase><phrase role="special">;</phrase><phrase role="keyword">

    if</phrase><phrase role="special">(</phrase><phrase role="identifier"> regex_search</phrase><phrase role="special">(</phrase><phrase role="identifier"> str</phrase><phrase role="special">,</phrase><phrase role="identifier"> what</phrase><phrase role="special">,</phrase><phrase role="identifier"> date</phrase><phrase role="special"> )</phrase><phrase role="special"> )</phrase><phrase role="special">
    {</phrase><phrase role="identifier">
        std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="identifier"> what</phrase><phrase role="special">[</phrase><phrase role="number">0</phrase><phrase role="special">]</phrase><phrase role="special">     &lt;&lt;</phrase><phrase role="char"> '\n'</phrase><phrase role="special">;</phrase><phrase role="comment"> // whole match
</phrase><phrase role="identifier">        std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="identifier"> what</phrase><phrase role="special">[</phrase><phrase role="identifier">day</phrase><phrase role="special">]</phrase><phrase role="special">   &lt;&lt;</phrase><phrase role="char"> '\n'</phrase><phrase role="special">;</phrase><phrase role="comment"> // the day
</phrase><phrase role="identifier">        std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="identifier"> what</phrase><phrase role="special">[</phrase><phrase role="identifier">month</phrase><phrase role="special">]</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="char"> '\n'</phrase><phrase role="special">;</phrase><phrase role="comment"> // the month
</phrase><phrase role="identifier">        std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="identifier"> what</phrase><phrase role="special">[</phrase><phrase role="identifier">year</phrase><phrase role="special">]</phrase><phrase role="special">  &lt;&lt;</phrase><phrase role="char"> '\n'</phrase><phrase role="special">;</phrase><phrase role="comment"> // the year
</phrase><phrase role="identifier">        std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="identifier"> what</phrase><phrase role="special">[</phrase><phrase role="identifier">delim</phrase><phrase role="special">]</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="char"> '\n'</phrase><phrase role="special">;</phrase><phrase role="comment"> // the delimiter
</phrase><phrase role="special">    }</phrase><phrase role="keyword">

    return</phrase><phrase role="number"> 0</phrase><phrase role="special">;</phrase><phrase role="special">
}</phrase>
</literal>
</programlisting>
<para>
This program outputs the following:</para>
<programlisting><literal>5/30/1973
30
5
1973
/
</literal></programlisting><para>
<sbr/>

<link linkend="boost_xpressive.user_s_guide.examples">top</link></para>
<para/><anchor id="user_s_guide.examples.replace_all_sub_strings_that_match_a_regex" /><bridgehead renderas="sect4">Replace all sub-strings that match a regex</bridgehead><para>
The following program finds dates in a string and marks them up with pseudo-HTML.</para>
<programlisting>
<literal>
<phrase role="preprocessor">#include</phrase><phrase role="special"> &lt;</phrase><phrase role="identifier">iostream</phrase><phrase role="special">&gt;</phrase><phrase role="preprocessor">
#include</phrase><phrase role="special"> &lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">/</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase><phrase role="keyword">

using</phrase><phrase role="keyword"> namespace</phrase><phrase role="identifier"> boost</phrase><phrase role="special">::</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">;</phrase><phrase role="keyword">

int</phrase><phrase role="identifier"> main</phrase><phrase role="special">()</phrase><phrase role="special">
{</phrase><phrase role="identifier">
    std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="identifier"> str</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;I was born on 5/30/1973 at 7am.&quot;</phrase><phrase role="special"> );</phrase><phrase role="comment">

    // essentially the same regex as in the previous example, but using a dynamic regex
</phrase><phrase role="identifier">    sregex</phrase><phrase role="identifier"> date</phrase><phrase role="special"> =</phrase><phrase role="identifier"> sregex</phrase><phrase role="special">::</phrase><phrase role="identifier">compile</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;(\\d{1,2})([/-])(\\d{1,2})\\2((?:\\d{2}){1,2})&quot;</phrase><phrase role="special"> );</phrase><phrase role="comment">

    // As in Perl, $&amp; is a reference to the sub-string that matched the regex
</phrase><phrase role="identifier">    std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="identifier"> format</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;&lt;date&gt;$&amp;&lt;/date&gt;&quot;</phrase><phrase role="special"> );</phrase><phrase role="identifier">

    str</phrase><phrase role="special"> =</phrase><phrase role="identifier"> regex_replace</phrase><phrase role="special">(</phrase><phrase role="identifier"> str</phrase><phrase role="special">,</phrase><phrase role="identifier"> date</phrase><phrase role="special">,</phrase><phrase role="identifier"> format</phrase><phrase role="special"> );</phrase><phrase role="identifier">
    std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="identifier"> str</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="char"> '\n'</phrase><phrase role="special">;</phrase><phrase role="keyword">

    return</phrase><phrase role="number"> 0</phrase><phrase role="special">;</phrase><phrase role="special">
}</phrase>
</literal>
</programlisting>
<para>
This program outputs the following:</para>
<programlisting><literal>I was born on &lt;date&gt;5/30/1973&lt;/date&gt; at 7am.
</literal></programlisting><para>
<sbr/>

<link linkend="boost_xpressive.user_s_guide.examples">top</link></para>
<para/><anchor id="user_s_guide.examples.find_all_the_sub_strings_that_match_a_regex_and_step_through_them_one_at_a_time" /><bridgehead renderas="sect4">Find all the sub-strings that match a regex and step through them one at a time</bridgehead><para>
The following program finds the words in a wide-character string.
It uses <code><phrase role="identifier">wsregex_iterator</phrase></code>. Notice that dereferencing a <code><phrase role="identifier">wsregex_iterator</phrase></code>
yields a <code><phrase role="identifier">wsmatch</phrase></code> object.</para>
<programlisting>
<literal>
<phrase role="preprocessor">#include</phrase><phrase role="special"> &lt;</phrase><phrase role="identifier">iostream</phrase><phrase role="special">&gt;</phrase><phrase role="preprocessor">
#include</phrase><phrase role="special"> &lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">/</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase><phrase role="keyword">

using</phrase><phrase role="keyword"> namespace</phrase><phrase role="identifier"> boost</phrase><phrase role="special">::</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">;</phrase><phrase role="keyword">

int</phrase><phrase role="identifier"> main</phrase><phrase role="special">()</phrase><phrase role="special">
{</phrase><phrase role="identifier">
    std</phrase><phrase role="special">::</phrase><phrase role="identifier">wstring</phrase><phrase role="identifier"> str</phrase><phrase role="special">(</phrase><phrase role="identifier"> L</phrase><phrase role="string">&quot;This is his face.&quot;</phrase><phrase role="special"> );</phrase><phrase role="comment">

    // find a whole word
</phrase><phrase role="identifier">    wsregex</phrase><phrase role="identifier"> token</phrase><phrase role="special"> =</phrase><phrase role="special"> +</phrase><phrase role="identifier">alnum</phrase><phrase role="special">;</phrase><phrase role="identifier">

    wsregex_iterator</phrase><phrase role="identifier"> cur</phrase><phrase role="special">(</phrase><phrase role="identifier"> str</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier"> str</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase><phrase role="identifier"> token</phrase><phrase role="special"> );</phrase><phrase role="identifier">
    wsregex_iterator</phrase><phrase role="identifier"> end</phrase><phrase role="special">;</phrase><phrase role="keyword">

    for</phrase><phrase role="special">(</phrase><phrase role="special"> ;</phrase><phrase role="identifier"> cur</phrase><phrase role="special"> !=</phrase><phrase role="identifier"> end</phrase><phrase role="special">;</phrase><phrase role="special"> ++</phrase><phrase role="identifier">cur</phrase><phrase role="special"> )</phrase><phrase role="special">
    {</phrase><phrase role="identifier">
        wsmatch</phrase><phrase role="keyword"> const</phrase><phrase role="special"> &amp;</phrase><phrase role="identifier">what</phrase><phrase role="special"> =</phrase><phrase role="special"> *</phrase><phrase role="identifier">cur</phrase><phrase role="special">;</phrase><phrase role="identifier">
        std</phrase><phrase role="special">::</phrase><phrase role="identifier">wcout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="identifier"> what</phrase><phrase role="special">[</phrase><phrase role="number">0</phrase><phrase role="special">]</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="identifier"> L</phrase><phrase role="char">'\n'</phrase><phrase role="special">;</phrase><phrase role="special">
    }</phrase><phrase role="keyword">

    return</phrase><phrase role="number"> 0</phrase><phrase role="special">;</phrase><phrase role="special">
}</phrase>
</literal>
</programlisting>
<para>
This program outputs the following:</para>
<programlisting><literal>This
is
his
face
</literal></programlisting><para>
<sbr/>

<link linkend="boost_xpressive.user_s_guide.examples">top</link></para>
<para/><anchor id="user_s_guide.examples.split_a_string_into_tokens_that_each_match_a_regex" /><bridgehead renderas="sect4">Split a string into tokens that each match a regex</bridgehead><para>
The following program finds race times in a string and displays first
the minutes and then the seconds. It uses <literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal>.</para>
<programlisting>
<literal>
<phrase role="preprocessor">#include</phrase><phrase role="special"> &lt;</phrase><phrase role="identifier">iostream</phrase><phrase role="special">&gt;</phrase><phrase role="preprocessor">
#include</phrase><phrase role="special"> &lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">/</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase><phrase role="keyword">

using</phrase><phrase role="keyword"> namespace</phrase><phrase role="identifier"> boost</phrase><phrase role="special">::</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">;</phrase><phrase role="keyword">

int</phrase><phrase role="identifier"> main</phrase><phrase role="special">()</phrase><phrase role="special">
{</phrase><phrase role="identifier">
    std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="identifier"> str</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;Eric: 4:40, Karl: 3:35, Francesca: 2:32&quot;</phrase><phrase role="special"> );</phrase><phrase role="comment">

    // find a race time
</phrase><phrase role="identifier">    sregex</phrase><phrase role="identifier"> time</phrase><phrase role="special"> =</phrase><phrase role="identifier"> sregex</phrase><phrase role="special">::</phrase><phrase role="identifier">compile</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;(\\d):(\\d\\d)&quot;</phrase><phrase role="special"> );</phrase><phrase role="comment">

    // for each match, the token iterator should first take the value of
    // the first marked sub-expression followed by the value of the second
    // marked sub-expression
</phrase><phrase role="keyword">    int</phrase><phrase role="keyword"> const</phrase><phrase role="identifier"> subs</phrase><phrase role="special">[]</phrase><phrase role="special"> =</phrase><phrase role="special"> {</phrase><phrase role="number"> 1</phrase><phrase role="special">,</phrase><phrase role="number"> 2</phrase><phrase role="special"> };</phrase><phrase role="identifier">

    sregex_token_iterator</phrase><phrase role="identifier"> cur</phrase><phrase role="special">(</phrase><phrase role="identifier"> str</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier"> str</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase><phrase role="identifier"> time</phrase><phrase role="special">,</phrase><phrase role="identifier"> subs</phrase><phrase role="special"> );</phrase><phrase role="identifier">
    sregex_token_iterator</phrase><phrase role="identifier"> end</phrase><phrase role="special">;</phrase><phrase role="keyword">

    for</phrase><phrase role="special">(</phrase><phrase role="special"> ;</phrase><phrase role="identifier"> cur</phrase><phrase role="special"> !=</phrase><phrase role="identifier"> end</phrase><phrase role="special">;</phrase><phrase role="special"> ++</phrase><phrase role="identifier">cur</phrase><phrase role="special"> )</phrase><phrase role="special">
    {</phrase><phrase role="identifier">
        std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="special"> *</phrase><phrase role="identifier">cur</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="char"> '\n'</phrase><phrase role="special">;</phrase><phrase role="special">
    }</phrase><phrase role="keyword">

    return</phrase><phrase role="number"> 0</phrase><phrase role="special">;</phrase><phrase role="special">
}</phrase>
</literal>
</programlisting>
<para>
This program outputs the following:</para>
<programlisting><literal>4
40
3
35
2
32
</literal></programlisting><para>
<sbr/>

<link linkend="boost_xpressive.user_s_guide.examples">top</link></para>
<para/><anchor id="user_s_guide.examples.split_a_string_using_a_regex_as_a_delimiter" /><bridgehead renderas="sect4">Split a string using a regex as a delimiter</bridgehead><para>
The following program takes some text that has been marked up with html and strips
out the mark-up. It uses a regex that matches an HTML tag and a <literal><classname alt="boost::xpressive::regex_token_iterator">regex_token_iterator&lt;&gt;</classname></literal>
that returns the parts of the string that do <emphasis>not</emphasis> match the regex.</para>
<programlisting>
<literal>
<phrase role="preprocessor">#include</phrase><phrase role="special"> &lt;</phrase><phrase role="identifier">iostream</phrase><phrase role="special">&gt;</phrase><phrase role="preprocessor">
#include</phrase><phrase role="special"> &lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">/</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase><phrase role="keyword">

using</phrase><phrase role="keyword"> namespace</phrase><phrase role="identifier"> boost</phrase><phrase role="special">::</phrase><phrase role="identifier">xpressive</phrase><phrase role="special">;</phrase><phrase role="keyword">

int</phrase><phrase role="identifier"> main</phrase><phrase role="special">()</phrase><phrase role="special">
{</phrase><phrase role="identifier">
    std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="identifier"> str</phrase><phrase role="special">(</phrase><phrase role="string"> &quot;Now &lt;bold&gt;is the time &lt;i&gt;for all good men&lt;/i&gt; to come to the aid of their&lt;/bold&gt; country.&quot;</phrase><phrase role="special"> );</phrase><phrase role="comment">

    // find a HTML tag
</phrase><phrase role="identifier">    sregex</phrase><phrase role="identifier"> html</phrase><phrase role="special"> =</phrase><phrase role="char"> '&lt;'</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="identifier"> optional</phrase><phrase role="special">(</phrase><phrase role="char">'/'</phrase><phrase role="special">)</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="special"> +</phrase><phrase role="identifier">_w</phrase><phrase role="special"> &gt;&gt;</phrase><phrase role="char"> '&gt;'</phrase><phrase role="special">;</phrase><phrase role="comment">

    // the -1 below directs the token iterator to display the parts of
    // the string that did NOT match the regular expression.
</phrase><phrase role="identifier">    sregex_token_iterator</phrase><phrase role="identifier"> cur</phrase><phrase role="special">(</phrase><phrase role="identifier"> str</phrase><phrase role="special">.</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier"> str</phrase><phrase role="special">.</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase><phrase role="identifier"> html</phrase><phrase role="special">,</phrase><phrase role="special"> -</phrase><phrase role="number">1</phrase><phrase role="special"> );</phrase><phrase role="identifier">
    sregex_token_iterator</phrase><phrase role="identifier"> end</phrase><phrase role="special">;</phrase><phrase role="keyword">

    for</phrase><phrase role="special">(</phrase><phrase role="special"> ;</phrase><phrase role="identifier"> cur</phrase><phrase role="special"> !=</phrase><phrase role="identifier"> end</phrase><phrase role="special">;</phrase><phrase role="special"> ++</phrase><phrase role="identifier">cur</phrase><phrase role="special"> )</phrase><phrase role="special">
    {</phrase><phrase role="identifier">
        std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="char"> '{'</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="special"> *</phrase><phrase role="identifier">cur</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="char"> '}'</phrase><phrase role="special">;</phrase><phrase role="special">
    }</phrase><phrase role="identifier">
    std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="char"> '\n'</phrase><phrase role="special">;</phrase><phrase role="keyword">

    return</phrase><phrase role="number"> 0</phrase><phrase role="special">;</phrase><phrase role="special">
}</phrase>
</literal>
</programlisting>
<para>
This program outputs the following:</para>
<programlisting><literal>{Now }{is the time }{for all good men}{ to come to the aid of their}{ country.}
</literal></programlisting><para>
<sbr/>

<link linkend="boost_xpressive.user_s_guide.examples">top</link></para>
<para/><anchor id="user_s_guide.examples.display_a_tree_of_nested_results" /><bridgehead renderas="sect4">Display a tree of nested results</bridgehead><para>
Here is a helper class to demonstrate how you might display a tree of nested results:</para>
<programlisting>
<literal>
<phrase role="comment">// Displays nested results to std::cout with indenting
</phrase><phrase role="keyword">struct</phrase><phrase role="identifier"> output_nested_results</phrase><phrase role="special">
{</phrase><phrase role="keyword">
    int</phrase><phrase role="identifier"> tabs_</phrase><phrase role="special">;</phrase><phrase role="identifier">

    output_nested_results</phrase><phrase role="special">(</phrase><phrase role="keyword"> int</phrase><phrase role="identifier"> tabs</phrase><phrase role="special"> =</phrase><phrase role="number"> 0</phrase><phrase role="special"> )</phrase><phrase role="special">
        :</phrase><phrase role="identifier"> tabs_</phrase><phrase role="special">(</phrase><phrase role="identifier"> tabs</phrase><phrase role="special"> )</phrase><phrase role="special">
    {</phrase><phrase role="special">
    }</phrase><phrase role="keyword">

    template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword"> typename</phrase><phrase role="identifier"> BidiIterT</phrase><phrase role="special"> &gt;</phrase><phrase role="keyword">
    void</phrase><phrase role="keyword"> operator</phrase><phrase role="special"> ()(</phrase><phrase role="identifier"> match_results</phrase><phrase role="special">&lt;</phrase><phrase role="identifier"> BidiIterT</phrase><phrase role="special"> &gt;</phrase><phrase role="keyword"> const</phrase><phrase role="special"> &amp;</phrase><phrase role="identifier">what</phrase><phrase role="special"> )</phrase><phrase role="keyword"> const</phrase><phrase role="special">
    {</phrase><phrase role="comment">
        // first, do some indenting
</phrase><phrase role="keyword">        typedef</phrase><phrase role="keyword"> typename</phrase><phrase role="identifier"> std</phrase><phrase role="special">::</phrase><phrase role="identifier">iterator_traits</phrase><phrase role="special">&lt;</phrase><phrase role="identifier"> BidiIterT</phrase><phrase role="special"> &gt;::</phrase><phrase role="identifier">value_type</phrase><phrase role="identifier"> char_type</phrase><phrase role="special">;</phrase><phrase role="identifier">
        char_type</phrase><phrase role="identifier"> space_ch</phrase><phrase role="special"> =</phrase><phrase role="identifier"> char_type</phrase><phrase role="special">(</phrase><phrase role="char">' '</phrase><phrase role="special">);</phrase><phrase role="identifier">
        std</phrase><phrase role="special">::</phrase><phrase role="identifier">fill_n</phrase><phrase role="special">(</phrase><phrase role="identifier"> std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream_iterator</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">char_type</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier"> std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> ),</phrase><phrase role="identifier"> tabs_</phrase><phrase role="special"> *</phrase><phrase role="number"> 4</phrase><phrase role="special">,</phrase><phrase role="identifier"> space_ch</phrase><phrase role="special"> );</phrase><phrase role="comment">

        // output the match
</phrase><phrase role="identifier">        std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="identifier"> what</phrase><phrase role="special">[</phrase><phrase role="number">0</phrase><phrase role="special">]</phrase><phrase role="special"> &lt;&lt;</phrase><phrase role="char"> '\n'</phrase><phrase role="special">;</phrase><phrase role="comment">

        // output any nested matches
</phrase><phrase role="identifier">        std</phrase><phrase role="special">::</phrase><phrase role="identifier">for_each</phrase><phrase role="special">(</phrase><phrase role="identifier">
            what</phrase><phrase role="special">.</phrase><phrase role="identifier">nested_results</phrase><phrase role="special">().</phrase><phrase role="identifier">begin</phrase><phrase role="special">(),</phrase><phrase role="identifier">
            what</phrase><phrase role="special">.</phrase><phrase role="identifier">nested_results</phrase><phrase role="special">().</phrase><phrase role="identifier">end</phrase><phrase role="special">(),</phrase><phrase role="identifier">
            output_nested_results</phrase><phrase role="special">(</phrase><phrase role="identifier"> tabs_</phrase><phrase role="special"> +</phrase><phrase role="number"> 1</phrase><phrase role="special"> )</phrase><phrase role="special"> );</phrase><phrase role="special">
    }</phrase><phrase role="special">
};</phrase>
</literal>
</programlisting>
<para>
<link linkend="boost_xpressive.user_s_guide.examples">top</link></para>
</section></section>
<xi:include href="autodoc.boostbook" />

<section id="boost_xpressive.acknowledgments">
<title>Acknowledgments</title>
<para>
I am indebted to <ulink url="http://boost.org/people/joel_de_guzman.htm">Joel de Guzman</ulink> and
<ulink url="http://boost.org/people/hartmut_kaiser.htm">Hartmut Kaiser</ulink> for their expert advice
during the early states of xpressive's development. I am thankful for
<ulink url="http://boost.org/people/john_maddock.htm">John Maddock</ulink>'s excellent work on his proposal
to add regular expressions to the standard library. I'd also like to thank
<ulink url="http://moderncppdesign.com/">Andrei Alexandrescu</ulink> for his input regarding the behavior
of nested regex objects, and <ulink url="http://boost.org/people/dave_abrahams.htm">Dave Abrahams</ulink>
for his suggestions regarding the regex domain-specific embedded language.</para>
</section>
<section id="boost_xpressive.appendix_1__not_yet_implemented">
<title>Appendix 1: Not Yet Implemented</title>
<para>
The following features of xpressive have not yet been implemented, but are planned
for the near future:<sbr/>

<sbr/>
</para>
<itemizedlist>
<listitem>
match_flag_type::format_sed
</listitem><listitem>
match_flag_type::format_perl
<sbr/>

</listitem>
</itemizedlist><para>
The following features are planned for xpressive 2.0:<sbr/>

<sbr/>
</para>
<itemizedlist>
<listitem>
syntax_option_type::collate
</listitem><listitem>
POSIX collation sequences such as <literal>[.a.]</literal> and <literal>[=a=]</literal>
</listitem><listitem>
Look-behind assertions <literal>(?&lt;=...)</literal> and <literal>(?&lt;!...)</literal>
</listitem><listitem>
Semantic actions
</listitem><listitem>
Fine-grained control over the dynamic regex syntax
</listitem><listitem>
Improved localization support, possibly as a custom facet for <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">locale</phrase></code>
</listitem>
</itemizedlist></section>
<section id="boost_xpressive.appendix_2__differences_from_boost_regex">
<title>Appendix 2: Differences from Boost.Regex</title>
<para>
Since many of xpressive's users are likely to be familiar with the <ulink url="../../libs/regex">Boost.Regex</ulink> library,
I would be remiss if I failed to point out some important differences between xpressive
and <ulink url="../../libs/regex">Boost.Regex</ulink>. In particular:<sbr/>
</para>
<itemizedlist>
<listitem>
<code><phrase role="identifier">xpressive</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_regex</phrase><phrase role="special">&lt;&gt;</phrase></code> is a template on the iterator type, not the character type.
</listitem><listitem>
<code><phrase role="identifier">xpressive</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_regex</phrase><phrase role="special">&lt;&gt;</phrase></code> cannot be constructed directly from a string; rather, you must use
  <code><phrase role="identifier">basic_regex</phrase><phrase role="special">::</phrase><phrase role="identifier">compile</phrase><phrase role="special">()</phrase></code> or <code><phrase role="identifier">regex_compiler</phrase><phrase role="special">&lt;&gt;</phrase></code> to build a regex object from a string.
</listitem><listitem>
<code><phrase role="identifier">xpressive</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_regex</phrase><phrase role="special">&lt;&gt;</phrase></code> does not have an <code><phrase role="identifier">imbue</phrase><phrase role="special">()</phrase></code> member function; rather, the <code><phrase role="identifier">imbue</phrase><phrase role="special">()</phrase></code> member
  function is in the <code><phrase role="identifier">xpressive</phrase><phrase role="special">::</phrase><phrase role="identifier">regex_compiler</phrase><phrase role="special">&lt;&gt;</phrase></code> factory.
</listitem><listitem>
<code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_regex</phrase><phrase role="special">&lt;&gt;</phrase></code> has a subset of <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_string</phrase><phrase role="special">&lt;&gt;</phrase></code>'s members. <code><phrase role="identifier">xpressive</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_regex</phrase><phrase role="special">&lt;&gt;</phrase></code>
  does not. The members lacking are: <code><phrase role="identifier">assign</phrase><phrase role="special">()</phrase></code>, <code><phrase role="keyword">operator</phrase><phrase role="special">[]()</phrase></code>, <code><phrase role="identifier">max_size</phrase><phrase role="special">()</phrase></code>, <code><phrase role="identifier">begin</phrase><phrase role="special">()</phrase></code>, <code><phrase role="identifier">end</phrase><phrase role="special">()</phrase></code>,
  <code><phrase role="identifier">size</phrase><phrase role="special">()</phrase></code>, <code><phrase role="identifier">compare</phrase><phrase role="special">()</phrase></code>, and <code><phrase role="keyword">operator</phrase><phrase role="special">=(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_string</phrase><phrase role="special">&lt;&gt;)</phrase></code>.
</listitem><listitem>
Other member functions that exist in <code><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_regex</phrase><phrase role="special">&lt;&gt;</phrase></code> but do not exist in
  <code><phrase role="identifier">xpressive</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_regex</phrase><phrase role="special">&lt;&gt;</phrase></code> are: <code><phrase role="identifier">set_expression</phrase><phrase role="special">()</phrase></code>, <code><phrase role="identifier">get_allocator</phrase><phrase role="special">()</phrase></code>, <code><phrase role="identifier">imbue</phrase><phrase role="special">()</phrase></code>, <code><phrase role="identifier">getloc</phrase><phrase role="special">()</phrase></code>,
  <code><phrase role="identifier">getflags</phrase><phrase role="special">()</phrase></code>, and <code><phrase role="identifier">str</phrase><phrase role="special">()</phrase></code>.
</listitem><listitem>
<code><phrase role="identifier">xpressive</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_regex</phrase><phrase role="special">&lt;&gt;</phrase></code> does not have a RegexTraits template parameter. Customization of regex
  syntax and localization behavior will be controlled by <code><phrase role="identifier">regex_compiler</phrase><phrase role="special">&lt;&gt;</phrase></code> and a custom regex facet
  for <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">locale</phrase></code>.
</listitem><listitem>
<code><phrase role="identifier">xpressive</phrase><phrase role="special">::</phrase><phrase role="identifier">basic_regex</phrase><phrase role="special">&lt;&gt;</phrase></code> and <code><phrase role="identifier">xpressive</phrase><phrase role="special">::</phrase><phrase role="identifier">match_results</phrase><phrase role="special">&lt;&gt;</phrase></code> do not have an Allocator template
  parameter. This is by design.
</listitem><listitem>
<code><phrase role="identifier">match_not_dot_null</phrase></code> and <code><phrase role="identifier">match_not_dot_newline</phrase></code> have moved from the <code><phrase role="identifier">match_flag_type</phrase></code> enum to the
  <code><phrase role="identifier">syntax_option_type</phrase></code> enum, and they have changed names to <code><phrase role="identifier">not_dot_null</phrase></code> and <code><phrase role="identifier">not_dot_newline</phrase></code>.
</listitem><listitem>
The following <code><phrase role="identifier">syntax_option_type</phrase></code> enumeration values are not supported: <code><phrase role="identifier">escape_in_lists</phrase></code>,
  <code><phrase role="identifier">char_classes</phrase></code>, <code><phrase role="identifier">intervals</phrase></code>, <code><phrase role="identifier">limited_ops</phrase></code>, <code><phrase role="identifier">newline_alt</phrase></code>, <code><phrase role="identifier">bk_plus_qm</phrase></code>, <code><phrase role="identifier">bk_braces</phrase></code>, <code><phrase role="identifier">bk_parens</phrase></code>,
  <code><phrase role="identifier">bk_refs</phrase></code>, <code><phrase role="identifier">bk_vbar</phrase></code>, <code><phrase role="identifier">use_except</phrase></code>, <code><phrase role="identifier">failbit</phrase></code>, <code><phrase role="identifier">literal</phrase></code>, <code><phrase role="identifier">perlex</phrase></code>, <code><phrase role="identifier">basic</phrase></code>, <code><phrase role="identifier">extended</phrase></code>, <code><phrase role="identifier">emacs</phrase></code>,
  <code><phrase role="identifier">awk</phrase></code>, <code><phrase role="identifier">grep</phrase></code> ,<code><phrase role="identifier">egrep</phrase></code>, <code><phrase role="identifier">sed</phrase></code>, <code><phrase role="identifier">JavaScript</phrase></code>, <code><phrase role="identifier">JScript</phrase></code>.
</listitem><listitem>
The following <code><phrase role="identifier">match_flag_type</phrase></code> enumeration values are not supported: <code><phrase role="identifier">match_not_bob</phrase></code>,
  <code><phrase role="identifier">match_not_eob</phrase></code>, <code><phrase role="identifier">match_perl</phrase></code>, <code><phrase role="identifier">match_posix</phrase></code>, and <code><phrase role="identifier">match_extra</phrase></code>.
</listitem>
</itemizedlist><para>
Also, in the current implementation, the regex algorithms in xpressive will not detect
pathological behavior and abort by throwing an exception. It is up to you to write efficient
patterns that do not behave pathologically.</para>
</section>
<section id="boost_xpressive.perf">
<title> Appendix 3: Performance Comparison</title>
<para>
The performance of xpressive is competitive with <ulink url="../../libs/regex">Boost.Regex</ulink>. I have run performance
benchmarks comparing static xpressive, dynamic xpressive and <ulink url="../../libs/regex">Boost.Regex</ulink> on two platforms:
gcc (Cygwin) and Visual C++. The tests include short matches and long searches. For both
platforms, xpressive comes off well on short matches and roughly on par with <ulink url="../../libs/regex">Boost.Regex</ulink> on
long searches.</para>
<para>
&lt;disclaimer&gt;
As with all benchmarks,
the true test is how xpressive performs with <emphasis>your</emphasis> patterns, <emphasis>your</emphasis> input, and <emphasis>your</emphasis>
platform, so if performance matters in your application, it's best to run your own tests.
&lt;/disclaimer&gt;</para>

<section id="boost_xpressive.perf.perf_gcc">
<title> xpressive vs. Boost.Regex with GCC (Cygwin)</title>
<para>
Below are the results of a performance comparison between:</para>
<itemizedlist>
<listitem>
static xpressive
</listitem><listitem>
dynamic xpressive
</listitem><listitem>
<ulink url="../../libs/regex">Boost.Regex</ulink>
</listitem>
</itemizedlist><variablelist>
<title>Test Specifications</title>
<varlistentry><term>Hardware:</term><listitem>hyper-threaded 3GHz Xeon with 1Gb RAM</listitem></varlistentry>
<varlistentry><term>Operating System:</term><listitem>Windows XP Pro + Cygwin</listitem></varlistentry>
<varlistentry><term>Compiler:</term><listitem>GNU C++ version 3.4.4 (Cygwin special)</listitem></varlistentry>
<varlistentry><term>C++ Standard Library:</term><listitem>GNU libstdc++ version 3.4.4</listitem></varlistentry>
<varlistentry><term><ulink url="../../libs/regex">Boost.Regex</ulink> Version:</term><listitem>1.33+, BOOST_REGEX_USE_CPP_LOCALE, BOOST_REGEX_RECURSIVE</listitem></varlistentry>
<varlistentry><term>xpressive Version:</term><listitem>0.9.6a</listitem></varlistentry>
</variablelist>
<anchor id="perf.perf_gcc.comparison_1__short_matches" /><bridgehead renderas="sect2">Comparison 1: Short Matches</bridgehead><para>
The following tests evaluate the time taken to match the expression to the input string.
For each result, the top number has been normalized relative to the fastest time, so 1.0
is as good as it gets. The bottom number (in parentheses) is the actual time in seconds.
The best time has been marked in green.</para>

<xi:include href="../perf/gcc/short_matches.xml" />
<anchor id="perf.perf_gcc.comparison_2__long_searches" /><bridgehead renderas="sect2">Comparison 2: Long Searches</bridgehead><para>
The next test measures the time to find <emphasis>all</emphasis> matches in a long English text. The text is the
<ulink url="http://www.gutenberg.org/dirs/3/2/0/3200/3200.zip">complete works of Mark Twain</ulink>,
from <ulink url="http://promo.net/pg/">Project Gutenberg</ulink>. The text is 19Mb long. As above, the top number
is the normalized time and the bottom number is the actual time. The best time is in green.</para>

<xi:include href="../perf/gcc/long_twain_search.xml" />
</section>
<section id="boost_xpressive.perf.perf_msvc">
<title> xpressive vs. Boost.Regex with Visual C++</title>
<para>
Below are the results of a performance comparison between:</para>
<itemizedlist>
<listitem>
static xpressive
</listitem><listitem>
dynamic xpressive
</listitem><listitem>
<ulink url="../../libs/regex">Boost.Regex</ulink>
</listitem>
</itemizedlist><variablelist>
<title>Test Specifications</title>
<varlistentry><term>Hardware:</term><listitem>hyper-threaded 3GHz Xeon with 1Gb RAM</listitem></varlistentry>
<varlistentry><term>Operating System:</term><listitem>Windows XP Pro</listitem></varlistentry>
<varlistentry><term>Compiler:</term><listitem>Visual C++ .NET 2003 (7.1)</listitem></varlistentry>
<varlistentry><term>C++ Standard Library:</term><listitem>Dinkumware, version 313</listitem></varlistentry>
<varlistentry><term><ulink url="../../libs/regex">Boost.Regex</ulink> Version:</term><listitem>1.33+, BOOST_REGEX_USE_CPP_LOCALE, BOOST_REGEX_RECURSIVE</listitem></varlistentry>
<varlistentry><term>xpressive Version:</term><listitem>0.9.6a</listitem></varlistentry>
</variablelist>
<anchor id="perf.perf_msvc.comparison_1__short_matches" /><bridgehead renderas="sect2">Comparison 1: Short Matches</bridgehead><para>
The following tests evaluate the time taken to match the expression to the input string.
For each result, the top number has been normalized relative to the fastest time, so 1.0
is as good as it gets. The bottom number (in parentheses) is the actual time in seconds.
The best time has been marked in green.</para>

<xi:include href="../perf/msvc/short_matches.xml" />
<anchor id="perf.perf_msvc.comparison_2__long_searches" /><bridgehead renderas="sect2">Comparison 2: Long Searches</bridgehead><para>
The next test measures the time to find <emphasis>all</emphasis> matches in a long English text. The text is the
<ulink url="http://www.gutenberg.org/dirs/3/2/0/3200/3200.zip">complete works of Mark Twain</ulink>,
from <ulink url="http://promo.net/pg/">Project Gutenberg</ulink>. The text is 19Mb long. As above, the top number
is the normalized time and the bottom number is the actual time. The best time is in green.</para>

<xi:include href="../perf/msvc/long_twain_search.xml" />
</section></section>
</library>

