<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
    <title>Boost.Range Range Implementation </title>
    <meta http-equiv="Content-Type"content="text/html; charset=iso-8859-1">
    <link rel="stylesheet" href="style.css" type="text/css">
</head>

    <body>

    <table  >
        <tr  >
            <td  ><img src="cboost.gif" width="100%" border="0"></td>
            <td  ><h1  ><br>
                Boost.Range </h1></td>
        </tr>
    </table>

    <h2>Single Pass Range, Forward Range and Bidirectional Range Implementation</h2>

    <ul  >
        <li>
            <a href="#overview">Overview</a>
        <li  >
            <a href="#Synopsis" >Synopsis</a>
        </li>
        <li  >
            <a href="#Semantics" >Semantics</a>
        </li>
    </ul>
    <hr size="1" >

    <h3>Overview</h3>
    <p>
    Four types of objects are currently supported by the library:
    <ul  >
        <li  >
            standard containers
        </li>
        <li  >
            <code  >std::pair&lt;iterator,iterator&gt;</code>
        </li>
        <li  >
            null terminated strings (this includes <code  >char[]</code>,<code  >wchar_t[]</code>,
            <code  >char*</code>, and <code  >wchar_t*</code>)
        </li>
        <li  >
            built-in arrays
        </li>
    </ul>
    
    Even though the behavior of the primary templates are exactly such 
    that standard containers will be supported by default, the requirements
    are much lower than the standard container requirements. For example, 
    the utility class <a href="utility_class#iterator_range"><code>iterator_range</code></a> implements the minimal interface required to make the class
    a <a href="range.htm#forward_range">Forward Range</a>.
    </p>
    
    <p>
    Please also see <a href="range.htm">Range concepts</a> for more details. 
    </p>
    
    <a name="Synopsis" ></a>
    <h3  >Synopsis</h3>

    <p  >

    <pre>
namespace boost
{
    //
    // Single Pass Range metafunctions
    //
    
    template< class T >
    struct <a href="#value_type_of" >value_type_of</a>;
                 
    template< class T >
    struct <a href="#iterator_of" >iterator_of</a>;
    
    template< class T >
    struct <a href="#const_iterator_of" >const_iterator_of</a>;
    
    //
    // Forward Range metafunctions
    //
    
    template< class T >
    struct <a href="#difference_type_of" >difference_type_of</a>;
    
    template< class T >
    struct <a href="#size_type_of" >size_type_of</a>;
    
    //
    // Bidirectional Range metafunctions
    //
    
    template< class T >
    struct <a href="#reverse_iterator_of" >reverse_iterator_of</a>;

    template< class T >
    struct <a href="#const_reverse_iterator_of" >const_reverse_iterator_of</a>;
    
    //
    // Special metafunctions
    //
    
    template< class T >
    struct <a href="#result_iterator_of" >result_iterator_of</a>;
                 
    template< class T >
    struct <a href="#reverse_result_iterator_of" >reverse_result_iterator_of</a>;

    //
    // Single Pass Range functions
    //
    
    template< class T >
    inline typename iterator_of&lt;T>::type
    <a href="#begin" >begin</a>( T& c );
    
    template< class T >
    inline typename const_iterator_of&lt;T>::type
    <a href="#begin" >begin</a>( const T& c );
        
    template< class T >
    inline typename iterator_of&lt;T>::type
    <a href="#end" >end</a>( T& c );
                      
    template< class T >
    inline typename const_iterator_of&lt;T>::type
    <a href="#end" >end</a>( const T& c );
    
    template< class T >
    inline bool
    <a href="#empty" >empty</a>( const T& c );
               
    //
    // Forward Range functions
    //
    
    template< class T >
    inline typename size_type_of&lt;T>::type
    <a href="#size" >size</a>( const T& c );
                            
    //
    // Bidirectional Range functions
    //
                     
    template< class T >
    inline typename reverse_iterator_of&lt;T>::type
    <a href="#rbegin" >rbegin</a>( T& c );
    
    template< class T >
    inline typename const_reverse_iterator_of&lt;T>::type
    <a href="#rbegin" >rbegin</a>( const T& c );
        
    template< class T >
    inline typename reverse_iterator_of&lt;T>::type
    <a href="#rend" >rend</a>( T& c );
                      
    template< class T >
    inline typename const_reverse_iterator_of&lt;T>::type
    <a href="#rend" >rend</a>( const T& c );
    
} // namespace 'boost' </pre>
    </p>

<a name="Semantics" ></a>
    <h3  >Semantics</h3>

    <h4>notation</h4>
    <p>
    <table cellpadding="5" border="1">
        <tr>
            <th>Type
            <th>Object
            <th>Describes
        </tr>
        <tr>
            <td><code>X</code>
            <td> <code>x</code> 
            <td>any type
        </tr>
        <tr>
            <td><code>T</code> </td>
            <td><code>t</code>
            <td>denotes behavior of the primary templates</td>
        </tr>
        <tr>
            <td><code>P</code>
            <td><code>p</code>
            <td>denotes <code>std::pair&lt;iterator,iterator></code>
        </tr>
        <tr>
            <td><code>A[sz]</code>
            <td><code>a</code>
            <td>denotes an array of type <code>A</code> of size <code>sz</code>
        <tr>
        <tr>
            <td><code>Char*</code>
            <td><code>s</code>
            <td>denotes either <code>char*</code> or <code>wchar_t*</code>
        </tr>
    </table>
    </p>

    <p>
    Please notice in tables below that when four lines appear in a  
    cell, the first line will describe the primary template, the second
    line pairs of iterators, the third line arrays and the last line
    null-terminated strings.
    </p>
    <h4>Metafunctions</h4>
    <p>
    <table border="1" cellpadding="5" >
        <tr  >
            <th  >Expression</th>
            <th  >Return type</th>
            <th  >Complexity</th>
        </tr>
        <tr  >
            <a name="value_type_of" ></a>
            <td  ><code  >value_type_of&lt;X&gt;::type</code></td>
            <td  ><code  >T::value_type</code><br>
                <code  >boost::iterator_value&lt;P::first_type&gt;::type</code><br>
                <code  >A</code><br>
                <code>Char</code>
            <td  >compile time</td>
        </tr>
        <tr  >
            <a name="iterator_of" ></a>
            <td  ><code  >iterator_of&lt;X&gt;::type</code></td>
            <td  ><code  >T::iterator</code><br>
                  <code  >P::first_type</code><br>
                  <code  >A*</code><br>
                  <code>Char*</code> 
            <td  >compile time</td>
        </tr>
        <tr  >
            <a name="const_iterator_of" ></a>
            <td  ><code  >const_iterator_of&lt;X&gt;::type</code></td>
            <td  ><code  >T::const_iterator</code><br>
                  <code  >P::first_type</code><br>
                <code  >const A*</code><br>
                <code>const Char*</code>
            <td  >compile time</td>
        </tr>
        <tr  >
            <a name="difference_type_of" ></a>
            <td  ><code  >difference_type_of&lt;X&gt;::type</code></td>
            <td  ><code  >T::difference_type</code><br>
                  <code  
>boost_iterator_difference&lt;P::first_type&gt;::type</code><br>
                 <code  >std::ptrdiff_t</code><br>
                 <code  >std::ptrdiff_t</code><br>
            <td  >compile time</td>
        </tr>
        <tr  >
            <a name="size_type_of" ></a>
            <td  ><code  >size_type_of&lt;X&gt;::type</code></td>
            <td  ><code  >T::size_type</code><br>
                <code  >std::size_t</code><br>
                <code  >std::size_t</code><br>
                <code  >std::size_t</code><br>
            <td  >compile time</td>
        </tr>
        <tr  >
            <a name="result_iterator_of" ></a>
            <td  ><code  >result_iterator_of&lt;X&gt;::type</code></td>
            <td  ><code  >const_iterator_of&lt;X&gt;::type</code> if <code  
>X</code> is <code  >const</code> <br>
                <code  >iterator_of&lt;X&gt;::type</code> otherwise </td>
            <td  >compile time</td>
        </tr>
        <tr  >
            <a name="reverse_iterator_of" ></a>
            <td  ><code  >reverse_iterator_of&lt;X&gt;::type</code></td>
            <td  ><code  >boost::reverse_iterator< typename iterator_of&lt;T>::type ></code><br>
            <td  >compile time</td>
        </tr>
        <tr  >
            <a name="const_reverse_iterator_of" ></a>
            <td  ><code  >const_reverse_iterator_of&lt;X&gt;::type</code></td>
            <td  ><code  >boost::reverse_iterator< typename const_iterator_of&lt;T>::type ></code>
                <br>
            <td  >compile time</td>
        </tr>
        <tr  >
            <a name="reverse_result_iterator_of" ></a>
            <td  ><code  >reverse_result_iterator_of&lt;X&gt;::type</code></td>
            <td  ><code  >boost::reverse_iterator< typename result_iterator_of&lt;T&gt;::type ></code>
            <td  >compile time</td>
        </tr>


    </table>
    </p>
    <p>
    The special metafunctions <code>result_iterator_of</code> and
     <code>reverse_result_iterator_of</code> are not part 
of any Range concept, but they are very useful when implementing certain
    Range classes like <a 
href="utility_class.html#sub_range"><code>sub_range</code></a> because of 
their ability to select iterators based on constness.
    </p>

    <h4>Functions</h4>
    <p>
    <table border="1" cellpadding="5" >
        <tr  >
            <th  >Expression</th>
            <th  >Return type</th>
            <th  >Returns</th>
            <th  >Complexity</th>
        </tr>
        <tr  >
            <a name="begin" ></a>
            <td  ><code  >begin(x)</code></td>
            <td  ><code  >result_iterator_of&lt;X&gt;::type</code></td>
            <td  ><code  >t.begin()</code><br>
                  <code  >p.first</code><br>
                <code  >a</code><br>
                <code>s</code>
            <td  >constant time</td>
        </tr>
        <tr  >
            <a name="end" ></a>
            <td  ><code  >end(x)</code></td>
            <td  ><code  >result_iterator_of&lt;X&gt;::type</code></td>
            <td  ><code  >t.end()</code><br>
                  <code  >p.second</code><br>
                  <code  >a + sz</code> <br>
                <code  >s + std::char_traits&lt;X&gt;::length( s )</code> if 
<code  >X</code> is <code  >Char*</code><br>
                <code  >s + sz - 1</code> if <code  >X</code> is <code  >Char[sz]</code> <br>

               
            <td  >linear if <code  >X</code> is <code  >Char*</code> <br>
                constant time otherwise</td>
        </tr>
        <tr  >
            <a name="empty" ></a>
            <td  ><code  >empty(x)</code></td>
            <td  ><code  >bool</code></td>
            <td  ><code  >begin(x) == end( x )</code><br>
            <td  >linear if <code  >X</code> is <code  >Char*</code> <br>
                constant time otherwise<br>
            </td>
        </tr>
        <tr  >
            <a name="size" ></a>
            <td  ><code  >size(x)</code></td>
            <td  ><code  >size_type_of&lt;X&gt;::type</code></td>
            <td  ><code  >t.size()</code><br>
                  <code>std::distance(p.first,p.second)</code><br>
                  <code  >sz</code><br>
                  <code>end(s) - s</code>

            <td  >linear if <code  >X</code> is <code  >Char*</code> <br>
                or if <code  >std::distance()</code> is linear <br>
                constant time otherwise</td>
        </tr>
        <tr  >
            <a name="rbegin" ></a>
            <td  ><code  >rbegin(x)</code></td>
            <td  ><code  >reverse_result_iterator_of&lt;X&gt;::type</code></td>
            <td  ><code  >reverse_result_iterator_of&lt;X&gt;::type( end(x) 
)</code> <br> <td  >same as <code>end(x)</code> </td>
        </tr>
        <tr  >
            <a name="rend" ></a>
            <td  ><code  >rend(x)</code></td>
            <td  ><code  >reverse_result_iterator_of&lt;X&gt;::type</code></td>
            <td  ><code  >reverse_result_iterator_of&lt;X&gt;::type( begin(x) 
)</code> <td  >same as <code>begin(x)</code></td>
        </tr>

    </table>
    </p>


    <hr>
    <p>
    (C) Copyright Thorsten Ottosen 2003-2004
    </p>

    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>


    </body>
</html>
