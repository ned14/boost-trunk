<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
    <title>Boost.Range Terminology and Style Guidelines </title>
    <link rel="stylesheet" href="style.css" type="text/css">
</head>

    <body>

    <table border="0" >
        <tr>
            <td ><img src="cboost.gif" border="0" ></td>
            <td ><h1 align="center">Boost.Range </h1></td>
        </tr>
    </table>

    <h2>Terminology and style guidelines </h2>

    <p>
    The use of a consistent terminology is as important for <a href="range.html#range">Range</a>s 
    and range-based algorithms as it is for iterators and iterator-based algorithms. 
    If a conventional set of names are adopted, we can avoid misunderstandings and 
    write generic function prototypes that are <i>self-documenting</i>.
    </p>

    <p>
    Since ranges are characterized by a specific underlying iterator type, we get a 
    type of range for each type of iterator. Hence we can speak of the following 
    types of ranges:
    <ul>
        <li>
            <i>Value access</i> category:
            <ul>
                <li>
                    Readable Range
                <li>
                    Writeable Range
                <li>
                    Swappable Range
                <li>
                    Lvalue Range
            </ul>
        <li>
            <i>Traversal</i> category:
            <ul>
                <li>
                    <a href="range.htm#single_pass_range">Single Pass Range</a>
                <li>
                    <a href="range.htm#forward_range">Forward Range</a>
                <li>
                    <a href="range.htm#bidirectional_range">Bidirectional Range</a>
                <li>
                    <a href="range.htm#random_access_range">Random Access Range</a>
            </ul>
    </ul>
    Notice how we have used the categories from the <a href=../../iterator/doc/new-iter-concepts.html>new 
    style iterators</a>. 

    <p>
    Notice that an iterator (and therefore an range) has one <i>traversal</i> 
    property and one or more properties from the <i>value access</i> category. So in 
    reality we will mostly talk about mixtures such as
    <ul>
        <li>
            Random Access Readable Writeable Range
        <li>
            Forward Lvalue Range
    </ul>
    By convention, we should always specify the <i>traversal</i> property first as 
    done above. This seems reasonable since there will only be one <i>traversal</i> 
    property, but perhaps many <i>value access</i> properties.
    </p>

    <p>
    As an example, consider how we specify the interface of <code>std::sort()</code>. 
    The iterator-based version looks like this:

    <pre>
   template< class RandomAccessTraversalReadableWritableIterator >
   void sort( RandomAccessTraversalReadableWritableIterator first,
              RandomAccessTraversalReadableWritableIterator last );
   </pre>
    For ranges the interface becomes

    <pre>
   template< class RandomAccessReadableWritableRange >
   void sort( RandomAccessReadableWritableRange& r );
   </pre>


    </p>


    <hr>
    <p>
    (C) Copyright Thorsten Ottosen 2003-2004
    </p>

    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>


    </body>
</html>

