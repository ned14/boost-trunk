<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
    <title>Boost.Range Introduction </title>
    <link rel="stylesheet" href="style.css" type="text/css">
</head>

    <body>

    <table border="0" >
        <tr>
            <td ><img src="cboost.gif" border="0" ></td>
            <td ><h1 align="center">Boost.Range</h1></td>
        </tr>
    </table>

    <h2>Introduction</h2>
    <p>
    When writing generic code that works with Standard Library containers, one often 
    finds it desirable to extend that code to work with other types that offer 
    enough functionality to satisfy the needs of the generic code, but in an altered 
    form.  For example, raw arrays are often suitable for use with generic code that 
    works with containers, provided a suitable adapter is used. Likewise, null 
    terminated strings can be treated as containers of characters, if suitably 
    adapted.  This library provides the means to adapt Standard Library containers, 
    null terminated strings, <code>std::pairs</code> of iterators, and raw 
arrays, such that the same generic code can work with them all.
    </p>

    <!--    <p>
    This library makes it possible to treat different types as if they have 
    implemented a subset of the container requirements (see &sect;23.1of the C++ 
    standard). Formally, that subset is defined by the  <a href="Range.htm"
    target="_self" >Range</a> concept. The subset deals mostly with iterator 
    returning functions and nested <code >typedef</code>s. The main goal is to treat 
    built-in arrays, standard containers, pairs of iterators and some iterators 
    uniformly.
    </p>
    -->
    <p  >
    The main advantages are
    <ul  >
        <li  >
            simpler implementation of generic range algorithms
        </li>
        <li  >
            more flexible client code
        </li>
        <li  >
            correct handling of null-terminated strings
        </li>
        <li  >
        safe use of built-in arrays (for legacy code; why else would you use 
arrays?) </li>

    </ul>
    </p>
    <p  >
    Below are given a small example (the complete example can be found <a href="../test/algorithm_example.cpp" target="_self" >here</a> 
    ):
    <blockquote>
        <pre  >
    //
    // example: extracting bounds in a generic algorithm
    //
    template< typename ForwardRange, typename T >
    inline typename boost::iterator_of< ForwardRange >::type
    find( ForwardRange& c, const T& value )
    {
       return std::find( boost::begin( c ), boost::end( c ), value );
    }
    
    template< typename ForwardRange, typename T >
    inline typename boost::const_iterator_of< ForwardRange >::type
    find( const ForwardRange& c, const T& value )
    {
       return std::find( boost::begin( c ), boost::end( c ), value );
    }
                   
    //
    // replace first value and return its index
    //
    template< class ForwardRange, class T >
    inline typename boost::size_type_of< ForwardRange >::type
    my_generic_replace( ForwardRange& c, const T& value, const T& replacement )
    {
       typename boost::iterator_of< ForwardRange >::type found = find( c, value );
       
       if( found != boost::end( c ) )
           *found = replacement;
       return std::distance( boost::begin( c ), found );
    }

    //
    // usage
    //
    const int N = 5;
    std::vector<int> my_vector;
    int values[] = { 1,2,3,4,5,6,7,8,9 };
    my_vector.assign( values, values + 9 );
    typedef std::vector<int>::iterator iterator;
    std::pair<iterator,iterator>       my_view( boost::begin( my_vector ),
                             boost::begin( my_vector ) + N );
    char  str_val[] = "a string";
    char* str       = str_val;
    
    std::cout << my_generic_replace( my_vector, 4, 2 )
              << my_generic_replace( my_view, 4, 2 )
              << my_generic_replace( str, 'a', 'b' );

    </pre>
    </blockquote>

    By using the free-standing functions and metafunctions, the code automatically 
    works for all the types supported by this library. Notice that we have to 
    provide two version of <code  >find()</code> since we cannot forward a non-const 
    rvalue with reference arguments (see this article about  <a href="http://std.dkuug.dk/jtc1/sc22/wg21/docs/papers/2002/n1385.htm" target="_self" >The 
    Forwarding Problem</a> ).

    </p>


    <hr>
    <p>
    (C) Copyright Thorsten Ottosen 2003-2004
    </p>

    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>


    </body>
</html>

