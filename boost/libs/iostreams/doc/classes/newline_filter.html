<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
    <TITLE>Class Template basic_newline_filter</TITLE>
    <LINK REL='stylesheet' HREF='../../../../boost.css'>
    <LINK REL='stylesheet' HREF='../theme/iostreams.css'>
</HEAD>
<BODY>

<!-- Begin Banner -->

    <H1 CLASS='title'>Class Template <CODE>basic_newline_filter</CODE></H1>
    <HR CLASS='banner'>

<!-- End Banner -->

<DL class='page-index'>
  <DT><A href='#description'>Description</A></DT>
  <!-- <DT><A href='#example'>Example</A></DT> -->
  <DT><A href='#headers'>Headers</A></DT>
  <DT><A href='#reference'>Reference</CODE></A></DT>
</DL>

<HR>

<A NAME='description'>
<H2>Description</H2>

<P>
    The class templates <CODE>basic_newline_filter</CODE> is a <A HREF='../concepts/dual_use_filter.html'>DualUseFilter</A> which converts between the text file formats used by various operating systems. Its sole constructor takes an integral flag parameter used to specify the source and target formats.
</P>
<P>
    Note: It is not known if specializations of <CODE>basic_newline_filter</CODE> other than <CODE>basic_newline_filter&lt;char&gt;</CODE> are useful. If not, the template parameter will be eliminated.
</P>

<!-- <A NAME='example'></A>
<H2>Example</H2>

<P>
    The following example uses a newline_filter to convert a text file to Unix format.
</P>

<PRE CLASS='broken_ie'>    <SPAN CLASS='preprocessor'>#include</SPAN> <A CLASS='header' HREF='../../../../boost/iostreams/copy.hpp'><SPAN CLASS='literal'>&lt;boost/iostreams/copy.hpp&gt;</SPAN></A>   
    <SPAN CLASS='preprocessor'>#include</SPAN> <A CLASS='header' HREF='../../../../boost/iostreams/device/file.hpp'><SPAN CLASS='literal'>&lt;boost/iostreams/device/file.hpp&gt;</SPAN></A>   
    <SPAN CLASS='preprocessor'>#include</SPAN> <A CLASS='header' HREF='../../../../boost/iostreams/filter/newline_filter.hpp'><SPAN CLASS='literal'>&lt;boost/iostreams/filter/newline_filter.hpp&gt;</SPAN></A>  

    using namespace boost::iostreams;
    filtering_streambuf in;
    in.push(newline_filter(newline::unixs));
    in.push(file_source("hello.txt", std::ios_base::binary));
    copy(in, file_sink("hello.txt", std::ios_base::binary) );
    
</PRE> -->

<A NAME='headers'>
<H2>Headers</H2>

<DL class='page-index'>
  <DT><A CLASS='header' HREF='../../../../boost/iostreams/filter/newline_filter.hpp'><CODE>&lt;boost/iostreams/filter/newline_filter.hpp&gt;</CODE></A></DT>
</DL>

<A NAME='reference'>
<H2>Reference</H2>

<H4>Synopsis</H4>

<PRE CLASS='broken_ie'><SPAN CLASS="keyword">namespace</SPAN> boost { <SPAN CLASS="keyword">namespace</SPAN> iostreams {

<SPAN CLASS="keyword">namespace</SPAN> newline { 

<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS='documented' HREF='#posix'>posix</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS='documented' HREF='#mac'>mac</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS='documented' HREF='#windows'>windows</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS='documented' HREF='#print_CR'>print_CR</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS='documented' HREF='#print_LF'>print_LF</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS='documented' HREF='#print_CRLF'>print_CRLF</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS='documented' HREF='#accept_CR'>accept_CR</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS='documented' HREF='#accept_LF'>accept_LF</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS='documented' HREF='#accept_CRLF'>accept_CRLF</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS='documented' HREF='#ignore_CR'>ignore_CR</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS='documented' HREF='#ignore_LF'>ignore_LF</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS='documented' HREF='#greedy'>greedy</A>;
<SPAN CLASS="keyword">const</SPAN> <SPAN CLASS="keyword">int</SPAN> <A CLASS='documented' HREF='#final_newline'>final_newline</A>;

} <SPAN CLASS='comment'>// End namespace boost::iostreams::newline</SPAN>

<SPAN CLASS="keyword">template</SPAN>&lt;<SPAN CLASS="keyword">typename</SPAN> <A CLASS="documented" HREF="#template_params">Ch</A>&gt;
<SPAN CLASS="keyword">class</SPAN> <A CLASS="documented" HREF="#template_params">basic_newline_filter</A> {
<SPAN CLASS="keyword">public</SPAN>:
    <SPAN CLASS="keyword">typedef</SPAN> Ch                     char_type;
    <SPAN CLASS="keyword">struct</SPAN> <SPAN CLASS='omitted'>implementation-defined</SPAN>  category
    <A CLASS="documented" HREF="#constructor">basic_newline_filter</A>(<SPAN CLASS="keyword">int</SPAN> flags);
    <SPAN CLASS='omitted'>...</SPAN>
};

<SPAN CLASS="keyword">typedef</SPAN> basic_newline_filter&lt;<SPAN CLASS="keyword">char</SPAN>&gt;     <SPAN CLASS="defined">newline_filter</SPAN>;
<SPAN CLASS="keyword">typedef</SPAN> basic_newline_filter&lt;<SPAN CLASS="keyword">wchar_t</SPAN>&gt;  <SPAN CLASS="defined">newline_wfilter</SPAN>;

} } <SPAN CLASS='comment'>// End namespace boost::io</PRE></SPAN>

<A NAME='template_params'></A>
<H4>Template Parameters</H4>

<TABLE STYLE='margin-left:2em' BORDER=0 CELLPADDING=2>
<TR>
    <TR>
        <TD VALIGN='top'><I>Ch</I></TD><TD WIDTH='2em' VALIGN='top'>-</TD>
        <TD>The character type</TD>
    </TR>
</TABLE>

<A NAME='constructor'></A>
<H4><CODE>basic_newline_filter::basic_newline_filter</CODE></H4>

<A NAME='constructor'></A>
<PRE CLASS='broken_ie'>    basic_newline_filter(<SPAN CLASS="keyword">int</SPAN> flags);</PRE>
    
<P>
    Constructs a <CODE>basic_newline_filter</CODE>. The <CODE>flags</CODE> argument must be a bitwise OR of the following constants from the namespace <CODE>boost::iostreams::newline</CODE>, having the interpretation shown in the table below:<SUP><A CLASS='footnote_ref' NAME='note_1_ref' HREF='#note_1'>[1]</A></SUP>
    <UL>
        <LI CLASS='square'>exactly one of <CODE>print_CR</CODE>, <CODE>print_LF</CODE> and <CODE>print_CRLF</CODE>, and
        <LI CLASS='square'>one or more of <CODE>accept_CR</CODE>, <CODE>accept_LF</CODE>, <CODE>ignore_CR</CODE>, <CODE>ignore_LF</CODE>, <CODE>greedy</CODE> and <CODE>final_newline</CODE>.
    </UL>
</P>

<TABLE STYLE='margin-left:2em; margin-bottom:2em' BORDER=1 CELLPADDING=4>
<TR><TH>Constant</TH><TH>Interpretation</TH></TR>
    <TR>
        <TD VALIGN='top'><A NAME='print_CR'></A><CODE>print_CR</CODE></TD>
        <TD>Filtered data uses the ASCII character <CODE>CR</CODE> (<CODE>0x0D</CODE>) as a line terminator</TD>
    </TR>
    <TR>
        <TD VALIGN='top'><A NAME='print_LF'></A><CODE>print_LF</CODE></TD>
        <TD>Filtered data uses the ASCII character <CODE>LF</CODE> (<CODE>0x0A</CODE>) as a line terminator</TD>
    </TR>
    <TR>
        <TD VALIGN='top'><A NAME='print_CRLF'></A><CODE>print_CRLF</CODE></TD>
        <TD>Filtered data uses the ASCII character sequence <CODE>CRLF</CODE> as a line terminator</TD>
    </TR>
    <TR>
        <TD VALIGN='top'><A NAME='accept_CR'></A><CODE>accept_CR</CODE></TD>
        <TD>The ASCII character <CODE>CR</CODE> (<CODE>0x0D</CODE>) encountered in unfiltered data is interpretted as a line terminator</TD>
    </TR>
    <TR>
        <TD VALIGN='top'><A NAME='accept_LF'></A><CODE>accept_LF</CODE></TD>
        <TD>The ASCII character <CODE>LF</CODE> (<CODE>0x0A</CODE>) encountered in unfiltered data is interpretted as a line terminator</TD>
    </TR>
    <TR>
        <TD VALIGN='top'><A NAME='accept_CRLF'></A><CODE>accept_CRLF</CODE></TD>
        <TD>The ASCII character sequence <CODE>CRLF</CODE> encountered in unfiltered data is interpretted as a line terminator</TD>
    </TR>
    <TR>
        <TD VALIGN='top'><A NAME='ignore_CR'></A><CODE>ignore_CR</CODE></TD>
        <TD>Occurrences of the ASCII character <CODE>CR</CODE> (<CODE>0x0D</CODE>) which do not form part of a line terminator are ignored</TD>
    </TR>
    <TR>
        <TD VALIGN='top'><A NAME='ignore_LF'></A><CODE>ignore_LF</CODE></TD>
        <TD>Occurrences of the ASCII character <CODE>LF</CODE> (<CODE>0x0A</CODE>) which do not form part of a line terminator are ignored</TD>
    </TR>
    <TR>
        <TD VALIGN='top'><A NAME='greedy'></A><CODE>greedy</CODE></TD>
        <TD>The ASCII character sequence <CODE>CRLF</CODE> is matched in preference to the character <CODE>CR</CODE> if both are accepted as line terminators
        </TD>
    </TR>
    <TR>
        <TD VALIGN='top'><A NAME='final_newline'></A><CODE>final_newline</CODE></TD>
        <TD>A newline is added to the end of the filtered data if not already present</TD>
    </TR>
    <TR>
        <TD VALIGN='top'><A NAME='posix'></A><CODE>posix</CODE></TD>
        <TD>
            Useful for converting data to the Unix format; equivalent to <CODE>print_LF | accept_CR | accept_LF | accept_CRLF | greedy</CODE>
        </TD>
    </TR>
    <TR>
        <TD VALIGN='top'><A NAME='mac'></A><CODE>mac</CODE></TD>
        <TD>
            Useful for converting data to the Classic Mac format; equivalent to <CODE>print_CR | accept_CR | accept_LF | accept_CRLF | greedy</CODE>
        </TD>
    </TR>
    <TR>
        <TD VALIGN='top'><A NAME='windows'></A><CODE>windows</CODE></TD>
        <TD>
            Useful for converting data to the Windows format; equivalent to <CODE>print_CRLF | accept_CR | accept_LF | accept_CRLF | greedy</CODE>
        </TD>
    </TR>
</TABLE>

<!-- Begin Footnotes -->

<HR>

<P>
    <SUP><A CLASS='footnote_ref' NAME='note_1' HREF='#note_1_ref'>[1]</A></SUP>Notice that <CODE>flags</CODE> has no default value. It would be convenient for a default-constructed <CODE>basic_newline_filter</CODE> to convert text files to the format used by the current platform, but it is not clear how to handle Mac OS X.
</P>

<!-- End Footnotes -->

<!-- Begin Footer -->

<HR>
<P CLASS='copyright'>Revised
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan -->
20 May, 2004
<!--webbot bot="Timestamp" endspan i-checksum="38504" -->
</P>

<P CLASS='copyright'>&copy; Copyright Jonathan Turkanis, 2004</P>
<P CLASS='copyright'> 
    Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at <A HREF='http://www.boost.org/LICENSE_1_0.txt'>http://www.boost.org/LICENSE_1_0.txt</A>)
</P>

<!-- End Footer -->

</BODY>