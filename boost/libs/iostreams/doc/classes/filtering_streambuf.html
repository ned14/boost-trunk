<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
    <TITLE>Class Template filtering_streambuf</TITLE>
    <LINK REL="stylesheet" HREF="../../../../boost.css">
    <LINK REL="stylesheet" HREF="../theme/iostreams.css">
</HEAD>
<BODY>

<!-- Begin Banner -->

    <H1 CLASS="title">Class Template <CODE>filtering_streambuf</CODE></H1>
    <HR CLASS="banner">

<!-- End Banner -->

<DL class="page-index">
  <DT><A href="#description">Description</A></DT>
  <DT><A href="#headers">Headers</A></DT>
  <DT><A href="#reference">Reference</A></DT>
</DL>

<HR>

<A NAME="description">
<H2>Description</H2>

<P>
    Derived class of <CODE>std::basic_streambuf</CODE> used for filtering data. Each <CODE>filtering_streambuf</CODE> contains a chain of zero or more Filters with an optional Device at the end. The chain can be manipulated using an interface similar to that of <CODE>std::stack</CODE>. (<I>See</I> <A HREF="../filtering_streams.html#overview">Filtering Streams and Stream Buffers</A>.)
</P>

<A NAME="headers">
<H2>Headers</H2>

<DL class="page-index">
  <DT><A CLASS="header" HREF="../../../../boost/iostreams/filtering_streambuf.hpp"><CODE>&lt;boost/iostreams/filtering_streambuf.hpp&gt;</CODE></A></DT>
</DL>

<A NAME="reference">
<H2>Reference</H2>

<A NAME="synopsis"></A>
<H4>Synopsis</H4>

<PRE CLASS="broken_ie"><SPAN CLASS="keyword">namespace</SPAN> boost { <SPAN CLASS="keyword">namespace</SPAN> iostreams {

<SPAN CLASS="keyword">template</SPAN>&lt; <SPAN CLASS="keyword">typename</SPAN> <A CLASS="documented" HREF="#template_params">Mode</A>,
          <SPAN CLASS="keyword">typename</SPAN> <A CLASS="documented" HREF="#template_params">Ch</A>    = <SPAN CLASS="keyword">char</SPAN>,
          <SPAN CLASS="keyword">typename</SPAN> <A CLASS="documented" HREF="#template_params">Tr</A>    = std::char_traits&lt;Ch&gt;, 
          <SPAN CLASS="keyword">typename</SPAN> <A CLASS="documented" HREF="#template_params">Alloc</A> = std::allocator&lt;<CODE>Ch</CODE>&gt; &gt;
<SPAN CLASS="keyword">class</SPAN> <A CLASS="documented" HREF="#template_params">filtering_streambuf</A>;

<SPAN CLASS="keyword">template</SPAN>&lt; <SPAN CLASS="keyword">typename</SPAN> <A CLASS="documented" HREF="#template_params">Mode</A>,
          <SPAN CLASS="keyword">typename</SPAN> <A CLASS="documented" HREF="#template_params">Ch</A>    = <SPAN CLASS="keyword">wchar_t</SPAN>,
          <SPAN CLASS="keyword">typename</SPAN> <A CLASS="documented" HREF="#template_params">Tr</A>    = std::char_traits&lt;Ch&gt;, 
          <SPAN CLASS="keyword">typename</SPAN> <A CLASS="documented" HREF="#template_params">Alloc</A> = std::allocator&lt;<CODE>Ch</CODE>&gt; &gt;
<SPAN CLASS="keyword">class</SPAN> <A CLASS="documented" HREF="#filtering_wstreambuf">filtering_wstreambuf</A>;

<SPAN CLASS="keyword">typedef</SPAN> filtering_streambuf&lt;input&gt;    <SPAN CLASS="defined">filtering_istreambuf</SPAN>;
<SPAN CLASS="keyword">typedef</SPAN> filtering_streambuf&lt;output&gt;   <SPAN CLASS="defined">filtering_ostreambuf</SPAN>;
<SPAN CLASS="keyword">typedef</SPAN> filtering_wstreambuf&lt;input&gt;   <SPAN CLASS="defined">filtering_wistreambuf</SPAN>;
<SPAN CLASS="keyword">typedef</SPAN> filtering_wstreambuf&lt;output&gt;  <SPAN CLASS="defined">filtering_wostreambuf</SPAN>;

<SPAN CLASS="keyword">template</SPAN>&lt; <SPAN CLASS="keyword">typename</SPAN> <A CLASS="documented" HREF="#template_params">Mode</A>,
          <SPAN CLASS="keyword">typename</SPAN> <A CLASS="documented" HREF="#template_params">Ch</A>    = <SPAN CLASS="keyword">char</SPAN>,
          <SPAN CLASS="keyword">typename</SPAN> <A CLASS="documented" HREF="#template_params">Tr</A>    = std::char_traits&lt;Ch&gt;, 
          <SPAN CLASS="keyword">typename</SPAN> <A CLASS="documented" HREF="#template_params">Alloc</A> = std::allocator&lt;<CODE>Ch</CODE>&gt; &gt;
<SPAN CLASS="keyword">class</SPAN> <A CLASS="documented" HREF="filtering_streambuf.html">filtering_streambuf</A> : <SPAN CLASS="keyword">public</SPAN> std::basic_streambuf<Ch, Tr> {
<SPAN CLASS="keyword">public</SPAN>:
    <SPAN CLASS="keyword">typedef</SPAN> Ch                      char_type;
    <SPAN CLASS="keyword">typedef</SPAN> Mode                    mode;
    <SPAN CLASS="keyword">typedef</SPAN> Alloc                   allocator_type;
    <SPAN CLASS="keyword">typedef</SPAN> <SPAN CLASS="omitted">implementation-defined</SPAN>  size_type;

    <A CLASS="documented" HREF="#default_constructor">filtering_streambuf</A>();

    <SPAN CLASS="keyword">template</SPAN>&lt;<SPAN CLASS="keyword">typename</SPAN> T&gt;
    <A CLASS="documented" HREF="#policy_constructor">filtering_streambuf</A>( <SPAN CLASS="keyword">const</SPAN> T& t,
                         std::streamsize buffer_size = <SPAN CLASS="omitted">default value</SPAN>,
                         std::streamsize pback_size = <SPAN CLASS="omitted">default value</SPAN> );

    <SPAN CLASS="keyword">template</SPAN>&lt;<SPAN CLASS="keyword">typename</SPAN> T&gt;
    <A CLASS="documented" HREF="#stream_constructor">filtering_streambuf</A>( T& t,
                         std::streamsize buffer_size = <SPAN CLASS="omitted">default value</SPAN>,
                         std::streamsize pback_size = <SPAN CLASS="omitted">default value</SPAN> );

    <SPAN CLASS="keyword">template</SPAN>&lt;<SPAN CLASS="keyword">typename</SPAN> Iter&gt;
    <A CLASS="documented" HREF="#iterator_constructor">filtering_streambuf</A>( Iter first, Iter last
                         std::streamsize buffer_size = <SPAN CLASS="omitted">default value</SPAN>,
                         std::streamsize pback_size = <SPAN CLASS="omitted">default value</SPAN> );

    <SPAN CLASS="keyword">template</SPAN>&lt;<SPAN CLASS="keyword">typename</SPAN> T&gt;
    void <A CLASS="documented" HREF="#policy_push">push</A>( <SPAN CLASS="keyword">const</SPAN> T& t,
               std::streamsize buffer_size = <SPAN CLASS="omitted">default value</SPAN>,
               std::streamsize pback_size = <SPAN CLASS="omitted">default value</SPAN> );

    <SPAN CLASS="keyword">template</SPAN>&lt;<SPAN CLASS="keyword">typename</SPAN> T&gt;
    void <A CLASS="documented" HREF="#stream_push">push</A>( T& t,
               std::streamsize buffer_size = <SPAN CLASS="omitted">default value</SPAN>,
               std::streamsize pback_size = <SPAN CLASS="omitted">default value</SPAN> );

    <SPAN CLASS="keyword">template</SPAN>&lt;<SPAN CLASS="keyword">typename</SPAN> Iter&gt;
    void <A CLASS="documented" HREF="#iterator_push">push</A>( Iter first, Iter last
               std::streamsize buffer_size = <SPAN CLASS="omitted">default value</SPAN>,
               std::streamsize pback_size = <SPAN CLASS="omitted">default value</SPAN> );

    <SPAN CLASS="keyword">void</SPAN> <A CLASS="documented" HREF="#pop">pop</A>();
    <SPAN CLASS="keyword">bool</SPAN> <A CLASS="documented" HREF="#empty">empty</A>() <SPAN CLASS="keyword">const</SPAN>;
    size_type <A CLASS="documented" HREF="#size">size</A>() <SPAN CLASS="keyword">const</SPAN>;
    <SPAN CLASS="keyword">void</SPAN> <A CLASS="documented" HREF="#reset">reset</A>();
    <SPAN CLASS="keyword">bool</SPAN> <A CLASS="documented" HREF="#is_complete">is_complete</A>() <SPAN CLASS="keyword">const</SPAN>;
};

} } // End namespace boost::io</PRE>

<A NAME="template_params"></A>
<H4>Template parameters</H4>

<TABLE STYLE="margin-left:2em" BORDER=0 CELLPADDING=2>
<TR>
    <TR>
        <TD VALIGN="top"><I>Mode</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>A <A HREF="../modes.html#mode_tags">mode tag</A>.</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><I>Ch</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>The character type</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><I>Tr</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>The traits type</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><I>Alloc</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>A standard library allocator type (<A CLASS="bib_ref" HREF="../bibliography.html#iso">[ISO]</A>, 20.1.5), used to allocate character buffers</TD>
    </TR>
</TABLE>

<A NAME="default_constructor"></A>
<H4><CODE>filtering_streambuf::filtering_streambuf</CODE></H4>

<PRE CLASS="broken_ie">    filtering_streambuf();</PRE>

<P>
    Constructs a <CODE>filtering_streambuf</CODE> with an empty chain of Filters and Devices.
</P>

<A NAME="policy_constructor"></A>
<H4><CODE>filtering_streambuf::filtering_streambuf</CODE></H4>
<PRE CLASS="broken_ie">    <SPAN CLASS="keyword">template</SPAN>&lt;<SPAN CLASS="keyword">typename</SPAN> T&gt;
    filtering_streambuf( <SPAN CLASS="keyword">const</SPAN> T& t,
                         std::streamsize buffer_size,
                         std::streamsize pback_size );</PRE>

<P>
    Constructs a <CODE>filtering_streambuf</CODE> with a chain consisting of a single instance of <CODE>T</CODE>. The parameters have the following interpretations:
</P>
<TABLE STYLE="margin-left:2em" BORDER=0 CELLPADDING=2>
<TR>
    <TR>
        <TD VALIGN="top"><I>T</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>A <A HREF="http://www.boost.org/doc/html/CopyConstructible.html">CopyConstructible</A> model of one of the <A HREF="../concepts.html#filter_concepts">Filter</A> or <A HREF="../concepts.html#device_concepts">Device</A> concepts whose <A HREF="../traits.html#char_type">character type</A> is <A HREF="#template_params"><CODE>Ch</CODE></A> and whose <A HREF="../modes.html">mode</A> refines <A HREF="#template_params"><CODE>Mode</CODE></A></TD>
    </TR>
    <TR>
        <TD VALIGN="top"><I>t</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>An instance of <I>T</I></TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="level"></A><I>buffer_size</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>The size of any buffers that need to be allocated</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="level"></A><I>pback_size</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>The size of the putback buffer, relevant only if <CODE>Mode</CODE> is a refinement of <A HREF="../modes.html#input"><CODE>input</CODE></TD>
    </TR>
</TABLE>

<P>
    A <CODE>filtering_streambuf</CODE> may be constructed from an instance of a Filter or Device type <CODE>T</CODE> which is <I>not</I> <A HREF="http://www.boost.org/doc/html/CopyConstructible.html">CopyConstructible</A> in one of two ways:
</P>
<UL>
    <LI>by using a <A HREF="http://www.boost.org/doc/html/ref.html">reference wrapper</A>, or 
    <LI>if <CODE>T</CODE> is a standard stream or stream buffer type, by using the <A HREF="#stream_constructor">templated constructor</A> taking a non-<CODE>const</CODE> reference.
</UL>

<A NAME="stream_constructor"></A>
<H4><CODE>filtering_streambuf::filtering_streambuf</CODE></H4>
<PRE CLASS="broken_ie">    <SPAN CLASS="keyword">template</SPAN>&lt;<SPAN CLASS="keyword">typename</SPAN> T&gt;
    filtering_streambuf( T& t,
                         std::streamsize buffer_size,
                         std::streamsize pback_size );</PRE>

<P>
    Constructs a <CODE>filtering_streambuf</CODE> with a chain consisting of a single <CODE>streambuf_facade</CODE> based on a stream or stream buffer.
</P>

<TABLE STYLE="margin-left:2em" BORDER=0 CELLPADDING=2>
<TR>
    <TR>
        <TD VALIGN="top"><I>T</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>A standard stream or stream buffer type whose <A HREF="../traits.html#char_type">character type</A> is <A HREF="#template_params"><CODE>Ch</CODE></A> and whose <A HREF="../modes.html"><CODE>mode_of</CODE></A> refines <A HREF="#template_params"><CODE>Mode</CODE></A></TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="level"></A><I>buffer_size</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>The size of any buffers that need to be allocated</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="level"></A><I>pback_size</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>The size of the putback buffer, relevant only if <CODE>Mode</CODE> is a refinement of <A HREF="../modes.html#input"><CODE>input</CODE></TD>
    </TR>
</TABLE>

<P>To use a standard stream or stream buffer with an i/o mode other than the default mode, use the function template <A HREF="../functions/adapt.html"><CODE>adapt</CODE></A>.</P>

<A NAME="iterator_constructor"></A>
<H4><CODE>filtering_streambuf::filtering_streambuf</CODE></H4>
<PRE CLASS="broken_ie">    <SPAN CLASS="keyword">template</SPAN>&lt;<SPAN CLASS="keyword">typename</SPAN> Iter&gt;
    filtering_streambuf( Iter first, Iter last
                         std::streamsize buffer_size,
                         std::streamsize pback_size );</PRE>

<P>
    Constructs a <CODE>filtering_streambuf</CODE> with a chain consisting of a single Device based on an iterator range.
</P>
<TABLE STYLE="margin-left:2em" BORDER=0 CELLPADDING=2>
<TR>
    <TR>
        <TD VALIGN="top"><A NAME="level"></A><I>Iter</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>
            <P>
                An iterator type whose <CODE>value_type</CODE> is <A HREF="#template_params"><CODE>Ch</CODE></A> and whose <A HREF="http://www.boost.org/libs/iterator/doc/new-iter-concepts.html#design">traveral</A> and <A HREF="http://www.boost.org/libs/iterator/doc/new-iter-concepts.html#design">value access</A> depend on <A HREF="#template_params"><CODE>Mode</CODE></A> as follows:
            <P>
        </TD>
     </TR>
     <TR>
        <TD COLSPAN=3>
            <TABLE STYLE="margin-bottom:1em" BORDER=1 CELLPADDING=4>
                <TR><TH><CODE>Mode</CODE></TH><TH><CODE>Iter</CODE></TH></TR>
                <TR>
                    <TD VALIGN="top">convertible to <A HREF="../modes.html#seekablet"><CODE>seekable</CODE></A></TD>
                    <TD>
                    A model of <A HREF="http://www.boost.org/libs/iterator/doc/new-iter-concepts.html#random-access-traversal-iterators-lib-random-access-traversal-iterators">Random Access Traversal Iterator</A>, <A HREF="http://www.boost.org/libs/iterator/doc/new-iter-concepts.html#readable-iterators-lib-readable-iterators">Readable Iterator</A> and <A HREF="http://www.boost.org/libs/iterator/doc/new-iter-concepts.html#writable-iterators-lib-writable-iterators">Writable Iterator</A>
                    </TD>
                </TR>
                <TR>
                    <TD VALIGN="top">convertible to <A HREF="../modes.html#input"><CODE>input</CODE></A></TD>
                    <TD>
                    A model of <A HREF="http://www.boost.org/libs/iterator/doc/new-iter-concepts.html#single-pass-iterators-lib-single-pass-iterators">Single Pass Iterator</A> and <A HREF="http://www.boost.org/libs/iterator/doc/new-iter-concepts.html#readable-iterators-lib-readable-iterators">Readable Iterator</A>
                    </TD>
                </TR>
                <TR>
                    <TD VALIGN="top">convertible to <A HREF="../modes.html#output"><CODE>output</CODE></A></TD>
                    <TD>
                    A model of <A HREF="http://www.boost.org/libs/iterator/doc/new-iter-concepts.html#single-pass-iterators-lib-single-pass-iterators">Single Pass Iterator</A> and <A HREF="http://www.boost.org/libs/iterator/doc/new-iter-concepts.html#writable-iterators-lib-writable-iterators">Writable Iterator</A>
                    </TD>
                </TR>
            </TABLE>
        </TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="level"></A><I>first</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>An iterator pointing to the first character in the sequence to be accessed by the <CODE>streambuf_facade</CODE></TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="level"></A><I>last</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>An iterator pointing to one position past the last character in the sequence</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="level"></A><I>buffer_size</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>The size of the character buffer &#8212; irrelevant if <I>Iter</I> is a pointer type</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="level"></A><I>pback_size</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>The size of the putback buffer, relevant only if <CODE>Mode</CODE> is a refinement of <A HREF="../modes.html#input"><CODE>input</CODE></TD>
    </TR>
</TABLE>

<A NAME="policy_push"></A>
<H4><CODE>filtering_streambuf::push</CODE></H4>
<PRE CLASS="broken_ie">    <SPAN CLASS="keyword">template</SPAN>&lt;<SPAN CLASS="keyword">typename</SPAN> T&gt;
    void push( <SPAN CLASS="keyword">const</SPAN> T& t,
               std::streamsize buffer_size,
               std::streamsize pback_size );</PRE>
<P>
    Appends the given instance of <CODE>T</CODE> to the underlying chain, which must not be <A HREF="#is_complete">complete</A>. The parameters have the following interpretations:
</P>

<TABLE STYLE="margin-left:2em" BORDER=0 CELLPADDING=2>
<TR>
    <TR>
        <TD VALIGN="top"><I>T</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>A <A HREF="http://www.boost.org/doc/html/CopyConstructible.html">CopyConstructible</A> model of one of the <A HREF="../concepts.html#filter_concepts">Filter</A> or <A HREF="../concepts.html#device_concepts">Device</A> concepts whose <A HREF="../traits.html#char_type">character type</A> is <A HREF="#template_params"><CODE>Ch</CODE></A> and whose <A HREF="../modes.html"><CODE>mode_of</CODE></A> refines <A HREF="#template_params"><CODE>Mode</CODE></A></TD>
    </TR>
    <TR>
        <TD VALIGN="top"><I>t</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>An instance of <I>T</I></TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="level"></A><I>buffer_size</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>The size of any buffers that need to be allocated</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="level"></A><I>pback_size</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>The size of the putback buffer, relevant only if <CODE>Mode</CODE> is a refinement of <A HREF="../modes.html#input"><CODE>input</CODE></TD>
    </TR>
</TABLE>

<P>
    An instance of a Filter or Device type <CODE>T</CODE> which is <I>not</I> <A HREF="http://www.boost.org/doc/html/CopyConstructible.html">CopyConstructible</A> may be appended to the chain in one of two ways:
</P>
<UL>
    <LI>by using a <A HREF="http://www.boost.org/doc/html/ref.html">reference wrapper</A>, or 
    <LI>if <CODE>T</CODE> is a standard stream or stream buffer type, by using the templated overload of <A HREF="#stream_push"><CODE>push</CODE></A> taking a non-<CODE>const</CODE> reference.
</UL>

<A NAME="stream_push"></A>
<H4><CODE>filtering_streambuf::push</CODE></H4>
<PRE CLASS="broken_ie">    <SPAN CLASS="keyword">template</SPAN>&lt;<SPAN CLASS="keyword">typename</SPAN> T&gt;
    void push( T& t,
               std::streamsize buffer_size,
               std::streamsize pback_size );</PRE>

<P>
    Appends the given stream or stream buffer to the underlying chain, which must not be <A HREF="#is_complete">complete</A>. The parameters have the following interpretations:
</P>

<TABLE STYLE="margin-left:2em" BORDER=0 CELLPADDING=2>
<TR>
    <TR>
        <TD VALIGN="top"><I>T</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>A standard stream or stream buffer type whose <A HREF="../traits.html#char_type">character type</A> is <A HREF="#template_params"><CODE>Ch</CODE></A> and whose <A HREF="../modes.html"><CODE>mode_of</CODE></A> refines <A HREF="#template_params"><CODE>Mode</CODE></A></TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="level"></A><I>buffer_size</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>The size of any buffers that need to be allocated</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="level"></A><I>pback_size</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>The size of the putback buffer, relevant only if <CODE>Mode</CODE> is a refinement of <A HREF="../modes.html#input"><CODE>input</CODE></TD>
    </TR>
</TABLE>

<P>To use a standard stream or stream buffer with an i/o mode other than the default mode, use the function template <A HREF="../functions/adapt.html"><CODE>adapt</CODE></A>.</P>

<A NAME="iterator_push"></A>
<H4><CODE>filtering_streambuf::push</CODE></H4>
<PRE CLASS="broken_ie">    <SPAN CLASS="keyword">template</SPAN>&lt;<SPAN CLASS="keyword">typename</SPAN> Iter&gt;
    void <A CLASS="documented" HREF="#iterator_push">push</A>( Iter first, Iter last
               std::streamsize buffer_size,
               std::streamsize pback_size );</PRE>
<P>
    Appends a <CODE>streambuf_facade</CODE> based on an iterator range to the underlying chain, which must not be <A HREF="#is_complete">complete</A>.
</P>
<TABLE STYLE="margin-left:2em" BORDER=0 CELLPADDING=2>
<TR>
    <TR>
        <TD VALIGN="top"><A NAME="level"></A><I>Iter</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>
            <P>
                An iterator type whose <CODE>value_type</CODE> is <A HREF="#template_params"><CODE>Ch</CODE></A> and whose <A HREF="http://www.boost.org/libs/iterator/doc/new-iter-concepts.html#design">traveral</A> and <A HREF="http://www.boost.org/libs/iterator/doc/new-iter-concepts.html#design">value access</A> depend on <A HREF="#template_params"><CODE>Mode</CODE></A> as follows:
            <P>
        </TD>
     </TR>
     <TR>
        <TD COLSPAN=3>
            <TABLE STYLE="margin-bottom:1em" BORDER=1 CELLPADDING=4>
                <TR><TH><CODE>Mode</CODE></TH><TH><CODE>Iter</CODE></TH></TR>
                <TR>
                    <TD VALIGN="top">convertible to <A HREF="../modes.html#seekablet"><CODE>seekable</CODE></A></TD>
                    <TD>
                    A model of <A HREF="http://www.boost.org/libs/iterator/doc/new-iter-concepts.html#random-access-traversal-iterators-lib-random-access-traversal-iterators">Random Access Traversal Iterator</A>, <A HREF="http://www.boost.org/libs/iterator/doc/new-iter-concepts.html#readable-iterators-lib-readable-iterators">Readable Iterator</A> and <A HREF="http://www.boost.org/libs/iterator/doc/new-iter-concepts.html#writable-iterators-lib-writable-iterators">Writable Iterator</A>
                    </TD>
                </TR>
                <TR>
                    <TD VALIGN="top">convertible to <A HREF="../modes.html#input"><CODE>input</CODE></A></TD>
                    <TD>
                    A model of <A HREF="http://www.boost.org/libs/iterator/doc/new-iter-concepts.html#single-pass-iterators-lib-single-pass-iterators">Single Pass Iterator</A> and <A HREF="http://www.boost.org/libs/iterator/doc/new-iter-concepts.html#readable-iterators-lib-readable-iterators">Readable Iterator</A>
                    </TD>
                </TR>
                <TR>
                    <TD VALIGN="top">convertible to <A HREF="../modes.html#output"><CODE>output</CODE></A></TD>
                    <TD>
                    A model of <A HREF="http://www.boost.org/libs/iterator/doc/new-iter-concepts.html#single-pass-iterators-lib-single-pass-iterators">Single Pass Iterator</A> and <A HREF="http://www.boost.org/libs/iterator/doc/new-iter-concepts.html#writable-iterators-lib-writable-iterators">Writable Iterator</A>
                    </TD>
                </TR>
            </TABLE>
        </TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="level"></A><I>first</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>An iterator pointing to the first character in the sequence to be accessed by the <CODE>streambuf_facade</CODE></TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="level"></A><I>last</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>An iterator pointing to one position past the last character in the sequence</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="level"></A><I>buffer_size</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>The size of the character buffer &#8212; irrelevant if <I>Iter</I> is a pointer type</TD>
    </TR>
    <TR>
        <TD VALIGN="top"><A NAME="level"></A><I>pback_size</I></TD><TD WIDTH="2em" VALIGN="top">-</TD>
        <TD>The size of the putback buffer, relevant only if <CODE>Mode</CODE> is a refinement of <A HREF="../modes.html#input"><CODE>input</CODE></TD>
    </TR>
</TABLE>

<A NAME="pop"></A>
<H4><CODE>filtering_streambuf::pop</CODE></H4>
<PRE CLASS="broken_ie">    <SPAN CLASS="keyword">void</SPAN> pop();</PRE>

<P>Removes the final <CODE>streambuf_facade</CODE> from the underlying chain, which must be non-empty. If the chain is initially <A HREF="#is_complete">complete</A>, causes each Filter and Device in the chain to be closed using the function <A HREF="../functions/close.html"><CODE>close</CODE></A>.</P>

<A NAME="empty"></A>
<H4><CODE>filtering_streambuf::empty</CODE></H4>
<PRE CLASS="broken_ie">    <SPAN CLASS="keyword">bool</SPAN> empty() <SPAN CLASS="keyword">const</SPAN>;</PRE>

<P>Returns <CODE>true</CODE> if the underlying chain is empty.</P>

<A NAME="size"></A>
<H4><CODE>filtering_streambuf::size</CODE></H4>
<PRE CLASS="broken_ie">    size_type size() <SPAN CLASS="keyword">const</SPAN>;</PRE>

<P>Returns the number of stream buffers in the underlying chain.</P>

<A NAME="reset"></A>
<H4><CODE>filtering_streambuf::reset</CODE></H4>
<PRE CLASS="broken_ie">    <SPAN CLASS="keyword">void</SPAN> reset();</PRE>

<P>Clears the underlying chain. If the chain is initially <A HREF="#is_complete">complete</A>, causes each Filter and Device in the chain to be closed using the function <A HREF="../functions/close.html"><CODE>close</CODE></A>.</P>

<A NAME="is_complete"></A>
<H4><CODE>filtering_streambuf::is_complete</CODE></H4>
<PRE CLASS="broken_ie">    <SPAN CLASS="keyword">bool</SPAN> is_complete() <SPAN CLASS="keyword">const</SPAN>;</PRE>

<P>Returns <CODE>true</CODE> if the underlying chain ends in a <CODE>streambuf_facade</CODE> based on a <A HREF="../concepts.html#device_concepts">Device</A>. </P>

<A NAME="filtering_wstreambuf"></A>
<H4><CODE>filtering_wstreambuf</CODE></H4>

<PRE CLASS="broken_ie"><SPAN CLASS="keyword">template</SPAN>&lt; <SPAN CLASS="keyword">typename</SPAN> Mode,
          <SPAN CLASS="keyword">typename</SPAN> Ch    = <SPAN CLASS="keyword">wchar_t</SPAN>,
          <SPAN CLASS="keyword">typename</SPAN> Tr    = std::char_traits&lt;Ch&gt;, 
          <SPAN CLASS="keyword">typename</SPAN> Alloc = std::allocator&lt;<CODE>Ch</CODE>&gt; &gt;
<SPAN CLASS="keyword">class</SPAN> filtering_wstreambuf;</PRE>

<P>Identical to <CODE>filtering_streambuf</CODE>, except for the default character type.


<!-- Begin Footer -->

<HR>
<P CLASS="copyright">Revised
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%d %B, %Y" startspan -->
20 May, 2004
<!--webbot bot="Timestamp" endspan i-checksum="38504" -->
</P>

<P CLASS="copyright">&copy; Copyright Jonathan Turkanis, 2004</P>
<P CLASS="copyright"> 
    Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at <A HREF="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</A>)
</P>

<!-- End Footer -->

</BODY>
