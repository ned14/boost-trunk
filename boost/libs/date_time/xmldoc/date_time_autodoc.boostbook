<?xml version="1.0" standalone="yes"?>
<!-- Copyright (c) 2001-2004 CrystalClear Software, Inc.
     Subject to the Boost Software License, Version 1.0. 
     (See accompanying file LICENSE-1.0 or  http://www.boost.org/LICENSE-1.0)
-->
<section id="date_time_reference">
<title>Date Time Reference</title>
  <header name="boost/date_time/adjust_functors.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="day_functor">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>
            <simpara>Functor to iterate a fixed number of days. </simpara>
          </purpose>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="get_neg_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="f">
              <paramtype>int</paramtype>
            </parameter>
          </constructor>
        </class>
        <class name="month_functor">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>
            <simpara>Provides calculation to find next nth month given a date. </simpara>
          </purpose>
          <description>
            <para>This adjustment function provides the logic for 'month-based' advancement on a ymd based calendar. The policy it uses to handle the non existant end of month days is to back up to the last day of the month. Also, if the starting date is the last day of a month, this functor will attempt to adjust to the end of the month. </para>
          </description>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <typedef name="cal_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="ymd_type">
            <type>cal_type::ymd_type</type>
          </typedef>
          <typedef name="day_type">
            <type>cal_type::day_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="get_neg_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Returns a negative duration_type. </simpara>
              </purpose>
            </method>
          </method-group>
          <constructor>
            <parameter name="f">
              <paramtype>int</paramtype>
            </parameter>
          </constructor>
        </class>
        <class name="week_functor">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>
            <simpara>Functor to iterate a over weeks. </simpara>
          </purpose>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="get_neg_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="f">
              <paramtype>int</paramtype>
            </parameter>
          </constructor>
        </class>
        <class name="year_functor">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>
            <simpara>Functor to iterate by a year adjusting for leap years. </simpara>
          </purpose>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="get_neg_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="f">
              <paramtype>int</paramtype>
            </parameter>
          </constructor>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/c_local_time_adjustor.hpp">
    <para>Time adjustment calculations based on machine</para>
    <namespace name="boost">
      <namespace name="date_time">
        <class name="c_local_adjustor">
          <template>
      <template-type-parameter name="time_type"/>
    </template>
          <purpose>
            <simpara>Adjust to / from utc using the C API. </simpara>
          </purpose>
          <description>
            <para>Warning!!! This class assumes that timezone settings of the machine are correct. This can be a very dangerous assumption. </para>
          </description>
          <typedef name="time_duration_type">
            <type>time_type::time_duration_type</type>
          </typedef>
          <typedef name="date_type">
            <type>time_type::date_type</type>
          </typedef>
          <typedef name="date_duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <method-group name="public static functions">
            <method name="utc_to_local" cv="">
              <type>time_type</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Convert a utc time to local time. </simpara>
              </purpose>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/c_time.hpp">
    <para>Provide workarounds related to the ctime header</para>
    <namespace name="std"/>
  </header>
  <header name="boost/date_time/compiler_config.hpp">
    <namespace name="std"/>
  </header>
  <header name="boost/date_time/constrained_value.hpp">
    <namespace name="boost">
      <namespace name="CV">
        <class name="constrained_value">
          <template>
      <template-type-parameter name="value_policies"/>
    </template>
          <purpose>
            <simpara>A template to specify a constrained basic value type. </simpara>
          </purpose>
          <description>
            <para>This template provides a quick way to generate an integer type with a constrained range. The type provides for the ability to specify the min, max, and and error handling policy.</para>
            <para><emphasis role="bold">value policies</emphasis>  A class that provides the range limits via the min and max functions as well as a function on_error that determines how errors are handled. A common strategy would be to assert or throw and exception. The on_error is passed both the current value and the new value that is in error. </para>
          </description>
          <typedef name="value_type">
            <type>value_policies::value_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="conversion-operator" cv="const">
              <type>value_type</type>
              <purpose>
                <simpara>Coerce into the representation type. </simpara>
              </purpose>
            </method>
          </method-group>
          <constructor>
            <parameter name="value">
              <paramtype>value_type</paramtype>
            </parameter>
          </constructor>
          <copy-assignment>
            <parameter name="v">
              <paramtype>value_type</paramtype>
            </parameter>
          </copy-assignment>
          <method-group name="public static functions">
            <method name="BOOST_PREVENT_MACRO_SUBSTITUTION" cv="">
              <type>value_type max</type>
              <purpose>
                <simpara>Return the max allowed value (traits method). </simpara>
              </purpose>
            </method>
            <method name="BOOST_PREVENT_MACRO_SUBSTITUTION" cv="">
              <type>value_type min</type>
              <purpose>
                <simpara>Return the min allowed value (traits method). </simpara>
              </purpose>
            </method>
          </method-group>
          <method-group name="private member functions">
            <method name="assign" cv="">
              <type>void</type>
              <parameter name="value">
                <paramtype>value_type</paramtype>
              </parameter>
            </method>
          </method-group>
        </class>
        <class name="simple_exception_policy">
          <template>
      <template-type-parameter name="rep_type"/>
      <template-nontype-parameter name="min_value"><type>rep_type</type></template-nontype-parameter>
      <template-nontype-parameter name="max_value"><type>rep_type</type></template-nontype-parameter>
      <template-type-parameter name="exception_type"/>
    </template>
          <purpose>
            <simpara>Template to shortcut the constrained_value policy creation process. </simpara>
          </purpose>
          <typedef name="value_type">
            <type>rep_type</type>
          </typedef>
          <method-group name="public static functions">
            <method name="BOOST_PREVENT_MACRO_SUBSTITUTION" cv="">
              <type>rep_type min</type>
            </method>
            <method name="BOOST_PREVENT_MACRO_SUBSTITUTION" cv="">
              <type>rep_type max</type>
            </method>
            <method name="on_error" cv="">
              <type>void</type>
              <parameter name="">
                <paramtype>rep_type</paramtype>
              </parameter>
              <parameter name="">
                <paramtype>rep_type</paramtype>
              </parameter>
              <parameter name="">
                <paramtype>violation_enum</paramtype>
              </parameter>
            </method>
          </method-group>
        </class>
        <enum name="violation_enum">
          <enumvalue name="min_violation"/>
          <enumvalue name="max_violation"/>
          <purpose>
            <simpara>Represent a min or max violation type. </simpara>
          </purpose>
        </enum>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="date">
          <template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="calendar"/>
      <template-type-parameter name="duration_type_"/>
    </template>
          <purpose>
            <simpara>Representation of timepoint at the one day level resolution. </simpara>
          </purpose>
          <description>
            <para>The date template represents an interface shell for a date class that is based on a year-month-day system such as the gregorian or iso systems. It provides basic operations to enable calculation and comparisons.</para>
            <para><emphasis role="bold">Theory</emphasis> </para>
            <para>This date representation fundamentally departs from the C tm struct approach. The goal for this type is to provide efficient date operations (add, subtract) and storage (minimize space to represent) in a concrete class. Thus, the date uses a count internally to represent a particular date. The calendar parameter defines the policies for converting the the year-month-day and internal counted form here. Applications that need to perform heavy formatting of the same date repeatedly will perform better by using the year-month-day representation.</para>
            <para>Internally the date uses a day number to represent the date. This is a monotonic time representation. This representation allows for fast comparison as well as simplifying the creation of writing numeric operations. Essentially, the internal day number is like adjusted julian day. The adjustment is determined by the Epoch date which is represented as day 1 of the calendar. Day 0 is reserved for negative infinity so that any actual date is automatically greater than negative infinity. When a date is constructed from a date or formatted for output, the appropriate conversions are applied to create the year, month, day representations. </para>
          </description>
          <typedef name="date_type">
            <type>T</type>
          </typedef>
          <typedef name="calendar_type">
            <type>calendar</type>
          </typedef>
          <typedef name="traits_type">
            <type>calendar::date_traits_type</type>
          </typedef>
          <typedef name="duration_type">
            <type>duration_type_</type>
          </typedef>
          <typedef name="year_type">
            <type>calendar::year_type</type>
          </typedef>
          <typedef name="month_type">
            <type>calendar::month_type</type>
          </typedef>
          <typedef name="day_type">
            <type>calendar::day_type</type>
          </typedef>
          <typedef name="ymd_type">
            <type>calendar::ymd_type</type>
          </typedef>
          <typedef name="date_rep_type">
            <type>calendar::date_rep_type</type>
          </typedef>
          <typedef name="date_int_type">
            <type>calendar::date_int_type</type>
          </typedef>
          <typedef name="day_of_week_type">
            <type>calendar::day_of_week_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="year" cv="const">
              <type>year_type</type>
            </method>
            <method name="month" cv="const">
              <type>month_type</type>
            </method>
            <method name="day" cv="const">
              <type>day_type</type>
            </method>
            <method name="day_of_week" cv="const">
              <type>day_of_week_type</type>
            </method>
            <method name="year_month_day" cv="const">
              <type>ymd_type</type>
            </method>
            <method name="operator&lt;" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="is_special" cv="const">
              <type>bool</type>
              <purpose>
                <simpara>check to see if date is a special value </simpara>
              </purpose>
            </method>
            <method name="is_not_a_date" cv="const">
              <type>bool</type>
              <purpose>
                <simpara>check to see if date is not a value </simpara>
              </purpose>
            </method>
            <method name="is_infinity" cv="const">
              <type>bool</type>
              <purpose>
                <simpara>check to see if date is one of the infinity values </simpara>
              </purpose>
            </method>
            <method name="is_pos_infinity" cv="const">
              <type>bool</type>
              <purpose>
                <simpara>check to see if date is greater than all possible dates </simpara>
              </purpose>
            </method>
            <method name="is_neg_infinity" cv="const">
              <type>bool</type>
              <purpose>
                <simpara>check to see if date is greater than all possible dates </simpara>
              </purpose>
            </method>
            <method name="as_special" cv="const">
              <type>special_values</type>
              <purpose>
                <simpara>return as a special value or a not_special if a normal date </simpara>
              </purpose>
            </method>
            <method name="operator-" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-" cv="const">
              <type>date_type</type>
              <parameter name="dd">
                <paramtype>const duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-=" cv="">
              <type>date_type</type>
              <parameter name="dd">
                <paramtype>const duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="day_count" cv="const">
              <type>date_rep_type</type>
            </method>
            <method name="operator+" cv="const">
              <type>date_type</type>
              <parameter name="dd">
                <paramtype>const duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator+=" cv="">
              <type>date_type</type>
              <parameter name="dd">
                <paramtype>const duration_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="y">
              <paramtype>year_type</paramtype>
            </parameter>
            <parameter name="m">
              <paramtype>month_type</paramtype>
            </parameter>
            <parameter name="d">
              <paramtype>day_type</paramtype>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="ymd">
              <paramtype>const ymd_type &amp;</paramtype>
            </parameter>
          </constructor>
          <method-group name="protected member functions"/>
          <constructor>
            <parameter name="days">
              <paramtype>date_int_type</paramtype>
            </parameter>
            <description>
              <para>This is a private constructor which allows for the creation of new dates. It is not exposed to users since that would require class users to understand the inner workings of the date class. </para>
            </description>
          </constructor>
          <constructor>
            <parameter name="days">
              <paramtype>date_rep_type</paramtype>
            </parameter>
          </constructor>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_clock_device.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="day_clock">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>
            <simpara>A clock providing day level services based on C time_t capabilities. </simpara>
          </purpose>
          <description>
            <para>This clock uses Posix interfaces as its implementation and hence uses the timezone settings of the operating system. Incorrect user settings will result in incorrect results for the calls to local_day. </para>
          </description>
          <typedef name="ymd_type">
            <type>date_type::ymd_type</type>
          </typedef>
          <method-group name="public static functions">
            <method name="local_day" cv="">
              <type>date_type</type>
              <purpose>
                <simpara>Get the local day as a date type. </simpara>
              </purpose>
            </method>
            <method name="local_day_ymd" cv="">
              <type>date_type::ymd_type</type>
              <purpose>
                <simpara>Get the local day as a ymd_type. </simpara>
              </purpose>
            </method>
            <method name="universal_day_ymd" cv="">
              <type>date_type::ymd_type</type>
              <purpose>
                <simpara>Get the current day in universal date as a ymd_type. </simpara>
              </purpose>
            </method>
            <method name="universal_day" cv="">
              <type>date_type</type>
              <purpose>
                <simpara>Get the UTC day as a date type. </simpara>
              </purpose>
            </method>
          </method-group>
          <method-group name="private static functions">
            <method name="get_local_time" cv="">
              <type>::std::tm *</type>
            </method>
            <method name="get_universal_time" cv="">
              <type>::std::tm *</type>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_defs.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <enum name="weekdays">
          <enumvalue name="Sunday"/>
          <enumvalue name="Monday"/>
          <enumvalue name="Tuesday"/>
          <enumvalue name="Wednesday"/>
          <enumvalue name="Thursday"/>
          <enumvalue name="Friday"/>
          <enumvalue name="Saturday"/>
          <purpose>
            <simpara>An enumeration of weekday names. </simpara>
          </purpose>
        </enum>
        <enum name="months_of_year">
          <enumvalue name="Jan">
            <default>1</default>
          </enumvalue>
          <enumvalue name="Feb"/>
          <enumvalue name="Mar"/>
          <enumvalue name="Apr"/>
          <enumvalue name="May"/>
          <enumvalue name="Jun"/>
          <enumvalue name="Jul"/>
          <enumvalue name="Aug"/>
          <enumvalue name="Sep"/>
          <enumvalue name="Oct"/>
          <enumvalue name="Nov"/>
          <enumvalue name="Dec"/>
          <enumvalue name="NotAMonth"/>
          <enumvalue name="NumMonths"/>
          <purpose>
            <simpara>Simple enum to allow for nice programming with Jan, Feb, etc. </simpara>
          </purpose>
        </enum>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_duration.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="date_duration">
          <template>
      <template-type-parameter name="duration_rep_traits"/>
    </template>
          <purpose>
            <simpara>Duration type with date level resolution. </simpara>
          </purpose>
          <typedef name="duration_rep_type">
            <type>duration_rep_traits::int_type</type>
          </typedef>
          <typedef name="duration_rep">
            <type>duration_rep_traits::impl_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_rep" cv="const">
              <type>duration_rep</type>
              <purpose>
                <simpara>returns days_ as it's instantiated type - used for streaming </simpara>
              </purpose>
            </method>
            <method name="is_special" cv="const">
              <type>bool</type>
            </method>
            <method name="days" cv="const">
              <type>duration_rep_type</type>
              <purpose>
                <simpara>returns days as value, not object. </simpara>
              </purpose>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>date_duration</classname> &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Equality. </simpara>
              </purpose>
            </method>
            <method name="operator&lt;" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>date_duration</classname> &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Less. </simpara>
              </purpose>
            </method>
            <method name="operator-=" cv="">
              <type>
                <classname>date_duration</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>date_duration</classname> &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Subtract another duration -- result is signed. </simpara>
              </purpose>
            </method>
            <method name="operator+=" cv="">
              <type>
                <classname>date_duration</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>date_duration</classname> &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Add a duration -- result is signed. </simpara>
              </purpose>
            </method>
            <method name="operator-" cv="const">
              <type>
                <classname>date_duration</classname>
              </type>
              <purpose>
                <simpara>unary- Allows for dd = -date_duration(2); -&gt; dd == -2 </simpara>
              </purpose>
            </method>
            <method name="operator/=" cv="">
              <type><classname>date_duration</classname>&lt; duration_rep_traits &gt;</type>
              <parameter name="divisor">
                <paramtype>int</paramtype>
              </parameter>
              <purpose>
                <simpara>Division operations on a duration with an integer. </simpara>
              </purpose>
            </method>
            <method name="operator/" cv="">
              <type><classname>date_duration</classname>&lt; duration_rep_traits &gt;</type>
              <parameter name="divisor">
                <paramtype>int</paramtype>
              </parameter>
            </method>
            <method name="is_negative" cv="const">
              <type>bool</type>
              <purpose>
                <simpara>return sign information </simpara>
              </purpose>
            </method>
          </method-group>
          <constructor>
            <parameter name="day_count">
              <paramtype>duration_rep</paramtype>
            </parameter>
            <purpose>
              <simpara>Construct from a day count. </simpara>
            </purpose>
          </constructor>
          <constructor>
            <parameter name="sv">
              <paramtype>special_values</paramtype>
            </parameter>
            <description>
              <para>construct from special_values - only works when instantiated with duration_traits_adapted </para>
            </description>
          </constructor>
          <constructor>
            <parameter name="other">
              <paramtype>const <classname>date_duration</classname>&lt; duration_rep_traits &gt; &amp;</paramtype>
            </parameter>
            <purpose>
              <simpara>Construct from another date_duration (Copy Constructor). </simpara>
            </purpose>
          </constructor>
          <method-group name="public static functions">
            <method name="unit" cv="">
              <type>
                <classname>date_duration</classname>
              </type>
              <purpose>
                <simpara>Returns the smallest duration -- used by to calculate 'end'. </simpara>
              </purpose>
            </method>
          </method-group>
        </class>
        <struct name="duration_traits_long">
          <description>
            <para>Struct for instantiating date_duration with <emphasis role="bold">NO</emphasis>  special values functionality. Allows for transparent implementation of either date_duration&lt;long&gt; or date_duration&lt;int_adapter&lt;long&gt; &gt; </para>
          </description>
          <typedef name="int_type">
            <type>long</type>
          </typedef>
          <typedef name="impl_type">
            <type>long</type>
          </typedef>
          <method-group name="public static functions">
            <method name="as_number" cv="">
              <type>int_type</type>
              <parameter name="i">
                <paramtype>impl_type</paramtype>
              </parameter>
            </method>
          </method-group>
        </struct>
        <struct name="duration_traits_adapted">
          <description>
            <para>Struct for instantiating date_duration <emphasis role="bold">WITH</emphasis>  special values functionality. Allows for transparent implementation of either date_duration&lt;long&gt; or date_duration&lt;int_adapter&lt;long&gt; &gt; </para>
          </description>
          <typedef name="int_type">
            <type>long</type>
          </typedef>
          <typedef name="impl_type">
            <type><classname>boost::date_time::int_adapter</classname>&lt; long &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="as_number" cv="">
              <type>int_type</type>
              <parameter name="i">
                <paramtype>
                  <classname>impl_type</classname>
                </paramtype>
              </parameter>
            </method>
          </method-group>
        </struct>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_duration_types.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="weeks_duration">
          <template>
      <template-type-parameter name="duration_config"/>
    </template>
          <inherit access="public">boost::date_time::date_duration&lt; duration_config &gt;</inherit>
          <purpose>
            <simpara>Additional duration type that represents a number of n*7 days. </simpara>
          </purpose>
          <method-group name="public member functions"/>
          <constructor>
            <parameter name="w">
              <paramtype>typename duration_config::impl_type</paramtype>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="sv">
              <paramtype>special_values</paramtype>
            </parameter>
          </constructor>
        </class>
        <class name="months_duration">
          <template>
      <template-type-parameter name="base_config"/>
    </template>
          <purpose>
            <simpara>additional duration type that represents a logical month </simpara>
          </purpose>
          <description>
            <para>A logical month enables things like: "date(2002,Mar,2) + months(2) -&gt; 2002-May2". If the date is a last day-of-the-month, the result will also be a last-day-of-the-month. </para>
          </description>
          <method-group name="public member functions">
            <method name="number_of_months" cv="const">
              <type>int_rep</type>
            </method>
            <method name="get_neg_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>returns a negative duration </simpara>
              </purpose>
            </method>
            <method name="get_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>months_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator!=" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>months_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator+" cv="const">
              <type>
                <classname>months_type</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>months_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator+=" cv="">
              <type><classname>months_type</classname> &amp;</type>
              <parameter name="rhs">
                <paramtype>const <classname>months_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-" cv="const">
              <type>
                <classname>months_type</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>months_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-=" cv="">
              <type><classname>months_type</classname> &amp;</type>
              <parameter name="rhs">
                <paramtype>const <classname>months_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator *" cv="const">
              <type>
                <classname>months_type</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator *=" cv="">
              <type><classname>months_type</classname> &amp;</type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator/" cv="const">
              <type>
                <classname>months_type</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator/=" cv="">
              <type><classname>months_type</classname> &amp;</type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator+" cv="const">
              <type>
                <classname>months_type</classname>
              </type>
              <parameter name="y">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator+=" cv="">
              <type><classname>months_type</classname> &amp;</type>
              <parameter name="y">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-" cv="const">
              <type>
                <classname>months_type</classname>
              </type>
              <parameter name="y">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-=" cv="">
              <type><classname>months_type</classname> &amp;</type>
              <parameter name="y">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="num">
              <paramtype>int_rep</paramtype>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="sv">
              <paramtype>special_values</paramtype>
            </parameter>
          </constructor>
        </class>
        <class name="years_duration">
          <template>
      <template-type-parameter name="base_config"/>
    </template>
          <purpose>
            <simpara>additional duration type that represents a logical year </simpara>
          </purpose>
          <description>
            <para>A logical year enables things like: "date(2002,Mar,2) + years(2) -&gt; 2004-Mar-2". If the date is a last day-of-the-month, the result will also be a last-day-of-the-month (ie date(2001-Feb-28) + years(3) -&gt; 2004-Feb-29). </para>
          </description>
          <method-group name="public member functions">
            <method name="number_of_years" cv="const">
              <type>int_rep</type>
            </method>
            <method name="get_neg_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>returns a negative duration </simpara>
              </purpose>
            </method>
            <method name="get_offset" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator!=" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator+" cv="const">
              <type>
                <classname>years_type</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator+=" cv="">
              <type><classname>years_type</classname> &amp;</type>
              <parameter name="rhs">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-" cv="const">
              <type>
                <classname>years_type</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-=" cv="">
              <type><classname>years_type</classname> &amp;</type>
              <parameter name="rhs">
                <paramtype>const <classname>years_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator *" cv="const">
              <type>
                <classname>years_type</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator *=" cv="">
              <type><classname>years_type</classname> &amp;</type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator/" cv="const">
              <type>
                <classname>years_type</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator/=" cv="">
              <type><classname>years_type</classname> &amp;</type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator+" cv="const">
              <type>
                <classname>months_type</classname>
              </type>
              <parameter name="m">
                <paramtype>const <classname>months_type</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-" cv="const">
              <type>
                <classname>months_type</classname>
              </type>
              <parameter name="m">
                <paramtype>const <classname>months_type</classname> &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="num">
              <paramtype>int_rep</paramtype>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="sv">
              <paramtype>special_values</paramtype>
            </parameter>
          </constructor>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_format_simple.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="simple_format">
          <template>
      <template-type-parameter name="charT"/>
    </template>
          <purpose>
            <simpara>Class to provide simple basic formatting rules. </simpara>
          </purpose>
          <method-group name="public static functions">
            <method name="not_a_date" cv="">
              <type>const charT *</type>
              <purpose>
                <simpara>String used printed is date is invalid. </simpara>
              </purpose>
            </method>
            <method name="pos_infinity" cv="">
              <type>const charT *</type>
              <purpose>
                <simpara>String used to for positive infinity value. </simpara>
              </purpose>
            </method>
            <method name="neg_infinity" cv="">
              <type>const charT *</type>
              <purpose>
                <simpara>String used to for positive infinity value. </simpara>
              </purpose>
            </method>
            <method name="month_format" cv="">
              <type>month_format_spec</type>
              <purpose>
                <simpara>Describe month format. </simpara>
              </purpose>
            </method>
            <method name="date_order" cv="">
              <type>ymd_order_spec</type>
            </method>
            <method name="has_date_sep_chars" cv="">
              <type>bool</type>
              <purpose>
                <simpara>This format uses '-' to separate date elements. </simpara>
              </purpose>
            </method>
            <method name="year_sep_char" cv="">
              <type>charT</type>
              <purpose>
                <simpara>Char to sep? </simpara>
              </purpose>
            </method>
            <method name="month_sep_char" cv="">
              <type>charT</type>
              <purpose>
                <simpara>char between year-month </simpara>
              </purpose>
            </method>
            <method name="day_sep_char" cv="">
              <type>charT</type>
              <purpose>
                <simpara>Char to separate month-day. </simpara>
              </purpose>
            </method>
            <method name="hour_sep_char" cv="">
              <type>charT</type>
              <purpose>
                <simpara>char between date-hours </simpara>
              </purpose>
            </method>
            <method name="minute_sep_char" cv="">
              <type>charT</type>
              <purpose>
                <simpara>char between hour and minute </simpara>
              </purpose>
            </method>
            <method name="second_sep_char" cv="">
              <type>charT</type>
              <purpose>
                <simpara>char for second </simpara>
              </purpose>
            </method>
          </method-group>
        </class>
        <class-specialization name="simple_format">
          <template>
    </template>
          <specialization>
            <template-arg>wchar_t</template-arg>
          </specialization>
          <purpose>
            <simpara>Specialization of formmating rules for wchar_t. </simpara>
          </purpose>
          <method-group name="public static functions">
            <method name="not_a_date" cv="">
              <type>const wchar_t *</type>
              <purpose>
                <simpara>String used printed is date is invalid. </simpara>
              </purpose>
            </method>
            <method name="pos_infinity" cv="">
              <type>const wchar_t *</type>
              <purpose>
                <simpara>String used to for positive infinity value. </simpara>
              </purpose>
            </method>
            <method name="neg_infinity" cv="">
              <type>const wchar_t *</type>
              <purpose>
                <simpara>String used to for positive infinity value. </simpara>
              </purpose>
            </method>
            <method name="month_format" cv="">
              <type>month_format_spec</type>
              <purpose>
                <simpara>Describe month format. </simpara>
              </purpose>
            </method>
            <method name="date_order" cv="">
              <type>ymd_order_spec</type>
            </method>
            <method name="has_date_sep_chars" cv="">
              <type>bool</type>
              <purpose>
                <simpara>This format uses '-' to separate date elements. </simpara>
              </purpose>
            </method>
            <method name="year_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>
                <simpara>Char to sep? </simpara>
              </purpose>
            </method>
            <method name="month_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>
                <simpara>char between year-month </simpara>
              </purpose>
            </method>
            <method name="day_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>
                <simpara>Char to separate month-day. </simpara>
              </purpose>
            </method>
            <method name="hour_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>
                <simpara>char between date-hours </simpara>
              </purpose>
            </method>
            <method name="minute_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>
                <simpara>char between hour and minute </simpara>
              </purpose>
            </method>
            <method name="second_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>
                <simpara>char for second </simpara>
              </purpose>
            </method>
          </method-group>
        </class-specialization>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_formatting.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="month_formatter">
          <template>
      <template-type-parameter name="month_type"/>
      <template-type-parameter name="format_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>
            <simpara>Formats a month as as string into an ostream. </simpara>
          </purpose>
          <method-group name="public static functions">
            <method name="format_month" cv="">
              <type>std::basic_ostream&lt; charT &gt; &amp;</type>
              <parameter name="month">
                <paramtype>const month_type &amp;</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>std::basic_ostream&lt; charT &gt; &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Formats a month as as string into an ostream. </simpara>
              </purpose>
              <description>
                <para>This function demands that month_type provide functions for converting to short and long strings if that capability is used. </para>
              </description>
            </method>
            <method name="format_month" cv="">
              <type>std::ostream &amp;</type>
              <parameter name="month">
                <paramtype>const month_type &amp;</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>std::ostream &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Formats a month as as string into an ostream. </simpara>
              </purpose>
              <description>
                <para>This function demands that month_type provide functions for converting to short and long strings if that capability is used. </para>
              </description>
            </method>
          </method-group>
        </class>
        <class name="ymd_formatter">
          <template>
      <template-type-parameter name="ymd_type"/>
      <template-type-parameter name="format_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>
            <simpara>Convert ymd to a standard string formatting policies. </simpara>
          </purpose>
          <method-group name="public static functions">
            <method name="ymd_to_string" cv="">
              <type>std::basic_string&lt; charT &gt;</type>
              <parameter name="ymd">
                <paramtype>ymd_type</paramtype>
              </parameter>
              <purpose>
                <simpara>Convert ymd to a standard string formatting policies. </simpara>
              </purpose>
              <description>
                <para>This is standard code for handling date formatting with year-month-day based date information. This function uses the format_type to control whether the string will contain separator characters, and if so what the character will be. In addtion, it can format the month as either an integer or a string as controled by the formatting policy </para>
              </description>
            </method>
            <method name="ymd_to_string" cv="">
              <type>std::string</type>
              <parameter name="ymd">
                <paramtype>ymd_type</paramtype>
              </parameter>
              <purpose>
                <simpara>Convert ymd to a standard string formatting policies. </simpara>
              </purpose>
              <description>
                <para>This is standard code for handling date formatting with year-month-day based date information. This function uses the format_type to control whether the string will contain separator characters, and if so what the character will be. In addtion, it can format the month as either an integer or a string as controled by the formatting policy </para>
              </description>
            </method>
          </method-group>
        </class>
        <class name="date_formatter">
          <template>
      <template-type-parameter name="date_type"/>
      <template-type-parameter name="format_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>
            <simpara>Convert a date to string using format policies. </simpara>
          </purpose>
          <typedef name="string_type">
            <type>std::basic_string&lt; charT &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="date_to_string" cv="">
              <type>string_type</type>
              <parameter name="d">
                <paramtype>date_type</paramtype>
              </parameter>
              <purpose>
                <simpara>Convert to a date to standard string using format policies. </simpara>
              </purpose>
            </method>
            <method name="date_to_string" cv="">
              <type>std::string</type>
              <parameter name="d">
                <paramtype>date_type</paramtype>
              </parameter>
              <purpose>
                <simpara>Convert to a date to standard string using format policies. </simpara>
              </purpose>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_formatting_limited.hpp">
    <namespace name="boost">
      <namespace name="date_time"/>
    </namespace>
  </header>
  <header name="boost/date_time/date_formatting_locales.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="ostream_month_formatter">
          <template>
      <template-type-parameter name="facet_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>
            <simpara>Formats a month as as string into an ostream. </simpara>
          </purpose>
          <typedef name="month_type">
            <type>facet_type::month_type</type>
          </typedef>
          <typedef name="ostream_type">
            <type>std::basic_ostream&lt; charT &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="format_month" cv="">
              <type>void</type>
              <parameter name="month">
                <paramtype>const month_type &amp;</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>ostream_type &amp;</paramtype>
              </parameter>
              <parameter name="f">
                <paramtype>const facet_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Formats a month as as string into an output iterator. </simpara>
              </purpose>
            </method>
          </method-group>
        </class>
        <class name="ostream_weekday_formatter">
          <template>
      <template-type-parameter name="weekday_type"/>
      <template-type-parameter name="facet_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>
            <simpara>Formats a weekday. </simpara>
          </purpose>
          <typedef name="month_type">
            <type>facet_type::month_type</type>
          </typedef>
          <typedef name="ostream_type">
            <type>std::basic_ostream&lt; charT &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="format_weekday" cv="">
              <type>void</type>
              <parameter name="wd">
                <paramtype>const weekday_type &amp;</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>ostream_type &amp;</paramtype>
              </parameter>
              <parameter name="f">
                <paramtype>const facet_type &amp;</paramtype>
              </parameter>
              <parameter name="as_long_string">
                <paramtype>bool</paramtype>
              </parameter>
              <purpose>
                <simpara>Formats a month as as string into an output iterator. </simpara>
              </purpose>
            </method>
          </method-group>
        </class>
        <class name="ostream_ymd_formatter">
          <template>
      <template-type-parameter name="ymd_type"/>
      <template-type-parameter name="facet_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>
            <simpara>Convert ymd to a standard string formatting policies. </simpara>
          </purpose>
          <typedef name="month_type">
            <type>ymd_type::month_type</type>
          </typedef>
          <typedef name="month_formatter_type">
            <type><classname>ostream_month_formatter</classname>&lt; facet_type, charT &gt;</type>
          </typedef>
          <typedef name="ostream_type">
            <type>std::basic_ostream&lt; charT &gt;</type>
          </typedef>
          <typedef name="foo_type">
            <type>std::basic_string&lt; charT &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="ymd_put" cv="">
              <type>void</type>
              <parameter name="ymd">
                <paramtype>ymd_type</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>ostream_type &amp;</paramtype>
              </parameter>
              <parameter name="f">
                <paramtype>const facet_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Convert ymd to a standard string formatting policies. </simpara>
              </purpose>
              <description>
                <para>This is standard code for handling date formatting with year-month-day based date information. This function uses the format_type to control whether the string will contain separator characters, and if so what the character will be. In addtion, it can format the month as either an integer or a string as controled by the formatting policy </para>
              </description>
            </method>
          </method-group>
        </class>
        <class name="ostream_date_formatter">
          <template>
      <template-type-parameter name="date_type"/>
      <template-type-parameter name="facet_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>
            <simpara>Convert a date to string using format policies. </simpara>
          </purpose>
          <typedef name="ostream_type">
            <type>std::basic_ostream&lt; charT &gt;</type>
          </typedef>
          <typedef name="ymd_type">
            <type>date_type::ymd_type</type>
          </typedef>
          <method-group name="public static functions">
            <method name="date_put" cv="">
              <type>void</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>ostream_type &amp;</paramtype>
              </parameter>
              <parameter name="f">
                <paramtype>const facet_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Put date into an ostream. </simpara>
              </purpose>
            </method>
            <method name="date_put" cv="">
              <type>void</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>ostream_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Put date into an ostream. </simpara>
              </purpose>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_generators.hpp">
    <para>Definition and implementation of date algorithm templates</para>
    <namespace name="boost">
      <namespace name="date_time">
        <class name="year_based_generator">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>
            <simpara>Base class for all generators that take a year and produce a date. </simpara>
          </purpose>
          <description>
            <para>This class is a base class for polymorphic function objects that take a year and produce a concrete date. 
</para>
          </description>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="year_type">
            <type>calendar_type::year_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_date" cv="const">
              <type>virtual date_type</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor/>
          <destructor/>
        </class>
        <class name="partial_date">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <inherit access="public">boost::date_time::year_based_generator&lt; date_type &gt;</inherit>
          <purpose>
            <simpara>Generates a date by applying the year to the given month and day. </simpara>
          </purpose>
          <description>
            <para>Example usage: <programlisting>    partial_date pd(1, Jan);
    partial_date pd2(70);
    date d = pd.get_date(2002); //2002-Jan-01
    date d2 = pd2.get_date(2002); //2002-Mar-10
</programlisting></para>
          </description>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="day_type">
            <type>calendar_type::day_type</type>
          </typedef>
          <typedef name="month_type">
            <type>calendar_type::month_type</type>
          </typedef>
          <typedef name="year_type">
            <type>calendar_type::year_type</type>
          </typedef>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <typedef name="duration_rep">
            <type>duration_type::duration_rep</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_date" cv="const">
              <type>date_type</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
              <purpose>
                <simpara>Return a concrete date when provided with a year specific year. </simpara>
              </purpose>
              <description>
                <para>Will throw an 'invalid_argument' exception if a partial_date object, instantiated with Feb-29, has get_date called with a non-leap year. Example: <programlisting> partial_date pd(29, Feb);
 pd.get_date(2003); // throws invalid_argument exception
 pg.get_date(2000); // returns 2000-2-29
</programlisting></para>
              </description>
            </method>
            <method name="operator()" cv="const">
              <type>date_type</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>partial_date</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&lt;" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>partial_date</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="month" cv="const">
              <type>month_type</type>
            </method>
            <method name="day" cv="const">
              <type>day_type</type>
            </method>
          </method-group>
          <constructor>
            <parameter name="d">
              <paramtype>day_type</paramtype>
            </parameter>
            <parameter name="m">
              <paramtype>month_type</paramtype>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="days">
              <paramtype>duration_rep</paramtype>
            </parameter>
            <purpose>
              <simpara>Partial date created from number of days into year. Range 1-366. </simpara>
            </purpose>
            <description>
              <para>Allowable values range from 1 to 366. 1=Jan1, 366=Dec31. If argument exceeds range, partial_date will be created with closest in-range value. 60 will always be Feb29, if get_date() is called with a non-leap year an exception will be thrown </para>
            </description>
          </constructor>
        </class>
        <class name="nth_kday_of_month">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <inherit access="public">boost::date_time::year_based_generator&lt; date_type &gt;</inherit>
          <purpose>
            <simpara>Useful generator functor for finding holidays. </simpara>
          </purpose>
          <description>
            <para>Based on the idea in Cal. Calc. for finding holidays that are the 'first Monday of September'. When instantiated with 'fifth' kday of month, the result will be the last kday of month which can be the fourth or fifth depending on the structure of the month.</para>
            <para>The algorithm here basically guesses for the first day of the month. Then finds the first day of the correct type. That is, if the first of the month is a Tuesday and it needs Wenesday then we simply increment by a day and then we can add the length of a week until we get to the 'nth kday'. There are probably more efficient algorithms based on using a mod 7, but this one works reasonably well for basic applications. </para>
          </description>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="day_of_week_type">
            <type>calendar_type::day_of_week_type</type>
          </typedef>
          <typedef name="month_type">
            <type>calendar_type::month_type</type>
          </typedef>
          <typedef name="year_type">
            <type>calendar_type::year_type</type>
          </typedef>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <enum name="week_num">
            <enumvalue name="first">
              <default>1</default>
            </enumvalue>
            <enumvalue name="second"/>
            <enumvalue name="third"/>
            <enumvalue name="fourth"/>
            <enumvalue name="fifth"/>
          </enum>
          <method-group name="public member functions">
            <method name="get_date" cv="const">
              <type>date_type</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
              <purpose>
                <simpara>Return a concrete date when provided with a year specific year. </simpara>
              </purpose>
            </method>
            <method name="month" cv="const">
              <type>month_type</type>
            </method>
            <method name="nth_week" cv="const">
              <type>week_num</type>
            </method>
            <method name="day_of_week" cv="const">
              <type>day_of_week_type</type>
            </method>
            <method name="nth_week_as_str" cv="const">
              <type>const char *</type>
            </method>
          </method-group>
          <constructor>
            <parameter name="week_no">
              <paramtype>week_num</paramtype>
            </parameter>
            <parameter name="dow">
              <paramtype>day_of_week_type</paramtype>
            </parameter>
            <parameter name="m">
              <paramtype>month_type</paramtype>
            </parameter>
          </constructor>
        </class>
        <class name="first_kday_of_month">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <inherit access="public">boost::date_time::year_based_generator&lt; date_type &gt;</inherit>
          <purpose>
            <simpara>Useful generator functor for finding holidays and daylight savings. </simpara>
          </purpose>
          <description>
            <para>Similar to nth_kday_of_month, but requires less paramters </para>
          </description>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="day_of_week_type">
            <type>calendar_type::day_of_week_type</type>
          </typedef>
          <typedef name="month_type">
            <type>calendar_type::month_type</type>
          </typedef>
          <typedef name="year_type">
            <type>calendar_type::year_type</type>
          </typedef>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_date" cv="const">
              <type>date_type</type>
              <parameter name="year">
                <paramtype>year_type</paramtype>
              </parameter>
              <purpose>
                <simpara>Return a concrete date when provided with a year specific year. </simpara>
              </purpose>
            </method>
            <method name="month" cv="const">
              <type>month_type</type>
            </method>
            <method name="day_of_week" cv="const">
              <type>day_of_week_type</type>
            </method>
          </method-group>
          <constructor>
            <parameter name="dow">
              <paramtype>day_of_week_type</paramtype>
              <description>
                <para>The day of week, eg: Sunday, Monday, etc </para>
              </description>
            </parameter>
            <parameter name="m">
              <paramtype>month_type</paramtype>
              <description>
                <para>The month of the year, eg: Jan, Feb, Mar, etc </para>
              </description>
            </parameter>
            <purpose>
              <simpara>Specify the first 'Sunday' in 'April' spec. </simpara>
            </purpose>
            <description>
              <para>
</para>
            </description>
          </constructor>
        </class>
        <class name="last_kday_of_month">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <inherit access="public">boost::date_time::year_based_generator&lt; date_type &gt;</inherit>
          <purpose>
            <simpara>Calculate something like Last Sunday of January. </simpara>
          </purpose>
          <description>
            <para>Useful generator functor for finding holidays and daylight savings Get the last day of the month and then calculate the difference to the last previous day. 
</para>
          </description>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="day_of_week_type">
            <type>calendar_type::day_of_week_type</type>
          </typedef>
          <typedef name="month_type">
            <type>calendar_type::month_type</type>
          </typedef>
          <typedef name="year_type">
            <type>calendar_type::year_type</type>
          </typedef>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_date" cv="const">
              <type>date_type</type>
              <parameter name="year">
                <paramtype>year_type</paramtype>
              </parameter>
              <purpose>
                <simpara>Return a concrete date when provided with a year specific year. </simpara>
              </purpose>
            </method>
            <method name="month" cv="const">
              <type>month_type</type>
            </method>
            <method name="day_of_week" cv="const">
              <type>day_of_week_type</type>
            </method>
          </method-group>
          <constructor>
            <parameter name="dow">
              <paramtype>day_of_week_type</paramtype>
              <description>
                <para>The day of week, eg: Sunday, Monday, etc </para>
              </description>
            </parameter>
            <parameter name="m">
              <paramtype>month_type</paramtype>
              <description>
                <para>The month of the year, eg: Jan, Feb, Mar, etc </para>
              </description>
            </parameter>
            <purpose>
              <simpara>Specify the date spec like last 'Sunday' in 'April' spec. </simpara>
            </purpose>
            <description>
              <para>
</para>
            </description>
          </constructor>
        </class>
        <class name="first_kday_after">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>
            <simpara>Calculate something like "First Sunday after Jan 1,2002. </simpara>
          </purpose>
          <description>
            <para>Date generator that takes a date and finds kday after <programlisting>     typedef boost::date_time::first_kday_after&lt;date&gt; firstkdayafter;
     firstkdayafter fkaf(Monday);
     fkaf.get_date(date(2002,Feb,1));
</programlisting></para>
          </description>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="day_of_week_type">
            <type>calendar_type::day_of_week_type</type>
          </typedef>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_date" cv="const">
              <type>date_type</type>
              <parameter name="start_day">
                <paramtype>date_type</paramtype>
              </parameter>
              <purpose>
                <simpara>Return next kday given. </simpara>
              </purpose>
            </method>
            <method name="day_of_week" cv="const">
              <type>day_of_week_type</type>
            </method>
          </method-group>
          <constructor>
            <parameter name="dow">
              <paramtype>day_of_week_type</paramtype>
            </parameter>
          </constructor>
        </class>
        <class name="first_kday_before">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>
            <simpara>Calculate something like "First Sunday before Jan 1,2002. </simpara>
          </purpose>
          <description>
            <para>Date generator that takes a date and finds kday after <programlisting>     typedef boost::date_time::first_kday_before&lt;date&gt; firstkdaybefore;
     firstkdaybefore fkbf(Monday);
     fkbf.get_date(date(2002,Feb,1));
</programlisting></para>
          </description>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="day_of_week_type">
            <type>calendar_type::day_of_week_type</type>
          </typedef>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_date" cv="const">
              <type>date_type</type>
              <parameter name="start_day">
                <paramtype>date_type</paramtype>
              </parameter>
              <purpose>
                <simpara>Return next kday given. </simpara>
              </purpose>
            </method>
            <method name="day_of_week" cv="const">
              <type>day_of_week_type</type>
            </method>
          </method-group>
          <constructor>
            <parameter name="dow">
              <paramtype>day_of_week_type</paramtype>
            </parameter>
          </constructor>
        </class>
        <function name="nth_as_str">
          <type>BOOST_DATE_TIME_DECL const char *</type>
          <parameter name="n">
            <paramtype>int</paramtype>
          </parameter>
          <purpose>
            <simpara>Returns nth arg as string. 1 -&gt; "first", 2 -&gt; "second", max is 5. </simpara>
          </purpose>
        </function>
        <function name="days_until_weekday">
          <type>date_type::duration_type</type>
          <template>
          <template-type-parameter name="date_type"/>
          <template-type-parameter name="weekday_type"/>
        </template>
          <parameter name="d">
            <paramtype>const date_type &amp;</paramtype>
          </parameter>
          <parameter name="wd">
            <paramtype>const weekday_type &amp;</paramtype>
          </parameter>
          <purpose>
            <simpara>Calculates the number of days until the next weekday. </simpara>
          </purpose>
          <description>
            <para>Calculates the number of days until the next weekday. If the date given falls on a Sunday and the given weekday is Tuesday the result will be 2 days </para>
          </description>
        </function>
        <function name="days_before_weekday">
          <type>date_type::duration_type</type>
          <template>
          <template-type-parameter name="date_type"/>
          <template-type-parameter name="weekday_type"/>
        </template>
          <parameter name="d">
            <paramtype>const date_type &amp;</paramtype>
          </parameter>
          <parameter name="wd">
            <paramtype>const weekday_type &amp;</paramtype>
          </parameter>
          <purpose>
            <simpara>Calculates the number of days since the previous weekday. </simpara>
          </purpose>
          <description>
            <para>Calculates the number of days since the previous weekday If the date given falls on a Sunday and the given weekday is Tuesday the result will be 5 days. The answer will be a positive number because Tuesday is 5 days before Sunday, not -5 days before. </para>
          </description>
        </function>
        <function name="next_weekday">
          <type>date_type</type>
          <template>
          <template-type-parameter name="date_type"/>
          <template-type-parameter name="weekday_type"/>
        </template>
          <parameter name="d">
            <paramtype>const date_type &amp;</paramtype>
          </parameter>
          <parameter name="wd">
            <paramtype>const weekday_type &amp;</paramtype>
          </parameter>
          <purpose>
            <simpara>Generates a date object representing the date of the following weekday from the given date. </simpara>
          </purpose>
          <description>
            <para>Generates a date object representing the date of the following weekday from the given date. If the date given is 2004-May-9 (a Sunday) and the given weekday is Tuesday then the resulting date will be 2004-May-11. </para>
          </description>
        </function>
        <function name="previous_weekday">
          <type>date_type</type>
          <template>
          <template-type-parameter name="date_type"/>
          <template-type-parameter name="weekday_type"/>
        </template>
          <parameter name="d">
            <paramtype>const date_type &amp;</paramtype>
          </parameter>
          <parameter name="wd">
            <paramtype>const weekday_type &amp;</paramtype>
          </parameter>
          <purpose>
            <simpara>Generates a date object representing the date of the previous weekday from the given date. </simpara>
          </purpose>
          <description>
            <para>Generates a date object representing the date of the previous weekday from the given date. If the date given is 2004-May-9 (a Sunday) and the given weekday is Tuesday then the resulting date will be 2004-May-4. </para>
          </description>
        </function>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_iterator.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="date_itr_base">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>
            <simpara>Base date iterator type. </simpara>
          </purpose>
          <description>
            <para>This class provides the skeleton for the creation of iterators. New and interesting interators can be created by plugging in a new function that derives the next value from the current state. generation of various types of -based information.</para>
            <para><emphasis role="bold">Template Parameters</emphasis> </para>
            <para><emphasis role="bold">date_type</emphasis> </para>
            <para>The date_type is a concrete date_type. The date_type must define a duration_type and a calendar_type. </para>
          </description>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <typedef name="value_type">
            <type>date_type</type>
          </typedef>
          <typedef name="iterator_category">
            <type>std::input_iterator_tag</type>
          </typedef>
          <method-group name="public member functions">
            <method name="operator++" cv="">
              <type><classname>date_itr_base</classname> &amp;</type>
            </method>
            <method name="operator--" cv="">
              <type><classname>date_itr_base</classname> &amp;</type>
            </method>
            <method name="get_offset" cv="const">
              <type>virtual duration_type</type>
              <parameter name="current">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="get_neg_offset" cv="const">
              <type>virtual duration_type</type>
              <parameter name="current">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator *" cv="">
              <type>date_type</type>
            </method>
            <method name="operator-&gt;" cv="">
              <type>date_type *</type>
            </method>
            <method name="operator&lt;" cv="">
              <type>bool</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&lt;=" cv="">
              <type>bool</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&gt;" cv="">
              <type>bool</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&gt;=" cv="">
              <type>bool</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator==" cv="">
              <type>bool</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator!=" cv="">
              <type>bool</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="d">
              <paramtype>date_type</paramtype>
            </parameter>
          </constructor>
          <destructor/>
        </class>
        <class name="date_itr">
          <template>
      <template-type-parameter name="offset_functor"/>
      <template-type-parameter name="date_type"/>
    </template>
          <inherit access="public">boost::date_time::date_itr_base&lt; date_type &gt;</inherit>
          <purpose>
            <simpara>Overrides the base date iterator providing hook for functors. </simpara>
          </purpose>
          <typedef name="duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <method-group name="public member functions"/>
          <constructor>
            <parameter name="d">
              <paramtype>date_type</paramtype>
            </parameter>
            <parameter name="factor">
              <paramtype>int</paramtype>
              <default>1</default>
            </parameter>
          </constructor>
          <method-group name="private member functions">
            <method name="get_offset" cv="const">
              <type>virtual duration_type</type>
              <parameter name="current">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="get_neg_offset" cv="const">
              <type>virtual duration_type</type>
              <parameter name="current">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
        </class>
        <enum name="date_resolutions">
          <enumvalue name="day"/>
          <enumvalue name="week"/>
          <enumvalue name="months"/>
          <enumvalue name="year"/>
          <enumvalue name="decade"/>
          <enumvalue name="century"/>
          <enumvalue name="NumDateResolutions"/>
          <purpose>
            <simpara>An iterator over dates with varying resolution (day, week, month, year, etc). </simpara>
          </purpose>
        </enum>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_names_put.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="date_names_put">
          <template>
      <template-type-parameter name="Config"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
      <template-type-parameter name="OutputIterator"><default>std::ostreambuf_iterator&lt;charT&gt;</default></template-type-parameter>
    </template>
          <purpose>
            <simpara>Output facet base class for gregorian dates. </simpara>
          </purpose>
          <description>
            <para>This class is a base class for date facets used to localize the names of months and the names of days in the week.</para>
            <para>Requirements of Config<itemizedlist>
<listitem><para>define an enumeration month_enum that enumerates the months. The enumeration should be '1' based eg: Jan==1</para></listitem><listitem><para>define as_short_string and as_long_string</para></listitem></itemizedlist>
</para>
            <para>(see langer &amp; kreft p334). </para>
          </description>
          <typedef name="iter_type">
            <type>OutputIterator</type>
          </typedef>
          <typedef name="month_type">
            <type>Config::month_type</type>
          </typedef>
          <typedef name="month_enum">
            <type>Config::month_enum</type>
          </typedef>
          <typedef name="weekday_enum">
            <type>Config::weekday_enum</type>
          </typedef>
          <typedef name="special_value_enum">
            <type>Config::special_value_enum</type>
          </typedef>
          <typedef name="string_type">
            <type>std::basic_string&lt; charT &gt;</type>
          </typedef>
          <method-group name="public member functions">
            <method name="put_special_value" cv="const">
              <type>void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="sv">
                <paramtype>special_value_enum</paramtype>
              </parameter>
            </method>
            <method name="put_month_short" cv="const">
              <type>void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="moy">
                <paramtype>month_enum</paramtype>
              </parameter>
            </method>
            <method name="put_month_long" cv="const">
              <type>void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="moy">
                <paramtype>month_enum</paramtype>
              </parameter>
            </method>
            <method name="put_weekday_short" cv="const">
              <type>void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="wd">
                <paramtype>weekday_enum</paramtype>
              </parameter>
            </method>
            <method name="put_weekday_long" cv="const">
              <type>void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="wd">
                <paramtype>weekday_enum</paramtype>
              </parameter>
            </method>
            <method name="has_date_sep_chars" cv="const">
              <type>bool</type>
            </method>
            <method name="year_sep_char" cv="const">
              <type>void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="month_sep_char" cv="const">
              <type>void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>char between year-month </simpara>
              </purpose>
            </method>
            <method name="day_sep_char" cv="const">
              <type>void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Char to separate month-day. </simpara>
              </purpose>
            </method>
            <method name="date_order" cv="const">
              <type>ymd_order_spec</type>
              <purpose>
                <simpara>Determines the order to put the date elements. </simpara>
              </purpose>
            </method>
            <method name="month_format" cv="const">
              <type>month_format_spec</type>
              <purpose>
                <simpara>Determines if month is displayed as integer, short or long string. </simpara>
              </purpose>
            </method>
          </method-group>
          <constructor/>
          <data-member name="id" specifiers="static">
            <type>std::locale::id</type>
            <purpose>
              <simpara>Generate storage location for a std::locale::id. </simpara>
            </purpose>
          </data-member>
          <method-group name="protected member functions">
            <method name="do_put_month_short" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="moy">
                <paramtype>month_enum</paramtype>
              </parameter>
              <purpose>
                <simpara>Default facet implementation uses month_type defaults. </simpara>
              </purpose>
            </method>
            <method name="do_put_month_long" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="moy">
                <paramtype>month_enum</paramtype>
              </parameter>
              <purpose>
                <simpara>Default facet implementation uses month_type defaults. </simpara>
              </purpose>
            </method>
            <method name="do_put_special_value" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="sv">
                <paramtype>special_value_enum</paramtype>
              </parameter>
              <purpose>
                <simpara>Default facet implementation for special value types. </simpara>
              </purpose>
            </method>
            <method name="do_put_weekday_short" cv="const">
              <type>virtual void</type>
              <parameter name="">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="">
                <paramtype>weekday_enum</paramtype>
              </parameter>
            </method>
            <method name="do_put_weekday_long" cv="const">
              <type>virtual void</type>
              <parameter name="">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="">
                <paramtype>weekday_enum</paramtype>
              </parameter>
            </method>
            <method name="do_has_date_sep_chars" cv="const">
              <type>virtual bool</type>
            </method>
            <method name="do_year_sep_char" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="do_month_sep_char" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>char between year-month </simpara>
              </purpose>
            </method>
            <method name="do_day_sep_char" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Char to separate month-day. </simpara>
              </purpose>
            </method>
            <method name="do_date_order" cv="const">
              <type>virtual ymd_order_spec</type>
              <purpose>
                <simpara>Default for date order. </simpara>
              </purpose>
            </method>
            <method name="do_month_format" cv="const">
              <type>virtual month_format_spec</type>
              <purpose>
                <simpara>Default month format. </simpara>
              </purpose>
            </method>
            <method name="put_string" cv="const">
              <type>void</type>
              <parameter name="oi">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="s">
                <paramtype>const charT *const</paramtype>
              </parameter>
            </method>
            <method name="put_string" cv="const">
              <type>void</type>
              <parameter name="oi">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="s1">
                <paramtype>const string_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
        </class>
        <class name="all_date_names_put">
          <template>
      <template-type-parameter name="Config"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
      <template-type-parameter name="OutputIterator"><default>std::ostreambuf_iterator&lt;charT&gt;</default></template-type-parameter>
    </template>
          <inherit access="public">boost::date_time::date_names_put&lt; Config, charT, OutputIterator &gt;</inherit>
          <purpose>
            <simpara>An date name output facet that takes an array of char* to define strings. </simpara>
          </purpose>
          <typedef name="iter_type">
            <type>OutputIterator</type>
          </typedef>
          <typedef name="month_enum">
            <type>Config::month_enum</type>
          </typedef>
          <typedef name="weekday_enum">
            <type>Config::weekday_enum</type>
          </typedef>
          <typedef name="special_value_enum">
            <type>Config::special_value_enum</type>
          </typedef>
          <method-group name="public member functions">
            <method name="get_short_month_names" cv="const">
              <type>const charT *const *</type>
            </method>
            <method name="get_long_month_names" cv="const">
              <type>const charT *const *</type>
            </method>
            <method name="get_special_value_names" cv="const">
              <type>const charT *const *</type>
            </method>
            <method name="get_short_weekday_names" cv="const">
              <type>const charT *const *</type>
            </method>
            <method name="get_long_weekday_names" cv="const">
              <type>const charT *const *</type>
            </method>
          </method-group>
          <constructor>
            <parameter name="month_short_names">
              <paramtype>const charT *const</paramtype>
            </parameter>
            <parameter name="month_long_names">
              <paramtype>const charT *const</paramtype>
            </parameter>
            <parameter name="special_value_names">
              <paramtype>const charT *const</paramtype>
            </parameter>
            <parameter name="weekday_short_names">
              <paramtype>const charT *const</paramtype>
            </parameter>
            <parameter name="weekday_long_names">
              <paramtype>const charT *const</paramtype>
            </parameter>
            <parameter name="separator_char">
              <paramtype>charT</paramtype>
              <default>'-'</default>
            </parameter>
            <parameter name="order_spec">
              <paramtype>ymd_order_spec</paramtype>
              <default>ymd_order_iso</default>
            </parameter>
            <parameter name="month_format">
              <paramtype>month_format_spec</paramtype>
              <default>month_as_short_string</default>
            </parameter>
          </constructor>
          <method-group name="protected member functions">
            <method name="do_put_month_short" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="moy">
                <paramtype>month_enum</paramtype>
              </parameter>
              <purpose>
                <simpara>Generic facet that takes array of chars. </simpara>
              </purpose>
            </method>
            <method name="do_put_month_long" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="moy">
                <paramtype>month_enum</paramtype>
              </parameter>
              <purpose>
                <simpara>Long month names. </simpara>
              </purpose>
            </method>
            <method name="do_put_special_value" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="sv">
                <paramtype>special_value_enum</paramtype>
              </parameter>
              <purpose>
                <simpara>Special values names. </simpara>
              </purpose>
            </method>
            <method name="do_put_weekday_short" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="wd">
                <paramtype>weekday_enum</paramtype>
              </parameter>
            </method>
            <method name="do_put_weekday_long" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <parameter name="wd">
                <paramtype>weekday_enum</paramtype>
              </parameter>
            </method>
            <method name="do_month_sep_char" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>char between year-month </simpara>
              </purpose>
            </method>
            <method name="do_day_sep_char" cv="const">
              <type>virtual void</type>
              <parameter name="oitr">
                <paramtype>iter_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Char to separate month-day. </simpara>
              </purpose>
            </method>
            <method name="do_date_order" cv="const">
              <type>virtual ymd_order_spec</type>
              <purpose>
                <simpara>Set the date ordering. </simpara>
              </purpose>
            </method>
            <method name="do_month_format" cv="const">
              <type>virtual month_format_spec</type>
              <purpose>
                <simpara>Set the date ordering. </simpara>
              </purpose>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/date_parsing.hpp"/>
  <header name="boost/date_time/dst_rules.hpp">
    <para>Contains template class to provide static dst rule calculations</para>
    <namespace name="boost">
      <namespace name="date_time">
        <class name="dst_calculator">
          <template>
      <template-type-parameter name="date_type_"/>
      <template-type-parameter name="time_duration_type_"/>
    </template>
          <purpose>
            <simpara>Dynamic class used to caluclate dst transition information. </simpara>
          </purpose>
          <typedef name="time_duration_type">
            <type>time_duration_type_</type>
          </typedef>
          <typedef name="date_type">
            <type>date_type_</type>
          </typedef>
          <method-group name="public static functions">
            <method name="process_local_dst_start_day" cv="">
              <type>time_is_dst_result</type>
              <parameter name="time_of_day">
                <paramtype>const time_duration_type &amp;</paramtype>
                <description>
                  <para>Time offset in the day for the local time </para>
                </description>
              </parameter>
              <parameter name="dst_start_offset_minutes">
                <paramtype>unsigned int</paramtype>
                <description>
                  <para>Local day offset for start of dst </para>
                </description>
              </parameter>
              <parameter name="dst_length_minutes">
                <paramtype>long</paramtype>
                <description>
                  <para>Number of minutes to adjust clock forward </para>
                </description>
              </parameter>
              <purpose>
                <simpara>Check the local time offset when on dst start day. </simpara>
              </purpose>
              <description>
                <para>On this dst transition, the time label between the transition boundary and the boudary + the offset are invalid times. If before the boundary then still not in dst. 

</para>
              </description>
            </method>
            <method name="process_local_dst_end_day" cv="">
              <type>time_is_dst_result</type>
              <parameter name="time_of_day">
                <paramtype>const time_duration_type &amp;</paramtype>
                <description>
                  <para>Time offset in the day for the local time </para>
                </description>
              </parameter>
              <parameter name="dst_end_offset_minutes">
                <paramtype>unsigned int</paramtype>
                <description>
                  <para>Local time of day for end of dst </para>
                </description>
              </parameter>
              <parameter name="dst_length_minutes">
                <paramtype>long</paramtype>
              </parameter>
              <purpose>
                <simpara>Check the local time offset when on the last day of dst. </simpara>
              </purpose>
              <description>
                <para>This is the calculation for the DST end day. On that day times prior to the conversion time - dst_length (1 am in US) are still in dst. Times between the above and the switch time are ambiguous. Times after the start_offset are not in dst. 

</para>
              </description>
            </method>
            <method name="local_is_dst" cv="">
              <type>time_is_dst_result</type>
              <parameter name="current_day">
                <paramtype>const date_type &amp;</paramtype>
                <description>
                  <para>The day to check for dst </para>
                </description>
              </parameter>
              <parameter name="time_of_day">
                <paramtype>const time_duration_type &amp;</paramtype>
                <description>
                  <para>Time offset within the day to check </para>
                </description>
              </parameter>
              <parameter name="dst_start_day">
                <paramtype>const date_type &amp;</paramtype>
                <description>
                  <para>Starting day of dst for the given locality </para>
                </description>
              </parameter>
              <parameter name="dst_start_offset_minutes">
                <paramtype>unsigned int</paramtype>
                <description>
                  <para>Offset within day for dst boundary (eg 120 for US which is 02:00:00) </para>
                </description>
              </parameter>
              <parameter name="dst_end_day">
                <paramtype>const date_type &amp;</paramtype>
                <description>
                  <para>Ending day of dst for the given locality </para>
                </description>
              </parameter>
              <parameter name="dst_end_offset_minutes">
                <paramtype>unsigned int</paramtype>
                <description>
                  <para>Offset within day given in dst for dst boundary (eg 120 for US which is 02:00:00) </para>
                </description>
              </parameter>
              <parameter name="dst_length_minutes">
                <paramtype>long</paramtype>
                <description>
                  <para>Length of dst adjusment (eg: 60 for US) </para>
                </description>
              </parameter>
              <purpose>
                <simpara>Calculates if the given local time is dst or not. </simpara>
              </purpose>
              <description>
                <para>Determines if the time is really in DST or not. Also checks for invalid and ambiguous. 

</para>
              </description>
            </method>
          </method-group>
        </class>
        <class name="dst_calc_engine">
          <template>
      <template-type-parameter name="date_type"/>
      <template-type-parameter name="time_duration_type"/>
      <template-type-parameter name="dst_traits"/>
    </template>
          <purpose>
            <simpara>Compile-time configurable daylight savings time calculation engine. </simpara>
          </purpose>
          <typedef name="year_type">
            <type>date_type::year_type</type>
          </typedef>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="dstcalc">
            <type><classname>dst_calculator</classname>&lt; date_type, time_duration_type &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="local_is_dst" cv="">
              <type>time_is_dst_result</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <parameter name="td">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Calculates if the given local time is dst or not. </simpara>
              </purpose>
              <description>
                <para>Determines if the time is really in DST or not. Also checks for invalid and ambiguous. 
</para>
              </description>
            </method>
            <method name="is_dst_boundary_day" cv="">
              <type>bool</type>
              <parameter name="d">
                <paramtype>date_type</paramtype>
              </parameter>
            </method>
            <method name="dst_offset" cv="">
              <type>time_duration_type</type>
              <purpose>
                <simpara>The time of day for the dst transition (eg: typically 01:00:00 or 02:00:00). </simpara>
              </purpose>
            </method>
            <method name="local_dst_start_day" cv="">
              <type>date_type</type>
              <parameter name="year">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
            <method name="local_dst_end_day" cv="">
              <type>date_type</type>
              <parameter name="year">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
          </method-group>
        </class>
        <class name="us_dst_rules">
          <template>
      <template-type-parameter name="date_type_"/>
      <template-type-parameter name="time_duration_type_"/>
      <template-nontype-parameter name="dst_start_offset_minutes"><type>unsigned int</type><default>120</default></template-nontype-parameter>
      <template-nontype-parameter name="dst_length_minutes"><type>short</type><default>60</default></template-nontype-parameter>
    </template>
          <purpose>
            <simpara>Depricated: Class to calculate dst boundaries for US time zones. </simpara>
          </purpose>
          <typedef name="time_duration_type">
            <type>time_duration_type_</type>
          </typedef>
          <typedef name="date_type">
            <type>date_type_</type>
          </typedef>
          <typedef name="year_type">
            <type>date_type::year_type</type>
          </typedef>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="lkday">
            <type><classname>date_time::last_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="fkday">
            <type><classname>date_time::first_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="dstcalc">
            <type><classname>dst_calculator</classname>&lt; date_type, time_duration_type &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="local_is_dst" cv="">
              <type>time_is_dst_result</type>
              <parameter name="d">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <parameter name="td">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Calculates if the given local time is dst or not. </simpara>
              </purpose>
              <description>
                <para>Determines if the time is really in DST or not. Also checks for invalid and ambiguous. 
</para>
              </description>
            </method>
            <method name="is_dst_boundary_day" cv="">
              <type>bool</type>
              <parameter name="d">
                <paramtype>date_type</paramtype>
              </parameter>
            </method>
            <method name="local_dst_start_day" cv="">
              <type>date_type</type>
              <parameter name="year">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
            <method name="local_dst_end_day" cv="">
              <type>date_type</type>
              <parameter name="year">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
            <method name="dst_offset" cv="">
              <type>time_duration_type</type>
            </method>
          </method-group>
        </class>
        <class name="null_dst_rules">
          <template>
      <template-type-parameter name="date_type_"/>
      <template-type-parameter name="time_duration_type_"/>
    </template>
          <purpose>
            <simpara>Used for local time adjustments in places that don't use dst. </simpara>
          </purpose>
          <typedef name="time_duration_type">
            <type>time_duration_type_</type>
          </typedef>
          <typedef name="date_type">
            <type>date_type_</type>
          </typedef>
          <method-group name="public static functions">
            <method name="local_is_dst" cv="">
              <type>time_is_dst_result</type>
              <parameter name="">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <parameter name="">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Calculates if the given local time is dst or not. </simpara>
              </purpose>
              <description>
                <para>
</para>
              </description>
            </method>
            <method name="utc_is_dst" cv="">
              <type>time_is_dst_result</type>
              <parameter name="">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <parameter name="">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Calculates if the given utc time is in dst. </simpara>
              </purpose>
            </method>
            <method name="is_dst_boundary_day" cv="">
              <type>bool</type>
              <parameter name="d">
                <paramtype>date_type</paramtype>
              </parameter>
            </method>
            <method name="dst_offset" cv="">
              <type>time_duration_type</type>
            </method>
          </method-group>
        </class>
        <enum name="time_is_dst_result">
          <enumvalue name="is_not_in_dst"/>
          <enumvalue name="is_in_dst"/>
          <enumvalue name="ambiguous"/>
          <enumvalue name="invalid_time_label"/>
        </enum>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/dst_transition_generators.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="dst_day_calc_rule">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>
            <simpara>Defines base interface for calculating start and end date of daylight savings. </simpara>
          </purpose>
          <typedef name="year_type">
            <type>date_type::year_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="start_day" cv="const">
              <type>virtual date_type</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
            <method name="end_day" cv="const">
              <type>virtual date_type</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
          </method-group>
          <destructor/>
        </class>
        <class name="day_calc_dst_rule">
          <template>
      <template-type-parameter name="spec"/>
    </template>
          <inherit access="public">boost::date_time::dst_day_calc_rule&lt; spec::date_type &gt;</inherit>
          <purpose>
            <simpara>Canonical form for a class that provides day rule calculation. </simpara>
          </purpose>
          <description>
            <para>This class is used to generate specific sets of dst rules</para>
            <para>
</para>
          </description>
          <typedef name="date_type">
            <type>spec::date_type</type>
          </typedef>
          <typedef name="year_type">
            <type>date_type::year_type</type>
          </typedef>
          <typedef name="start_rule">
            <type>spec::start_rule</type>
          </typedef>
          <typedef name="end_rule">
            <type>spec::end_rule</type>
          </typedef>
          <method-group name="public member functions">
            <method name="start_day" cv="const">
              <type>virtual date_type</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
            <method name="end_day" cv="const">
              <type>virtual date_type</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="dst_start">
              <paramtype>start_rule</paramtype>
            </parameter>
            <parameter name="dst_end">
              <paramtype>end_rule</paramtype>
            </parameter>
          </constructor>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/filetime_functions.hpp">
    <para>Function(s) for converting between a FILETIME structure and a time object. This file is only available on systems that have BOOST_HAS_FTIME defined.</para>
    <namespace name="boost">
      <namespace name="date_time">
        <function name="time_from_ftime">
          <type>time_type</type>
          <template>
          <template-type-parameter name="time_type"/>
        </template>
          <parameter name="ft">
            <paramtype>const FILETIME &amp;</paramtype>
          </parameter>
          <purpose>
            <simpara>Create a time object from an initialized FILETIME struct. </simpara>
          </purpose>
          <description>
            <para>Create a time object from an initialized FILETIME struct. A FILETIME struct holds 100-nanosecond units (0.0000001). When built with microsecond resolution the FILETIME's sub second value will be truncated. Nanosecond resolution has no truncation. </para>
          </description>
        </function>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/gregorian_calendar.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="gregorian_calendar_base">
          <template>
      <template-type-parameter name="ymd_type_"/>
      <template-type-parameter name="date_int_type_"/>
    </template>
          <purpose>
            <simpara>An implementation of the Gregorian calendar. </simpara>
          </purpose>
          <description>
            <para>This is a parameterized implementation of a proleptic Gregorian Calendar that can be used in the creation of date systems or just to perform calculations. All the methods of this class are static functions, so the intent is to never create instances of this class. 
</para>
          </description>
          <typedef name="ymd_type">
            <purpose>
              <simpara>define a type a date split into components </simpara>
            </purpose>
            <type>ymd_type_</type>
          </typedef>
          <typedef name="month_type">
            <purpose>
              <simpara>define a type for representing months </simpara>
            </purpose>
            <type>ymd_type::month_type</type>
          </typedef>
          <typedef name="day_type">
            <purpose>
              <simpara>define a type for representing days </simpara>
            </purpose>
            <type>ymd_type::day_type</type>
          </typedef>
          <typedef name="year_type">
            <purpose>
              <simpara>Type to hold a stand alone year value (eg: 2002). </simpara>
            </purpose>
            <type>ymd_type::year_type</type>
          </typedef>
          <typedef name="date_int_type">
            <purpose>
              <simpara>Define the integer type to use for internal calculations. </simpara>
            </purpose>
            <type>date_int_type_</type>
          </typedef>
          <method-group name="public static functions">
            <method name="day_of_week" cv="">
              <type>unsigned short</type>
              <parameter name="ymd">
                <paramtype>const ymd_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="week_number" cv="">
              <type>int</type>
              <parameter name="ymd">
                <paramtype>const ymd_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="day_number" cv="">
              <type>date_int_type</type>
              <parameter name="ymd">
                <paramtype>const ymd_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="julian_day_number" cv="">
              <type>date_int_type</type>
              <parameter name="ymd">
                <paramtype>const ymd_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="modjulian_day_number" cv="">
              <type>long</type>
              <parameter name="ymd">
                <paramtype>const ymd_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="from_day_number" cv="">
              <type>ymd_type</type>
              <parameter name="">
                <paramtype>date_int_type</paramtype>
              </parameter>
            </method>
            <method name="from_julian_day_number" cv="">
              <type>ymd_type</type>
              <parameter name="">
                <paramtype>date_int_type</paramtype>
              </parameter>
            </method>
            <method name="from_modjulian_day_number" cv="">
              <type>ymd_type</type>
              <parameter name="">
                <paramtype>long</paramtype>
              </parameter>
            </method>
            <method name="is_leap_year" cv="">
              <type>bool</type>
              <parameter name="">
                <paramtype>year_type</paramtype>
              </parameter>
            </method>
            <method name="end_of_month_day" cv="">
              <type>unsigned short</type>
              <parameter name="y">
                <paramtype>year_type</paramtype>
              </parameter>
              <parameter name="m">
                <paramtype>month_type</paramtype>
              </parameter>
            </method>
            <method name="epoch" cv="">
              <type>ymd_type</type>
            </method>
            <method name="days_in_week" cv="">
              <type>unsigned short</type>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/int_adapter.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="int_adapter">
          <template>
      <template-type-parameter name="int_type_"/>
    </template>
          <purpose>
            <simpara>Adapter to create integer types with +-infinity, and not a value. </simpara>
          </purpose>
          <description>
            <para>This class is used internally in counted date/time representations. It adds the floating point like features of infinities and not a number. It also provides mathmatical operations with consideration to special values following these rules: <programlisting>  +infinity  -  infinity  == Not A Number (NAN)
   infinity  *  non-zero  == infinity
   infinity  *  zero      == NAN
  +infinity  * -integer   == -infinity
   infinity  /  infinity  == NAN
   infinity  *  infinity  == infinity 
 *
</programlisting></para>
          </description>
          <typedef name="int_type">
            <type>int_type_</type>
          </typedef>
          <method-group name="public member functions">
            <method name="is_infinity" cv="const">
              <type>bool</type>
            </method>
            <method name="is_pos_infinity" cv="const">
              <type>bool</type>
            </method>
            <method name="is_neg_infinity" cv="const">
              <type>bool</type>
            </method>
            <method name="is_nan" cv="const">
              <type>bool</type>
            </method>
            <method name="is_special" cv="const">
              <type>bool</type>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const int &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator!=" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator!=" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const int &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&lt;" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&lt;" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const int &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&gt;" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="as_number" cv="const">
              <type>int_type</type>
            </method>
            <method name="as_special" cv="const">
              <type>special_values</type>
              <purpose>
                <simpara>Returns either special value type or is_not_special. </simpara>
              </purpose>
            </method>
            <method name="operator+" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <template>
          <template-type-parameter name="rhs_type"/>
        </template>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname>&lt; rhs_type &gt; &amp;</paramtype>
              </parameter>
              <description>
                <para>Operator allows for adding dissimilar int_adapter types. The return type will match that of the the calling object's type </para>
              </description>
            </method>
            <method name="operator+" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator-" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <template>
          <template-type-parameter name="rhs_type"/>
        </template>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname>&lt; rhs_type &gt; &amp;</paramtype>
              </parameter>
              <description>
                <para>Operator allows for subtracting dissimilar int_adapter types. The return type will match that of the the calling object's type </para>
              </description>
            </method>
            <method name="operator-" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int_type</paramtype>
              </parameter>
            </method>
            <method name="operator *" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator *" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int</paramtype>
              </parameter>
              <description>
                <para>Provided for cases when automatic conversion from 'int' to 'int_adapter' causes incorrect results. </para>
              </description>
            </method>
            <method name="operator/" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator/" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int</paramtype>
              </parameter>
              <description>
                <para>Provided for cases when automatic conversion from 'int' to 'int_adapter' causes incorrect results. </para>
              </description>
            </method>
            <method name="operator%" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator%" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int</paramtype>
              </parameter>
              <description>
                <para>Provided for cases when automatic conversion from 'int' to 'int_adapter' causes incorrect results. </para>
              </description>
            </method>
          </method-group>
          <constructor>
            <parameter name="v">
              <paramtype>int_type</paramtype>
            </parameter>
          </constructor>
          <method-group name="public static functions">
            <method name="has_infinity" cv="">
              <type>bool</type>
            </method>
            <method name="pos_infinity" cv="">
              <type>const <classname>int_adapter</classname></type>
            </method>
            <method name="neg_infinity" cv="">
              <type>const <classname>int_adapter</classname></type>
            </method>
            <method name="not_a_number" cv="">
              <type>const <classname>int_adapter</classname></type>
            </method>
            <method name="BOOST_PREVENT_MACRO_SUBSTITUTION" cv="">
              <type><classname>int_adapter</classname> max</type>
            </method>
            <method name="BOOST_PREVENT_MACRO_SUBSTITUTION" cv="">
              <type><classname>int_adapter</classname> min</type>
            </method>
            <method name="from_special" cv="">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="sv">
                <paramtype>special_values</paramtype>
              </parameter>
            </method>
            <method name="is_inf" cv="">
              <type>bool</type>
              <parameter name="v">
                <paramtype>int_type</paramtype>
              </parameter>
            </method>
            <method name="is_neg_inf" cv="">
              <type>bool</type>
              <parameter name="v">
                <paramtype>int_type</paramtype>
              </parameter>
            </method>
            <method name="is_pos_inf" cv="">
              <type>bool</type>
              <parameter name="v">
                <paramtype>int_type</paramtype>
              </parameter>
            </method>
            <method name="is_not_a_number" cv="">
              <type>bool</type>
              <parameter name="v">
                <paramtype>int_type</paramtype>
              </parameter>
            </method>
            <method name="to_special" cv="">
              <type>special_values</type>
              <parameter name="v">
                <paramtype>int_type</paramtype>
              </parameter>
              <purpose>
                <simpara>Returns either special value type or is_not_special. </simpara>
              </purpose>
            </method>
            <method name="maxcount" cv="">
              <type>int_type</type>
            </method>
          </method-group>
          <method-group name="private member functions">
            <method name="compare" cv="const">
              <type>int</type>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname> &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>returns -1, 0, 1, or 2 if 'this' is &lt;, ==, &gt;, or 'nan comparison' rhs </simpara>
              </purpose>
            </method>
            <method name="mult_div_specials" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const <classname>int_adapter</classname> &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Assumes at least 'this' or 'rhs' is a special value. </simpara>
              </purpose>
            </method>
            <method name="mult_div_specials" cv="const">
              <type>
                <classname>int_adapter</classname>
              </type>
              <parameter name="rhs">
                <paramtype>const int &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Assumes 'this' is a special value. </simpara>
              </purpose>
            </method>
          </method-group>
        </class>
        <function name="operator&lt;&lt;">
          <type>std::basic_ostream&lt; charT, traits &gt; &amp;</type>
          <template>
          <template-type-parameter name="charT"/>
          <template-type-parameter name="traits"/>
          <template-type-parameter name="int_type"/>
        </template>
          <parameter name="os">
            <paramtype>std::basic_ostream&lt; charT, traits &gt; &amp;</paramtype>
          </parameter>
          <parameter name="ia">
            <paramtype>const <classname>int_adapter</classname>&lt; int_type &gt; &amp;</paramtype>
          </parameter>
          <description>
            <para>Expected output is either a numeric representation or a special values representation.
 Ex. "12", "+infinity", "not-a-number", etc. </para>
          </description>
        </function>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/iso_format.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="iso_format_base">
          <template>
      <template-type-parameter name="charT"/>
    </template>
          <purpose>
            <simpara>Class to provide common iso formatting spec. </simpara>
          </purpose>
          <method-group name="public static functions">
            <method name="month_format" cv="">
              <type>month_format_spec</type>
              <purpose>
                <simpara>Describe month format -- its an integer in iso format. </simpara>
              </purpose>
            </method>
            <method name="not_a_date" cv="">
              <type>const charT *</type>
              <purpose>
                <simpara>String used printed is date is invalid. </simpara>
              </purpose>
            </method>
            <method name="pos_infinity" cv="">
              <type>const charT *</type>
              <purpose>
                <simpara>String used to for positive infinity value. </simpara>
              </purpose>
            </method>
            <method name="neg_infinity" cv="">
              <type>const charT *</type>
              <purpose>
                <simpara>String used to for positive infinity value. </simpara>
              </purpose>
            </method>
            <method name="year_sep_char" cv="">
              <type>charT</type>
              <purpose>
                <simpara>ISO char for a year -- used in durations. </simpara>
              </purpose>
            </method>
            <method name="month_sep_char" cv="">
              <type>charT</type>
              <purpose>
                <simpara>ISO char for a month. </simpara>
              </purpose>
            </method>
            <method name="day_sep_char" cv="">
              <type>charT</type>
              <purpose>
                <simpara>ISO char for a day. </simpara>
              </purpose>
            </method>
            <method name="hour_sep_char" cv="">
              <type>charT</type>
              <purpose>
                <simpara>char for minute </simpara>
              </purpose>
            </method>
            <method name="minute_sep_char" cv="">
              <type>charT</type>
              <purpose>
                <simpara>char for minute </simpara>
              </purpose>
            </method>
            <method name="second_sep_char" cv="">
              <type>charT</type>
              <purpose>
                <simpara>char for second </simpara>
              </purpose>
            </method>
            <method name="period_start_char" cv="">
              <type>charT</type>
              <purpose>
                <simpara>ISO char for a period. </simpara>
              </purpose>
            </method>
            <method name="time_start_char" cv="">
              <type>charT</type>
              <purpose>
                <simpara>Used in time in mixed strings to set start of time. </simpara>
              </purpose>
            </method>
            <method name="week_start_char" cv="">
              <type>charT</type>
              <purpose>
                <simpara>Used in mixed strings to identify start of a week number. </simpara>
              </purpose>
            </method>
            <method name="period_sep_char" cv="">
              <type>charT</type>
              <purpose>
                <simpara>Separators for periods. </simpara>
              </purpose>
            </method>
            <method name="time_sep_char" cv="">
              <type>charT</type>
              <purpose>
                <simpara>Separator for hh:mm:ss. </simpara>
              </purpose>
            </method>
            <method name="fractional_time_sep_char" cv="">
              <type>charT</type>
              <purpose>
                <simpara>Preferred Separator for hh:mm:ss,decimal_fraction. </simpara>
              </purpose>
            </method>
            <method name="is_component_sep" cv="">
              <type>bool</type>
              <parameter name="sep">
                <paramtype>charT</paramtype>
              </parameter>
            </method>
            <method name="is_fractional_time_sep" cv="">
              <type>bool</type>
              <parameter name="sep">
                <paramtype>charT</paramtype>
              </parameter>
            </method>
            <method name="is_timezone_sep" cv="">
              <type>bool</type>
              <parameter name="sep">
                <paramtype>charT</paramtype>
              </parameter>
            </method>
            <method name="element_sep_char" cv="">
              <type>charT</type>
            </method>
          </method-group>
        </class>
        <class-specialization name="iso_format_base">
          <template>
    </template>
          <specialization>
            <template-arg>wchar_t</template-arg>
          </specialization>
          <purpose>
            <simpara>Class to provide common iso formatting spec. </simpara>
          </purpose>
          <method-group name="public static functions">
            <method name="month_format" cv="">
              <type>month_format_spec</type>
              <purpose>
                <simpara>Describe month format -- its an integer in iso format. </simpara>
              </purpose>
            </method>
            <method name="not_a_date" cv="">
              <type>const wchar_t *</type>
              <purpose>
                <simpara>String used printed is date is invalid. </simpara>
              </purpose>
            </method>
            <method name="pos_infinity" cv="">
              <type>const wchar_t *</type>
              <purpose>
                <simpara>String used to for positive infinity value. </simpara>
              </purpose>
            </method>
            <method name="neg_infinity" cv="">
              <type>const wchar_t *</type>
              <purpose>
                <simpara>String used to for positive infinity value. </simpara>
              </purpose>
            </method>
            <method name="year_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>
                <simpara>ISO char for a year -- used in durations. </simpara>
              </purpose>
            </method>
            <method name="month_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>
                <simpara>ISO char for a month. </simpara>
              </purpose>
            </method>
            <method name="day_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>
                <simpara>ISO char for a day. </simpara>
              </purpose>
            </method>
            <method name="hour_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>
                <simpara>char for minute </simpara>
              </purpose>
            </method>
            <method name="minute_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>
                <simpara>char for minute </simpara>
              </purpose>
            </method>
            <method name="second_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>
                <simpara>char for second </simpara>
              </purpose>
            </method>
            <method name="period_start_char" cv="">
              <type>wchar_t</type>
              <purpose>
                <simpara>ISO char for a period. </simpara>
              </purpose>
            </method>
            <method name="time_start_char" cv="">
              <type>wchar_t</type>
              <purpose>
                <simpara>Used in time in mixed strings to set start of time. </simpara>
              </purpose>
            </method>
            <method name="week_start_char" cv="">
              <type>wchar_t</type>
              <purpose>
                <simpara>Used in mixed strings to identify start of a week number. </simpara>
              </purpose>
            </method>
            <method name="period_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>
                <simpara>Separators for periods. </simpara>
              </purpose>
            </method>
            <method name="time_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>
                <simpara>Separator for hh:mm:ss. </simpara>
              </purpose>
            </method>
            <method name="fractional_time_sep_char" cv="">
              <type>wchar_t</type>
              <purpose>
                <simpara>Preferred Separator for hh:mm:ss,decimal_fraction. </simpara>
              </purpose>
            </method>
            <method name="is_component_sep" cv="">
              <type>bool</type>
              <parameter name="sep">
                <paramtype>wchar_t</paramtype>
              </parameter>
            </method>
            <method name="is_fractional_time_sep" cv="">
              <type>bool</type>
              <parameter name="sep">
                <paramtype>wchar_t</paramtype>
              </parameter>
            </method>
            <method name="is_timezone_sep" cv="">
              <type>bool</type>
              <parameter name="sep">
                <paramtype>wchar_t</paramtype>
              </parameter>
            </method>
            <method name="element_sep_char" cv="">
              <type>wchar_t</type>
            </method>
          </method-group>
        </class-specialization>
        <class name="iso_format">
          <template>
      <template-type-parameter name="charT"/>
    </template>
          <inherit access="public">boost::date_time::iso_format_base&lt; charT &gt;</inherit>
          <purpose>
            <simpara>Format description for iso normal YYYYMMDD. </simpara>
          </purpose>
          <method-group name="public static functions">
            <method name="has_date_sep_chars" cv="">
              <type>bool</type>
              <purpose>
                <simpara>The ios standard format doesn't use char separators. </simpara>
              </purpose>
            </method>
          </method-group>
        </class>
        <class name="iso_extended_format">
          <template>
      <template-type-parameter name="charT"/>
    </template>
          <inherit access="public">boost::date_time::iso_format_base&lt; charT &gt;</inherit>
          <purpose>
            <simpara>Extended format uses seperators YYYY-MM-DD. </simpara>
          </purpose>
          <method-group name="public static functions">
            <method name="has_date_sep_chars" cv="">
              <type>bool</type>
              <purpose>
                <simpara>Extended format needs char separators. </simpara>
              </purpose>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/local_time_adjustor.hpp">
    <para>Time adjustment calculations for local times</para>
    <namespace name="boost">
      <namespace name="date_time">
        <class name="utc_adjustment">
          <template>
      <template-type-parameter name="time_duration_type"/>
      <template-nontype-parameter name="hours"><type>short</type></template-nontype-parameter>
      <template-nontype-parameter name="minutes"><type>unsigned short</type><default>0</default></template-nontype-parameter>
    </template>
          <purpose>
            <simpara>Provides a base offset adjustment from utc. </simpara>
          </purpose>
          <method-group name="public static functions">
            <method name="local_to_utc_base_offset" cv="">
              <type>time_duration_type</type>
            </method>
            <method name="utc_to_local_base_offset" cv="">
              <type>time_duration_type</type>
            </method>
          </method-group>
        </class>
        <class name="dynamic_local_time_adjustor">
          <template>
      <template-type-parameter name="time_type"/>
      <template-type-parameter name="dst_rules"/>
    </template>
          <purpose>
            <simpara>Allow sliding utc adjustment with fixed dst rules. </simpara>
          </purpose>
          <typedef name="time_duration_type">
            <type>time_type::time_duration_type</type>
          </typedef>
          <typedef name="date_type">
            <type>time_type::date_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="utc_offset" cv="">
              <type>time_duration_type</type>
              <parameter name="is_dst">
                <paramtype>bool</paramtype>
              </parameter>
              <purpose>
                <simpara>Presumes local time. </simpara>
              </purpose>
            </method>
          </method-group>
          <constructor>
            <parameter name="utc_offset">
              <paramtype>time_duration_type</paramtype>
            </parameter>
          </constructor>
        </class>
        <class name="static_local_time_adjustor">
          <template>
      <template-type-parameter name="time_type"/>
      <template-type-parameter name="dst_rules"/>
      <template-type-parameter name="utc_offset_rules"/>
    </template>
          <purpose>
            <simpara>Embed the rules for local time adjustments at compile time. </simpara>
          </purpose>
          <typedef name="time_duration_type">
            <type>time_type::time_duration_type</type>
          </typedef>
          <typedef name="date_type">
            <type>time_type::date_type</type>
          </typedef>
          <method-group name="public static functions">
            <method name="utc_to_local_offset" cv="">
              <type>time_duration_type</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
                <description>
                  <para>UTC time to calculate offset to local time This adjustment depends on the following observations about the workings of the DST boundary offset. Since UTC time labels are monotonically increasing we can determine if a given local time is in DST or not and therefore adjust the offset appropriately.</para>
                </description>
              </parameter>
              <purpose>
                <simpara>Calculates the offset from a utc time to local based on dst and utc offset. </simpara>
              </purpose>
              <description>
                <para>
The logic is as follows. Starting with UTC time use the offset to create a label for an non-dst adjusted local time. Then call dst_rules::local_is_dst with the non adjust local time. The results of this function will either unabiguously decide that the initial local time is in dst or return an illegal or ambiguous result. An illegal result only occurs at the end of dst (where labels are skipped) and indicates that dst has ended. An ambiguous result means that we need to recheck by making a dst adjustment and then rechecking. If the dst offset is added to the utc time and the recheck proves non-ambiguous then we are past the boundary. If it is still ambiguous then we are ahead of the boundary and dst is still in effect.</para>
                <para>TODO -- check if all dst offsets are positive. If not then the algorithm needs to check for this and reverse the illegal/ambiguous logic. </para>
              </description>
            </method>
            <method name="local_to_utc_offset" cv="">
              <type>time_duration_type</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
              <parameter name="dst">
                <paramtype>date_time::dst_flags</paramtype>
                <default>date_time::calculate</default>
              </parameter>
              <purpose>
                <simpara>Get the offset to UTC given a local time. </simpara>
              </purpose>
            </method>
          </method-group>
        </class>
        <class name="local_adjustor">
          <template>
      <template-type-parameter name="time_type"/>
      <template-nontype-parameter name="utc_offset"><type>short</type></template-nontype-parameter>
      <template-type-parameter name="dst_rule"/>
    </template>
          <purpose>
            <simpara>Template that simplifies the creation of local time calculator. </simpara>
          </purpose>
          <description>
            <para>Use this template to create the timezone to utc convertors as required.</para>
            <para>This class will also work for other regions that don't use dst and have a utc offset which is an integral number of hours.</para>
            <para><emphasis role="bold">Template Parameters</emphasis>  -time_type -- Time class to use -utc_offset -- Number hours local time is adjust from utc -use_dst -- true (default) if region uses dst, false otherwise For example: <programlisting>  //eastern timezone is utc-5
     typedef date_time::local_adjustor&lt;ptime, -5, us_dst&gt; us_eastern;
     typedef date_time::local_adjustor&lt;ptime, -6, us_dst&gt; us_central;
     typedef date_time::local_adjustor&lt;ptime, -7, us_dst&gt; us_mountain;
     typedef date_time::local_adjustor&lt;ptime, -8, us_dst&gt; us_pacific;
     typedef date_time::local_adjustor&lt;ptime, -7, no_dst&gt; us_arizona;
</programlisting></para>
          </description>
          <typedef name="time_duration_type">
            <type>time_type::time_duration_type</type>
          </typedef>
          <typedef name="date_type">
            <type>time_type::date_type</type>
          </typedef>
          <typedef name="dst_adjustor">
            <type><classname>static_local_time_adjustor</classname>&lt; time_type, dst_rule, <classname>utc_adjustment</classname>&lt; time_duration_type, utc_offset &gt; &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="utc_to_local" cv="">
              <type>time_type</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Convert a utc time to local time. </simpara>
              </purpose>
            </method>
            <method name="local_to_utc" cv="">
              <type>time_type</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
              <parameter name="dst">
                <paramtype>date_time::dst_flags</paramtype>
                <default>date_time::calculate</default>
              </parameter>
              <purpose>
                <simpara>Convert a local time to utc. </simpara>
              </purpose>
            </method>
          </method-group>
        </class>
        <function name="dummy_to_prevent_msvc6_ice">
          <type>void</type>
        </function>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/local_timezone_defs.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <struct name="us_dst_trait">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>
            <simpara>Specification for daylight savings start rules in US. </simpara>
          </purpose>
          <description>
            <para>This class is used to configure dst_calc_engine template typically as follows: <programlisting>          using namespace boost::gregorian;
          using namespace boost::posix_time;
          typedef us_dst_trait&lt;date&gt; us_dst_traits;
          typedef boost::date_time::dst_calc_engine&lt;date, time_duration, 
                                                    us_dst_traits&gt;  
                                                    us_dst_calc;
          //calculate the 2002 transition day of USA April 7 2002
          date dst_start = us_dst_calc::local_dst_start_day(2002); 

          //calculate the 2002 transition day of USA Oct 27 2002
          date dst_end = us_dst_calc::local_dst_end_day(2002); 
                                                    
          //check if a local time is in dst or not -- posible answers
          //are yes, no, invalid time label, ambiguous
          ptime t(...some time...);  
          if (us_dst::local_is_dst(t.date(), t.time_of_day()) 
              == boost::date_time::is_not_in_dst) 
          {

          }
</programlisting>This generates a type suitable for the calculation of dst transitions for the United States. Of course other templates can be used for other locales. </para>
          </description>
          <typedef name="day_of_week_type">
            <type>date_type::day_of_week_type</type>
          </typedef>
          <typedef name="month_type">
            <type>date_type::month_type</type>
          </typedef>
          <typedef name="start_rule_functor">
            <type><classname>date_time::first_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="end_rule_functor">
            <type><classname>date_time::last_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="start_day" cv="">
              <type>day_of_week_type</type>
            </method>
            <method name="start_month" cv="">
              <type>month_type</type>
            </method>
            <method name="end_day" cv="">
              <type>day_of_week_type</type>
            </method>
            <method name="end_month" cv="">
              <type>month_type</type>
            </method>
            <method name="dst_start_offset_minutes" cv="">
              <type>int</type>
            </method>
            <method name="dst_end_offset_minutes" cv="">
              <type>int</type>
            </method>
            <method name="dst_shift_length_minutes" cv="">
              <type>int</type>
            </method>
          </method-group>
        </struct>
        <struct name="eu_dst_trait">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <purpose>
            <simpara>Rules for daylight savings start in the EU (Last Sun in Mar). </simpara>
          </purpose>
          <description>
            <para>These amount to the following:<itemizedlist>
<listitem><para>Start of dst day is last Sunday in March</para></listitem><listitem><para>End day of dst is last Sunday in Oct</para></listitem><listitem><para>Going forward switch time is 2:00 am (offset 120 minutes)</para></listitem><listitem><para>Going back switch time is 3:00 am (off set 180 minutes)</para></listitem><listitem><para>Shift duration is one hour (60 minutes) </para></listitem></itemizedlist>
</para>
          </description>
          <typedef name="day_of_week_type">
            <type>date_type::day_of_week_type</type>
          </typedef>
          <typedef name="month_type">
            <type>date_type::month_type</type>
          </typedef>
          <typedef name="start_rule_functor">
            <type><classname>date_time::last_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="end_rule_functor">
            <type><classname>date_time::last_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="start_day" cv="">
              <type>day_of_week_type</type>
            </method>
            <method name="start_month" cv="">
              <type>month_type</type>
            </method>
            <method name="end_day" cv="">
              <type>day_of_week_type</type>
            </method>
            <method name="end_month" cv="">
              <type>month_type</type>
            </method>
            <method name="dst_start_offset_minutes" cv="">
              <type>int</type>
            </method>
            <method name="dst_end_offset_minutes" cv="">
              <type>int</type>
            </method>
            <method name="dst_shift_length_minutes" cv="">
              <type>int</type>
            </method>
          </method-group>
        </struct>
        <struct name="uk_dst_trait">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <inherit access="public">boost::date_time::eu_dst_trait&lt; date_type &gt;</inherit>
          <purpose>
            <simpara>Alternative dst traits for some parts of the United Kingdom. </simpara>
          </purpose>
          <method-group name="public static functions">
            <method name="dst_start_offset_minutes" cv="">
              <type>int</type>
            </method>
            <method name="dst_end_offset_minutes" cv="">
              <type>int</type>
            </method>
            <method name="dst_shift_length_minutes" cv="">
              <type>int</type>
            </method>
          </method-group>
        </struct>
        <struct name="acst_dst_trait">
          <template>
      <template-type-parameter name="date_type"/>
    </template>
          <typedef name="day_of_week_type">
            <type>date_type::day_of_week_type</type>
          </typedef>
          <typedef name="month_type">
            <type>date_type::month_type</type>
          </typedef>
          <typedef name="start_rule_functor">
            <type><classname>date_time::last_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <typedef name="end_rule_functor">
            <type><classname>date_time::last_kday_of_month</classname>&lt; date_type &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="start_day" cv="">
              <type>day_of_week_type</type>
            </method>
            <method name="start_month" cv="">
              <type>month_type</type>
            </method>
            <method name="end_day" cv="">
              <type>day_of_week_type</type>
            </method>
            <method name="end_month" cv="">
              <type>month_type</type>
            </method>
            <method name="dst_start_offset_minutes" cv="">
              <type>int</type>
            </method>
            <method name="dst_end_offset_minutes" cv="">
              <type>int</type>
            </method>
            <method name="dst_shift_length_minutes" cv="">
              <type>int</type>
            </method>
          </method-group>
        </struct>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/locale_config.hpp"/>
  <header name="boost/date_time/microsec_time_clock.hpp">
    <para>This file contains a high resolution time clock implementation.</para>
    <namespace name="boost">
      <namespace name="date_time">
        <class name="microsec_clock">
          <template>
      <template-type-parameter name="time_type"/>
    </template>
          <purpose>
            <simpara>A clock providing microsecond level resolution. </simpara>
          </purpose>
          <description>
            <para>A high precision clock that measures the local time at a resolution up to microseconds and adjusts to the resolution of the time system. For example, for the a library configuration with nano second resolution, the last 3 places of the fractional seconds will always be 000 since there are 1000 nano-seconds in a micro second. </para>
          </description>
          <typedef name="date_type">
            <type>time_type::date_type</type>
          </typedef>
          <typedef name="time_duration_type">
            <type>time_type::time_duration_type</type>
          </typedef>
          <typedef name="resolution_traits_type">
            <type>time_duration_type::rep_type</type>
          </typedef>
          <method-group name="public static functions">
            <method name="local_time" cv="">
              <type>time_type</type>
              <purpose>
                <simpara>Return the local time based on computer clock settings. </simpara>
              </purpose>
            </method>
          </method-group>
          <method-group name="private static functions">
            <method name="create_time" cv="">
              <type>time_type</type>
              <parameter name="tv">
                <paramtype>timeval *</paramtype>
              </parameter>
            </method>
            <method name="local_time" cv="">
              <type>time_type</type>
              <purpose>
                <simpara>Return the local time based on computer clock settings. </simpara>
              </purpose>
            </method>
            <method name="create_time" cv="">
              <type>time_type</type>
              <parameter name="ft">
                <paramtype>FILETIME &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/parse_format_base.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <enum name="month_format_spec">
          <enumvalue name="month_as_integer"/>
          <enumvalue name="month_as_short_string"/>
          <enumvalue name="month_as_long_string"/>
          <purpose>
            <simpara>Enum for distinguishing parsing and formatting options. </simpara>
          </purpose>
        </enum>
        <enum name="ymd_order_spec">
          <enumvalue name="ymd_order_iso"/>
          <enumvalue name="ymd_order_dmy"/>
          <enumvalue name="ymd_order_us"/>
          <purpose>
            <simpara>Enum for distinguishing the order of Month, Day, &amp; Year. </simpara>
          </purpose>
          <description>
            <para>Enum for distinguishing the order in which Month, Day, &amp; Year will appear in a date string </para>
          </description>
        </enum>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/period.hpp">
    <para>This file contain the implementation of the period abstraction. This is basically the same idea as a range. Although this class is intended for use in the time library, it is pretty close to general enough for other numeric uses.</para>
    <namespace name="boost">
      <namespace name="date_time">
        <class name="period">
          <template>
      <template-type-parameter name="point_rep"/>
      <template-type-parameter name="duration_rep"/>
    </template>
          <purpose>
            <simpara>Provides generalized period type useful in date-time systems. </simpara>
          </purpose>
          <description>
            <para>This template uses a class to represent a time point within the period and another class to represent a duration. As a result, this class is not appropriate for use when the number and duration representation are the same (eg: in the regular number domain).</para>
            <para>A period can be specified by providing either the starting point and a duration or the starting point and the end point( end is NOT part of the period but 1 unit past it. A period will be "invalid" if either start_point &gt;= end_point or the given duration is &lt; 0. Any valid period will return false for is_null().</para>
            <para>Zero length periods are considered valid. In this case the start point is exactly 1 unit less than the end point, in other words start is equal to last.</para>
            <para>In the case that the begin and last are the same, the period has a length of zero units. For example, suppose this is a period of days. That is, each time-point represents a single day. If the start and the last is the same day then the period is zero length.</para>
            <para>The best way to handle periods is usually to provide a start point and a duration. So, day1 + 7 days is a week period which includes all of the first day and 6 more days (eg: Sun to Sat). </para>
          </description>
          <typedef name="point_type">
            <type>point_rep</type>
          </typedef>
          <typedef name="duration_type">
            <type>duration_rep</type>
          </typedef>
          <method-group name="public member functions">
            <method name="begin" cv="const">
              <type>point_rep</type>
              <purpose>
                <simpara>Return the first element in the period. </simpara>
              </purpose>
            </method>
            <method name="end" cv="const">
              <type>point_rep</type>
              <purpose>
                <simpara>Return one past the last element. </simpara>
              </purpose>
            </method>
            <method name="last" cv="const">
              <type>point_rep</type>
              <purpose>
                <simpara>Return the last item in the period. </simpara>
              </purpose>
            </method>
            <method name="length" cv="const">
              <type>duration_rep</type>
              <purpose>
                <simpara>Return the length of the period. </simpara>
              </purpose>
            </method>
            <method name="is_null" cv="const">
              <type>bool</type>
              <purpose>
                <simpara>True if period is ill formed (length less than zero). </simpara>
              </purpose>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>period</classname> &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Equality operator. </simpara>
              </purpose>
            </method>
            <method name="operator&lt;" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>period</classname> &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Strict as defined by rhs.last &lt;= lhs.last. </simpara>
              </purpose>
            </method>
            <method name="shift" cv="">
              <type>void</type>
              <parameter name="d">
                <paramtype>const duration_rep &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Shift the start and end by the specified amount. </simpara>
              </purpose>
            </method>
            <method name="contains" cv="const">
              <type>bool</type>
              <parameter name="point">
                <paramtype>const point_rep &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>True if the point is inside the period. </simpara>
              </purpose>
            </method>
            <method name="contains" cv="const">
              <type>bool</type>
              <parameter name="other">
                <paramtype>const <classname>period</classname> &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>True if this period fully contains (or equals) the other period. </simpara>
              </purpose>
            </method>
            <method name="intersects" cv="const">
              <type>bool</type>
              <parameter name="other">
                <paramtype>const <classname>period</classname> &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>True if the periods overlap in any way. </simpara>
              </purpose>
            </method>
            <method name="is_adjacent" cv="const">
              <type>bool</type>
              <parameter name="other">
                <paramtype>const <classname>period</classname> &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>True if periods are next to each other without a gap. </simpara>
              </purpose>
            </method>
            <method name="is_before" cv="const">
              <type>bool</type>
              <parameter name="point">
                <paramtype>const point_rep &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>True if all of the period is prior to the passed point or end &lt;= t. </simpara>
              </purpose>
            </method>
            <method name="is_after" cv="const">
              <type>bool</type>
              <parameter name="point">
                <paramtype>const point_rep &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>True if all of the period is prior or t &lt; start. </simpara>
              </purpose>
            </method>
            <method name="intersection" cv="const">
              <type>
                <classname>period</classname>
              </type>
              <parameter name="other">
                <paramtype>const <classname>period</classname> &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Returns the period of intersection or invalid range no intersection. </simpara>
              </purpose>
            </method>
            <method name="merge" cv="const">
              <type>
                <classname>period</classname>
              </type>
              <parameter name="other">
                <paramtype>const <classname>period</classname> &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Returns the union of intersecting periods -- or null period. </simpara>
              </purpose>
            </method>
            <method name="span" cv="const">
              <type>
                <classname>period</classname>
              </type>
              <parameter name="other">
                <paramtype>const <classname>period</classname> &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Combine two periods with earliest start and latest end. </simpara>
              </purpose>
              <description>
                <para>Combines two periods and any gap between them such that start = min(p1.start, p2.start) end = max(p1.end , p2.end) <programlisting>        [---p1---)
                       [---p2---)
 result:
        [-----------p3----------) 
   *
</programlisting></para>
              </description>
            </method>
          </method-group>
          <constructor>
            <parameter name="first_point">
              <paramtype>point_rep</paramtype>
            </parameter>
            <parameter name="end_point">
              <paramtype>point_rep</paramtype>
            </parameter>
            <purpose>
              <simpara>create a period from begin to last eg: [begin,end) </simpara>
            </purpose>
            <description>
              <para>If end &lt;= begin then the period will be invalid </para>
            </description>
          </constructor>
          <constructor>
            <parameter name="first_point">
              <paramtype>point_rep</paramtype>
            </parameter>
            <parameter name="len">
              <paramtype>duration_rep</paramtype>
            </parameter>
            <purpose>
              <simpara>create a period as [begin, begin+len) </simpara>
            </purpose>
            <description>
              <para>If len is &lt; 0 then the period will be invalid </para>
            </description>
          </constructor>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/special_defs.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <enum name="special_values">
          <enumvalue name="not_a_date_time"/>
          <enumvalue name="neg_infin"/>
          <enumvalue name="pos_infin"/>
          <enumvalue name="min_date_time"/>
          <enumvalue name="max_date_time"/>
          <enumvalue name="not_special"/>
          <enumvalue name="NumSpecialValues"/>
        </enum>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time.hpp">
    <para>This file contains the interface for the time associated classes.</para>
    <namespace name="boost">
      <namespace name="date_time">
        <class name="base_time">
          <template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="time_system"/>
    </template>
          <purpose>
            <simpara>Representation of a precise moment in time, including the date. </simpara>
          </purpose>
          <description>
            <para>This class is a skeleton for the interface of a temporal type with a resolution that is higher than a day. It is intended that this class be the base class and that the actual time class be derived using the BN pattern. In this way, the derived class can make decisions such as 'should there be a default constructor' and what should it set its value to, should there be optional constructors say allowing only an time_durations that generate a time from a clock,etc. So, in fact multiple time types can be created for a time_system with different construction policies, and all of them can perform basic operations by only writing a copy constructor. Finally, compiler errors are also shorter.</para>
            <para>The real behavior of the time class is provided by the time_system template parameter. This class must provide all the logic for addition, subtraction, as well as define all the interface types. </para>
          </description>
          <typedef name="time_type">
            <type>T</type>
          </typedef>
          <typedef name="time_rep_type">
            <type>time_system::time_rep_type</type>
          </typedef>
          <typedef name="date_type">
            <type>time_system::date_type</type>
          </typedef>
          <typedef name="date_duration_type">
            <type>time_system::date_duration_type</type>
          </typedef>
          <typedef name="time_duration_type">
            <type>time_system::time_duration_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="date" cv="const">
              <type>date_type</type>
            </method>
            <method name="time_of_day" cv="const">
              <type>time_duration_type</type>
            </method>
            <method name="zone_name" cv="const">
              <type>std::string</type>
            </method>
            <method name="is_not_a_date_time" cv="const">
              <type>bool</type>
              <purpose>
                <simpara>check to see if date is not a value </simpara>
              </purpose>
            </method>
            <method name="is_infinity" cv="const">
              <type>bool</type>
              <purpose>
                <simpara>check to see if date is one of the infinity values </simpara>
              </purpose>
            </method>
            <method name="is_pos_infinity" cv="const">
              <type>bool</type>
              <purpose>
                <simpara>check to see if date is greater than all possible dates </simpara>
              </purpose>
            </method>
            <method name="is_neg_infinity" cv="const">
              <type>bool</type>
              <purpose>
                <simpara>check to see if date is greater than all possible dates </simpara>
              </purpose>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Equality operator -- others generated by boost::equality_comparable. </simpara>
              </purpose>
            </method>
            <method name="operator&lt;" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Equality operator -- others generated by boost::less_than_comparable. </simpara>
              </purpose>
            </method>
            <method name="operator-" cv="const">
              <type>time_duration_type</type>
              <parameter name="rhs">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>difference between two times </simpara>
              </purpose>
            </method>
            <method name="operator+" cv="const">
              <type>time_type</type>
              <parameter name="dd">
                <paramtype>const date_duration_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>add date durations </simpara>
              </purpose>
            </method>
            <method name="operator+=" cv="">
              <type>time_type</type>
              <parameter name="dd">
                <paramtype>const date_duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-" cv="const">
              <type>time_type</type>
              <parameter name="dd">
                <paramtype>const date_duration_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>subtract date durations </simpara>
              </purpose>
            </method>
            <method name="operator-=" cv="">
              <type>time_type</type>
              <parameter name="dd">
                <paramtype>const date_duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator+" cv="const">
              <type>time_type</type>
              <parameter name="td">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>add time durations </simpara>
              </purpose>
            </method>
            <method name="operator+=" cv="">
              <type>time_type</type>
              <parameter name="td">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-" cv="const">
              <type>time_type</type>
              <parameter name="rhs">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>subtract time durations </simpara>
              </purpose>
            </method>
            <method name="operator-=" cv="">
              <type>time_type</type>
              <parameter name="td">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="day">
              <paramtype>const date_type &amp;</paramtype>
            </parameter>
            <parameter name="td">
              <paramtype>const time_duration_type &amp;</paramtype>
            </parameter>
            <parameter name="dst">
              <paramtype>dst_flags</paramtype>
              <default>not_dst</default>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="rhs">
              <paramtype>const time_rep_type &amp;</paramtype>
            </parameter>
          </constructor>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_clock.hpp">
    <para>This file contains the interface for clock devices.</para>
    <namespace name="boost">
      <namespace name="date_time">
        <class name="second_clock">
          <template>
      <template-type-parameter name="date_type"/>
      <template-type-parameter name="time_type"/>
    </template>
          <purpose>
            <simpara>A clock providing time level services based on C time_t capabilities. </simpara>
          </purpose>
          <description>
            <para>This clock provides resolution to the 1 second level </para>
          </description>
          <typedef name="time_duration_type">
            <type>time_type::time_duration_type</type>
          </typedef>
          <method-group name="public static functions">
            <method name="local_time" cv="">
              <type>time_type</type>
            </method>
            <method name="universal_time" cv="">
              <type>time_type</type>
              <purpose>
                <simpara>Get the current day in universal date as a ymd_type. </simpara>
              </purpose>
            </method>
          </method-group>
          <method-group name="private static functions">
            <method name="create_time" cv="">
              <type>time_type</type>
              <parameter name="current">
                <paramtype>::std::tm *</paramtype>
              </parameter>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_defs.hpp">
    <para>This file contains nice definitions for handling the resoluion of various time reprsentations.</para>
    <namespace name="boost">
      <namespace name="date_time">
        <enum name="time_resolutions">
          <enumvalue name="sec"/>
          <enumvalue name="tenth"/>
          <enumvalue name="hundreth"/>
          <enumvalue name="milli"/>
          <enumvalue name="ten_thousandth"/>
          <enumvalue name="micro"/>
          <enumvalue name="nano"/>
          <enumvalue name="NumResolutions"/>
          <purpose>
            <simpara>Defines some nice types for handling time level resolutions. </simpara>
          </purpose>
        </enum>
        <enum name="dst_flags">
          <enumvalue name="not_dst"/>
          <enumvalue name="is_dst"/>
          <enumvalue name="calculate"/>
          <purpose>
            <simpara>Flags for daylight savings or summer time. </simpara>
          </purpose>
        </enum>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_duration.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="time_duration">
          <template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="rep_type"/>
    </template>
          <purpose>
            <simpara>Represents some amount of elapsed time measure to a given resolution. </simpara>
          </purpose>
          <description>
            <para>This class represents a standard set of capabilities for all counted time durations. Time duration implementations should derive from this class passing their type as the first template parameter. This design allows the subclass duration types to provide custom construction policies or other custom features not provided here.</para>
            <para>
</para>
          </description>
          <typedef name="duration_type">
            <type>T</type>
          </typedef>
          <typedef name="traits_type">
            <type>rep_type</type>
          </typedef>
          <typedef name="day_type">
            <type>rep_type::day_type</type>
          </typedef>
          <typedef name="hour_type">
            <type>rep_type::hour_type</type>
          </typedef>
          <typedef name="min_type">
            <type>rep_type::min_type</type>
          </typedef>
          <typedef name="sec_type">
            <type>rep_type::sec_type</type>
          </typedef>
          <typedef name="fractional_seconds_type">
            <type>rep_type::fractional_seconds_type</type>
          </typedef>
          <typedef name="tick_type">
            <type>rep_type::tick_type</type>
          </typedef>
          <typedef name="impl_type">
            <type>rep_type::impl_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="hours" cv="const">
              <type>hour_type</type>
              <purpose>
                <simpara>Returns number of hours in the duration. </simpara>
              </purpose>
            </method>
            <method name="minutes" cv="const">
              <type>min_type</type>
              <purpose>
                <simpara>Returns normalized number of minutes. </simpara>
              </purpose>
            </method>
            <method name="seconds" cv="const">
              <type>sec_type</type>
              <purpose>
                <simpara>Returns normalized number of seconds (0..60). </simpara>
              </purpose>
            </method>
            <method name="total_seconds" cv="const">
              <type>sec_type</type>
              <purpose>
                <simpara>Returns total number of seconds truncating any fractional seconds. </simpara>
              </purpose>
            </method>
            <method name="total_milliseconds" cv="const">
              <type>tick_type</type>
              <purpose>
                <simpara>Returns total number of milliseconds truncating any fractional seconds. </simpara>
              </purpose>
            </method>
            <method name="total_nanoseconds" cv="const">
              <type>tick_type</type>
              <purpose>
                <simpara>Returns total number of nanoseconds truncating any sub millisecond values. </simpara>
              </purpose>
            </method>
            <method name="total_microseconds" cv="const">
              <type>tick_type</type>
              <purpose>
                <simpara>Returns total number of microseconds truncating any sub microsecond values. </simpara>
              </purpose>
            </method>
            <method name="fractional_seconds" cv="const">
              <type>fractional_seconds_type</type>
              <purpose>
                <simpara>Returns count of fractional seconds at given resolution. </simpara>
              </purpose>
            </method>
            <method name="invert_sign" cv="const">
              <type>duration_type</type>
            </method>
            <method name="is_negative" cv="const">
              <type>bool</type>
            </method>
            <method name="operator&lt;" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>time_duration</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator==" cv="const">
              <type>bool</type>
              <parameter name="rhs">
                <paramtype>const <classname>time_duration</classname> &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator-" cv="const">
              <type>duration_type</type>
              <purpose>
                <simpara>unary- Allows for time_duration td = -td1 </simpara>
              </purpose>
            </method>
            <method name="operator-" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator+" cv="const">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator/" cv="">
              <type>duration_type</type>
              <parameter name="divisor">
                <paramtype>int</paramtype>
              </parameter>
            </method>
            <method name="operator-=" cv="">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator+=" cv="">
              <type>duration_type</type>
              <parameter name="d">
                <paramtype>const duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator/=" cv="">
              <type>duration_type</type>
              <parameter name="divisor">
                <paramtype>int</paramtype>
              </parameter>
              <purpose>
                <simpara>Division operations on a duration with an integer. </simpara>
              </purpose>
            </method>
            <method name="operator *" cv="const">
              <type>duration_type</type>
              <parameter name="rhs">
                <paramtype>int</paramtype>
              </parameter>
              <purpose>
                <simpara>Multiplication operations an a duration with an integer. </simpara>
              </purpose>
            </method>
            <method name="operator *=" cv="">
              <type>duration_type</type>
              <parameter name="divisor">
                <paramtype>int</paramtype>
              </parameter>
            </method>
            <method name="ticks" cv="const">
              <type>tick_type</type>
            </method>
            <method name="is_special" cv="const">
              <type>bool</type>
              <purpose>
                <simpara>Is ticks_ a special value? </simpara>
              </purpose>
            </method>
            <method name="is_pos_infinity" cv="const">
              <type>bool</type>
              <purpose>
                <simpara>Is duration pos-infinity. </simpara>
              </purpose>
            </method>
            <method name="is_neg_infinity" cv="const">
              <type>bool</type>
              <purpose>
                <simpara>Is duration neg-infinity. </simpara>
              </purpose>
            </method>
            <method name="is_not_a_date_time" cv="const">
              <type>bool</type>
              <purpose>
                <simpara>Is duration not-a-date-time. </simpara>
              </purpose>
            </method>
            <method name="get_rep" cv="const">
              <type>impl_type</type>
              <purpose>
                <simpara>Used for special_values output. </simpara>
              </purpose>
            </method>
          </method-group>
          <constructor/>
          <constructor>
            <parameter name="hours">
              <paramtype>hour_type</paramtype>
            </parameter>
            <parameter name="minutes">
              <paramtype>min_type</paramtype>
            </parameter>
            <parameter name="seconds">
              <paramtype>sec_type</paramtype>
              <default>0</default>
            </parameter>
            <parameter name="frac_sec">
              <paramtype>fractional_seconds_type</paramtype>
              <default>0</default>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="other">
              <paramtype>const <classname>time_duration</classname>&lt; T, rep_type &gt; &amp;</paramtype>
            </parameter>
            <purpose>
              <simpara>Construct from another time_duration (Copy constructor). </simpara>
            </purpose>
          </constructor>
          <constructor>
            <parameter name="sv">
              <paramtype>special_values</paramtype>
            </parameter>
            <purpose>
              <simpara>Construct from special_values. </simpara>
            </purpose>
          </constructor>
          <method-group name="public static functions">
            <method name="unit" cv="">
              <type>duration_type</type>
              <purpose>
                <simpara>Returns smallest representable duration. </simpara>
              </purpose>
            </method>
            <method name="ticks_per_second" cv="">
              <type>tick_type</type>
              <purpose>
                <simpara>Return the number of ticks in a second. </simpara>
              </purpose>
            </method>
            <method name="resolution" cv="">
              <type>time_resolutions</type>
              <purpose>
                <simpara>Provide the resolution of this duration type. </simpara>
              </purpose>
            </method>
            <method name="num_fractional_digits" cv="">
              <type>unsigned short</type>
              <purpose>
                <simpara>Returns number of possible digits in fractional seconds. </simpara>
              </purpose>
            </method>
          </method-group>
          <method-group name="protected member functions"/>
          <constructor>
            <parameter name="in">
              <paramtype>impl_type</paramtype>
            </parameter>
          </constructor>
        </class>
        <class name="subsecond_duration">
          <template>
      <template-type-parameter name="base_duration"/>
      <template-nontype-parameter name="frac_of_second"><type>long</type></template-nontype-parameter>
    </template>
          <purpose>
            <simpara>Template for instantiating derived adjusting durations. </simpara>
          </purpose>
          <typedef name="traits_type">
            <type>base_duration::traits_type</type>
          </typedef>
          <method-group name="public member functions"/>
          <constructor>
            <parameter name="ss">
              <paramtype>long</paramtype>
            </parameter>
          </constructor>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_formatting_streams.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="ostream_time_duration_formatter">
          <template>
      <template-type-parameter name="time_duration_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>
            <simpara>Put a time type into a stream using appropriate facets. </simpara>
          </purpose>
          <typedef name="ostream_type">
            <type>std::basic_ostream&lt; charT &gt;</type>
          </typedef>
          <typedef name="fractional_seconds_type">
            <type>time_duration_type::fractional_seconds_type</type>
          </typedef>
          <method-group name="public static functions">
            <method name="duration_put" cv="">
              <type>void</type>
              <parameter name="td">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>ostream_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Put time into an ostream. </simpara>
              </purpose>
            </method>
          </method-group>
        </class>
        <class name="ostream_time_formatter">
          <template>
      <template-type-parameter name="time_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>
            <simpara>Put a time type into a stream using appropriate facets. </simpara>
          </purpose>
          <typedef name="ostream_type">
            <type>std::basic_ostream&lt; charT &gt;</type>
          </typedef>
          <typedef name="date_type">
            <type>time_type::date_type</type>
          </typedef>
          <typedef name="time_duration_type">
            <type>time_type::time_duration_type</type>
          </typedef>
          <typedef name="duration_formatter">
            <type><classname>ostream_time_duration_formatter</classname>&lt; time_duration_type, charT &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="time_put" cv="">
              <type>void</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>ostream_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Put time into an ostream. </simpara>
              </purpose>
            </method>
          </method-group>
        </class>
        <class name="ostream_time_period_formatter">
          <template>
      <template-type-parameter name="time_period_type"/>
      <template-type-parameter name="charT"><default>char</default></template-type-parameter>
    </template>
          <purpose>
            <simpara>Put a time period into a stream using appropriate facets. </simpara>
          </purpose>
          <typedef name="ostream_type">
            <type>std::basic_ostream&lt; charT &gt;</type>
          </typedef>
          <typedef name="time_type">
            <type>time_period_type::point_type</type>
          </typedef>
          <typedef name="time_formatter">
            <type><classname>ostream_time_formatter</classname>&lt; time_type, charT &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="period_put" cv="">
              <type>void</type>
              <parameter name="tp">
                <paramtype>const time_period_type &amp;</paramtype>
              </parameter>
              <parameter name="os">
                <paramtype>ostream_type &amp;</paramtype>
              </parameter>
              <purpose>
                <simpara>Put time into an ostream. </simpara>
              </purpose>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_iterator.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="time_itr">
          <template>
      <template-type-parameter name="time_type"/>
    </template>
          <purpose>
            <simpara>Simple time iterator skeleton class. </simpara>
          </purpose>
          <typedef name="time_duration_type">
            <type>time_type::time_duration_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="operator++" cv="">
              <type><classname>time_itr</classname> &amp;</type>
            </method>
            <method name="operator--" cv="">
              <type><classname>time_itr</classname> &amp;</type>
            </method>
            <method name="operator *" cv="">
              <type>time_type</type>
            </method>
            <method name="operator-&gt;" cv="">
              <type>time_type *</type>
            </method>
            <method name="operator&lt;" cv="">
              <type>bool</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&lt;=" cv="">
              <type>bool</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator!=" cv="">
              <type>bool</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator==" cv="">
              <type>bool</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&gt;" cv="">
              <type>bool</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="operator&gt;=" cv="">
              <type>bool</type>
              <parameter name="t">
                <paramtype>const time_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="t">
              <paramtype>time_type</paramtype>
            </parameter>
            <parameter name="d">
              <paramtype>time_duration_type</paramtype>
            </parameter>
          </constructor>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_parsing.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <function name="parse_delimited_time_duration">
          <type>
            <classname>time_duration</classname>
          </type>
          <template>
          <template-type-parameter name="time_duration"/>
        </template>
          <parameter name="s">
            <paramtype>const std::string &amp;</paramtype>
          </parameter>
          <purpose>
            <simpara>Creates a time_duration object from a delimited string. </simpara>
          </purpose>
          <description>
            <para>Expected format for string is "[-]h[h][:mm][:ss][.fff]". A negative duration will be created if the first character in string is a '-', all other '-' will be treated as delimiters. Accepted delimiters are "-:,.". </para>
          </description>
        </function>
        <function name="split">
          <type>bool</type>
          <parameter name="s">
            <paramtype>const std::string &amp;</paramtype>
          </parameter>
          <parameter name="sep">
            <paramtype>char</paramtype>
          </parameter>
          <parameter name="first">
            <paramtype>std::string &amp;</paramtype>
          </parameter>
          <parameter name="second">
            <paramtype>std::string &amp;</paramtype>
          </parameter>
          <purpose>
            <simpara>Utility function to split appart string. </simpara>
          </purpose>
        </function>
        <function name="parse_delimited_time">
          <type>time_type</type>
          <template>
          <template-type-parameter name="time_type"/>
        </template>
          <parameter name="s">
            <paramtype>const std::string &amp;</paramtype>
          </parameter>
          <parameter name="sep">
            <paramtype>char</paramtype>
          </parameter>
        </function>
        <function name="parse_undelimited_time_duration">
          <type>
            <classname>time_duration</classname>
          </type>
          <template>
          <template-type-parameter name="time_duration"/>
        </template>
          <parameter name="s">
            <paramtype>const std::string &amp;</paramtype>
          </parameter>
          <purpose>
            <simpara>Parse time duration part of an iso time of form: [-]hhmmss (eg: 120259 is 12 hours 2 min 59 seconds). </simpara>
          </purpose>
        </function>
        <function name="parse_iso_time">
          <type>time_type</type>
          <template>
          <template-type-parameter name="time_type"/>
        </template>
          <parameter name="s">
            <paramtype>const std::string &amp;</paramtype>
          </parameter>
          <parameter name="sep">
            <paramtype>char</paramtype>
          </parameter>
          <purpose>
            <simpara>Parse time string of form YYYYMMDDThhmmss where T is delimeter between date and time. </simpara>
          </purpose>
        </function>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_resolution_traits.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <struct name="time_resolution_traits_bi32_impl">
          <purpose>
            <simpara>traits struct for time_resolution_traits implementation type </simpara>
          </purpose>
          <typedef name="int_type">
            <type>boost::int32_t</type>
          </typedef>
          <typedef name="impl_type">
            <type>boost::int32_t</type>
          </typedef>
          <method-group name="public static functions">
            <method name="as_number" cv="">
              <type>int_type</type>
              <parameter name="i">
                <paramtype>impl_type</paramtype>
              </parameter>
            </method>
            <method name="is_adapted" cv="">
              <type>bool</type>
              <purpose>
                <simpara>Used to determine if implemented type is int_adapter or int. </simpara>
              </purpose>
            </method>
          </method-group>
        </struct>
        <struct name="time_resolution_traits_adapted32_impl">
          <purpose>
            <simpara>traits struct for time_resolution_traits implementation type </simpara>
          </purpose>
          <typedef name="int_type">
            <type>boost::int32_t</type>
          </typedef>
          <typedef name="impl_type">
            <type><classname>boost::date_time::int_adapter</classname>&lt; boost::int32_t &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="as_number" cv="">
              <type>int_type</type>
              <parameter name="i">
                <paramtype>
                  <classname>impl_type</classname>
                </paramtype>
              </parameter>
            </method>
            <method name="is_adapted" cv="">
              <type>bool</type>
              <purpose>
                <simpara>Used to determine if implemented type is int_adapter or int. </simpara>
              </purpose>
            </method>
          </method-group>
        </struct>
        <struct name="time_resolution_traits_bi64_impl">
          <purpose>
            <simpara>traits struct for time_resolution_traits implementation type </simpara>
          </purpose>
          <typedef name="int_type">
            <type>boost::int64_t</type>
          </typedef>
          <typedef name="impl_type">
            <type>boost::int64_t</type>
          </typedef>
          <method-group name="public static functions">
            <method name="as_number" cv="">
              <type>int_type</type>
              <parameter name="i">
                <paramtype>impl_type</paramtype>
              </parameter>
            </method>
            <method name="is_adapted" cv="">
              <type>bool</type>
              <purpose>
                <simpara>Used to determine if implemented type is int_adapter or int. </simpara>
              </purpose>
            </method>
          </method-group>
        </struct>
        <struct name="time_resolution_traits_adapted64_impl">
          <purpose>
            <simpara>traits struct for time_resolution_traits implementation type </simpara>
          </purpose>
          <typedef name="int_type">
            <type>boost::int64_t</type>
          </typedef>
          <typedef name="impl_type">
            <type><classname>boost::date_time::int_adapter</classname>&lt; boost::int64_t &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="as_number" cv="">
              <type>int_type</type>
              <parameter name="i">
                <paramtype>
                  <classname>impl_type</classname>
                </paramtype>
              </parameter>
            </method>
            <method name="is_adapted" cv="">
              <type>bool</type>
              <purpose>
                <simpara>Used to determine if implemented type is int_adapter or int. </simpara>
              </purpose>
            </method>
          </method-group>
        </struct>
        <class name="time_resolution_traits">
          <template>
      <template-type-parameter name="frac_sec_type"/>
      <template-nontype-parameter name="res"><type>time_resolutions</type></template-nontype-parameter>
      <template-nontype-parameter name="resolution_adjust"><type>#if(defined(BOOST_MSVC)&amp;&amp;(_MSC_VER&lt;=1200)) boost::int64_t</type></template-nontype-parameter>
      <template-nontype-parameter name="resolution_adjust"><type>#else typename frac_sec_type::int_type</type></template-nontype-parameter>
      <template-nontype-parameter name="frac_digits"><type>#endif unsigned short</type></template-nontype-parameter>
      <template-type-parameter name="v_type"><default>boost::int32_t</default></template-type-parameter>
    </template>
          <typedef name="fractional_seconds_type">
            <type>frac_sec_type::int_type</type>
          </typedef>
          <typedef name="tick_type">
            <type>frac_sec_type::int_type</type>
          </typedef>
          <typedef name="impl_type">
            <type>frac_sec_type::impl_type</type>
          </typedef>
          <typedef name="day_type">
            <type>v_type</type>
          </typedef>
          <typedef name="hour_type">
            <type>v_type</type>
          </typedef>
          <typedef name="min_type">
            <type>v_type</type>
          </typedef>
          <typedef name="sec_type">
            <type>v_type</type>
          </typedef>
          <method-group name="public member functions">
            <method name="BOOST_STATIC_CONSTANT" cv="">
              <type/>
              <parameter name="">
                <paramtype>int</paramtype>
              </parameter>
              <parameter name="">
                <paramtype>ticks_per_second</paramtype>
                <default>resolution_adjust</default>
              </parameter>
            </method>
          </method-group>
          <method-group name="public static functions">
            <method name="as_number" cv="">
              <type>frac_sec_type::int_type</type>
              <parameter name="i">
                <paramtype>typename frac_sec_type::impl_type</paramtype>
              </parameter>
            </method>
            <method name="is_adapted" cv="">
              <type>bool</type>
            </method>
            <method name="resolution" cv="">
              <type>time_resolutions</type>
            </method>
            <method name="num_fractional_digits" cv="">
              <type>unsigned short</type>
            </method>
            <method name="res_adjust" cv="">
              <type>fractional_seconds_type</type>
            </method>
            <method name="to_tick_count" cv="">
              <type>tick_type</type>
              <parameter name="hours">
                <paramtype>hour_type</paramtype>
              </parameter>
              <parameter name="minutes">
                <paramtype>min_type</paramtype>
              </parameter>
              <parameter name="seconds">
                <paramtype>sec_type</paramtype>
              </parameter>
              <parameter name="fs">
                <paramtype>fractional_seconds_type</paramtype>
              </parameter>
              <purpose>
                <simpara>Any negative argument results in a negative tick_count. </simpara>
              </purpose>
            </method>
          </method-group>
        </class>
        <typedef name="milli_res">
          <type>time_resolution_traits&lt; <classname>time_resolution_traits_adapted32_impl</classname>, milli, 1000, 3 &gt;</type>
        </typedef>
        <typedef name="micro_res">
          <type>time_resolution_traits&lt; <classname>time_resolution_traits_adapted64_impl</classname>, micro, 1000000, 6 &gt;</type>
        </typedef>
        <typedef name="nano_res">
          <type>time_resolution_traits&lt; <classname>time_resolution_traits_adapted64_impl</classname>, nano, 1000000000, 9 &gt;</type>
        </typedef>
        <function name="absolute_value">
          <type>T</type>
          <template>
          <template-type-parameter name="T"/>
        </template>
          <parameter name="x">
            <paramtype>T</paramtype>
          </parameter>
          <purpose>
            <simpara>Simple function to calculate absolute value of a numeric type. </simpara>
          </purpose>
        </function>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_system_counted.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <struct name="counted_time_rep">
          <template>
      <template-type-parameter name="config"/>
    </template>
          <purpose>
            <simpara>Time representation that uses a single integer count. </simpara>
          </purpose>
          <typedef name="int_type">
            <type>config::int_type</type>
          </typedef>
          <typedef name="date_type">
            <type>config::date_type</type>
          </typedef>
          <typedef name="impl_type">
            <type>config::impl_type</type>
          </typedef>
          <typedef name="date_duration_type">
            <type>date_type::duration_type</type>
          </typedef>
          <typedef name="calendar_type">
            <type>date_type::calendar_type</type>
          </typedef>
          <typedef name="ymd_type">
            <type>date_type::ymd_type</type>
          </typedef>
          <typedef name="time_duration_type">
            <type>config::time_duration_type</type>
          </typedef>
          <typedef name="resolution_traits">
            <type>config::resolution_traits</type>
          </typedef>
          <method-group name="public member functions">
            <method name="date" cv="const">
              <type>date_type</type>
            </method>
            <method name="day_count" cv="const">
              <type>int_type</type>
            </method>
            <method name="time_count" cv="const">
              <type>int_type</type>
            </method>
            <method name="tod" cv="const">
              <type>int_type</type>
            </method>
            <method name="is_pos_infinity" cv="const">
              <type>bool</type>
            </method>
            <method name="is_neg_infinity" cv="const">
              <type>bool</type>
            </method>
            <method name="is_not_a_date_time" cv="const">
              <type>bool</type>
            </method>
            <method name="is_special" cv="const">
              <type>bool</type>
            </method>
            <method name="get_rep" cv="const">
              <type>impl_type</type>
            </method>
          </method-group>
          <constructor>
            <parameter name="d">
              <paramtype>const date_type &amp;</paramtype>
            </parameter>
            <parameter name="tod">
              <paramtype>const time_duration_type &amp;</paramtype>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="count">
              <paramtype>int_type</paramtype>
            </parameter>
          </constructor>
          <constructor>
            <parameter name="count">
              <paramtype>impl_type</paramtype>
            </parameter>
          </constructor>
          <method-group name="public static functions">
            <method name="frac_sec_per_day" cv="">
              <type>int_type</type>
            </method>
          </method-group>
        </struct>
        <class name="counted_time_system">
          <template>
      <template-type-parameter name="time_rep"/>
    </template>
          <purpose>
            <simpara>An unadjusted time system implementation. </simpara>
          </purpose>
          <typedef name="time_rep_type">
            <type>time_rep</type>
          </typedef>
          <typedef name="impl_type">
            <type>time_rep_type::impl_type</type>
          </typedef>
          <typedef name="time_duration_type">
            <type>time_rep_type::time_duration_type</type>
          </typedef>
          <typedef name="fractional_seconds_type">
            <type>time_duration_type::fractional_seconds_type</type>
          </typedef>
          <typedef name="date_type">
            <type>time_rep_type::date_type</type>
          </typedef>
          <typedef name="date_duration_type">
            <type>time_rep_type::date_duration_type</type>
          </typedef>
          <method-group name="public static functions">
            <method name="unused_var" cv="">
              <type>void</type>
              <template>
          <template-type-parameter name="T"/>
        </template>
              <parameter name="">
                <paramtype>const T &amp;</paramtype>
              </parameter>
            </method>
            <method name="get_time_rep" cv="">
              <type>time_rep_type</type>
              <parameter name="day">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <parameter name="tod">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <parameter name="dst">
                <paramtype>date_time::dst_flags</paramtype>
                <default>not_dst</default>
              </parameter>
            </method>
            <method name="get_date" cv="">
              <type>date_type</type>
              <parameter name="val">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="get_time_of_day" cv="">
              <type>time_duration_type</type>
              <parameter name="val">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="zone_name" cv="">
              <type>std::string</type>
              <parameter name="">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="is_equal" cv="">
              <type>bool</type>
              <parameter name="lhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="rhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="is_less" cv="">
              <type>bool</type>
              <parameter name="lhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="rhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="add_days" cv="">
              <type>time_rep_type</type>
              <parameter name="base">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="dd">
                <paramtype>const date_duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="subtract_days" cv="">
              <type>time_rep_type</type>
              <parameter name="base">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="dd">
                <paramtype>const date_duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="subtract_time_duration" cv="">
              <type>time_rep_type</type>
              <parameter name="base">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="td">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="add_time_duration" cv="">
              <type>time_rep_type</type>
              <parameter name="base">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="td">
                <paramtype>time_duration_type</paramtype>
              </parameter>
            </method>
            <method name="subtract_times" cv="">
              <type>time_duration_type</type>
              <parameter name="lhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="rhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/time_system_split.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="split_timedate_system">
          <template>
      <template-type-parameter name="config"/>
      <template-nontype-parameter name="ticks_per_second"><type>boost::int32_t</type></template-nontype-parameter>
    </template>
          <purpose>
            <simpara>An unadjusted time system implementation. </simpara>
          </purpose>
          <typedef name="time_rep_type">
            <type>config::time_rep_type</type>
          </typedef>
          <typedef name="date_type">
            <type>config::date_type</type>
          </typedef>
          <typedef name="time_duration_type">
            <type>config::time_duration_type</type>
          </typedef>
          <typedef name="date_duration_type">
            <type>config::date_duration_type</type>
          </typedef>
          <typedef name="int_type">
            <type>config::int_type</type>
          </typedef>
          <typedef name="resolution_traits">
            <type>config::resolution_traits</type>
          </typedef>
          <typedef name="wrap_int_type">
            <type><classname>date_time::wrapping_int</classname>&lt; int_type, INT64_C(86400)*ticks_per_second</type>
          </typedef>
          <typedef name="wrap_int_type">
            <type><classname>date_time::wrapping_int</classname>&lt; int_type, ticks_per_day &gt;</type>
          </typedef>
          <method-group name="public static functions">
            <method name="get_time_rep" cv="">
              <type>time_rep_type</type>
              <parameter name="day">
                <paramtype>const date_type &amp;</paramtype>
              </parameter>
              <parameter name="tod">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
              <parameter name="dst">
                <paramtype>date_time::dst_flags</paramtype>
                <default>not_dst</default>
              </parameter>
            </method>
            <method name="get_date" cv="">
              <type>date_type</type>
              <parameter name="val">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="get_time_of_day" cv="">
              <type>time_duration_type</type>
              <parameter name="val">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="zone_name" cv="">
              <type>std::string</type>
              <parameter name="">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="is_equal" cv="">
              <type>bool</type>
              <parameter name="lhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="rhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="is_less" cv="">
              <type>bool</type>
              <parameter name="lhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="rhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="add_days" cv="">
              <type>time_rep_type</type>
              <parameter name="base">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="dd">
                <paramtype>const date_duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="subtract_days" cv="">
              <type>time_rep_type</type>
              <parameter name="base">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="dd">
                <paramtype>const date_duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="subtract_time_duration" cv="">
              <type>time_rep_type</type>
              <parameter name="base">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="td">
                <paramtype>const time_duration_type &amp;</paramtype>
              </parameter>
            </method>
            <method name="add_time_duration" cv="">
              <type>time_rep_type</type>
              <parameter name="base">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="td">
                <paramtype>time_duration_type</paramtype>
              </parameter>
            </method>
            <method name="subtract_times" cv="">
              <type>time_duration_type</type>
              <parameter name="lhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
              <parameter name="rhs">
                <paramtype>const time_rep_type &amp;</paramtype>
              </parameter>
            </method>
          </method-group>
          <method-group name="private member functions">
            <method name="BOOST_STATIC_CONSTANT" cv="">
              <type/>
              <parameter name="">
                <paramtype>int_type</paramtype>
              </parameter>
              <parameter name="">
                <paramtype>ticks_per_day</paramtype>
                <default>INT64_C(86400)*config::tick_per_second</default>
              </parameter>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/wrapping_int.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <class name="wrapping_int">
          <template>
      <template-type-parameter name="int_type_"/>
      <template-nontype-parameter name="wrap_val"><type>int_type_</type></template-nontype-parameter>
    </template>
          <purpose>
            <simpara>A wrapping integer used to support time durations. </simpara>
          </purpose>
          <description>
            <para>In composite date and time types this type is used to wrap at the day boundary. </para>
          </description>
          <typedef name="int_type">
            <type>int_type_</type>
          </typedef>
          <method-group name="public member functions">
            <method name="as_int" cv="const">
              <type>int_type</type>
              <purpose>
                <simpara>Explicit converion method. </simpara>
              </purpose>
            </method>
            <method name="conversion-operator" cv="const">
              <type>int_type</type>
            </method>
            <method name="add" cv="">
              <type>int_type</type>
              <parameter name="v">
                <paramtype>int_type</paramtype>
              </parameter>
            </method>
            <method name="subtract" cv="">
              <type>int_type</type>
              <parameter name="v">
                <paramtype>int_type</paramtype>
              </parameter>
            </method>
          </method-group>
          <constructor>
            <parameter name="v">
              <paramtype>int_type</paramtype>
            </parameter>
            <purpose>
              <simpara>Add, return true if wrapped. </simpara>
            </purpose>
          </constructor>
          <method-group name="public static functions">
            <method name="wrap_value" cv="">
              <type>int_type</type>
            </method>
          </method-group>
        </class>
        <class name="wrapping_int2">
          <template>
      <template-type-parameter name="int_type_"/>
      <template-nontype-parameter name="wrap_min"><type>int_type_</type></template-nontype-parameter>
      <template-nontype-parameter name="wrap_max"><type>int_type_</type></template-nontype-parameter>
    </template>
          <purpose>
            <simpara>A wrapping integer used to wrap around at the top. </simpara>
          </purpose>
          <description>
            <para>Bad name, quick impl to fix a bug -- fix later!! This allows the wrap to restart at a value other than 0. Currently this only works if wrap_min == 1 </para>
          </description>
          <typedef name="int_type">
            <type>int_type_</type>
          </typedef>
          <method-group name="public member functions">
            <method name="as_int" cv="const">
              <type>int_type</type>
              <purpose>
                <simpara>Explicit converion method. </simpara>
              </purpose>
            </method>
            <method name="conversion-operator" cv="const">
              <type>int_type</type>
            </method>
            <method name="add" cv="">
              <type>int_type</type>
              <parameter name="v">
                <paramtype>int_type</paramtype>
              </parameter>
              <purpose>
                <simpara>Add, return number of wraps performed. </simpara>
              </purpose>
            </method>
            <method name="subtract" cv="">
              <type>int_type</type>
              <parameter name="v">
                <paramtype>int_type</paramtype>
              </parameter>
              <purpose>
                <simpara>Subtract will return '-d' if wrapping took place ('d' is the number of wraps). </simpara>
              </purpose>
            </method>
          </method-group>
          <constructor>
            <parameter name="v">
              <paramtype>int_type</paramtype>
            </parameter>
            <description>
              <para>If initializing value is out of range of [wrap_min, wrap_max], value will be initialized to closest of min or max </para>
            </description>
          </constructor>
          <method-group name="public static functions">
            <method name="wrap_value" cv="">
              <type>unsigned long</type>
            </method>
            <method name="min_value" cv="">
              <type>unsigned long</type>
            </method>
          </method-group>
        </class>
      </namespace>
    </namespace>
  </header>
  <header name="boost/date_time/year_month_day.hpp">
    <namespace name="boost">
      <namespace name="date_time">
        <struct name="year_month_day_base">
          <template>
      <template-type-parameter name="YearType"/>
      <template-type-parameter name="MonthType"/>
      <template-type-parameter name="DayType"/>
    </template>
          <purpose>
            <simpara>Allow rapid creation of ymd triples of different types. </simpara>
          </purpose>
          <typedef name="year_type">
            <type>YearType</type>
          </typedef>
          <typedef name="month_type">
            <type>MonthType</type>
          </typedef>
          <typedef name="day_type">
            <type>DayType</type>
          </typedef>
          <method-group name="public member functions"/>
          <constructor>
            <parameter name="year">
              <paramtype>YearType</paramtype>
            </parameter>
            <parameter name="month">
              <paramtype>MonthType</paramtype>
            </parameter>
            <parameter name="day">
              <paramtype>DayType</paramtype>
            </parameter>
            <purpose>
              <simpara>A basic constructor. </simpara>
            </purpose>
          </constructor>
          <data-member name="year">
            <type>YearType</type>
          </data-member>
          <data-member name="month">
            <type>MonthType</type>
          </data-member>
          <data-member name="day">
            <type>DayType</type>
          </data-member>
        </struct>
      </namespace>
    </namespace>
  </header>
</section>
