<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE library PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN" 
"../../../tools/boostbook/dtd/boostbook.dtd">

<!-- Copyright (c) 2001-2005 CrystalClear Software, Inc.
     Subject to the Boost Software License, Version 1.0. 
     (See accompanying file LICENSE-1.0 or  http://www.boost.org/LICENSE-1.0)
-->

<section id="date_time.posix_time.ptime_class">
  <title>Ptime</title>

  <link linkend="ptime_intro">Introduction</link> --
  <link linkend="ptime_header">Header</link> --
  <link linkend="ptime_constr">Construction</link> --
  <link linkend="ptime_from_string">Construct from String</link> --
  <link linkend="ptime_from_clock">Construct from Clock</link> --
  <link linkend="ptime_from_funcs">Construct using Conversion functions</link> --
  <link linkend="ptime_accessors">Accessors</link> --
  <link linkend="ptime_to_string">Conversion To String</link> --
  <link linkend="ptime_operators">Operators</link>

  <anchor id="ptime_intro" />
  <bridgehead renderas="sect3">Introduction</bridgehead>
  <para>
    The class boost::posix_time::ptime is the primary interface for time point manipulation. In general, the ptime class is immutable once constructed although it does allow assignment. 
  </para>
  <para>
    Class ptime is dependent on <link linkend="date_time.gregorian.date_class">gregorian::date</link> for the interface to the date portion of a time point. 
  </para>
  <para>
    Other techniques for creating times include <link linkend="date_time.posix_time.time_iterators">time iterators</link>. 
  </para>

  <anchor id="ptime_header" />
  <bridgehead renderas="sect3">Header</bridgehead>
  <para>
    <programlisting>#include "boost/date_time/posix_time/posix_time.hpp" //include all types plus i/o
or
#include "boost/date_time/posix_time/posix_time_types.hpp" //no i/o just types</programlisting>
  </para>

  <anchor id="ptime_constr" />
  <bridgehead renderas="sect3">Construction</bridgehead>
  <para>
    <informaltable frame="all">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry valign="top" morerows="1">Syntax</entry>
	    <entry>Description</entry>
	  </row>
	  <row>
	    <entry>Example</entry>
	  </row>
	</thead>
	<tbody>
          <row>
	    <entry valign="top" morerows="1"><screen>ptime(date,time_duration)</screen></entry>
	    <entry>Construct from a date and offset</entry>
	  </row>
	  <row>
	    <entry><screen>ptime t1(date(2002,Jan,10), 
         time_duration(1,2,3));
ptime t2(date(2002,Jan,10), 
         hours(1)+nanosec(5));</screen>
	    </entry>
          </row>

	  <row>
	    <entry valign="top" morerows="1"><screen>ptime(ptime)</screen></entry>
	    <entry>Copy constructor</entry>
	  </row>
	  <row>
	    <entry><screen>ptime t3(t1)</screen></entry>
          </row>
          
	  <row>
	    <entry valign="top" morerows="1"><screen>ptime(special_values sv)</screen></entry>
	    <entry>Constructor for infinities, not-a-date-time, max_date_time, and min_date_time</entry>
	  </row>
	  <row>
	    <entry><screen>ptime d1(neg_infin);
ptime d2(pos_infin);
ptime d3(not_a_date_time);
ptime d4(max_date_time);
ptime d5(min_date_time);</screen></entry>
          </row>
          
          <row>
	    <entry valign="top" morerows="1"><screen>ptime;</screen></entry>
	    <entry>Default constructor. Creates a ptime object initialized to not_a_date_time. NOTE: this constructor can be disabled by defining DATE_TIME_NO_DEFAULT_CONSTRUCTOR (see compiler_config.hpp)</entry>
	  </row>
	  <row>
	    <entry><screen>ptime p; // p =&gt; not_a_date_time</screen></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
  </para>


  <anchor id="ptime_from_string" />
  <bridgehead renderas="sect3">Construct from String</bridgehead>
  <para>
    <informaltable frame="all">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry valign="top" morerows="1">Syntax</entry>
	    <entry>Description</entry>
	  </row>
	  <row>
	    <entry>Example</entry>
	  </row>
	</thead>
	<tbody>
          <row>
	    <entry valign="top" morerows="1"><screen>ptime time_from_string(std::string)</screen></entry>
            <entry>From delimited string. NOTE: Excess digits in fractional seconds will be dropped. Ex: "1:02:03.123456999" =&gt; 1:02:03.123456. This behavior is affected by the precision the library is compiled with (see <link linkend="date_time.buildinfo">Build-Compiler Information</link>.</entry>
	  </row>
	  <row>
	    <entry><screen>std::string ts("2002-01-20 23:59:59.000");
ptime t(time_from_string(ts))</screen></entry>
          </row>

	  <row>
	    <entry valign="top" morerows="1"><screen>ptime from_iso_string(std::string)</screen></entry>
	    <entry>From non delimited iso form string.</entry>
	  </row>
          <row>
	    <entry><screen>std::string ts("20020131T235959");
ptime t(from_iso_string(ts))</screen></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
  </para>


  <anchor id="ptime_from_clock" />
  <bridgehead renderas="sect3">Construct from Clock</bridgehead>
  <para>
    <informaltable frame="all">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry valign="top" morerows="1">Syntax</entry>
	    <entry>Description</entry>
	  </row>
	  <row>
	    <entry>Example</entry>
	  </row>
	</thead>
	<tbody>
          <row>
	    <entry valign="top" morerows="1"><screen>ptime second_clock::local_time()</screen></entry>
	    <entry>Get the local time, second level resolution, based on the time zone settings of the computer.</entry>
	  </row>
	  <row>
	    <entry><screen>ptime t(second_clock::local_time());</screen></entry>
          </row>

	  <row>
	    <entry valign="top" morerows="1"><screen>ptime second_clock::universal_time()</screen></entry>
	    <entry>Get the UTC time.</entry>
	  </row>
	  <row>
	    <entry><screen>ptime t(second_clock::universal_time())</screen></entry>
          </row>
          
          <row>
	    <entry valign="top" morerows="1"><screen>ptime microsec_clock::local_time()</screen></entry>
	    <entry>Get the local time using a subsecond resolution clock.  On Unix systems this is implemented using GetTimeOfDay.  On most Win32 platforms it is implemented using ftime.  Win32 systems often do not achieve microsecond resolution via this API.  If higher resolution is critical to your application test your platform to see the acheived resolution.</entry>
	  </row>
	  <row>
	    <entry><screen>ptime t(microsec_clock::local_time());</screen></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
  </para>


  <anchor id="ptime_from_funcs" />
  <bridgehead renderas="sect3">Construct using Conversion Functions</bridgehead>
  <para>
    <informaltable frame="all">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry valign="top" morerows="1">Syntax</entry>
	    <entry>Description</entry>
	  </row>
	  <row>
	    <entry>Example</entry>
	  </row>
	</thead>
	<tbody>
          <row>
	    <entry valign="top" morerows="1"><screen>ptime from_time_t(time_t t);</screen></entry>
	    <entry>Converts a time_t into a ptime.</entry>
	  </row>
	  <row>
	    <entry><screen>ptime t = from_time_t(tt);</screen></entry>
          </row>

          <row>
            <entry valign="top" morerows="1"><screen>ptime from_ftime&lt;ptime&gt;(FILETIME ft);</screen></entry>
            <entry>Creates a ptime object from a FILETIME structure.</entry>
	  </row>
	  <row>
            <entry><screen>ptime t = from_ftime&lt;ptime&gt;(ft);</screen></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
  </para>


  <anchor id="ptime_accessors" />
  <bridgehead renderas="sect3">Accessors</bridgehead>
  <para>
    <informaltable frame="all">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry valign="top" morerows="1">Syntax</entry>
	    <entry>Description</entry>
	  </row>
	  <row>
	    <entry>Example</entry>
	  </row>
	</thead>
	<tbody>
          <row>
	    <entry valign="top" morerows="1"><screen>date date()</screen></entry>
	    <entry>Get the date part of a time.</entry>
	  </row>
	  <row>
	    <entry><screen>date d(2002,Jan,10);
ptime t(d, hour(1));
t.date() --> 2002-Jan-10;</screen>
	    </entry>
          </row>

	  <row>
	    <entry valign="top" morerows="1"><screen>time_duration time_of_day()</screen></entry>
	    <entry>Get the time offset in the day.</entry>
	  </row>
	  <row>
	    <entry><screen>date d(2002,Jan,10);
ptime t(d, hour(1));
t.time_of_day() --> 01:00:00;</screen>
	    </entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
  </para>


  <anchor id="ptime_to_string" />
  <bridgehead renderas="sect3">Conversion to String</bridgehead>
  <para>
    <informaltable frame="all">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry valign="top" morerows="1">Syntax</entry>
	    <entry>Description</entry>
	  </row>
	  <row>
	    <entry>Example</entry>
	  </row>
	</thead>
	<tbody>
          <row>
	    <entry valign="top" morerows="1"><screen>std::string to_simple_string(ptime)</screen></entry>
            <entry>To <code>YYYY-mmm-DD HH:MM:SS.fffffffff</code> string where <code>mmm</code> 3 char month name. Fractional seconds only included if non-zero.</entry>
	  </row>
	  <row>
	    <entry><screen>2002-Jan-01 10:00:01.123456789</screen></entry>
          </row>

	  <row>
	    <entry valign="top" morerows="1"><screen>std::string to_iso_string(ptime)</screen></entry>
            <entry>Convert to form <code>YYYYMMDDTHHMMSS,fffffffff</code> where <code>T</code> is the date-time separator</entry>
	  </row>
	  <row>
	    <entry><screen>20020131T100001,123456789</screen></entry>
          </row>
          
          <row>
	    <entry valign="top" morerows="1"><screen>std::string to_iso_extended_string(ptime)</screen></entry>
            <entry>Convert to form <code>YYYY-MM-DDTHH:MM:SS,fffffffff</code> where <code>T</code> is the date-time separator</entry>
	  </row>
	  <row>
	    <entry><screen>2002-01-31T10:00:01,123456789</screen></entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
  </para>


  <anchor id="ptime_operators" />
  <bridgehead renderas="sect3">Operators</bridgehead>
  <para>
    <informaltable frame="all">
      <tgroup cols="2">
	<thead>
	  <row>
	    <entry valign="top" morerows="1">Syntax</entry>
	    <entry>Description</entry>
	  </row>
	  <row>
	    <entry>Example</entry>
	  </row>
	</thead>
	<tbody>
          <row>
	    <entry valign="top" morerows="1"><screen>operator==, operator!=,
operator>, operator&lt;,
operator>=, operator&lt;=</screen>
	    </entry>
	    <entry>A full complement of comparison operators</entry>
	  </row>
	  <row>
	    <entry><screen>t1 == t2, etc</screen></entry>
          </row>

	  <row>
	    <entry valign="top" morerows="1"><screen>ptime operator+(date_duration)</screen></entry>
	    <entry>Return a ptime adding a day offset</entry>
	  </row>
	  <row>
	    <entry><screen>date d(2002,Jan,1);
ptime t(d,minutes(5));
date_duration dd(1);
ptime t2 = t + dd;</screen>
	    </entry>
          </row>
          
	  <row>
	    <entry valign="top" morerows="1"><screen>ptime operator-(date_duration)</screen></entry>
	    <entry>Return a ptime subtracting a day offset</entry>
	  </row>
	  <row>
	    <entry><screen>date d(2002,Jan,1);
ptime t(d,minutes(5));
date_duration dd(1);
ptime t2 = t - dd;</screen>
	    </entry>
          </row>
          
	  <row>
	    <entry valign="top" morerows="1"><screen>ptime operator+(time_duration)</screen></entry>
	    <entry>Return a ptime adding a time duration</entry>
	  </row>
	  <row>
	    <entry><screen>date d(2002,Jan,1);
ptime t(d,minutes(5));
ptime t2 = t + hours(1) + minutes(2);</screen>
	    </entry>
          </row>
          
	  <row>
	    <entry valign="top" morerows="1"><screen>ptime operator-(time_duration)</screen></entry>
	    <entry>Return a ptime subtracting a time duration</entry>
	  </row>
	  <row>
	    <entry><screen>date d(2002,Jan,1);
ptime t(d,minutes(5));
ptime t2 = t - minutes(2);</screen>
	    </entry>
          </row>
          
          <row>
	    <entry valign="top" morerows="1"><screen>time_duration operator-(ptime)</screen></entry>
	    <entry>Take the difference between two times.</entry>
	  </row>
	  <row>
	    <entry><screen>date d(2002,Jan,1);
ptime t1(d,minutes(5));
ptime t2(d,seconds(5));
time_duration t3 = t2 - t1;//negative result</screen>
	    </entry>
	  </row>
	</tbody>
      </tgroup>
    </informaltable>
  </para>

</section>
