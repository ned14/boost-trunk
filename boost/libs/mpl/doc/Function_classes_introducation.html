<!doctype html public "-//ietf//dtd html//en">
<html><head><title>boost::mpl::Function classes introducation</title>
<link rel="stylesheet" href="./mpl_wiki.css">
</head><body bgcolor="white">
<h1><a href="./Table_of_Content.html"><img src="./mpl_logo.jpg" alt="[Home]" border=0 align="right"></a>Function classes introducation</h1><h3>(raw)
</h3>
<p>
A <em>metafunction</em> is a compile-time entity of a certain structure that represents a function invocable at compile-time. In C++, the basic underlying language construct of any model of metafunction concept is a <em>class template</em> (14.5.1 [temp.class]): it can take types and/or non-type arguments as actual template parameters and "return" types or non-type values through its nested type/static const data members declarations. Obviously, a bare class template is the simplest possible model of the concept:
<p>
<pre>
<span class="cxx-comment">// 'plus' metafunction</span>
template&lt;long N1, long N2&gt;
struct plus
{
    static long const value = N1 + N2;
};
<p>
<span class="cxx-comment">// metafunction "invocation"</span>
long const sum = plus&lt;5, 10&gt;::value;
</pre>
<p>
Of course, the above example is not very interesting, because one might as well write: 
<p>
<pre>
long const sum = 5 + 10;
</pre>
<p>
but, as you might expect, not all class template metafunctions are as trivial as the above <code>plus</code> class - see, for example, <a href="http:://www.boost.org/libs/type_traits/index.htm">[boost::type_traits]</a> library. In any case, for all their simplicity, the class templates like <code>plus</code> have one important property that makes their existence worthwhile - by encapsulating an operation into compile-time invocable entity (metafunction), they give you a possibility to defer its execution. You can store the entity, pass it around, and invoke the operation at any time you need:
<p>
<pre>
<span class="cxx-comment">// recursive 'accumulate' algortihm parametrized by BinaryOperation</span>
<span class="cxx-comment">// class template meta-function</span>
template&lt; typename ValueSequence
        , template&lt;long, long&gt; class BinaryFunction
        , long InitialValue
        &gt;
struct accumulate
{
    static long const value = accumulate&lt;
          typename mpl::pop_front<a href="./action=edit&id=pop_front.html">?</a>&lt;ValueSequence&gt;::sequence
        , BinaryFunction
        , BinaryFunction&lt;
                  mpl::front<a href="./action=edit&id=front.html">?</a>&lt;ValueSequence&gt;::value
                , InitialValue
                &gt;::value
        &gt;::value;
};
<p>
<span class="cxx-comment">// using the algorithm together with the 'plus' meta-function</span>
typedef mpl::value_list<a href="./action=edit&id=value_list.html">?</a>&lt;2, 5, 1, 7&gt; values;
long const sum = accumulate&lt;values, plus, 0&gt;::value; <span class="cxx-comment">// value == 15</span>
</pre>
<p>
[to be continiued]
<p><hr>
<a href="./Table_of_Content.html">Table of Content</a><br>Last edited December 23, 2001 2:05 pm</body></html>