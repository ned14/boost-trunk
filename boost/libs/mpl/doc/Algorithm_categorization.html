<!doctype html public "-//ietf//dtd html//en">
<html><head><title>boost::mpl::Algorithm categorization</title>
<link rel="stylesheet" href="./mpl_wiki.css">
</head><body bgcolor="white">
<h1><a href="./Table_of_Content.html"><img src="./mpl_logo.jpg" alt="[Home]" border=0 align="right"></a>Algorithm categorization</h1><h3>(from correspondence, very raw)
</h3>
<p>
All <code>boost::mpl</code> algorithms can be classified into two categories:
<p>
1. Basic, sequence-specific algorithms, such as <code>begin/end</code>, <code>push_front/push_back</code>, <code>pop_front/pop_back</code>, <code>clear</code>, etc.; implementation of these algorithms is determined by the underlying structure of the sequence they are applied to; dispatching to a particular implementation of every such algorithm for a particular kind of sequence is done by introducing an additional level of indirection, a specific for the algorithm <code>algorithm_traits</code> class template, and using the <code>sequence_traits&lt;&gt;::sequence_category</code> tag to choose the appropriate specialization of this template for the concrete <code>sequence_category</code> tag; an alternative approach would to use partial specialization, something like
<p>
<pre>
template&lt;typename T1, typename T2&gt;
struct push_back&lt; type_pair&lt;T1, T2&gt; &gt;
{
    <span class="cxx-comment">//</span>...
};
</pre>
<p>
but it turned out that this is not a very viable option here, because
<ul>
<li>it's partial specialization
<li>it would require to turn all sequence classes into type generators, i.e. one would have to write <code>type_list&lt;int, long, char&gt;::type</code> instead of plain <code>type_list&lt;int, long, char&gt;</code>, and
<li>it might prevent use of simple classes like <code>type_pair</code> for building different kinds of sequences.
</ul>
<p>
2. Generic sequence algorithms, such as <code>for_each</code>, <code>find</code>, <code>copy</code>, etc., that are implemented in terms of iterators and basic sequence algorithms like <code>push_back</code> and <code>clear</code>. 
<p>
<p>
Now, if you look at implementation of type_list basic sequence algorithms (e.g. mpl/list/push_back.hpp), you will see that they, in turn, are generalized to the extent that, given appropriate specialization of <code>list_traits&lt;&gt;</code> class template, they should work on any recursive compile-time sequence. <code>list_traits&lt;&gt;::is_null&lt;&gt;</code> is more or less equivalent to the Loki's "termination type". But it shouldn't be needed for anything besides type_list's core sequence-dependent algorithms. 
<p>
There might be different kinds of sequences, and having <em>OutputSequence</em> parameter allows you to transform (or copy) one of them into another, e.g.
<p>
<pre>
<p>
template&lt;typename T&gt;
struct make_array
{
    template&lt;class N&gt; struct apply
    {
    typedef T type[N::value];
    };
};
<p>
typedef mpl::transform<a href="./action=edit&id=transform.html">?</a>&lt;
      mpl::value_range<a href="./action=edit&id=value_range.html">?</a>&lt;0, 10&gt;
    , mpl::type_list<a href="./action=edit&id=type_list.html">?</a>&lt;&gt;
    , make_array&lt;int&gt;
    &gt;::sequence result;
</pre>
<p>
will give you a <code>type_list</code> of <code>int[0]</code>, <code>int[2]</code>, .., <code>int[9]</code>. 
<p><hr>
<a href="./Table_of_Content.html">Table of Content</a><br>Last edited December 23, 2001 2:03 pm</body></html>