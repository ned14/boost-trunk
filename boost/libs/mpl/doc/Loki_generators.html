<!doctype html public "-//ietf//dtd html//en">
<html><head><title>boost::mpl::Loki generators</title>
<link rel="stylesheet" href="./mpl_wiki.css">
</head><body bgcolor="white">
<h1><a href="./Table_of_Content.html"><img src="./mpl_logo.jpg" alt="[Home]" border=0 align="right"></a>Loki generators</h1><h2>1. Introduction
</h2>
<p>
There has been a fair amount of general philosophical discussion
lately about Loki and MPL. I think we might benefit by examining more
concrete use cases to get a better feel for what is offered. To
continue in this direction, today I will report on some recent
experiences using MPL. I have been spending my spare cycles over the
last week or so trying to figure out some of MPL's key mechanisms. In
a recent article I reported on implementing Loki's HierarchyGenerators
to work with MSVC (see
  <a href="http://groups.yahoo.com/group/boost/message/20944">http://groups.yahoo.com/group/boost/message/20944</a> ).
In this article I will implement HierarchyGenerators using MPL. Along
the way I hope to:
<p>
<ul>
<li>Further our review of typelists by offering a concrete usage example with a possible move towards AbstractFactory
<li>Provide a tutorial on using boost::mpl
<li>Offer a partial review of boost::mpl
<li>Begin a port of Loki's HierarchyGenerators to MSVC
</ul>
<p>
If I manage to work out some additional VC bugs I can post an MPL
version of HierarchyGenerators to the files section.
<p>
Note: this article represents my own attempt to understand
MPL. Aleksey, please correct me where I'm mistaken. Also, it's late at
night and I'm sure there are plenty of mistakes below...
<p>
<p>
<h2>2. GenLinearHierarchy
</h2>
<p>
<h3>2.1 GenLinHierarchy Specification
</h3>
<p>
GenLinearHierarchy accepts three inputs: a list of types, a "glue
metafunction", and an optional root class. In return
GenLinearHierarchy&lt;TList, Glue, Root&gt;::type generates a linear
hierarchy which is best described by the following example picture.
Lets look at:
<pre>
  GenLinearHierarchy&lt;
type_list&lt;Window, Button, ScrollBar&gt;, EventHandler, EmptyType&gt;::type
</pre>
In this example is EmptyType is just a struct with no members, and
EventHandler&lt;T,...&gt; provides one virtual function which OnEvent. That
is:
<pre>
  struct EmptyType {};
<p>
  template &lt;class T, class Base&gt;
struct EventHander : public Base
  {
    virtual void OnEvent(T&amp; obj, int eventID) = 0;
  };
<p>
Then GenLinearHierarchy will give us:
<p>
<p>
  EmptyType
     ^
     |
     |
  EventHander&lt;Window, EmptyType&gt;
     ^
<p>
     |
<p>
     |
  EventHandler&lt;Button, EventHander&lt;Window, EmptyType&gt; &gt;
     ^
     |
     |
  EventHandler&lt;ScrollBar, EventHandler&lt;Button,
                EventHander&lt;Window, EmptyType&gt; &gt; &gt;
     ^
     |
     |
  GenLinearHierarchy&lt;type_list&lt;Window, Button, ScrollBar&gt;,
                           EventHandlerQuoted,
                           EmptyType&gt; &gt;::type
</pre>
<h3>2.2 GenlinearHierarchy MPL implementation
</h3>
<p>
<p>
The implementation in MPL is a one-liner.
<pre>
  template &lt;class TList, class Glue, class Root = EmptyType&gt;
struct GenLinearHierarchy {
    typedef for_each<a href="./action=edit&id=for_each.html">?</a>&lt;TList, Root, Glue&gt;::state type;
  };
</pre>
Client code will look like this:
<pre>
  template &lt;class T, class Base&gt;
struct EventHander : public Base
  {
    virtual void OnEvent(T&amp; obj, int eventID) = 0;
  };
<p>
  BOOST_MPL_MAKE_F_YX_TMPL(EventHandlerQuoted, EventHandler);
<p>
<p>
  GenLinearHierarchy&lt;type_list&lt;Window, Button, ScrollBar&gt;,
               EventHandlerQuoted,
               EmptyType&gt; &gt;::type v;
<p>
</pre>
This example requires some explanation. First let's examine
for_each. For_each behaves somewhat like std::accumulate. In fact,
"reduce" might be a better name for it. For_each accepts a type_list,
an initial state, and a binary "quoted metafunction". First, for_each
applies the "quoted metafunction" to the initial state and the first
element of the type-list to obtain the next state2. Then for_each
applies the "quoted metafunction" to state2 and the second type_list
element to obtain state3, and so on. For_each returns the final state
as a nested typedef named "state".
<p>
But what is a "quoted metafunction"?  Well, all MPL algorithms expect
any of their arguments which happen to be metafunctions to be wrapped
up in a struct. This technique is described in Czarnecki and
Eisenecker's Generative Programming Book as an alternative to using
template template parameters. I find it very helpful to think of these
struct-wrapped metafunctions as "quoted". (Here I borrow the #'
concept from common lisp. In common lisp, functions must be #' quoted
to be passed as parameters to other functions. Another alternative
would be to talk about the address of a metafunction but that seems
more confusing. Perhaps someone will come up with a better name). A
quoted metafunction is eval-ed (applied) by calling its nested apply
template. An example will probably help here:
<p>
Plain old template, EventHandler:
<p>
<pre>
  template &lt;class T, class Base&gt;
struct EventHander : public Base
  {
    virtual void OnEvent(T&amp; obj, int eventID) = 0;
  };
<p>
Metafunction, EventHandlerMF, returning EventHandler:
<p>
  template &lt;class T, class Base&gt;
struct EventHanderMF
  {
    typedef EventHadler&lt;T, Base&gt; type;
  };
<p>
Quoted Metafunction, EventHandlerQuoted, for use with MPL algorithms:
<p>
  struct EventHandlerQuoted {
    template&lt;typename T, typename Base&gt;
struct apply {
     typedef EventHandler&lt;T, Base&gt; type;
    };
  };
</pre>
MPL provides some convenience macros for creating "quoted
metafunctions" from normal metafunctions. So instead of writing
EventHandlerQuoted by hand as above we can simply write:
<p>
  BOOST_MPL_MAKE_F_XY(EventHandlerQuoted, EventHandlerMF);
<p>
Sometimes it is convenient to create a quoted metafunction directly
from a template so I added another macro to do so:
<p>
  =BOOST_MPL_MAKE_F_XY_TMPL(EventHandlerQuoted, EventHandler);=
<p>
There are also X (one argument) and YX (reverse arguments)
versions. MPL also provides unary_function and binary_function that,
amongst other things, can be viewed as a way to create a metafunction
from a quoted metafunction.  To summarize, the following types are
equivalent
<p>
<pre>
  ::binary_function<a href="./action=edit&id=binary_function.html">?</a>&lt;EventHandlerQuoted, T, Base&gt;::type
<p>
  EventhandlerQuoted::template apply&lt;T, Base&gt;::type
<p>
  EventHandlerMF&lt;T,Base&gt;::type
<p>
  EventHandler&lt;T,Base&gt;
</pre>
<p>
It is worth noting that the first form can fare better with VC 6/7
then the second form above. (See my previous article
  &lt;<a href="http://groups.yahoo.com/group/boost/message/20944&gt">http://groups.yahoo.com/group/boost/message/20944&gt</a>;
for more details.)
<p>
<h2>3. GenScatterHierarchy
</h2>
<p>
<h3>3.1 GenScatterHierarchy Specification
</h3>
<p>
Like GenLinearHierarchy, GenScatterHierarchy generates a class with
interesting ancestors. In this case however we use multiple
inheritance to create a tree of ancestors. Let's examine the class
diagram for GenScatterHierarchy&lt;type_list&lt;char, short, int&gt;,
HolderQuoted&gt; &gt; :
<p>
<pre>
    <span class="cxx-comment">// Node is an apply-based metafunction which will produce a node</span>
    <span class="cxx-comment">// which inherits from its second argument and HolderQuoted applied to its</span>
    <span class="cxx-comment">// first argument.</span>
    <span class="cxx-comment">//</span>
    <span class="cxx-comment">// HolderQuoted&lt;char&gt;          EmptyType</span>
    <span class="cxx-comment">//                  \               /</span>
    <span class="cxx-comment">//                   \             /</span>
    <span class="cxx-comment">//   HolderQuoted&lt;short&gt;          *</span>
    <span class="cxx-comment">//                     \         /</span>
    <span class="cxx-comment">//                      \       /</span>
    <span class="cxx-comment">//       HolderQuoted&lt;long&gt;    *</span>
    <span class="cxx-comment">//                        \   /</span>
    <span class="cxx-comment">//                         \ /</span>
    <span class="cxx-comment">//                          *</span>
    <span class="cxx-comment">//                         /</span>
    <span class="cxx-comment">//                        /</span>
    <span class="cxx-comment">//          GenScatterHierarchy</span>
    <span class="cxx-comment">//</span>
    <span class="cxx-comment">//                     * = implementation class: name ommitted</span>
<p>
</pre>
Note that Loki uses a slightly different tree.
<p>
<p>
<h3>3.2 MPL GenScatterHierarchy Implementation
</h3>
<p>
<pre>
<span class="cxx-comment">// First we declare some building block templates and metafunctions:</span>
  template &lt;class L, class R&gt;
struct InheritTwo : public  L , public R
  {
    typedef L Left;
    typedef R Right;
  };
<p>
  template &lt;class ScatterHier&gt;
struct LeftParent
  {
    typedef typename ScatterHier::Left type;
  };
<p>
  template &lt;class ScatterHier&gt;
struct RightParent
  {
    typedef typename ScatterHier::Right type;
  };
<p>
  BOOST_MPL_MAKE_F_X(LeftParentQuoted, LeftParent);
  BOOST_MPL_MAKE_F_X(RightParentQuoted, RightParent);
  BOOST_MPL_MAKE_F_YX_TMPL(ReverseInheritTwoQuoted, InheritTwo);
<p>
<span class="cxx-comment">// Now we can define GenScatterHierarchy</span>
<p>
  template &lt;class TList, class QuotedMF&gt;
struct GenScatterHierarchy {
<p>
  public:
    typedef for_each<a href="./action=edit&id=for_each.html">?</a>&lt;
TList      <span class="cxx-comment">// for each type in TList</span>
     , EmptyType   <span class="cxx-comment">// begin with state EmptyType</span>
     , compose_f_gx_hy<a href="./action=edit&id=compose_f_gx_hy.html">?</a>&lt;
ReverseInheritTwoQuoted
      , identity<a href="./action=edit&id=identity.html">?</a>&lt;_1<a href="./action=edit&id=1.html">?</a>&gt;
, QuotedMF&gt;
<span class="cxx-comment">// apply binary metafunctor mapping &lt;oldState, aType&gt;</span>
<span class="cxx-comment">// to InheritTwo&lt;unary_function&lt;Unit,aType&gt;::type, oldState&gt;</span>
&gt;::state type;
  };
</pre>
We employ mpl::for_each<a href="./action=edit&id=for_each.html">?</a> once again. The twist here is our use of
<a href="./compose.html">mpl::compose</a>. Compose is just as useful in mpl as it is in stl. We
prefer not to have to create the appropriate quoted metafunction by
hand. So instead we "dynamically" generate it with compose_f_gx_hy. In
pseudo-meta-code this looks like:ReverseInheritQuoted(_1,
QuotedMF(_2)).  Here _1 and _2 are place holders for the arguments to
the composed metafunction.
<p>
<h2>4 Fields
</h2>
<p>
<h3>4.1 Fields Specification
</h3>
<p>
Loki defines accessor function templates for scatter hierarchies. One
form of accessor accepts an integer index and returns a reference to
the part of the object which instantiates the type at that index. In
other words:
<pre>
GenScatterHierarchy&lt;type_list&lt;char, short, long&gt;,
              HolderQuoted&gt;::type h;
Fields&lt;1&gt;(h); <span class="cxx-comment">// refers to the Holder&lt;short&gt; part of h.</span>
</pre>
<h3>4.2 Fields Implementation
</h3>
<pre>
  template &lt;int N, class TList, class QuotedMF&gt;
inline typename ::unary_function<a href="./action=edit&id=unary_function.html">?</a>&lt;QuotedMF,
    typename at<a href="./action=edit&id=at.html">?</a>&lt;N, TList&gt;::type&gt;::type&amp;
Fields(typename GenScatterHierarchy&lt;TList, QuotedMF&gt;&amp; obj)
  {
    typedef for_loop<a href="./action=edit&id=for_loop.html">?</a>&lt;
int_t<a href="./action=edit&id=int_t.html">?</a>&lt;N + 1&gt;
, lt<a href="./action=edit&id=lt.html">?</a>&lt;size<a href="./action=edit&id=size.html">?</a>&lt;TList&gt;::value&gt;
, <a href="./next.html">next</a>&lt;_1<a href="./action=edit&id=1.html">?</a>&gt;
, GenScatterHierarchy&lt;TList, QuotedMF&gt;
, compose_f_gxy<a href="./action=edit&id=compose_f_gxy.html">?</a>&lt;
detail::RightParent
       , ::project1st<a href="./action=edit&id=project1st.html">?</a>&lt;_1<a href="./action=edit&id=1.html">?</a>,_2<a href="./action=edit&id=2.html">?</a>&gt;
&gt;
&gt;::executed::state hier;
<p>
    typedef typename
     ::unary_function<a href="./action=edit&id=unary_function.html">?</a>&lt;detail::LeftParent, hier&gt;::type&amp;
typeref;
    return typeref(obj);
<p>
  };
</pre>
Here we make us of mpl::for_loop<a href="./action=edit&id=for_loop.html">?</a>. For_loop is a bit more complicated
than for_each. Instead of iterating over all the elements in a
type_list, the compile time for_loop uses an initial type, a condition
and an incrementation step just like a run time for loop. In this case
we are looping from N+1 to the size of our type_list, with an
increment of 1. We start with GenScatterHierarchy&lt;TList, Unit&gt; as our
initial state. Each time through the loop we take the right
parent. When the loop is done we take the left parent to give us the
desired result. In cheesy runtime style pseudo-code we calculate the
return type as follows:
<pre>
  for (J=N+1, State = GenScatterHierarchy; J &lt; TList.Size(); ++i)
    State = RightParent(State);
  typedef LeftParent(State) ReturnType;
</pre>
<p>
<h2>5. Conclusions
</h2>
<p>
<ul>
<li>MPL is quite powerful. In this small example we were able to:
<li>Use reduction (for_each) instead of awkward, non-portable pattern matching.
<li>"Dynamically" compose metafunctions with compose_f_gxy
<li>Employ integer based for_loops
<li>Take advantage of a simple compile time lambda/currying facility.
<li>MPL offers many other facilities not described here
</ul>
<p>
<ul>
<li>MPL needs documentation now. I believe some mpl naming conventions could
</ul>
  be improved as well.For me things did seem simpler once I started
  thinking in terms of quoted metafunctions. But the learning curve is
  high.
<p>
<ul>
<li>MPL seems to tax the compiler somewhat more than Loki. One particular
</ul>
  problem is that small type_lists are padded with a lot of unused
  types.
<p>
<ul>
<li>MPL does not rely on template templates or partial
</ul>
  specialization. It does a pretty good job encapsulating compiler
  limitations. Of course metaprogramming VC 6/7 remains
  somewhat nightmarish, and the port here is still not complete.
<p>
}}}
 -- Main.MatMarcus - 30 Nov 2001
<p><hr>
<a href="./Table_of_Content.html">Table of Content</a><br>Last edited February 18, 2002 10:59 am</body></html>