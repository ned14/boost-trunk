<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>4. Code generation facilities</title>
<link rel="stylesheet" href="article.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.50.0">
<meta name="keywords" content="template metaprogramming, generic programming, programming languages, C++, STL, type systems, polymorphism, compile-time">
<link rel="home" href="index.html" title="the boost c++ metaprogramming library">
<link rel="up" href="index.html" title="the boost c++ metaprogramming library">
<link rel="previous" href="lambda.html" title="3. lambda facility">
<link rel="next" href="example.html" title="5. example: a compile-time fsm generator">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr>
<th colspan="3" align="center">4. Code generation facilities</th>
</tr>

<tr>
<td width="20%" align="left"><a accesskey="p" href="lambda.html">Prev</a>&nbsp;</td>
<th width="60%" align="center">&nbsp;</th>
<td width="20%" align="right">&nbsp;<a accesskey="n" href="example.html">Next</a></td>
</tr>
</table>

<hr>
</div>

<div class="section">
<div class="titlepage">
<div>
<h2 class="title" style="clear: both"><a name="codegeneration"></a>4. Code generation facilities</h2>
</div>
</div>

<p>There are cases, especially in domain of numeric computations, then you want make some part of calculations at compile-time, and then pass the results to a run-time part of the program for further processing. For example, suppose you've implemented a complex compile-time algorithm that works with fixed-point arithmetics:</p>

<pre class="programlisting">
// fixed-point algorithm input
typedef mpl::vector&lt;
      mpl::fixed_c&lt;-1,2345678&gt;
    , mpl::fixed_c&lt;9,0001&gt;
    // ..
    , mpl::fixed_c&lt;3,14159&gt;
    &gt; input_data;

/*
  complex compile-time algorithm 
*/
typedef /*...*/ result_data;
</pre>

<p>Suppose the <tt>result_data</tt> here is a sequence of <tt>mpl::fixed_c</tt> types that keeps the results of your algorithm, and now you want to feed that result to run-time part of the algorithm. With MPL you can do it this way:</p>

<pre class="programlisting">
namespace aux {
struct push_back
{
    template&lt; typename T &gt; struct apply
    {
        template&lt; typename C &gt; void execute(C&amp; c)
        {
            // in our case T() == fixed_c() == fixed_c().operator()()
            c.push_back(T());
        }
    };
};
}

double my_algorithm()
{
    // passing the results to the run-time part of the program
    std::vector&lt;double&gt; results;
    results.reserve(mpl::size&lt;result_data&gt;::value);
    mpl::for_each&lt;result_data, aux::push_back&gt;::execute(results);
    // ...
}
</pre>

<p><tt>for_each&lt;...&gt;</tt> call there is what actually transfers the compile-time <tt>result_data</tt> into run-time <tt>std::vector&lt;double&gt; results</tt>. The <tt>for_each</tt> algorithm is one of the explicit facilities the library provides for run-time code generation:</p>

<pre class="programlisting">
template&lt;
      typename Sequence
    , typename Operation
    &gt;
struct for_each
{
    template&lt; typename T &gt;
    static void execute(T&amp; x)
    {
       // ...
    }

    static void execute()
    {
       // ...
    }
};
</pre>

<p>The semantics of <tt>for_each</tt> is simple: it iterates over a <tt>Sequence</tt> and applies the <tt>Operation</tt> for each element <tt>E</tt> of the sequence:</p>

<pre class="programlisting">
mpl::apply&lt;Operation,E&gt;::execute(x);
</pre>

<p>Applying this to our example, the</p>

<pre class="programlisting">
mpl::for_each&lt;result_data, aux::push_back&gt;::execute(results);
</pre>

<p>line is equivalent to this:</p>

<pre class="programlisting">
mpl::apply&lt; Operation, mpl::at_c&lt;result_data,0&gt;::type &gt;::execute(results);
mpl::apply&lt; Operation, mpl::at_c&lt;result_data,1&gt;::type &gt;::execute(results);
// ...
mpl::apply&lt; Operation, mpl::at_c&lt;result_data,n&gt;::type &gt;::execute(results);
</pre>

<p>There are other ways to generate an analogous code, but they are much less expressive.</p>
</div>

<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left"><a accesskey="p" href="lambda.html">Prev</a>&nbsp;</td>
<td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td>
<td width="40%" align="right">&nbsp;<a accesskey="n" href="example.html">Next</a></td>
</tr>

<tr>
<td width="40%" align="left" valign="top">3. Lambda facility&nbsp;</td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top">&nbsp;5. Example: a compile-time FSM generator</td>
</tr>
</table>
</div>
</body>
</html>

