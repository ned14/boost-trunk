<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type">
<title>3. Lambda facility</title>
<link rel="stylesheet" href="article.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.50.0">
<meta name="keywords" content="template metaprogramming, generic programming, programming languages, C++, STL, type systems, polymorphism, compile-time">
<link rel="home" href="index.html" title="the boost c++ metaprogramming library">
<link rel="up" href="index.html" title="the boost c++ metaprogramming library">
<link rel="previous" href="usage.html" title="2. basic usage">
<link rel="next" href="codegeneration.html" title="4. code generation facilities">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="navheader">
<table width="100%" summary="Navigation header">
<tr>
<th colspan="3" align="center">3. Lambda facility</th>
</tr>

<tr>
<td width="20%" align="left"><a accesskey="p" href="usage.html">Prev</a>&nbsp;</td>
<th width="60%" align="center">&nbsp;</th>
<td width="20%" align="right">&nbsp;<a accesskey="n" href="codegeneration.html">Next</a></td>
</tr>
</table>

<hr>
</div>

<div class="section">
<div class="titlepage">
<div>
<h2 class="title" style="clear: both"><a name="lambda"></a>3. Lambda facility</h2>
</div>
</div>

<p>The MPL's lambda facility allows the <i>inline composition</i> of class templates into &lsquo;lambda expressions&rsquo; that are classes and therefore can be passed around as ordinary function classes, and transformed into metafunction classes before application using</p>

<pre class="programlisting">
typedef lambda&lt;expr&gt;::type func;
</pre>

<p>expression. For example, <tt>boost::remove_const</tt> traits template from Boost <tt>type_traits</tt> library <span class="citation">[<a class="interlink" href="refs.html#ref.ttl" title="[ttl]">TTL</a>]</span> is a class template (obviously), and a <a class="interlink" href="usage.html#metafunctions" title="2.2. metafunctions">metafunction</a> in MPL terminology. The simplest example of &lsquo;inline composition&rsquo; of it would be something like</p>

<pre class="programlisting">
typedef boost::remove_const&lt;_1&gt; expr;
</pre>

<p>and that forms a so called &lsquo;lambda expression&rsquo;, that is neither a function class, not a metafunction, but can be passed around everywhere because it's an ordinary C++ class, and all MPL facilities are polymorphic regarding their arguments. Now, that lambda expression can be <span class="emphasis"><em>transformed</em></span> into a metafunction class using MPL's <tt>lambda</tt> facility:</p>

<pre class="programlisting">
typedef boost::remove_const&lt;_1&gt; expr;
typedef lambda&lt;expr&gt;::type func;
</pre>

<p>Now <tt>func</tt> is an unary metafunction class and can be used as such - in particular, it can be pass around, and it can be invoked (applied):</p>

<pre class="programlisting">
typedef apply1&lt;func,int const&gt;::type res;
BOOST_MPL_ASSERT_IS_SAME(res, int);
</pre>

<p>or even</p>

<pre class="programlisting">
typedef func::apply&lt;int const&gt;::type res;
BOOST_MPL_ASSERT_IS_SAME(res, int);
</pre>

<p>Inline composition is very appealing syntactically when you deal with metafunctions, because it makes the expression obvious:</p>

<pre class="programlisting">
typedef logical_or&lt;
      less&lt; size_of&lt;_1&gt;, int_c&lt;16&gt; &gt;
    , boost::is_same&lt;_1,_2&gt;
    &gt; expr;

typedef lambda&lt;expr&gt;::type func;
</pre>

<p>And you don't have to do the last part (<tt>typedef lambda&lt;expr&gt;::type func</tt>) yourself, because all the algorithms do this to any of their metafunction class operands internally (<tt>lambda&lt;T&gt;::type</tt> expression applied to a metafunction class gives back the same metafunction class, so it's safe to apply the expression unconditionally).</p>

<p>The alternative way to get an equivalent to the above metafunction class would be:</p>

<pre class="programlisting">
typedef bind&lt;
      meta_fun2&lt;logical_or&gt;
    , bind&lt; meta_fun2&lt;less&gt;
        , bind&lt; meta_fun1&lt;size_of&gt;,_1 &gt;
        , int_c&lt;16&gt;
        &gt;
    , bind&lt; meta_fun2&lt;boost::is_same&gt;,_1,_2 &gt;
    &gt; func;
</pre>

<p>or to use <tt>compose_</tt> family of templates an similar way. Here, we use <tt>meta_fun</tt> templates to convert metafunctions into metafunction classes, and then we combine them using <tt>bind</tt>. The transformation from this form to the above inline lambda expression and visa-versa is mechanic, and that's what essentially <tt>typedef lambda&lt;expr&gt;::type</tt> expression does.</p>

<p>In absence of lambda (on compilers that don't support partial class template specialization), MPL enables one to write the above in a less cumbersome way by fully <span class="emphasis"><em>specializing</em></span> its own metafunctions (algorithms, primitives, etc.) for the case when all the arguments are replaced by a special lambda placeholder <tt>_</tt> (underscore). For example, the original <tt>mpl::less</tt> template looks like this:</p>

<pre class="programlisting">
template&lt; typename T1, typename T2 &gt;
struct less 
{
    typedef bool_c&lt;(T1::value &lt; T2::value)&gt; type;
};
</pre>

<p>and it's specialized like this:</p>

<pre class="programlisting">
template&lt;&gt;
struct less&lt;_,_&gt;
{
    template&lt; typename T1, typename T2 &gt; struct apply
    {
        typedef bool_c&lt;(T1::value &lt; T2::value)&gt; type;
    };
};
</pre>

<p>The same is done for everything else in the library that is represented by top level class template (metafunction), so, with this knowledge, the previous awkward bind example can be rewritten as:</p>

<pre class="programlisting">
typedef bind&lt;
      logical_or&lt;_,_&gt;
    , bind&lt; less&lt;_,_&gt;, size_of&lt;_&gt;, int_c&lt;16&gt; &gt;
    , bind&lt; make_f2&lt;boost::is_same&gt;, _1,_2 &gt;
    &gt; func;
</pre>

<p>Note that you still have to wrap <tt>is_same</tt> into <tt>make_f2</tt>, because it's a foreign template.</p>

<p>Now, about combining class template metufunctions and metafunction classes in the single lambda expression - it can be done like this:</p>

<pre class="programlisting">
struct my_predicate
{
    template&lt; typename T1, typename T2 &gt; struct apply
    {
        //...
    };
};

typedef logical_or&lt;
      less&lt; size_of&lt;_1&gt;, 16&gt;
    , bind&lt; my_predicate,_1,_2 &gt; // here
    &gt; expr;
</pre>

<p>or, if, for example, you want to bind something to one of it's arguments (or change the order of parameters), then either</p>

<pre class="programlisting">
typedef logical_or&lt;
      less&lt; size_of&lt;_1&gt;, 16&gt;
    , bind&lt;my_predicate,int,_1&gt;::type // here
    &gt; expr;
</pre>

<p>or</p>

<pre class="programlisting">
typedef logical_or&lt;
      less&lt; size_of&lt;_1&gt;, 16&gt;
    , my_predicate::apply&lt;int,_1&gt; // here
    &gt; expr;
</pre>
</div>

<div class="navfooter">
<hr>
<table width="100%" summary="Navigation footer">
<tr>
<td width="40%" align="left"><a accesskey="p" href="usage.html">Prev</a>&nbsp;</td>
<td width="20%" align="center"><a accesskey="u" href="index.html">Up</a></td>
<td width="40%" align="right">&nbsp;<a accesskey="n" href="codegeneration.html">Next</a></td>
</tr>

<tr>
<td width="40%" align="left" valign="top">2. Basic usage&nbsp;</td>
<td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td>
<td width="40%" align="right" valign="top">&nbsp;4. Code generation facilities</td>
</tr>
</table>
</div>
</body>
</html>

