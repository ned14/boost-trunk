
<!-- ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| section -->
<section id="sequences">
<title>Sequences, algorithms, and iterators</>

<!-- ||||||||||||||||||||||||||||| subsection -->
<section id="sequences.intro">
<title>Introduction</>

<para>
Compile-time iteration over a sequence (of types) is one of the basic concept of template metaprogramming. Difference in types of objects being manipulated is the most common point of variability of similar but not identical code/design, and such designs are the direct target for some metaprogramming. Templates in their original usage were intended to be used to solve this exact problem (<literal>std::vector</>), but without predefined  abstractions/constructs for manipulating/iterating <emphasis>sequences</> of types instead of standalone types, and without developed (known) techniques for emulating these constructs using the current language facilities, their effect on helping high-level metaprogramming happen has been limited. 
</>

<para>
Czarnecki and Eisenecker <citation><xref linkend="ref.CE98"></>, <citation><xref linkend="ref.CE00"></> were the first to introduce the compile-time sequences of types and some simple algorithms on them, although the idea of representation common data structures like trees, lists, etc. at compile time using class template composition has been around for a while (for example, most of the expression template libraries build such trees as a part of their expression "parsing" process <citation><xref linkend="ref.Vel95b"></>). Alexandrescu <citation><xref linkend="ref.Ale01"></> used list of types and some algorithms on them to implement several design patterns; the accompanying code is known as the Loki library <citation><xref linkend="ref.Loki"></>. 
</>
</section>

<!-- ||||||||||||||||||||||||||||| subsection -->
<section id="sequences.algo">
<title>Algorithms and sequences</>

<para>
Most of algorithms in &BMPL; operates on sequences. For example, searching a type in a list looks like this:
</>

<programlisting>
<![CDATA[
typedef mpl::list<char,short,int,long,float,double> types;
typedef mpl::find<types,long>::type iter;
]]>
</>

<para>
Here, <literal>find</> accepts two parameters - a sequence to search (<literal>types</>), the type to search for (<literal>long</>), and returns an iterator <literal>iter</> pointing to the first element of the sequence such that <literal>iter::type</> is identical to <literal>long</>; if no such element exists, <literal>iter</> is identical to <literal>end&lt;types&gt;::type</>. Basically, this is how one would search for a value in <literal>std::list</> or <literal>std::vector</>, except that <literal>mpl::find</> accepts the sequence as a single parameter, while <literal>std::find</> takes two iterators.  Everything else is pretty much the same - the names are the same, the semantics is very close, there are iterators, and you can search not only by type, but also using a predicate:
</>

<programlisting>
<![CDATA[
typedef mpl::find_if< types,boost::is_float<_1> >::type iter;
]]></>

<para>
This conceptual/syntactical similarity with the STL is not coincidental. Reusing the conceptual framework of STL in compile-time world allows us to apply familiar and sound approaches for dealing with sequential data structures. The algorithms and idioms which programmers already know from STL can be applied again at compile-time. We consider this to be one of the greatest strengths that distinguishes the library from earlier attempts to build a template metaprogramming library.
</>
</section>

<!-- ||||||||||||||||||||||||||||| subsection -->
<section id="sequences.concepts">
<title>Sequence concepts</>

<para>
In the <literal>find</> example above we searched for a type in the sequence built using the <literal>mpl::list</> template, but <literal>list</> is not the only sequence that the library provides you with. Neither is <literal>mpl::find</> or any other algorithm hard-coded to work only with <literal>list</> sequences. <literal>list</> is just one model of &MPL;'s Forward Sequence concept, and <literal>find</> works with anything that satisfies this concept's requirements. The hierarchy of sequence concepts in &MPL; is quite simple - a Sequence is any compile-time entity for which <literal>begin&lt;&gt;</> and <literal>end&lt;&gt;</> produce iterators to the range of its elements; a Forward Sequence is a Sequence whose iterators satisfy Forward Iterator requirements, a Bidirectional Sequence is a Forward Sequence whose iterators satisfy Bidirectional Iterator requirements, and, finally, Random Access Sequence is a Bidirectional Sequence whose iterators satisfy Random Access Iterator requirements.
</>

<para>
Decoupling algorithms from particular sequence implementations (through iterators) allows a metaprogrammer to create her own sequence types and to retain the rest of the library at her disposal. For example, you can define a <literal>tiny_list</> for dealing with sequences of 3 types as follows:
</>

<programlisting>
<![CDATA[
template< typename TinyList, long Pos >
struct tiny_list_item;

template< typename TinyList, long Pos >
struct tiny_list_iterator
{
    typedef typename tiny_list_item<TinyList,Pos>::type type;
    typedef tiny_list_iterator<TinyList, Pos-1> prior;
    typedef tiny_list_iterator<TinyList, Pos+1> next;
};

template< typename T0, typename T1, typename T2 >
struct tiny_list
{
    typedef tiny_list_iterator<tiny_list, 0> begin;
    typedef tiny_list_iterator<tiny_list, 3> end;
    typedef T0 type0;
    typedef T1 type1;
    typedef T2 type2;
};

template< typename TinyList >
struct tiny_list_item<TinyList,0>
{
    typedef typename TinyList::type0 type;
};

template< typename TinyList >
struct tiny_list_item<TinyList,1>
{
    typedef typename TinyList::type1 type;
};

template< typename TinyList >
struct tiny_list_item<TinyList,2>
{
    typedef typename TinyList::type2 type;
};
]]>
</>

<para>
and then use it with any of the library algorithms as if it was <literal>mpl::list</>:
</>

<programlisting>
<![CDATA[
typedef tiny_list< char,short,int > types;
typedef mpl::transform<
      types
    , boost::add_pointer<_1>
    >::type pointers;
]]>
</>

<para>
Note that <literal>tiny_list</> is a model of Bidirectional Sequence; it would be a Random Access Sequence if we added <literal>advance</> and <literal>distance</> members to <literal>tiny_list_iterator</>:
</>

<programlisting>
<![CDATA[
template< typename TinyList, long Pos >
struct tiny_list_iterator
{
    static long const position = Pos;

    typedef typename tiny_list_item<TinyList,Pos>::type type;
    typedef tiny_list_iterator<TinyList, Pos-1> prior;
    typedef tiny_list_iterator<TinyList, Pos+1> next;

    template< typename N > struct advance
    {
        typedef tiny_list_iterator<
              TinyList
            , Pos + N::value
            > type;
    };

    template< typename Other > struct distance
    {
        typedef mpl::integral_c<
              long
            , Other::position - position
            > type;
    };
};
]]>
</>

<para>
While the <literal>tiny_list</> itself might be not that interesting - after all, it can hold only 3 elements, if the technique above can be automated so we would be able to define not so tiny sequences - with 5, 10, 20, etc. number of elements, when it would be very valuable (random access is almost as important at compile-time as it is at run-time - for example searching something in a sorted random-access sequence using <literal>lower_bound</> can be much faster than doing the same operation on forward-access-only <literal>list</>). 
</>

<para>
External code generation is one option here, but there is also a solution within the language, although it's not a template metaprogramming, but <emphasis>preprocessor metaprogramming</>. In fact, MPL's <literal>vector</> - a fixed-size type sequence that provides random-access iterators - is implemented very like the above <literal>tiny_list</> - using the Boost Preprocessor library <citation><xref linkend="ref.PRE"></>.
</>
</section>

<!-- ||||||||||||||||||||||||||||| subsection -->
<section id="sequences.revisited">
<title>Ad hoc example revisited</>

<para>
So, the library provides you with almost complete compile-time equivalent of STL framework. Does it help you to solve you metaprogramming tasks? Let's return to our earlier <link linkend="example.largest"><literal>largest</></> example to see if we can rewrite it in a better way with what &MPL; has to offer. Well, actually there is not much to look at, because implementation of it with &MPL; is a one-liner (we'll spread it out here for readability):
</>

<programlisting>
<![CDATA[
template< typename Sequence >
struct largest
{
    typedef typename mpl::max_element<
          Sequence
        , mpl::less<
              mpl::size_of<_1>
            , mpl::size_of<_2>
            >
        >::type type;
};
]]></>

<para>
No more termination conditions with a tricky pattern matching, no more partial specializations, and even more importantly, it's <emphasis>obvious</> what the above code does - even although it's all templates - something that you cannot say about the original version.
</>
</section>

<!-- ||||||||||||||||||||||||||||| subsection -->
<section id="sequences.iterfold">
<title>iter_fold as the main iteration algorithm</>

<para>
For the purpose of examining a little bit more of the library's internal structure, let's look at how <literal>max_element</> from the above example is implemented. One might expect that <emphasis>now</> we will again see all these awkward partial specializations, esoteric pattern matching, etc. Well, let's see:
</>

<programlisting>
<![CDATA[
namespace aux {
template< typename Predicate >
struct select_max
{
    template< typename OldIterator, typename Iterator >
    struct apply
    {
        typedef typename mpl::apply<
              Predicate
            , typename OldIterator::type
            , typename Iterator::type
            >::type condition_;

        typedef typename mpl::if_<
              condition_
            , Iterator
            , OldIterator
            >::type type;
    };
};
} // namespace aux 

template<
      typename Sequence
    , typename Predicate
    >
struct max_element
{
    typedef typename mpl::iter_fold<    
          Sequence
        , typename mpl::begin<Sequence>::type
        , aux::select_max<Predicate>
        >::type type;
};
]]>
</>

<para>
The first thing to notice here is that this algorithm is implemented in terms of another one: <literal>iter_fold</>. In fact, this is probably the most important point of the example, because nearly all other generic sequence algorithms in the library are implemented in terms of <literal>iter_fold</>. If a user ever should need to implement her own sequence algorithm, she'll almost certainly be able to do it using this primitive, which means she won't have to resort to implementing hand-crafted iteration, pattern matching of special cases for loop termination, or workarounds for lack of partial specialization. It also means that her algorithm will automatically benefit from any optimizations the library has implemented, (e.g. recursion unrolling), and that it will work with any sequence that is a model of ForwardSequence, because <literal>iter_fold</> does not require any more of its sequence argument.
</>

<para>
<literal>iter_fold</> algorithm is basically a compile-time equivalent of the <literal>fold</> or <literal>reduce</> functions that comprise the basic and well-known primitives of many functional programming languages. An analogy more familiar to a &Cxx; programmer would be <literal>std::accumulate</> algorithm from the &Cxx; standard library (<citation><xref linkend="ref.ISO98"></>, section 26.4.1 [lib.accumulate]). However, <literal>iter_fold</> is designed to take advantage of the natural characteristics of recursive traversal: it accepts <emphasis>two</> metafunction class arguments, the first of which is applied to the state "on the way in" and the second of which is applied "on the
way out".
</>

<para>
The interface to <literal>iter_fold</> is defined in &MPL; as follows:
</>

<programlisting>
<![RCDATA[
template<
      typename Sequence
    , typename InitialState
    , typename ForwardOp
    , typename BackwardOp = project1st<_1>
    >
struct iter_fold
{
    typedef &unspec; type;
};
]]>
</>

<para>
The algorithm <quote>returns</> the result of two-way successive applications of binary <literal>ForwardOp</> and <literal>BackwardOp</> operations to iterators in range [<literal>begin&lt;Sequence&gt;::type</>, <literal>end&lt;Sequence&gt;::type</>) and previous result of an operation; the <literal>InitialState</> is logically placed before the sequence and included in the forward traversal. The result <literal>type</> is identical to <literal>InitialState</> if the sequence is empty. 
</>

<para>
Of course the &MPL; also provides higher-level <literal>fold</> and <literal>fold_reverse</> algorithms which wrap <literal>iter_fold</> to accommodate its most common usage patterns.
</>
</section>

<!-- ||||||||||||||||||||||||||||| subsection -->
<section id="sequences.numbers">
<title>Sequences of numbers</>

<para>
What we've seen so far were sequences (and algorithms on sequences) of types. It's very much possible and easy to manipulate values using the library as well. The only thing to remember is that in &Cxx; class template non-type template parameters give us one more example of non-polymorphic behavior.  In other words, if you declared a metafunction to take a non-type template parameter, e.g. <literal>long</>, it's not possible to pass anything besides compile-time integral constants to it:
</>

<programlisting>
<![CDATA[
template< long N1, long N2 >
struct equal_to
{
    static bool const value = (N1 == N2);
};

equal_to<5,5>::value; // ok
equal_to<int,int>::value; // error!
]]>
</>

<para>
And of course this doesn't work the other way around either:
</>

<programlisting>
<![CDATA[
typedef mpl::list<1,2,3,4,5> numbers; // error!
]]>
</>

<para>
While this may be an obvious limitation, it imposes yet another dilemma on the library design - on one hand, we don't want to restrict users to type manipulations only, and on another hand, full support for integral manipulations would require at least duplication of most of the library facilities (ideally, if going this route, all the templates should be re-implemented for every integral type - <literal>char</>, <literal>int</>, <literal>short</>, <literal>long</>, etc.) - the same situation as we would have if we had chosen to represent metafunctions as ordinary class templates. The solution for this issue is the same as well - we represent integral values by wrapping them in types, so, for example, to create a list of numbers you write:
</>

<programlisting>
<![CDATA[
typedef mpl::list<
      mpl::int_c<1>
    , mpl::int_c<2>
    , mpl::int_c<3>
    , mpl::int_c<4>
    , mpl::int_c<5>
    > numbers;
]]>
</>

<para>
Wrapping integral constants into types to make them first-class citizens is important well inside metaprograms, 
where you often don't know (and don't care) if the metafunctions you are using operate on types, integral values, other metafunctions, or something else, like fixed-point or rational numbers (<literal>mpl::fixed_c</> and <literal>mpl::rational_c</>).
</>

<para>
But, from user's perspective, the above example is much more verbose than the shorter one, the one that was incorrect. So, for the convenience purposes, the library does provide users with a template that takes non-type template parameters, but allows a more compact notation:
</>

<programlisting>
<![CDATA[
typedef mpl::list_c<long,1,2,3,4,5> numbers;
]]></>

<para>
There is a similar <literal>vector</> counterpart as well:
</>

<programlisting>
<![CDATA[
typedef mpl::vector_c<long,1,2,3,4,5> numbers;
]]>
</>
</section>

<!-- ||||||||||||||||||||||||||||| subsection -->
<section id="sequences.variety">
<title>A variety of sequences</>

<para>
Previous efforts to provide generalized metaprogramming facilities for &Cxx; have always concentrated on <literal>cons</>-style type lists and a few core algorithms like <literal>size</> and <literal>at</> which are tied to the specific sequence implementation. Such systems have an elegant simplicity reminiscent of the analogous functionality in pure functional Lisp. It is much more time-consuming to implement even a basic set of the sequence algorithms provided by equivalent run-time libraries (STL in particular), but if we have learned anything from the STL it is that tying those algorithms' implementations to a specific sequence implementation is a misguided effort!
</>

<para>
The truth is that there is no single <quote>best</> type sequence implementation for the same reasons that there will never be a single <quote>best</> runtime sequence implementation. Furthermore, there are <emphasis>already</> quite a number of type list implementations in use today, and just as the STL algorithms can operate on sequences which don't come from STL containers, so the MPL algorithms are designed to work with foreign type sequences.
</>

<para>
It may be an eye-opening fact for some that type lists are not the only useful compile-time sequence. Again, the need for a variety of compile-time containers arises for the same reasons that we have lists, vectors, deques, and sets in the &Cxx; standard library - different containers have different functional and performance characteristics which determine not only applicability and efficiency of particular algorithms, but also the expressiveness or verbosity of the code that uses them. While runtime performance is not an issue for &Cxx; metaprograms, compilation speed is often a significant bottleneck to advanced &Cxx; software development <citation><xref linkend="ref.Abr01"></>.
</>

<para>
The &MPL; provides four built-in sequences: <literal>list</>, <literal>list_c</> (really just a <literal>list</> of value wrappers), <literal>vector</>, a randomly-accessible sequence of fixed maximum size, and <literal>range_c</>, a randomly-accessible sequence of consecutive integral values. More important, however, is its ability to adapt to arbitrary sequence types. The only core operations that a sequence is required to provide in order to be used with the library algorithms are <literal>begin&lt;&gt;</> and <literal>end&lt;&gt;</> metafunctions which "return" iterators into to the sequence. As in the STL it is the iterators which are used to implement most of the general purpose sequence algorithms the library provides. Also as in STL, algorithm specialization is used to take advantage of implementation knowledge about particular sequences: many of the "basic" sequence operations such as <literal>back&lt;&gt;</>, <literal>front&lt;&gt;</>, <literal>size&lt;&gt;</> and <literal>at&lt;&gt;</> are specialized on sequence type to provide a more efficient implementation than the fully generic version.
</>
</section>

<!-- ||||||||||||||||||||||||||||| subsection -->
<section id="sequences.unrolling">
<title>Loop/recursion unrolling</>

<para>
Almost coincidentally, loop unrolling can be as important to compile-time iterative algorithms as it is to runtime algorithms. To see why, one must first remember that all "loops" in &Cxx; metaprograms are in fact implemented with recursion, and that the depth of template instantiations can be a valuable resource in a compiler implementation. In fact, Annex B of the &Cxx; standard (<citation><xref linkend="ref.ISO98"></>, annex B [limits]) <emphasis>recommends</> a minimum depth of 17 recursively nested template instantiations, but this is far too low for many serious metaprograms some of which easily exceed the hard-coded instantiation limits of some otherwise excellent compilers. To see how this works in action, let's examine a straightforward implementation of the <literal>fold</> metafunction, which combines some algorithm state with each element of a sequence:
</>

<programlisting>
<![CDATA[
// Unspecialized version combines the initial state and first element
// and recurses to process the rest
template<
      typename Start
    , typename Finish
    , typename State
    , typename BinaryFunction
    >
struct fold
  : fold<
        typename Start::next
      , Finish
      , typename apply<
              BinaryFunction
            , State
            , typename Start::type
            >::type
      , BinaryFunction
      >
{
};

// Specialization for loop termination
template<
      typename Finish
    , typename State
    , typename BinaryFunction
    >
struct fold<Finish,Finish,State,BinaryFunction>
{
    typedef State type;
};
]]>
</>

<para>
Although simple and elegant, this implementation will always incur at least as many levels of recursive template instantiation as there are elements in the input sequence.

<footnote id="note.unrolling1"><para>It could be much more, depending on the complexity of the <literal>apply&lt;...&gt;</> expression, whose depth is added to the overall recursion depth.
</></>

The library addresses this problem by explicitly "unrolling" the recursion. To apply the technique to our <literal>fold</> example, we begin by factoring out a single step of the algorithm. Our <literal>fold_step</> metafunction has two results: <literal>type</> (the next state), and <literal>iterator</> (the next sequence position).
</>

<programlisting>
<![CDATA[
template<
      typename BinaryFunction
    , typename State
    , typename Start
    , typename Finish
    >
struct fold_step
{
    typedef typename apply<
          BinaryFunction
        , State
        , typename Start::type
        >::type type;

    typedef typename Start::next iterator;
};
]]>
</>

<para>
As with our main algorithm implementation, we specialize for the loop termination condition so that the step becomes a no-op:
</>

<programlisting>
<![CDATA[
template<
      typename BinaryFunction
    , typename State
    , typename Finish
    >
struct fold_step<BinaryFunction,State,Finish,Finish>
{
    typedef State type;
    typedef Finish iterator;
};
]]>
</>

<para>
Now we can now reduce <literal>fold</>'s instantiation depth by any constant factor N simply by inserting N invocations of <literal>fold_step</>. Here we've chosen a factor of 4:
</>

<programlisting>
<![CDATA[
template<
      typename Start
    , typename Finish
    , typename State
    , typename BinaryFunction
    >
struct fold
{
 private:
    typedef fold_step<
        BinaryFunction
      , State
      , Start
      , Finish
      > next1;
    
    typedef fold_step<
        BinaryFunction
      , typename next1::type
      , typename next1::iterator
      , Finish
      > next2;
    
    typedef fold_step<
        BinaryFunction
      , typename next2::type
      , typename next2::iterator
      , Finish
      > next3;
    
    typedef fold_step<
        BinaryFunction
      , typename next3::type
      , typename next3::iterator
      , Finish
      > next4;
    
    typedef fold<
          typename next4::iterator
        , Finish
        , typename next4::type
        , BinaryFunction
        > recursion;

 public:
    typedef typename recursion::type type;
};
]]>
</>

<para>
The &MPL; applies this unrolling technique across all algorithms with an unrolling factor tuned according to the demands of the &Cxx; implementation in use, and with an option for the user to override the value.

<footnote id="note.unrolling2"><para>
This implementation detail is made relatively painless through heavy reliance on the Boost Preprocessor Library, so only one copy of the code needs to be maintained.
</></>

This fact enables users to push beyond the metaprogramming limits they would usually encounter with more naive algorithm implementations. Experiments also show a small (up to 10%) increase in metaprogram instantiation speed on some compilers when loop unrolling is used.
</>
</section>

</section>
