
<!-- ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| section -->
<section id="lambda">
<title>Lambda facility</>

<para>
The &MPL;'s lambda facility allows the <firstterm>inline composition</> of class templates into <quote>lambda expressions</> that are classes and therefore can be passed around as ordinary function classes, and transformed into metafunction classes before application using
</>

<programlisting><![CDATA[
typedef lambda<expr>::type func;
]]></>

<para>
expression. For example, <literal>boost::remove_const</> traits template from Boost <literal>type_traits</> library <citation><xref linkend="ref.TTL"></> is a class template (obviously), and a <link linkend="metafunctions">metafunction</> in &MPL; terminology. The simplest example of <quote>inline composition</> of it would be something like
</>

<programlisting><![CDATA[
typedef boost::remove_const<_1> expr;
]]></>

<para>
and that forms a so called <quote>lambda expression</>, that is neither a function class, not a metafunction, but can be passed around everywhere because it's an ordinary &Cxx; class, and all &MPL; facilities are polymorphic regarding their arguments. Now, that lambda expression can be <emphasis>transformed</> into a metafunction class using &MPL;'s <literal>lambda</> facility:
</>

<programlisting><![CDATA[
typedef boost::remove_const<_1> expr;
typedef lambda<expr>::type func;
]]></>

<para>
Now <literal>func</> is an unary metafunction class and can be used as such - in particular, it can be pass around, and it can be invoked (applied):
</>

<programlisting><![CDATA[
typedef apply1<func,int const>::type res;
BOOST_MPL_ASSERT_IS_SAME(res, int);
]]></>

<para>
or even
</>

<programlisting><![CDATA[
typedef func::apply<int const>::type res;
BOOST_MPL_ASSERT_IS_SAME(res, int);
]]></>

<para>
Inline composition is very appealing syntactically when you deal with metafunctions, because it makes the expression obvious:
</>

<programlisting><![CDATA[
typedef logical_or<
      less< size_of<_1>, int_c<16> >
    , boost::is_same<_1,_2>
    > expr;

typedef lambda<expr>::type func;
]]></>

<para>
And you don't have to do the last part (<literal>typedef lambda&lt;expr&gt;::type func</>) yourself, because all the algorithms do this to any of their metafunction class operands internally (<literal>lambda&lt;T&gt;::type</> expression applied to a metafunction class gives back the same metafunction class, so it's safe to apply the expression unconditionally).
</>

<para>
The alternative way to get an equivalent to the above metafunction class would be:
</>

<programlisting><![CDATA[
typedef bind<
      meta_fun2<logical_or>
    , bind< meta_fun2<less>
        , bind< meta_fun1<size_of>,_1 >
        , int_c<16>
        >
    , bind< meta_fun2<boost::is_same>,_1,_2 >
    > func;
]]></>

<para>
or to use <literal>compose_</> family of templates an similar way. Here, we use <literal>meta_fun</> templates to convert metafunctions into metafunction classes, and then we combine them using <literal>bind</>. The transformation from this form to the above inline lambda expression and visa-versa is mechanic, and that's what essentially <literal>typedef lambda&lt;expr&gt;::type</> expression does.
</>

<para>
In absence of lambda (on compilers that don't support partial class template specialization), &MPL; enables one to write the above in a less cumbersome way by fully <emphasis>specializing</> its own metafunctions (algorithms, primitives, etc.) for the case when all the arguments are replaced by a special lambda placeholder <literal>_</> (underscore). For example, the original <literal>mpl::less</> template looks like this:
</>

<programlisting><![CDATA[
template< typename T1, typename T2 >
struct less 
{
    typedef bool_c<(T1::value < T2::value)> type;
};
]]></>

<para>
and it's specialized like this:
</>

<programlisting><![CDATA[
template<>
struct less<_,_>
{
    template< typename T1, typename T2 > struct apply
    {
        typedef bool_c<(T1::value < T2::value)> type;
    };
};
]]></>

<para>
The same is done for everything else in the library that is represented by top level class template (metafunction), so, with this knowledge, the previous awkward bind example can be rewritten as:
</>

<programlisting><![CDATA[
typedef bind<
      logical_or<_,_>
    , bind< less<_,_>, size_of<_>, int_c<16> >
    , bind< make_f2<boost::is_same>, _1,_2 >
    > func;
]]></>

<para>
Note that you still have to wrap <literal>is_same</> into <literal>make_f2</>, because it's a foreign template.
</>

<para>
Now, about combining class template metufunctions and metafunction classes in the single lambda expression - it can be done like this:
</>

<programlisting><![CDATA[
struct my_predicate
{
    template< typename T1, typename T2 > struct apply
    {
        //...
    };
};

typedef logical_or<
      less< size_of<_1>, 16>
    , bind< my_predicate,_1,_2 > // here
    > expr;
]]></>

<para>
or, if, for example, you want to bind something to one of it's arguments (or change the order of parameters), then either
</>

<programlisting><![CDATA[
typedef logical_or<
      less< size_of<_1>, 16>
    , bind<my_predicate,int,_1>::type // here
    > expr;
]]></>

<para>
or
</>

<programlisting><![CDATA[
typedef logical_or<
      less< size_of<_1>, 16>
    , my_predicate::apply<int,_1> // here
    > expr;
]]></>

</section>
