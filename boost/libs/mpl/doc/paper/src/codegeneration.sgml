
<!-- ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| section -->
<section id="codegeneration">
<title>Code generation facilities</>

<para>
There are cases, especially in domain of numeric computations, then you want make some part of calculations at compile-time, and then pass the results to a run-time part of the program for further processing. For example, suppose you've implemented a complex compile-time algorithm that works with fixed-point arithmetics:
</>

<programlisting>
<![CDATA[
// fixed-point algorithm input
typedef mpl::vector<
      mpl::fixed_c<-1,2345678>
    , mpl::fixed_c<9,0001>
    // ..
    , mpl::fixed_c<3,14159>
    > input_data;

/*
  complex compile-time algorithm 
*/
typedef /*...*/ result_data;
]]>
</>

<para>
Suppose the <literal>result_data</> here is a sequence of <literal>mpl::fixed_c</> types that keeps the results of your algorithm, and now you want to feed that result to run-time part of the algorithm. With &MPL; you can do it this way:
</>

<programlisting>
<![CDATA[
namespace aux {
struct push_back
{
    template< typename T > struct apply
    {
        template< typename C > void execute(C& c)
        {
            // in our case T() == fixed_c() == fixed_c().operator()()
            c.push_back(T());
        }
    };
};
}

double my_algorithm()
{
    // passing the results to the run-time part of the program
    std::vector<double> results;
    results.reserve(mpl::size<result_data>::value);
    mpl::for_each<result_data, aux::push_back>::execute(results);
    // ...
}
]]>
</>

<para>
<literal>for_each&lt;...&gt;</> call there is what actually transfers the compile-time <literal>result_data</> into run-time <literal>std::vector&lt;double&gt; results</>. The <literal>for_each</> algorithm is one of the explicit facilities the library provides for run-time code generation:
</>

<programlisting>
<![CDATA[
template<
      typename Sequence
    , typename Operation
    >
struct for_each
{
    template< typename T >
    static void execute(T& x)
    {
       // ...
    }

    static void execute()
    {
       // ...
    }
};
]]>
</>

<para>
The semantics of <literal>for_each</> is simple: it iterates over a <literal>Sequence</> and applies the <literal>Operation</> for each element <literal>E</> of the sequence:
</>

<programlisting>
<![CDATA[
mpl::apply<Operation,E>::execute(x);
]]>
</>

<para>
Applying this to our example, the 
</>

<programlisting>
<![CDATA[
mpl::for_each<result_data, aux::push_back>::execute(results);
]]>
</>

<para>
line is equivalent to this:
</>

<programlisting>
<![CDATA[
mpl::apply< Operation, mpl::at_c<result_data,0>::type >::execute(results);
mpl::apply< Operation, mpl::at_c<result_data,1>::type >::execute(results);
// ...
mpl::apply< Operation, mpl::at_c<result_data,n>::type >::execute(results);
]]>
</>

<para>
There are other ways to generate an analogous code, but they are much less expressive.
</>

</section>
