
<!-- ||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| section -->
<section id="example">
<title>Example: a compile-time FSM generator</>

<para>
Finite state machines (<acronym>FSM</>) are an important tool of describing and implementing controlling program behavior <citation><xref linkend="ref.hu79"></>, <citation><xref linkend="ref.mar98"></>. They also are a good example of the domain where some &mping; can be applied to reduce the amount of repetitive and boilerplate operations one has to perform in order to implement these simple mathematical models in code. Below we present a simple state machine generator that has been implemented using &BMPL; facilities. The generator takes a compile-time automata description, and turns it into &Cxx; code that implements the FSM at run-time. The FSM description is basically a combination of states and events + a state transition table (<acronym>STT</>) that ties them 
all together. The generator walks through the table and generates the state machine's <literal>process_event</>
method that is essentially what a FSM is about.
</>

<para>
Suppose we want to implement a simple music player using a finite state machine model. The state transition table 
for the FSM is shown in <xref linkend="example.fsm.stt">. The STT format reflects the way one usually describes the behavior of a FSM in plain English. For example, the first line of the table can be read as follows: <quote>If the model is in the <literal>stopped</> state, and the <literal>play_event</> is received, then the <literal>do_play</> transition function is called, and the model goes into the <literal>playing</> state</>.
</>

<table id="example.fsm.stt" frame="none">
<title>Player's state transition table with actions</>

<tgroup cols="4" align="left">
<thead>
<row>   <entry>State</>   <entry>Event</>       <entry>Next state</>  <entry>Transition function</></>
</>
<tbody>
<row>   <entry>stopped</> <entry>play_event</>  <entry>playing</>     <entry>do_play</>   </>
<row>   <entry>playing</> <entry>stop_event</>  <entry>stopped</>     <entry>do_stop</>   </>
<row>   <entry>playing</> <entry>pause_event</> <entry>paused</>      <entry>do_pause</>  </>
<row>   <entry>paused</>  <entry>play_event</>  <entry>playing</>     <entry>do_resume</> </>
<row>   <entry>paused</>  <entry>stop_event</>  <entry>stopped</>     <entry>do_stop</>   </>
</>
</tgroup>

</table>

<para>
The transition table provides us with complete formal definition of the target FSM, and there are several ways to 
transform that definition into code. For example, if we define states as members of enumeration type, and events as classes  derived from some base <literal>event</> class (they need to be passed to action functions, and they may
contain some event-specific information for an action), 
</>

<programlisting>
<![CDATA[
class player
{
 public:
    // event declarations
    struct event;
    struct play_event;
    struct stop_event;
    struct pause_event;

    // "input" function
    void process_event(event const&); // throws

 private:
    // states
    enum state_t { stopped, playing, paused };

    // transition functions
    void do_play(play_event const&);
    void do_stop(stop_event const&);
    void do_pause(pause_event const&);
    void do_resume(play_event const&);

 private:
    state_t m_state;
};
]]>
</>

<para>
then the most straightforward way to derive the FSM implementation from the above table would be something 
like this:
</>

<programlisting>
<![CDATA[
void player::process_event(event const& e)
{
    if (m_state == stopped)
    {
        if (typeid(e) == typeid(play_event))
        {
            do_play(static_cast<play_event const&>(e));
            m_state = playing;
            return;
        }
    }
    else if (m_state == playing)
    {
        if (typeid(e) == typeid(stop_event))
        {
            do_stop(static_cast<stop_event const&>(e));
            m_state = stopped;
            return;
        }

        if (typeid(e) == typeid(pause_event))
        {
            do_pause(static_cast<pause_event const&>(e));
            m_state = paused;
            return;
        }
    }
    else if (m_state == paused)
    {
        if (typeid(e) == typeid(stop_event))
        {
            do_stop(static_cast<stop_event const&>(e));
            m_state = stopped;
            return;
        }

        if (typeid(e) == typeid(play_event))
        {
            do_play(static_cast<play_event const&>(e));
            m_state = playing;
            return;
        }
    }
    else
    {
        throw logic_error(
            boost::format("unknown state: %d")
                % static_cast<int>(m_state)
            );
    }

    throw std::logic_error(
        "unexpected event: " + typeid(e).name()
        );
}
]]>
</>

<para>
Although there is nothing particularly wrong with implementing a FSM's structure using nested <literal>if</> (or <literal>switch-case</>) statements, the obvious thing about this approach is that most of the above code is boilerplate. What you tend to do with boilerplate code is copy and paste it, and then change names etc. to adjust it to its new location, and that's there the errors are most likely to creep in - since all the lines of events processing look alike (structurally), it's very easy to overlook or forget something that's need to be changed, and many of such errors won't appear until the runtime.
</>

<para>
The transition table of our FSM is just a 5-lines table, and ideally, we would like the skeleton implementation of the automata's controlling logic to be equally small (or, at least, to look equally small, e.g. to be encapsulated in some form so we never worry about it). 
</>

<!-- ||||||||||||||||||||||||||||| subsection -->
<section id="example.impl">
<title>Implementing it</>

<para>
To represent the TTS in &Cxx; program, we define a <literal>transition</> class template that represents a single line of the table, and than the table itself can be represented as a sequence of such lines:
</>

<programlisting>
<![CDATA[
typedef mpl::list<
      transition<stopped, play_event,  playing, &player::do_play>
    , transition<playing, stop_event,  stopped, &player::do_stop>
    , transition<playing, pause_event, paused,  &player::do_pause>
    , transition<paused,  play_event,  playing, &player::do_resume>
    , transition<paused,  stop_event,  stopped, &player::do_stop>
    >::type transition_table;
]]></>

<para>
Now, the complete FSM will look like this:
</>

<programlisting>
<![CDATA[
class player
    : state_machine<player>
{
 private:
    typedef player self_t;

    // state invariants
    void stopped_state_invariant();
    void playing_state_invariant();
    void paused_state_invariant();

    // states (invariants are passed as non-type template arguments,
    // and are called then the FSM enters the corresponding state)
    typedef state<0, &self_t::stopped_state_invariant> stopped;
    typedef state<1, &self_t::playing_state_invariant> playing;
    typedef state<2, &self_t::paused_state_invariant> paused;

 private:
    // event declarations; events are represented as types, 
    // and can carry a specific data for each event;
    // but it's not needed for generator, so we define them later
    struct play_event;
    struct stop_event;
    struct pause_event;

    // transition functions
    void do_play(play_event const&);
    void do_stop(stop_event const&);
    void do_pause(pause_event const&);
    void do_resume(play_event const&);

    // STT
    friend class state_machine<player>;
    typedef mpl::list<
          transition<stopped, play_event,  playing, &player::do_play>
        , transition<playing, stop_event,  stopped, &player::do_stop>
        , transition<playing, pause_event, paused,  &player::do_pause>
        , transition<paused,  play_event,  playing, &player::do_resume>
        , transition<paused,  stop_event,  stopped, &player::do_stop>
        >::type transition_table;
};
]]>
</>

<para>
That's all - the above will generate a complete FSM implementation according to our specification. The only thing we need to start using it is to define the events types (that were just forward declared before):
</>

<programlisting>
<![CDATA[
// event definitions
struct player::play_event
    : player::event
{
};

// ...
]]>
</>

<para>
The usage is simple as well:
</>

<programlisting>
<![CDATA[
int main()
{
    // usage example
    player p;
    p.process_event(player::play_event());
    p.process_event(player::pause_event());
    p.process_event(player::play_event());
    p.process_event(player::stop_event());
    return 0;
}
]]>
</>
</section>

<!-- ||||||||||||||||||||||||||||| subsection -->
<section id="example.relatedwork">
<title>Related work</>

<para>
A notable prior work in the field of automation of general-purpose state machine implementation in &Cxx; is the Robert Martin's <emphasis>State Machine Compiler</> <citation><xref linkend="ref.smc"></>. The SMC takes an ASCII description of the machine's state transition table and produces a &Cxx; code that implements the FSM using a variation of State design pattern <citation><xref linkend="ref.hun91"></>, <citation><xref linkend="ref.ghj95"></>. Lafreniere <citation><xref linkend="ref.laf00"></> presents another approach, where no external tools are used, and the FSMs are table driven. 
</>
</section>

</section>
