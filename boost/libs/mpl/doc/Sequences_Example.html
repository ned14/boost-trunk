<!doctype html public "-//ietf//dtd html//en">
<html><head><title>boost::mpl::Sequences Example</title>
<link rel="stylesheet" href="./mpl_wiki.css">
</head><body bgcolor="white">
<h1><a href="./Table_of_Content.html"><img src="./mpl_logo.jpg" alt="[Home]" border=0 align="right"></a>Sequences Example</h1><h3>[random notes]
</h3>
<p>
As the name suggests, type list is basically a compile-time linear sequence of types that allows you to manipulate its elements very much like the standard std::list and std::vector containers allows you to manipulate their content at runtime. Each instantiation of type_list template represents a fixed-length sequence of types, which can be manipulated in different ways, in particular for building another, more shorter or more longer sequence of types from it. As any pure model of a compile-time concept, type_list template does not have any member functions or member variables; all members of the class template are either also class templates or typedefs. 
<p>
Also, all type lists' alogrithms are <em>external</em>. All the sequence algorithms/operations, even simple one such as <code>size<a href="./action=edit&id=size.html">?</a></code>, <code>front<a href="./action=edit&id=front.html">?</a></code> or <code>push_back<a href="./action=edit&id=push_back.html">?</a></code> are external, i.e. they are not nested inside the sequence classes and the typical usage looks like this
<p>
<pre>
size&lt; list&lt;char, int&gt; &gt;::value == 2
</pre>
<p>
Externalizing the algorithms allows their reuse across the different sequence types/implementations and also make the sequence classes much more lightweight, as there are (may be) quite a few sequence algorithms that would ??. Also externalization of even such simple algorithms as size allows to adopt into your program some external components that do conform the sequence requirement but have different naming conventions/set of embedded operations.
<p>
<p>
Although different from the Standard Template Library in that it operates on compile-time entites (data structures), <code>boost::mpl</code> still has very similar to the STL architecture and flavor of genericity.
<p>
Most of the STL algorithms can be also found in <code>boost::mpl</code>, although some of them might have sligthly different semantics due to compile-time nature of the library.
<p>
As with the STL, algorithms and the structures their operate on are decoupled through iterators and iterator ranges. 
<p>
<p>
<p>
One important thing about type_list types is that they do not have identity property. For example, you shouldn't assume that the following will compile:
<p>
<pre>
typedef list<a href="./action=edit&id=list.html">?</a>&lt;char, int&gt; list1;
typedef list<a href="./action=edit&id=list.html">?</a>&lt;char&gt; list2;
<p>
BOOST_STATIC_ASSERT((boost::is_same&lt;list1, push_back&lt;list2,int&gt;::type&gt;::value));
</pre>
<p>
To compare two lists on equality use <code><a href="./equal.html">equal</a></code> algorithm. 
<p><hr>
<a href="./Table_of_Content.html">Table of Content</a><br>Last edited February 18, 2002 10:42 pm</body></html>