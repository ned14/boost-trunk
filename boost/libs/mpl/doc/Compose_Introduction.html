<!doctype html public "-//ietf//dtd html//en">
<html><head><title>boost::mpl::Compose Introduction</title>
<link rel="stylesheet" href="./mpl_wiki.css">
</head><body bgcolor="white">
<h1><a href="./Table_of_Content.html"><img src="./mpl_logo.jpg" alt="[Home]" border=0 align="right"></a>Compose Introduction</h1>As with the standard library, many of the <code>boost::mpl</code> algorithms take either predicates or transformation unary/binary function classes as their parameters, and as the experience shows that the ability to compose simple
predicates/functions into more complex ones is just as important in compile-time world as it is in run-time one, the library provides compile-time equivalent of boost::compose (boost/mpl/compose.hpp) and std::bind (boost/mpl/bind.hpp) functionality (see also <a href="./Lambda_facility.html">Lambda facility</a>).
<p>
<h3>Example
</h3>
<p>
<pre>
<span class="cxx-comment">// find either a 'void' or a type convertible to 'int'</span>
typedef <a href="./find_if.html">find if</a>&lt;
        types
      , compose_f_gx_hx<a href="./action=edit&id=compose_f_gx_hx.html">?</a>&lt;
            make_f2<a href="./action=edit&id=make_f2.html">?</a>&lt; <a href="./logical_or.html">logical or</a> &gt;
          , bind1st<a href="./action=edit&id=bind1st.html">?</a>&lt; make_f2<a href="./action=edit&id=make_f2.html">?</a>&lt;boost::is_same&gt;, void &gt;
          , bind2nd<a href="./action=edit&id=bind2nd.html">?</a>&lt; make_f2<a href="./action=edit&id=make_f2.html">?</a>&lt;boost::is_convertible&gt;, int &gt;
          &gt;
      &gt;::type itor;
</pre>
<p><hr>
<a href="./Table_of_Content.html">Table of Content</a><br>Last edited February 18, 2002 10:06 pm</body></html>