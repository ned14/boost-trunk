<!doctype html public "-//ietf//dtd html//en">
<html><head><title>boost::mpl::Rationale for design decisions</title>
<link rel="stylesheet" href="./mpl_wiki.css">
</head><body bgcolor="white">
<h1><a href="./Table_of_Content.html"><img src="./mpl_logo.jpg" alt="[Home]" border=0 align="right"></a>Rationale for design decisions</h1><h3>Type and value objects manipulation (very raw)
</h3>
The distinguishing between type and value template parameters in the language does not allow a smooth re-use of the same metaprogramming constructs for both types and values. As all template metaprogramming constructs, objects and algorithms are actually implemented as class templates, and as the language does not allow overloading or partial template specialization of class templates with different kind of template parameters (type-parameters and value-parameters), at the early developmenty stage of the library a question arised whether significant part of the library components should be duplicated in order to support compile-time value manipulations at the same level as types, or to provide a little bit more cumbersome way to do some value manipulations, but having preserve the simplicity and relatively small size of the library. The second choice was made, ????, in particular because in most metaprograms value manipulations are relatively simple. Note, that still this is no functionality discrimination of value-targeted part of the library. All algorithms, constructs and utilities that can be applied to types can be applied to values too, just sometimes in a more cumbersome way. 
<p>
<h3>Implementation of basic sequence algorithms as "free functions" instead of members of a particular sequence (raw)
</h3>
<p>
1) while the nested functions notation in some cases is less verbose,
<p>
<pre>
typedef mpl::type_list<a href="./action=edit&id=type_list.html">?</a>&lt;char,short,int,long&gt; types;
typedef mpl::select_type<a href="./action=edit&id=select_type.html">?</a>&lt;types::empty, long, types::back&gt;::type t;
</pre>
<p>
it is also less generic/more intrusive; requiring a sequence class to implement <code>size<a href="./action=edit&id=size.html">?</a></code>, <code>empty<a href="./action=edit&id=empty.html">?</a></code>, <code>at<a href="./action=edit&id=at.html">?</a></code>, etc. algorithms as members is often unnecessary and over restrictive; in many cases the default implementations provided by the library are sufficient; currently the only requirement that a "foreign" sequence should conform to in order to be used with the library algorithms is to implement external <code>begin/end</code> metafunctions; you don't have to modify your sequence code; with the requirement to provide these as nested functions that wouldn't be the case anymore.
<p>
2) if a nested function has at least one argument, and it's invoked on a sequence that is a template parameter, or depends on a template parameter, the notation actually becomes <em>more</em> verbose, e.g.
<p>
<pre>
struct my_func
{
    template&lt;typename Sequence, typename N&gt; struct apply
    {
        <span class="cxx-comment">// invoking 'at' nested metafunction on a Sequence class</span>
        typedef typename Sequence::template at&lt;N::value&gt;::type type;
    };
};
</pre>
<p>
comparing to the current
<p>
<pre>
struct my_func
{
    template&lt;typename Sequence, typename N&gt; struct apply
    {
        typedef typename mpl::at<a href="./action=edit&id=at.html">?</a>&lt;N::value,Sequence&gt;::type type;
    };
};
</pre>
<p>
3) placing functions inside of a sequence class makes impossible to pass
them around as predicates/function classes:
<p>
<pre>
    typedef mpl::type_list<a href="./action=edit&id=type_list.html">?</a>&lt;seq1,seq2,seq3&gt; sequences; <span class="cxx-comment">// list of sequences</span>
    <span class="cxx-comment">// find first non-empty sequence</span>
    typedef mpl::find_if<a href="./action=edit&id=find_if.html">?</a>&lt; sequences, mpl::size<a href="./action=edit&id=size.html">?</a>&lt;mpl::_1<a href="./action=edit&id=1.html">?</a>&gt; &gt;::type itor;
</pre>
<p>
instead, you have to write an explicit predicate for every such case,
<p>
<pre>
    struct size_pred
    {
        template&lt;typename Sequence&gt; struct apply
        {
            typedef typename Sequence::size type;
        };
    };
<p>
    <span class="cxx-comment">// find first non-empty sequence</span>
    typedef mpl::find_if<a href="./action=edit&id=find_if.html">?</a>&lt; sequences, size_pred &gt;::type itor;
</pre>
<p><hr>
<a href="./Table_of_Content.html">Table of Content</a><br>Last edited December 23, 2001 2:00 pm</body></html>