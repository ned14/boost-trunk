<!doctype html public "-//ietf//dtd html//en">
<html><head><title>boost::mpl::Expression templates</title>
<link rel="stylesheet" href="./mpl_wiki.css">
</head><body bgcolor="white">
<h1><a href="./Table_of_Content.html"><img src="./mpl_logo.jpg" alt="[Home]" border=0 align="right"></a>Expression templates</h1><h3>(from correspondence, very raw)
</h3>
<p>
Here is how expression templates should interact with the rest of the library:
<p>
1) ordinary class template specializations with specific types of template arguments (<code>boost::_1</code>, <code>boost:_2</code>, etc.) should be accepted in all algorithms where equivalent mpl-style function-classes (<code>struct f { template&lt;typename T&gt; struct apply { typedef T type; }; };</code>) are accepted (<code>find_if</code>, <code>for_each</code>, <code>transform</code>, etc.); equivalence is informally defined by the following examples:
<p>
<pre>
    boost::remove_const&lt;boost::_1&gt; == mpl::make_f_x<a href="./action=edit&id=make_f_x.html">?</a>&lt;boost::remove_const&gt;
    boost::is_same&lt;boost::_1,boost::_2&gt; == mpl::make_f_xy<a href="./action=edit&id=make_f_xy.html">?</a>&lt;boost::is_same&gt;
    boost::is_same&lt;boost::_2,boost::_1&gt; == mpl::make_f_yx<a href="./action=edit&id=make_f_yx.html">?</a>&lt;boost::is_same&gt;
    boost::is_same&lt;int,boost::_1&gt; == mpl::bind1st<a href="./action=edit&id=bind1st.html">?</a>&lt;mpl::make_f_yx<a href="./action=edit&id=make_f_yx.html">?</a>&lt;boost::is_same&gt;,int&gt;
    boost::is_same&lt;boost::_1,int&gt; == mpl::bind2nd<a href="./action=edit&id=bind2nd.html">?</a>&lt;mpl::make_f_yx<a href="./action=edit&id=make_f_yx.html">?</a>&lt;boost::is_same&gt;,int&gt;
    boost::is_same&lt;int,boost::_2&gt; - illegal if used standalone
    boost::is_same&lt;boost::_2,int&gt; - illegal if used standalone
</pre>
<p>
Example:
<pre>
    typedef mpl::find_if<a href="./action=edit&id=find_if.html">?</a>&lt; input_list,boost::is_same&lt;boost::_1,int&gt; &gt; find;
    typedef mpl::transform<a href="./action=edit&id=transform.html">?</a>&lt; input_list,boost::remove_const&lt;boost::_1&gt; &gt; seq;
</pre>
<p>
2) <em>combinations</em> of class template specializations (taking class template specializations) with specific types of template arguments (up to a certain level of nestedness) should be supported and accepted in all places where equivalent mpl-style function-classes are accepted, e.g.
<p>
<pre>
    typedef mpl::find_if<a href="./action=edit&id=find_if.html">?</a>&lt; input_list
        , <a href="./logical_or.html">mpl::logical or</a>&lt;
              , boost::is_same&lt;boost::_1,int&gt;
              , boost::is_convertible&lt;long, boost::_1&gt;
              &gt;
        &gt; find;
<p>
    typedef mpl::transform<a href="./action=edit&id=transform.html">?</a>&lt;
          input_list1
        , input_list2
        , less_specialized&lt;
              boost::_1
            , boost::remove_pointer&lt;boost::_2&gt;
            &gt;
        &gt; seq;
</pre>
<p>
3) standalone expression templates are NOT required to generate equivalent mpl-style function-classes, e.g.
<p>
<pre>
    typedef boost::is_same&lt;boost::_1,int&gt; same_as_int;
    typedef same_as_int::apply&lt;long&gt;::type result; <span class="cxx-comment">// not required to work</span>
</pre>
<p>
4) it's acceptable to limit the level of nestedness of the expressions, for instance 3 seems like an acceptable (from user's point of view) choice:
<p>
<pre>
    typedef mpl::find_if<a href="./action=edit&id=find_if.html">?</a>&lt; input_list
        , <a href="./logical_or.html">mpl::logical or</a>&lt;
              , mpl::logical_not<a href="./action=edit&id=logical_not.html">?</a>&lt; boost::is_same&lt;boost::_1,int&gt; &gt;
              , boost::is_convertible&lt;long, boost::_1&gt;
              &gt;
        &gt; find; <span class="cxx-comment">// ok</span>
<p>
    typedef mpl::find_if<a href="./action=edit&id=find_if.html">?</a>&lt; input_list
        , <a href="./logical_or.html">mpl::logical or</a>&lt;
              , mpl::logical_not<a href="./action=edit&id=logical_not.html">?</a>&lt; boost::is_same&lt;
                    boost::remove_pointer&lt;boost::_1&gt; <span class="cxx-comment">// too much</span>
                  , int
                  &gt; &gt;
              , boost::is_convertible&lt;long, boost::_1&gt;
              &gt;
        &gt; illegal_find;
</pre>
<p>
5) it's acceptable to limit the overall number of parameters of a class template that can participate in expression template, e.g.
<p>
<pre>
    typedef mpl::find_if<a href="./action=edit&id=find_if.html">?</a>&lt;
          input_list
        , boost::is_same&lt;boost::_1,int&gt;
        &gt; find; <span class="cxx-comment">// ok</span>
<p>
    typedef mpl::find_if<a href="./action=edit&id=find_if.html">?</a>&lt; 
          input_list
        , in_between&lt;boost::_1,int,double&gt; <span class="cxx-comment">// template has too many parameters</span>
        &gt; illegal_find;
</pre>
<p>
6) it's acceptable to limit the arity of functions that can be generated by expression template, e.g. 2 seems like an acceptable (from user's point of view) choice:
<p>
<pre>
    typedef mpl::transform<a href="./action=edit&id=transform.html">?</a>&lt;
          input_list1
        , input_list2
        , less_specialized&lt;boost::_1, boost::_2&gt;
        &gt; tranform; <span class="cxx-comment">// ok</span>
<p>
    typedef mpl::transform<a href="./action=edit&id=transform.html">?</a>&lt;
          input_list1
        , input_list2
        , less_specialized&lt;boost::_1, boost::_2, boost::_3&gt;
        &gt; illegal_tranform; <span class="cxx-comment">// not supported</span>
</pre>
<p><hr>
<a href="./Table_of_Content.html">Table of Content</a><br>Last edited December 23, 2001 2:11 pm</body></html>