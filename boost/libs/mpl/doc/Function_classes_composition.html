<!doctype html public "-//ietf//dtd html//en">
<html><head><title>boost::mpl::Function classes composition</title>
<link rel="stylesheet" href="./mpl_wiki.css">
</head><body bgcolor="white">
<h1><a href="./Table_of_Content.html"><img src="./mpl_logo.jpg" alt="[Home]" border=0 align="right"></a>Function classes composition</h1>As with the standard library, many of the <code>boost::mpl</code> algorithms take either predicates or transformation unary/binary function classes as their parameters, and as the experience shows that the ability to compose simple
predicates/functions into more complex ones is just as important in compile-time world as it is in run-time one, the library provides compile-time equivalent of boost::compose (boost/mpl/compose.hpp) and std::bind (boost/mpl/bind.hpp) functionality (see also <a href="./Expression_templates.html">Expression templates</a>).
<p>
<h3>Example
</h3>
<p>
<pre>
namespace mpl = boost::mpl;
<p>
<span class="cxx-comment">// find either a 'void' or a type convertible to 'int'</span>
typedef mpl::find_if<a href="./action=edit&id=find_if.html">?</a>&lt;
        types
      , mpl::compose_f_gx_hx<a href="./action=edit&id=compose_f_gx_hx.html">?</a>&lt;
            mpl::make_f_yx<a href="./action=edit&id=make_f_yx.html">?</a>&lt;<a href="./logical_or.html">mpl::logical or</a>&gt;
          , mpl::bind1st<a href="./action=edit&id=bind1st.html">?</a>&lt; mpl::make_f_xy<a href="./action=edit&id=make_f_xy.html">?</a>&lt;boost::is_same&gt;, void &gt;
          , mpl::bind2nd<a href="./action=edit&id=bind2nd.html">?</a>&lt; mpl::make_f_xy<a href="./action=edit&id=make_f_xy.html">?</a>&lt;boost::is_convertible&gt;, int &gt;
          &gt;
      &gt;::type itor;
</pre>
<p><hr>
<a href="./Table_of_Content.html">Table of Content</a><br>Last edited December 23, 2001 2:07 pm</body></html>