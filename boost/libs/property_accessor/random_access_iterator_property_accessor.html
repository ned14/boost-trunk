<HTML>
<!--
  -- Copyright (c) Jeremy Siek, Lie-Quan Lee, and Andrew Lumsdaine 2000
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  We make no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
<Head>
<Title>Random Access Iterator Property Accessor Adaptor</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<IMG SRC="../../../c++boost.gif" 
     ALT="C++ Boost"> 

<BR Clear>


<H2><A NAME="sec:random-access-iterator-property-accessor"></A>
<PRE>
random_access_iterator_property_accessor&lt;Iterator,T,R,OffsetPA&gt;
</PRE>
</H2>

<P>
This property accessor is an adaptor that converts any random access
iterator into a <a
href="./LvaluePropertyAccessor.html">LvaluePropertyAccessor</a>.
The <tt>OffsetPA</tt> type is responsible for converting
key objects to integers that can be used as offsets with the
random access iterator.

<P>

<h3>Example</h3>

<pre>
// print out the capacity and flow for all the edges in the graph
template &lt;class Graph, class CapacityPA, class FlowPA&gt;
void print_network(Graph& G, CapacityPA capacity, FlowPA flow)
{
  typedef typename boost::graph_traits&lt;Graph&gt;::vertex_iterator    Viter;
  typedef typename boost::graph_traits&lt;Graph&gt;::out_edge_iterator OutEdgeIter;
  typedef typename boost::graph_traits&lt;Graph&gt;::in_edge_iterator InEdgeIter;

  Viter ui, uiend;
  for (boost::tie(ui, uiend) = vertices(G); ui != uiend; ++ui) {
    OutEdgeIter out, out_end;
    std::cout &lt;&lt; *ui &lt;&lt; "\t";

    for(boost::tie(out, out_end) = out_edges(*ui, G); out != out_end; ++out)
      std::cout &lt;&lt; "--(" &lt;&lt; get(capacity, *out) &lt;&lt; ", " 
	   &lt;&lt; get(flow, *out) &lt;&lt; ")--> " &lt;&lt; target(*out,G) &lt;&lt; "\t";
    std::cout &lt;&lt; std::endl &lt;&lt; "\t";

    InEdgeIter in, in_end;    
    for(boost::tie(in, in_end) = in_edges(*ui, G); in != in_end; ++in)
      std::cout &lt;&lt; "<--(" &lt;&lt; get(capacity, *in) &lt;&lt; "," &lt;&lt; get(flow, *in) &lt;&lt; ")-- "
           &lt;&lt; source(*in,G) &lt;&lt; "\t";
    std::cout &lt;&lt; std::endl;
  }
}

int main(int, char*[])
{
  typedef boost::adjacency_list&lt;boost::vecS, boost::vecS, 
    boost::bidirectionalS, boost::no_plugin, 
    boost::plugin&lt;boost::id_tag, std::size_t&gt; &gt; Graph;

  const int num_vertices = 9;
  Graph G(num_vertices);

  int capacity[] = { 10, 20, 20, 20, 40, 40, 20, 20, 20, 10 };
  int flow[] = { 8, 12, 12, 12, 12, 12, 16, 16, 16, 8 };

  // add edges to the graph, and assign each edge an ID number
  // to index into the property arrays
  add_edge(G, 0, 1, 0);
  // ...

  typedef boost::graph_traits&lt;Graph&gt;::edge_descriptor Edge;
  typedef boost::edge_property_accessor&lt;Graph, boost::id_tag&gt;::type EdgeID_PA;
  EdgeID_PA edge_id = get_edge_property_accessor(G, boost::id_tag());

  boost::random_access_iterator_property_accessor&lt;int*, int, int&, EdgeID_PA&gt;
     capacity_pa(capacity, edge_id),
     flow_pa(flow, edge_id);

  print_network(G, capacity_pa, flow_pa);
          
  return 0;
}
</pre>

<H3>Where Defined</H3>

<P>
<a href="../../boost/property_accessor.hpp"><TT>boost/property_accessor.hpp</TT></a>

<p>
<H3>Model Of</H3>

<a href="./LvaluePropertyAccessor.html">LvaluePropertyAccessor</a>

<P>

<H3>Template Parameters</H3>

<P>

<TABLE border>
<TR>
<th>Parameter</th><th>Description</th><th>Default</th>
</tr>


<TR>
<TD><TT>Iterator</TT></TD> 
<TD>Must be a model of <a href="http://www.sgi.com/Technology/STL/RandomAccessIterator.html">RandomAccessIterator</a>.</TD>
<TD>&nbsp;</td>
</tr>

<TR>
<TD><TT>T</TT></TD>
<TD>The value type of the iterator.</TD>
<TD><TT>std::iterator_traits&lt;RandomAccessIterator&gt;::value_type</TT></TD>
</TR>


<TR>
<TD><TT>R</TT></TD>
<TD>The reference type of the iterator.</TD>
<TD><TT>std::iterator_traits&lt;RandomAccessIterator&gt;::reference</TT></TD>
</TR>

<TR>
<TD><TT>OffsetPA</TT></TD> <TD>Must be a model of <a
href="./ReadablePropertyAccessor.html">ReadablePropertyAccessor</a>
and the value type must be convertible to the difference type of the
iterator.</TD> <TD><TT>boost::identity_property_accessor</TT></TD>
</TR>

</TABLE>
<P>

<H3>Members</H3>

<P>
In addition the methods and functions required by <a
href="./LvaluePropertyAccessor.html">LvaluePropertyAccessor</a>, this
class has the following members.

<P>
 
<table border>
<tr>
<th>Member</th><th>Description</th>
</tr>

<tr>
<td><tt>
value_type
</tt></td>
<td>This will be the same type as
<TT>std::iterator_traits&lt;Iterator&gt;::value_type</TT>.
</td>
</tr>

<tr>
<td><tt>
random_access_iterator_property_accessor(Iterator i)
</tt></td>
<td>
Constructor.
</td>
</tr>


<tr>
<td><tt>
reference operator[](difference_type v) const
</tt></td>
<td>
The operator bracket for property access. The <TT>reference</TT> and
<TT>difference_type</TT> types are from  
<TT>std::iterator_traits&lt;Iterator&gt;</TT>.
</td>
</tr>

</table>



<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy 2000</TD><TD>
<A HREF=http://www.boost.org/people/jeremy_siek.htm>Jeremy Siek</A>,
Univ.of Notre Dame (<A
HREF="mailto:jsiek@lsc.nd.edu">jsiek@lsc.nd.edu</A>)<br>
<A HREF=http://www.lsc.nd.edu/~llee1>Lie-Quan Lee</A>, Univ.of Notre Dame (<A HREF="mailto:llee1@lsc.nd.edu">llee1@lsc.nd.edu</A>)<br>
<A HREF=http://www.lsc.nd.edu/~lums>Andrew Lumsdaine</A>,
Univ.of Notre Dame (<A
HREF="mailto:lums@lsc.nd.edu">lums@lsc.nd.edu</A>)
</TD></TR></TABLE>

</BODY>
</HTML> 
