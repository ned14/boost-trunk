<HTML>
<!--
  -- Copyright (c) Jeremy Siek 2000
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Jeremy Siek makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
<Head>
<Title>Boost Graph Library: Dijkstra's Shortest Paths</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
        ALINK="#ff0000"> 
<IMG SRC="../../../c++boost.gif" 
     ALT="C++ Boost" width="277" height="86"> 

<BR Clear>

<H1><A NAME="sec:dijkstra"></A>
<TT>dijkstra_shortest_paths</TT>
</H1>

<P>
<DIV ALIGN="left">
<TABLE CELLPADDING=3 border>
<TR><TH ALIGN="LEFT"><B>Graphs:</B></TH>
<TD ALIGN="LEFT">directed and undirected</TD>
</TR>
<TR><TH ALIGN="LEFT"><B>Properties:</B></TH>
<TD ALIGN="LEFT">color, distance, weight, vertex index</TD>
</TR>
<TR><TH ALIGN="LEFT"><B>Complexity:</B></TH>
<TD ALIGN="LEFT"><i>O((V + E) log V)</i>
</TD>
</TR>
<TR><TH ALIGN="LEFT"><B>Where Defined:</B></TH>
<TD ALIGN="LEFT">
<a href="../../../boost/graph/dijkstra_shortest_paths.hpp"><TT>boost/graph/dijkstra_shortest_paths.hpp</TT></a>
</TD>
</TR>
</TABLE>
</DIV>

<P>
<PRE>
(1)
template &lt;class <a href="./VertexListGraph.html">VertexListGraph</a>&gt;
void
dijkstra_shortest_paths(VertexListGraph& g,
  typename graph_traits&lt;VertexListGraph&gt;::vertex_descriptor s);

(2)
template &lt;class <a href="./VertexListGraph.html">VertexListGraph</a>, class <a href="#DistanceMap">DistanceMap</a>&gt;
void
dijkstra_shortest_paths(VertexListGraph& g,
  typename graph_traits&lt;VertexListGraph&gt;::vertex_descriptor s, 
  DistanceMap d);

(3)
template &lt;class <a href="./VertexListGraph.html">VertexListGraph</a>, class <a href="#DistanceMap">DistanceMap</a>, class <a href="./UniformCostVisitor.html">UniformCostVisitor</a>&gt;
void
dijkstra_shortest_paths(VertexListGraph& g, 
  typename graph_traits&lt;VertexListGraph&gt;::vertex_descriptor s, 
  DistanceMap d, UniformCostVisitor visit);

(4)
template &lt;class <a href="./VertexListGraph.html">VertexListGraph</a>, class <a href="./UniformCostVisitor.html">UniformCostVisitor</a>, 
          class <a href="#DistanceMap">DistanceMap</a>, class <a href="#WeightMap">WeightMap</a>, class <a href="#ColorMap">ColorMap</a>, class <a href="#VertexIndexMap">VertexIndexMap</a>&gt;
void
dijkstra_shortest_paths(VertexListGraph& g,
  typename graph_traits&lt;VertexListGraph&gt;::vertex_descriptor s, 
  DistanceMap distance, WeightMap weight, ColorMap color, VertexIndexMap id,
  UniformCostVisitor vis);
</PRE>

<P>
This is the modified Dijkstra algorithm&nbsp;[<A
 HREF="bibliography.html#dijkstra59">10</A>,<A
 HREF="bibliography.html#clr90">8</A>] which solves the single-source
 shortest-paths problem on a weighted, directed graph for the case
 where all edge weights are nonnegative.  See Section <A
 HREF="graph_theory_review.html#sec:shortest-path-algorithms">Shortest-Paths Algorithms</A>
 for some background to the shortest-path problem. The priority queue
 used inside the algorithm is implemented with a heap for efficiency.

<P>
There are four versions of the algorithm to accommodate whether the
necessary graph properties will be supplied by the graph object or
externally via a argument to this function. The properties needed by
the algorithm are distance, weight, color, and vertex index. Version 3
and 4 of the algorithm also include a visitor argument for added
extensibility.

<P>

<H3>Requirements on Types</H3>

<P>

<UL>
<LI>The type <TT>VertexListGraph</TT> must be a model of <a href="./VertexListGraph.html">VertexListGraph</a>.
</LI>
<li>In version (1) of the algorithm, the graph must be a <a href="./PropertyGraph.html">PropertyGraph</a> with respect to <tt>vertex_color_t</tt>,
 <tt>vertex_distance_t</tt>, <tt>edge_weight_t</tt>, and <tt>vertex_index_t</tt></li>

<li>In version (2) of the algorithm, the graph must be a <a href="./PropertyGraph.html">PropertyGraph</a> with respect to <tt>vertex_color_t</tt>,
 <tt>edge_weight_t</tt>, and <tt>vertex_index_t</tt></li>

<li>In version (3) of the algorithm, the graph must be a <a href="./PropertyGraph.html">PropertyGraph</a> with respect to <tt>vertex_color_t</tt>,
 <tt>edge_weight_t</tt>, and <tt>vertex_index_t</tt></li>

<LI>The type <TT>UniformCostVisitor</TT> must be a model of <a href="./UniformCostVisitor.html">UniformCostVisitor</a>.
</LI>
<LI><a name="DistanceMap">The type <TT>DistanceMap</TT> must be a model of <a
    href="../../property_map/ReadWritePropertyMap.html">ReadWritePropertyMap</a>. The
    vertex descriptor type of the graph needs to be usable as the key
    type of the distance map. The value type of the distance
    map must be <a href="http://www.sgi.com/Technology/STL/LessThanComparable.html">LessThanComparable</a>.</a>
</LI>
<LI><a name="WeightMap">The type <TT>WeightMap</TT> must be a model of <a
     href="../../property_map/ReadablePropertyMap.html">ReadablePropertyMap</a>. The
     edge descriptor type of the graph needs to be usable as the key
     type for the weight map. The value type for the map
     must be <I>Addable</I> with the value type of the distance
     map.</a>
</LI>
<LI><a name="ColorMap">The type <TT>ColorMap</TT> must be a model of
     <a href="../../property_map/ReadWritePropertyMap.html">ReadWritePropertyMap</a>. A vertex descriptor must be
     usable as the key type of the map, and the value type of the
     map must be a model of <a href="./ColorValue.html">ColorValue</a>.</a>
</LI>
<LI><a name="VertexIndexMap">The type <TT>VertexIndexMap</TT> must be a model of <a
     href="../../property_map/ReadablePropertyMap.html">ReadablePropertyMap</a>. The
     value type of <TT>VertexIndexMap</TT> must be an integer type. The
     integers must map vertex descriptors to the integers zero through
     <tt>num_vertices(g) - 1</tt>. The vertex
     descriptor type of the graph needs to be usable as the key type
     of the vertex index map.</a>
</LI>
</UL>

<P>

<H3>Complexity</H3>

<P>
The time complexity is <i>O((V + E) log V)</i>, or just <i>O(E log V)</i>
if all vertices are reachable from the source.

<H3>Example</H3>

<P>
The source code for this example is in <a
href="../examples/dijkstra.cpp"><TT>examples/dijkstra.cpp</TT></a>.

<P>
<PRE>
int 
main(int , char* [])
{
  using namespace boost;

  typedef property&lt;edge_weight_t, int&gt; weightp;
  typedef adjacency_list&lt; listS, vecS, directedS, 
    property&lt;vertex_color_t,default_color_type&gt;, weightp &gt; Graph;
  typedef graph_traits&lt;Graph&gt;::vertex_descriptor Vertex;

  typedef std::pair&lt;int,int&gt; E;

  const int num_nodes = 5;
  E edges[] = { E(0,2), 
                E(1,1), E(1,3), E(1,4),
                E(2,1), E(2,3), 
                E(3,4),
                E(4,0), E(4,1) };
  int weights[] = { 1, 2, 1, 2, 7, 3, 1, 1, 1};

  Graph G(num_nodes, edges, edges + sizeof(edges)/sizeof(E), weights);

  std::vector&lt;Vertex&gt; p(num_vertices(G));
  std::vector&lt;int&gt; d(num_vertices(G));

  Vertex s = *(vertices(G).first);
  p[s] = s;  
  dijkstra_shortest_paths(G, s, &d[0], 
    make_ucs_visitor(record_predecessors(&p[0], on_edge_relaxed())));

  std::cout &lt;&lt; "distances from start vertex:" &lt;&lt; std::endl;
  graph_traits&lt;Graph&gt;::vertex_iterator vi, vend;
  for(tie(vi,vend) = vertices(G); vi != vend; ++vi)
    std::cout &lt;&lt; "distance(" &lt;&lt; *vi &lt;&lt; ") = " &lt;&lt; d[*vi] &lt;&lt; std::endl;
  std::cout &lt;&lt; std::endl;

  std::cout &lt;&lt; "shortest paths tree" &lt;&lt; std::endl;
  adjacency_list&lt;&gt; tree(num_nodes);
  
  for(tie(vi,vend) = vertices(G); vi != vend; ++vi)
    if (*vi != p[*vi])
      add_edge(p[*vi], *vi, tree);

  print_graph(tree);

  return 0;
}
</PRE>
The output is:
<PRE>
  distances from start vertex:
  distance(0) = 0
  distance(1) = 6
  distance(2) = 1
  distance(3) = 4
  distance(4) = 5

  shortest paths tree
  0 --> 2 
  1 --> 
  2 --> 3 
  3 --> 4 
  4 --> 1 
</PRE>


<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy 2000</TD><TD>
<A HREF=http://www.boost.org/people/jeremy_siek.htm>Jeremy Siek</A>, Univ.of Notre Dame (<A HREF="mailto:jsiek@lsc.nd.edu">jsiek@lsc.nd.edu</A>)
</TD></TR></TABLE>

</BODY>
</HTML> 
