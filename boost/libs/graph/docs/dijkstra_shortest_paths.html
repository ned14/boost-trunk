<HTML>
<!--
  -- Copyright (c) Jeremy Siek 2000
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Jeremy Siek makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
<Head>
<Title>Boost Graph Library: Dijkstra's Shortest Paths</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<IMG SRC="../../../c++boost.gif" 
     ALT="C++ Boost"> 

<BR Clear>

<H1><A NAME="sec:dijkstra"></A>
<TT>dijkstra_shortest_paths</TT>
</H1>

<P>
<DIV ALIGN="left">
<TABLE CELLPADDING=3 border>
<TR><TH ALIGN="LEFT"><B>Graphs:</B></TH>
<TD ALIGN="LEFT">directed or undirected</TD>
</TR>
<TR><TH ALIGN="LEFT"><B>Properties:</B></TH>
<TD ALIGN="LEFT">color, distance, weight, vertex ID</TD>
</TR>
<TR><TH ALIGN="LEFT"><B>Complexity:</B></TH>
<TD ALIGN="LEFT"><i>O((V + E) log V)</i>
</TD>
</TR>
</TABLE>
</DIV>

<P>
<PRE>
(1)
template &lt;class VertexListGraph, class Vertex,
          class Distance&gt;
void dijkstra_shortest_paths(VertexListGraph&amp; G, Vertex s);

(2)
template &lt;class VertexListGraph, class Vertex,
          class Distance&gt;
void dijkstra_shortest_paths(VertexListGraph&amp; G, Vertex s, 
                             Distance d)

(3)
template &lt;class VertexListGraph, class Vertex, 
          class Distance, class Weight, class Visitor&gt;
void dijkstra_shortest_paths(VertexListGraph&amp; G, Vertex s, 
                             Distance d, Visitor visit)

(4)
template &lt;class VertexListGraph, class Vertex, 
          class Distance, class Weight, class Color, 
          class ID, class Visitor&gt;
void dijkstra_shortest_paths(VertexListGraph&amp; G, Vertex s, 
                             Distance d, Weight w, Color c, ID id,
                             Visitor visit);
</PRE>

<P>
This is the modified Dijkstra algorithm&nbsp;[<A
 HREF="bibliography.html#dijkstra59">10</A>,<A
 HREF="bibliography.html#clr90">8</A>] which
solves the single-source shortest-paths problem on a weighted,
directed graph for the case where all edge weights are nonnegative.
See Section&nbsp;<A HREF="#sec:shortest-path-algorithms"><IMG  ALIGN="BOTTOM" BORDER="1" ALT="[*]"
 SRC="file:/usr/local/src/teTeX00/lib/latex2html/icons/crossref.gif"></A> for some background to
the shortest-path problem. The priority queue used inside the
algorithm is implemented with a heap for efficiency.

<P>
There are four versions of the algorithm to accommodate whether the
necessary graph properties will be supplied by the graph object or
externally via a argument to this function. The properties needed by
the algorithm are distance, weight, and vertex ID. Version 4 of the
algorithm also includes a visitor argument for added extensibility.

<P>

<H3>Where Defined</H3>
<a href="../../../boost/graph/dijkstra_shortest_paths.hpp"><TT>boost/graph/dijkstra_shortest_paths.hpp</TT></a>

<P>

<H3>Requirements on Types</H3>

<P>

<UL>
<LI>The type <TT>VertexListGraph</TT> must be a model of <a href="./VertexListGraph.html">VertexListGraph</a>.
</LI>
<LI>The type <TT>Vertex</TT> must be convertible to type <TT>graph_traits&lt;VertexListGraph&gt;::vertex_descriptor</TT>.
</LI>
<LI>The type <TT>Visitor</TT> must be a model of <I>Visitor</I>.
</LI>
<LI>The type <TT>Distance</TT> must be a model of <a
    href="../../property_accessor/ReadWritePropertyAccessor.html">ReadWritePropertyAccessor</a>. The
    vertex descriptor type of the graph needs to be usable as the key
    type of the distance accessor. The value type of the distance
    accessor must be <I>LessThanComparable</I>.
</LI>
<LI>The type <TT>Weight</TT> must be a model of <a
     href="../../property_accessor/ReadablePropertyAccessor.html">ReadablePropertyAccessor</a>. The
     edge descriptor type of the graph needs to be usable as the key
     type for the weight accessor. The value type for the accessor
     must be <I>Addable</I> with the value type of the distance
     accessor.
</LI>
<LI>The type <TT>Color</TT> must be a model of
     <a href="../../property_accessor/ReadWritePropertyAccessor.html">ReadWritePropertyAccessor</a>. A vertex descriptor must be
     usable as the key type of the accessor, and the value type of the
     accessor must be a model of <I>ColorValue</I>.
</LI>
<LI>The type <TT>ID</TT> must be a model of <a
     href="../../property_accessor/ReadablePropertyAccessor.html">ReadablePropertyAccessor</a>. The
     value type of <TT>ID</TT> must be an integer type. The vertex
     descriptor type of the graph needs to be usable as the key type
     of the ID accessor.
</LI>
</UL>

<P>

<H3>Complexity</H3>

<P>
The time complexity is <i>O((V + E) log V)</i>, or just <i>O(E log V)</i>
if all vertices are reachable from the source.

<H3>Example</H3>

<P>
The source code for this example is in <a
href="../examples/dijkstra.cpp"><TT>examples/dijkstra.cpp</TT></a>.

<P>
<PRE>
  typedef weight_plugin&lt;int&gt; weightp;
  typedef adjacency_list&lt; listS, vecS, directedS, 
                          no_vertex_plugin, weightp &gt; Graph;
  typedef graph_traits&lt;Graph&gt;::vertex_descriptor Vertex;

  typedef std::pair&lt;int,int&gt; E;

  const int num_nodes = 5;
  E edges[] = { E(0,2), 
                E(1,1), E(1,3), E(1,4),
                E(2,1), E(2,3), 
                E(3,4),
                E(4,0), E(4,1) };
  int weights[] = { 1, 2, 1, 2, 7, 3, 1, 1, 1};

  Graph G(num_nodes, edges, edges + sizeof(edges)/sizeof(E), weights);

  std::vector&lt;Vertex&gt; p(num_vertices(G));
  std::vector&lt;int&gt; d(num_vertices(G));

  Vertex s = *(vertices(G).first);

  dijkstra_shortest_paths(G, s, d.begin(), visit_predecessor_ptr(p.begin()));

  std::cout &lt;&lt; "distances from start vertex:" &lt;&lt; std::endl;
  graph_traits&lt;Graph&gt;::vertex_iterator vi;
  for(vi = vertices(G).first; vi != vertices(G).second; ++vi)
    std::cout &lt;&lt; "distance(" &lt;&lt; index(*vi) &lt;&lt; ") = " &lt;&lt; d[*vi] &lt;&lt; std::endl;
  std::cout &lt;&lt; std::endl;

  std::cout &lt;&lt; "parents in the tree of shortest paths:" &lt;&lt; std::endl;
  for(vi = vertices(G).first; vi != vertices(G).second; ++vi) {
    std::cout &lt;&lt; "parent(" &lt;&lt; index(*vi);
    if ( p[*vi] == Vertex() )
      std::cout &lt;&lt; ") = no parent" &lt;&lt; std::endl; 
    else 
      std::cout &lt;&lt; ") = " &lt;&lt; index(p[*vi]) &lt;&lt; std::endl;
  }
</PRE>
The output is:
<PRE>
  distances from start vertex:
  distance(0) = 0
  distance(1) = 6
  distance(2) = 1
  distance(3) = 4
  distance(4) = 5

  parents in the tree of shortest paths:
  parent(0) = no parent
  parent(1) = 4
  parent(2) = 0
  parent(3) = 2
  parent(4) = 3
</PRE>


<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy 2000</TD><TD>
<A HREF=http://www.boost.org/people/jeremy_siek.htm>Jeremy Siek</A>, Univ.of Notre Dame (<A HREF="mailto:jsiek@lsc.nd.edu">jsiek@lsc.nd.edu</A>)
</TD></TR></TABLE>

</BODY>
</HTML> 
