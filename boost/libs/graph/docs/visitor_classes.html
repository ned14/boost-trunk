<HTML>
<!--
  -- Copyright (c) Jeremy Siek, Lie-Quan Lee, and Andrew Lumsdaine 2000
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  We make no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
<Head>
<Title>Boost Graph Library: Visitor Classes</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<IMG SRC="c++boost.gif" 
     ALT="C++ Boost"> 

<BR Clear>

<H1><A NAME="sec:foundation-visitor-classes"></A>
Foundation Visitor Classes
</H1>

<P>
Foundation visitor is just the name we use for visitor classes that are
used inside the implementation of  BGL algorithms. Typically you will
never need to see or use these classes, however perhaps they will be
of interest as examples or can reused in some unforeseen
circumstances.

<P>

<UL>
<LI><TT>coloring_visitor</TT> 
<BR>
This visitor is used inside the <TT>breadth_first_search()</TT>
  family of algorithms. The main responsibility of this visitor is to
  keep track of the progress of the algorithm through the graph by
  coloring the graph.

<P>
</LI>
<LI><TT>dfs_visitor</TT> 
<BR>
This visitor is used inside the <TT>depth_first-_search()</TT> family of
  algorithms. Like the <TT>coloring_visitor</TT>, the responsibility
  of this visitor is to color the graph to control the progress
  of the algorithm.

<P>
</LI>
<LI><TT>weighted_edge_visitor</TT> 
<BR>
This visitor is used for Prim's algorithm for minimum spanning tree and
  Dijkstra's algorithm for single-source shortest paths. This visitor
  is responsible for calculating and <I>relaxing</I> the distances
  to the vertices.

<P>
</LI>
<LI><TT>topo_sort_visitor</TT> 
<BR>
This visitor is used inside the <TT>topological_sort()</TT> algorithm,
 and is responsible for feeding vertices to the output-iterator
 during the execution of a <TT>depth_first_search()</TT>.

<P>
</LI>
<LI><TT>components_visitor</TT> 
<BR>
This visitor is used in the strongly connected components algorithm
  for recording to which component a vertex belongs.

<P>
</LI>
</UL>

<H1><A NAME="sec:user-visitor-classes"></A>
User-Level Visitor Classes
</H1>

<P>
There are a handful of visitors defined by BGL, but the visitor
mechanism is mainly intended as a way for users to extend BGL with
their own custom visitors. Use the BGL visitors as examples for how to
implement you own. The visitors in this section are models of <a
href="./UserVisitor.html">UserVisitor</a>.

<P>

<hr>

<H2><TT>null_visitor</TT></H2>

<P>
This is a visitor that does nothing. It is useful as a base class for
user-defined visitors that only implement some of the visitor
methods. The unimplemented methods will default to the empty ones in
the <TT>base_visitor</TT> class. Due to deficiencies in VC++ this class
can not be used with that compiler. Use <TT>base_visitor</TT> instead
if you need VC++ portability.

<P>

<H3>Members</H3>

<P>
 
<P> <P>
 <PRE>
null_visitor::category
</PRE>
The category for this visitor is <TT>every_edge_tag</TT>.

<P>

<P> <P>
 <PRE>
template &lt;class Vertex&gt;
void null_visitor::initialize(Vertex u) { }
</PRE>

<P>

<P> <P>
 <PRE>
template &lt;class Vertex&gt;
void null_visitor::start(Vertex s) { }
</PRE>

<P>

<P> <P>
 <PRE>
template &lt;class Vertex&gt;
void null_visitor::discover(Vertex s) { }
</PRE>

<P>

<P> <P>
 <PRE>
template &lt;class Vertex&gt;
void null_visitor::finish(Vertex s) { }
</PRE>

<P>

<P> <P>
 <PRE>
template &lt;class Edge, class Graph&gt;
void null_visitor::process(Edge e, Graph&amp; g) { }
</PRE>

<P>
 
<P>

<hr>


<H2><A NAME="SECTION001542000000000000000">
<TT>base_visitor</TT></A>
</H2>

<P>
<PRE>
base_visitor&lt;Visitor&gt;
</PRE>

<P>
This is a visitor that does nothing. It is useful as a base class for
user-defined visitors that only implement some of the visitor
methods. The unimplemented methods will default to the empty ones in
the <TT>base_visitor</TT> class. The template argument <TT>Visitor</TT>
must be the deriving visitor class. This class is a workaround for
VC++. If VC++ portability is not an issue use <TT>null_visitor</TT>
instead.

<P>

<H3><A NAME="SECTION001542100000000000000">
Members</A>
</H3>

<P>
 
<P> <P>
 <PRE>
base_visitor::category
</PRE>
The category for this visitor is <TT>every_edge_tag</TT>.

<P>

<P> <P>
 <PRE>
template &lt;class Vertex&gt;
void base_visitor::initialize(Vertex u) { }
</PRE>

<P>

<P> <P>
 <PRE>
template &lt;class Vertex&gt;
void base_visitor::start(Vertex s) { }
</PRE>

<P>

<P> <P>
 <PRE>
template &lt;class Vertex&gt;
void base_visitor::discover(Vertex s) { }
</PRE>

<P>

<P> <P>
 <PRE>
template &lt;class Vertex&gt;
void base_visitor::finish(Vertex s) { }
</PRE>

<P>

<P> <P>
 <PRE>
template &lt;class Edge, class Graph&gt;
void base_visitor::process(Edge e, Graph&amp; g) { }
</PRE>

<P>
 
<P>

<hr>


<H2><A NAME="SECTION001543000000000000000">
<TT>distance_visitor</TT></A>
</H2>

<P>
<PRE>
distance_visitor&lt;Distance&gt;
</PRE>

<P>
The distance visitor records the distance from the starting vertex to
each vertex in a search tree. The type of search tree depends on the
algorithm being applied.

<P>

<H3>Example</H3>

<P>

<H3>Template Parameters</H3>

<P>
<TABLE border>
<TR><TD><TT>Distance</TT></TD> 
<TD>Must be a model of <a
href="./ReadWritePropertyAccessor.html">ReadWritePropertyAccessor</a>.</TD>
</TR>
</TABLE>
<P>

<H3>Model of</H3>

<P>
<a href="./Visitor.html">Visitor</a>

<P>

<H3>Members</H3>

<P>
 
<P> <P>
 <PRE>
distance_visitor::category
</PRE>
The visitor category for this class is <TT>tree_edge_tag</TT>.

<P>

<P> <P>
 <PRE>
distance_visitor::distance_visitor(Distance p)
</PRE>
Constructor.

<P>

<P> <P>
 <PRE>
template &lt;class Vertex&gt;
distance_visitor::initialize(Vertex u)
</PRE>
This initializes the distance property for all the vertices
to <TT>std::numeric_limits&lt;T&gt;::max()</TT> where <TT>T</TT> is
the value type of the distance property accessor.

<P>

<P> <P>
 <PRE>
template &lt;class Vertex&gt;
distance_visitor::start(Vertex u)
</PRE>
This initializes the distance of the starting vertex to zero.

<P>

<P> <P>
 <PRE>
template &lt;class Edge, class Graph&gt;
distance_visitor::process(Edge e, Graph&amp; g)
</PRE>
This records the distance of for the <TT>target(e,g)</TT> as
<TT>d[source(e,g)] + 1</TT>.

<P>
 
<P>

<hr>

<H2><TT>predecessor_visitor</TT>
</H2>

<P>
<PRE>
predecessor_visitor&lt;Predecessor&gt;
</PRE>

<P>
The predecessor visitor records the predecessors (or parents) of the
nodes in a search tree, where the search tree depends on the kind of
graph search algorithm being applied.

<P>

<H3><A NAME="SECTION001544100000000000000">
Example</A>
</H3>

<P>

<H3><A NAME="SECTION001544200000000000000">
Template Parameters</A>
</H3>

<P>
<TABLE border>
<TR><TD><TT>Predecessor</TT></TD>
<TD>Must be a model of <a
href="./WritablePropertyAccessor.html">WritablePropertyAccessor</a>.</TD>
</TR>
</TABLE>
<P>

<H3>Model of</H3>

<P>
<a href="./Visitor.html">Visitor</a>

<P>

<H3>Members</H3>

<P>
 
<P> <P>
 <PRE>
predecessor_visitor::category
</PRE>
The visitor category for this class is <TT>tree_edge_tag</TT>.

<P>

<P> <P>
 <PRE>
predecessor_visitor::predecessor_visitor(Predecessor p)
</PRE>
Constructor.

<P>

<P> <P>
 <PRE>
template &lt;class Edge, class Graph&gt;
predecessor_visitor::process(Edge e, Graph&amp; g)
</PRE>
This method records the predecessor (or parent), where
<TT>target(e)</TT> is the parent and <TT>source(e)</TT> is the child.
The implementation is simply <TT>p[target(e,g)] = source(e,g)</TT>.  
<P>

<hr>

<H2><TT>timestamp_visitor</TT></H2>

<P>
<PRE>
timestamp_visitor&lt;DiscoverTime,FinishTime&gt;
</PRE>

<P>
The time-stamp visitor is for recording the ``discover'' and
``finish'' order for vertices during a graph search. The time-stamp
starts at zero and increments one each time a vertex is discovered or
finished.

<P>

<H3>Example</H3>

<P>

<H3>Template Parameters</H3>

<P>
<TABLE border>
<TR><TD><TT>DiscoverTime</TT></TD>
<TD>Must be a model of <a
href="./WritablePropertyAccessor.html">WritablePropertyAccessor</a>.</TD>
</TR>
<TR><TD><TT>FinishTime</TT></TD>
<TD>Must be a model of <a
href="./WritablePropertyAccessor.html">WritablePropertyAccessor</a>.</TD>
</TR>
</TABLE>
<P>

<H3>Model of</H3>

<P>
<a href="./Visitor.html">Visitor</a>

<P>

<H3>Members</H3>

<P>
 
<P> <P>
 <PRE>
timestamp_visitor::category
</PRE>
The visitor category for this class is <TT>tree_edge_tag</TT>.

<P>

<P> <P>
 <PRE>
timestamp_visitor::timestamp_visitor(DiscoverTime d, FinishTime f)
</PRE>
Constructor.

<P>

<P> <P>
 <PRE>
template &lt;class Vertex&gt;
timestamp_visitor::discover(Vertex u)
</PRE>
This method records the discover time for vertex <TT>u</TT>. The
implementation is simply <TT>d[u] = ++time</TT>.

<P>

<P> <P>
 <PRE>
template &lt;class Vertex&gt;
timestamp_visitor::finish(Vertex u)
</PRE>
This method records the finish time for vertex <TT>u</TT>. The
implementation is simply <TT>f[u] = ++time</TT>.

<P>
 
<P>





<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy 2000</TD><TD>
<A HREF=http://www.boost.org/people/jeremy_siek.htm>Jeremy Siek</A>,
Univ.of Notre Dame (<A
HREF="mailto:jsiek@lsc.nd.edu">jsiek@lsc.nd.edu</A>)<br>
<A HREF=http://www.lsc.nd.edu/~llee1>Lie-Quan Lee</A>, Univ.of Notre Dame (<A HREF="mailto:llee1@lsc.nd.edu">llee1@lsc.nd.edu</A>)<br>
<A HREF=http://www.lsc.nd.edu/~lums>Andrew Lumsdaine</A>,
Univ.of Notre Dame (<A
HREF="mailto:lums@lsc.nd.edu">lums@lsc.nd.edu</A>)
</TD></TR></TABLE>

</BODY>
</HTML> 
