<HTML>
<!--
  -- Copyright (c) Jeremy Siek 2000
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Jeremy Siek makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
<Head>
<Title>Boost Graph Library: Connected Components</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<IMG SRC="c++boost.gif" 
     ALT="C++ Boost"> 

<BR Clear>


<H1>
<A NAME="sec:connected-components"></A><A NAME="sec:strongly-connected-components"></A>
<TT>connected_components</TT>
</H1>

<P>
<DIV ALIGN="left">
<TABLE CELLPADDING=3 border>
<TR><TH ALIGN="LEFT"><B>Graphs:</B></TH>
<TD ALIGN="LEFT">see below</TD>
</TR>
<TR><TH ALIGN="LEFT"><B>Properties:</B></TH>
<TD ALIGN="LEFT">components, color, discover time, finish time</TD>
</TR>
<TR><TH ALIGN="LEFT"><B>Complexity:</B></TH>
<TD ALIGN="LEFT"><i>O(V + E)</i></TD>
</TR>
</TABLE>
</DIV>

<P>
<PRE>
(1)
template &lt;class VertexListGraph, class Visitor, 
          class Components&gt;
typename property_traits&lt; Components &gt;::value_type
connected_components(VertexListGraph&amp; G, Components c,
                     Visitor v);

(2)
template &lt;class VertexListGraph, class Visitor, 
          class Components, class Color&gt;
typename property_traits&lt;Components&gt;::value_type
connected_components(VertexListGraph&amp; G, Components c, 
                     Color color, Visitor v);

(3)
template &lt;class VertexListGraph, class Visitor, 
          class Components, class DiscoverTime, 
          class FinishTime, class Color&gt;
typename property_traits&lt;Components&gt;::value_type
connected_components(VertexListGraph&amp; G, Components c, 
                     DiscoverTime d, FinishTime f, 
                     Color color, Visitor v);
</PRE>

<P>
The <TT>connected_component()</TT> function dispatches to two different
algorithms depending on whether the graph in question is directed or
undirected.

<P>

<UL>
<LI>Computes the strongly connected components of a directed graph
    using the DFS/transpose/DFS algorithm&nbsp;[<A
 HREF="bibliography.html#aho83:_data_struct_algo">1</A>,<A
 HREF="bibliography.html#clr90">8</A>].

<P>
</LI>
<LI>Computes the connected components of an undirected graph using
    a DFS-based approach. If the connected-components are to be
    calculated over and over while a graph is changing the disjoint-set
    based approach of function
    <TT>dynamic_connected_components()</TT> is faster. For
    ``static'' graphs this DFS-based approach is faster&nbsp;[<A
 HREF="bibliography.html#clr90">8</A>].
</LI>
</UL>

<P>
The output of the algorithm is recorded in the component property
accessor <TT>c</TT>, which will contain numbers giving the component ID
assigned to each vertex. The number of components is the return value
of the function.

<P>
The algorithm requires the use of several property accessors: color,
discover time, and finish time. There are several versions of this
algorithm to accommodate whether you wish to use interior or exterior
property accessors.

<P>

<H3>Where Defined</H3>

<P>
<a href="../../../boost/graph/connected_components.hpp"><TT>boost/graph/connected_components.hpp</TT></a>

<P>

<H3>Definitions</H3>

<P>
A <I>connected component</I> of an undirected graph is a set of
vertices that are all reachable from each other.  A <I>strongly
connected component</I> of a directed graph <i>G=(V,E)</i> is a
maximal set of vertices <i>U</i> which is in <i>V</i> such that for
every pair of vertices <i>u</i> and <i>v</i> in <i>U</i>, we have both
a path from <i>u</i> to <i>v</i> and path from <i>v</i> to
<i>u</i>. That is to say that <i>u</i> and <i>v</i> are reachable from
each other.

<P>

<H3>Requirements on Types</H3>

<P>

<UL>
<LI>The graph type must be a model of <a
href="./VertexListGraph.html">VertexListGraph</a>.
 
</LI>
<LI><TT>DiscoverTime</TT> and <TT>FinishTime</TT> must be models of <a
 href="../../property_accessor/WritablePropertyAccessor.html">WritablePropertyAccessor</a>
 and their value type must be an integer type. Vertex descriptors from
 the graph should be usable as the key type for these accessors.
</LI>
<LI>The <TT>Color</TT> accessor must be a <a
     href="../../property_accessor/ReadWritePropertyAccessor.html">ReadWritePropertyAccessor</a>
     and the graph's vertex descriptor type should be usable as the
     accessor's key type. The value type of the accessor must be a
     model of <I>ColorValue</I>.
</LI>
<LI>The <TT>Components</TT> type must be a model of <a
    href="../../property_accessor/ReadWritePropertyAccessor.html">ReadWritePropertyAccessor</a>. The
    value type of the <TT>Components</TT> property accessor should be
    an integer type, preferably the same as the <TT>size_type</TT> of
    the graph. The key type should be the graph's vertex descriptor
    type.
</LI>
</UL>

<P>

<H3>Complexity</H3>

<P>
The time complexity for the strongly connected components algorithm is
<i>O(V + E)</i>.  The time complexity for the connected components
algorithm is also <i>O(V + E)</i>.

<P>

<H3>Example</H3>

<P>
Calculating the connected components of an undirected graph. The
complete source is in file <a
href="../examples/connected_components.cpp"><tt>examples/connected_components.cpp</tt></a>.

<P>
<PRE>
  typedef discover_time_plugin&lt; finish_time_plugin
                                &lt; color_plugin&lt;&gt; &gt; &gt; VertexPlugin;
  typedef adjacency_list &lt;vecS, vecS, undirectedS, VertexPlugin&gt; Graph;
  typedef Graph::vertex_descriptor Vertex;

  const int N = 6;
  Graph G(N);
  add_edge(G, 0, 1);
  add_edge(G, 1, 4);
  add_edge(G, 4, 0);
  add_edge(G, 2, 5);
    
  std::vector&lt;int&gt; c(num_vertices(G));
  int num = connected_components(G, c.begin(), 
              get_color_accessor(G), null_visitor());
    
  cout &lt;&lt; endl;
  std::vector&lt;int&gt;::iterator i;
  cout &lt;&lt; "Total number of components: " &lt;&lt; num &lt;&lt; endl;
  for (i = c.begin(); i != c.end(); ++i)
    cout &lt;&lt; "Vertex " &lt;&lt; i - c.begin() 
         &lt;&lt; " is in component " &lt;&lt; *i &lt;&lt; endl;
  cout &lt;&lt; endl;
</PRE>
The output is:
<PRE>
  Total number of components: 3
  Vertex 0 is in component 1
  Vertex 1 is in component 1
  Vertex 2 is in component 2
  Vertex 3 is in component 3
  Vertex 4 is in component 1
  Vertex 5 is in component 2
</PRE>

<P>
Calculating the strongly connected components of a directed graph.
<PRE>
    typedef discover_time_plugin&lt; finish_time_plugin
                                  &lt; color_plugin&lt;&gt; &gt; &gt; VertexPlugin;
    typedef adjacency_list&lt; vecS, vecS, directedS, VertexPlugin &gt;  Graph;
    const int N = 6;
    Graph G(N);
    add_edge(G, 0, 1);
    add_edge(G, 1, 1);
    add_edge(G, 1, 3);
    add_edge(G, 1, 4);
    add_edge(G, 4, 3);
    add_edge(G, 3, 4);
    add_edge(G, 3, 0);
    add_edge(G, 5, 2);

    typedef Graph::vertex_descriptor Vertex;
    
    std::vector&lt;int&gt; c(N);
    int num = connected_components(G, c.begin(), 
      get_color_accessor(G), null_visitor());
    
    cout &lt;&lt; endl;
    cout &lt;&lt; "Total number of components: " &lt;&lt; num &lt;&lt; endl;
    std::vector&lt;int&gt;::iterator i;
    for (i = c.begin(); i != c.end(); ++i)
      cout &lt;&lt; "Vertex " &lt;&lt; i - c.begin() 
           &lt;&lt; " is in component " &lt;&lt; *i &lt;&lt; endl;
  }
</PRE>
The output is:
<PRE>
  Total number of components: 3
  Vertex 0 is in component 3
  Vertex 1 is in component 3
  Vertex 2 is in component 2
  Vertex 3 is in component 3
  Vertex 4 is in component 3
  Vertex 5 is in component 1
</PRE>

<P>


<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy 2000</TD><TD>
<A HREF=http://www.boost.org/people/jeremy_siek.htm>Jeremy Siek</A>, Univ.of Notre Dame (<A HREF="mailto:jsiek@lsc.nd.edu">jsiek@lsc.nd.edu</A>)
</TD></TR></TABLE>

</BODY>
</HTML> 
