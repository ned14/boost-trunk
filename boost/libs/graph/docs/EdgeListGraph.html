<HTML>
<!--
  -- Copyright (c) Jeremy Siek 2000
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
<Head>
<Title>EdgeListGraph</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<IMG SRC="../../../c++boost.gif" 
     ALT="C++ Boost"> 

<BR Clear>


<H2><A NAME="concept:EdgeListGraph"></A>
EdgeListGraph
</H2>

The EdgeListGraph concept refines the <a href="./Graph.html">Graph</a>
concept, and adds the requirement for efficient access to all the
edges in the graph.


<H3>Refinement of</H3>

<a href="./Graph.html">Graph</a>


<H3>Associated Types</H3>

<table border>

<tr>
<td>Edge Iterator Type </td>
<td><TT>boost::graph_traits&lt;G&gt;::edge_iterator</TT></td> 
<td>
An edge iterator (obtained via <TT>edges(g)</TT>) provides access to
all of the edges in a graph. An edge iterator type must meet the
requirements of <a
href="../../utility/MultiPassInputIterator.html">MultiPassInputIterator</a>.  The
value type of the edge iterator must be the same as the edge
descriptor of the graph.

<tr>
<td>Edges Size Type </td>
<td><TT>boost::graph_traits&lt;G&gt;::edges_size_type</TT></td>
<td>
The unsigned integer type used to represent the number of edges
    in the graph.
</td>
</tr>

</table>

<h3>Valid Expressions</h3>

<table border>

<tr>
<td>Edge Set of the Graph </td>
<TD><TT>edges(g)</TT></TD>
<TD><TT>std::pair&lt;edge_iterator, edge_iterator&gt;</TT></TD>
<TD>Returns an iterator-range providing access to all
     the edges in the graph <TT>g</TT>.</TD>
</TR>

<tr>
<td>Number of Edges in the Graph </td>
<TD><TT>num_edges(g)</TT></TD>
<TD><TT>edges_size_type</TT></TD>
<TD>Returns the number of edges in the graph <TT>g</TT>.</TD>
</TR>

<tr>
<td>Source Vertex of an Edge </td>
<TD><TT>source(e, g)</TT></TD>
<TD><TT>vertex_descriptor</TT></TD>
<TD>
Returns the vertex descriptor for <i>u</i> of the edge <i>(u,v)</i>
represented by <TT>e</TT>.
</TD>

<tr>
<td>Target Vertex of an Edge </td>
<TD><TT>target(e, g)</TT></TD>
<TD><TT>vertex_descriptor</TT></TD>
<TD>
Returns the vertex descriptor for 
<i>v</i> of the edge <i>(u,v)</i> represented by  <TT>e</TT>.
</TD>
</TR>

</TABLE>


<H3>Models</H3>

<UL>
<LI><TT>adjacency_list</TT></LI>
<LI><TT>edge_list</TT></LI>
</UL>


<H3>Complexity guarantees</H3>

The <TT>edges()</TT>, <TT>source()</TT>, and <TT>target()</TT> functions
must all return in constant time.


<H3>See Also</H3>

<a href="./graph_concepts.html">Graph concepts</a>

<H3>Concept Checking Class</H3>

<P>
<PRE>
  template &lt;class G&gt;
  struct EdgeListGraph_concept
  {
    typedef typename boost::graph_traits&lt;G&gt;::edge_iterator 
      edge_iterator;
    void constraints() {
      REQUIRE(G, Graph);
      REQUIRE(edge_iterator, MultiPassInputIterator);

      p = edges(g);
      E = num_edges(g);
      e = *p.first;
      u = source(e, g);
      v = target(e, g);
      const_constraints(g);
    }
    void const_constraints(const G&amp; g) {
      p = edges(g);
      E = num_edges(g);
      e = *p.first;
      u = source(e, g);
      v = target(e, g);
    }
    std::pair&lt;edge_iterator,edge_iterator&gt; p;
    typename boost::graph_traits&lt;G&gt;::vertex_descriptor u, v;
    typename boost::graph_traits&lt;G&gt;::edge_descriptor e;
    typename boost::graph_traits&lt;G&gt;::edges_size_type E;
    G g;
  };
</PRE>


<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy 2000</TD><TD>
<A HREF=http://www.boost.org/people/jeremy_siek.htm>Jeremy Siek</A>, Univ.of Notre Dame (<A HREF="mailto:jsiek@lsc.nd.edu">jsiek@lsc.nd.edu</A>)
</TD></TR></TABLE>

</BODY>
</HTML> 
