<HTML>
<!--
  -- Copyright (c) Jeremy Siek 2000
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
<Head>
<Title>Johnson All Pairs Shortest Paths</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<IMG SRC="c++boost.gif" 
     ALT="C++ Boost"> 

<BR Clear>

<H1><A NAME="sec:johnson">
<TT>johnson_all_pairs_shortest_paths</TT>
</H1>

<P>
<DIV ALIGN="left">
<TABLE CELLPADDING=3 border>
<TR><TH ALIGN="LEFT"><B>Graphs:</B></TH>
<TD ALIGN="LEFT">directed or undirected</TD>
</TR>
<TR><TH ALIGN="LEFT"><B>Properties:</B></TH>
<TD ALIGN="LEFT">distance matrix, distance, weight, color, vertex id</TD>
</TR>
<TR><TH ALIGN="LEFT"><B>Complexity:</B></TH>
<TD ALIGN="LEFT">
<i>O(V E log V) or <i>O(V<sup>2</sup> log V + V E)</i>
</TD>
</TR>
</TABLE>
</DIV>

<P>
<PRE>
template &lt;class VertexAndEdgeListGraph, class DistanceMatrix,
          class Distance, class Weight, class Color, class VertexID&gt;
bool johnson_all_pairs_shortest_paths(VertexAndEdgeListGraph&amp; g, 
                                      DistanceMatrix&amp; D,
                                      Distance d, Distance h,
                                      Weight w, Color c, VertexID id)
</PRE>

<P>
This algorithm finds the shortest distance between every pair of
vertices in the graph. The algorithm returns false if there is a
negative weight cycle in the graph and true otherwise. The distance
between each pair of vertices is stored in the distance matrix
<TT>D</TT>. This is one of the more time intensive graph algorithms,
having a time complexity of <i>O(V E log V)</i> if a binary heap is
used within Dijkstra's or <i>O(V<sup>2</sup> log V + V E)</i> if a fibonacci
heap is used (the algorithm can be configured to use either). It is a
wonder that London taxi-cab drivers are able to instantaneously
compute this kind of information in their heads!

<P>

<H3>Where Defined</H3>

<P>
<a href="../../../boost/graph/johnson_all_pairs_shortest_paths.hpp"><TT>boost/graph/johnson_all_pairs_shortest_paths.hpp</TT></a>

<P>

<H3>Example</H3>

<P>
Johnson's algorithm for all-pairs shortest paths applied to the
example graph from page 568 of the CLR&nbsp;[<A
HREF="bibliography.html#clr90">8</A>]. The resulting distance matrix
<TT>D[u][v]</TT> gives the shortest path from vertex <TT>u</TT> to
<TT>v</TT>.

<P>
<PRE>
  typedef adjacency_list&lt;vecS,vecS,directedS,no_plugin,
    plugin&lt;weight_tag,int&gt; &gt; Graph;
  const int V = 6;

  typedef std::pair&lt;int,int&gt; Edge;
  Edge edge_array[] =
    { Edge(0,1), Edge(0,2), Edge(0,3), Edge(0,4), Edge(0,5),
      Edge(1, 2), Edge(1,5), Edge(1,3),
      Edge(2, 4), Edge(2,5),
      Edge(3, 2), 
      Edge(4, 3), Edge(4,1),
      Edge(5, 4)
    };
  const int E = sizeof(edge_array)/sizeof(Edge);

  Graph g(V, edge_array, edge_array + E);

  edge_property_accessor&lt;Graph,weight_tag&gt;::type
    w = get_edge_property(g, weight_tag());

  int weights[] = { 0, 0, 0, 0, 0,
                    3, -4, 8,
                    1, 7,
                    4,
                    -5, 2,
                    6 };
  int* wp = weights;
  
  Graph::edge_iterator e,e_end;
  for (boost::tie(e,e_end) = edges(g); e != e_end; ++e)
    w[*e] = *wp++;

  std::vector&lt;int&gt; d(V, std::numeric_limits&lt;int&gt;::max());
  std::vector&lt;int&gt; h(V);
  std::vector&lt;default_color_type&gt; c(V);

  int D[V][V];

  johnson_all_pairs_shortest_paths
    (g, D, d.begin(), h.begin(), w, c.begin(), 
     get_vertex_property(g, id_tag()));

  // output matrix D ...
</PRE>
The output is:
<PRE>
            0       1       2       3       4       5       
  0 -&gt;      0       0       -1      -5      0       -4      
  1 -&gt;      inf     0       1       -3      2       -4      
  2 -&gt;      inf     3       0       -4      1       -1      
  3 -&gt;      inf     7       4       0       5       3       
  4 -&gt;      inf     2       -1      -5      0       -2      
  5 -&gt;      inf     8       5       1       6       0
</PRE>



<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy 2000</TD><TD>
<A HREF=http://www.boost.org/people/jeremy_siek.htm>Jeremy Siek</A>, Univ.of Notre Dame (<A HREF="mailto:jsiek@lsc.nd.edu">jsiek@lsc.nd.edu</A>)
</TD></TR></TABLE>

</BODY>
</HTML> 
