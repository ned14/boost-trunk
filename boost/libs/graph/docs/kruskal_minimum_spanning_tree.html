<HTML>
<!--
  -- Copyright (c) Jeremy Siek 2000
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
<Head>
<Title>Boost Graph Library: Kruskal Minimum Spanning Tree</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
	ALINK="#ff0000"> 
<IMG SRC="c++boost.gif" 
     ALT="C++ Boost"> 

<BR Clear>


<H1><A NAME="sec:kruskal">
<TT>kruskal_minimum_spanning_tree</TT>
</H1>

<P>
<DIV ALIGN="left">
<TABLE CELLPADDING=3 border>
<TR><TH ALIGN="LEFT"><B>Graphs:</B></TH>
<TD ALIGN="LEFT">undirected</TD>
</TR>
<TR><TH ALIGN="LEFT"><B>Properties:</B></TH>
<TD ALIGN="LEFT">rank, parent, weight</TD>
</TR>
<TR><TH ALIGN="LEFT"><B>Complexity:</B></TH>
<TD ALIGN="LEFT"><i>O(E log E)</i>
</TD>
</TR>
</TABLE>
</DIV>

<P>
<PRE>
(1)
template &lt;class VertexAndEdgeListGraph, class OutputIterator, 
          class Rank, class Parent &gt;
void kruskal_minimum_spanning_tree(VertexAndEdgeListGraph&amp; G, 
                                   OutputIterator c, 
                                   Rank rank, Parent p);

(2)
template &lt;class VertexAndEdgeListGraph, class OutputIterator, 
          class Rank, class Parent, class Weight &gt;
void kruskal_minimum_spanning_tree(VertexAndEdgeListGraph&amp; G, 
                                   OutputIterator out, 
                                   Rank rank, Parent p, Weight w);
</PRE>

<P>
This is Kruskal's
algorithm&nbsp;[<A
 HREF="bibliography.html#kruskal56">18</A>,<A
 HREF="bibliography.html#clr90">8</A>,<A
 HREF="bibliography.html#tarjan83:_data_struct_network_algo">27</A>,<A
 HREF="bibliography.html#graham85">15</A>]
for solving the minimum spanning tree problem. This is a greedy
algorithm to calculate the minimum spanning tree for an undirected
graph with weighted edges. The output is a set of edges written to the
<tt>OutputIterator</tt>.

<P>

<H3>Where Defined</H3>

<P>
<a href="../../../boost/graph/kruskal_minimum_spanning_tree.hpp"><TT>boost/graph/kruskal_minimum_spanning_tree.hpp</TT></a>

<P>

<H3>Definitions</H3>

<P>
The <I>minimum-spanning-tree problem</I> is defined as follows: for a
graph <i>G = (V,E)</i> find an acyclic subset <i>T</i> of <i>E</i>
that connects all of the vertices in the graph and whose total weight
is minimized, where the total weight is given by

<P></P>
<DIV ALIGN="left">
<i>w(T)</i> = sum of <i>w(u,v)</i> over all <i>(u,v)</i> in <i>T</i>,
where <i>w(u,v)</i> is the weight on the edge <i>(u,v)</i>
</DIV>
<BR CLEAR="ALL">
<P></P>
<i>T</i> is called the <I>spanning tree</I>.

<P>

<H3>Requirements on Types</H3>

<P>

<UL>
<LI>The graph type must be a model of <a href="./VertexAndEdgeListGraph.html">VertexAndEdgeListGraph</a>.
</LI>
<LI>The <TT>Rank</TT> type must be a model of <a
    href="../../property_accessor/ReadWritePropertyAccessor.html">ReadWritePropertyAccessor</a>. <TT>Rank</TT>'s
    value type must be an integer type. The graph's vertex descriptor
    needs to be usable as the key type for the accessor.
</LI>
<LI>The <TT>Parent</TT> type must be a model of <a
    href="../../property_accessor/ReadWritePropertyAccessor.html">ReadWritePropertyAccessor</a>. The
    value type and key type should be the graph's vertex descriptor
    type.
</LI>
<LI>The <TT>Weight</TT> type must be a model of <a
     href="../../property_accessor/ReadablePropertyAccessor.html">ReadablePropertyAccessor</a>. The
     <TT>Weight</TT> accessor's value type must be <a
     href="http://www.sgi.com/Technology/LessThanComparable.html">LessThanComparable</a>. The
     key type of this accessor needs to be the graph's edge descriptor
     type.
</LI>
<LI>The graph's edge descriptors will be output to the
    <TT>OutputIterator</TT>, which must be a model of <a href="http://www.sgi.com/Technology/OutputIterator.html">OutputIterator</a>.
</LI>
</UL>

<P>

<H3>Complexity</H3>

<P>
The time complexity is <i>O(E log E)</i>

<H3>Example</H3>

<P>
The source code for this example is in <a
href="../examples/kruskal.cpp"><TT>examples/kruskal.cpp</TT></a>.

<P>
<PRE>
  typedef weight_plugin&lt;int&gt; weightp;
  typedef adjacency_list&lt; vecS, vecS, undirectedS, 
                off_vertex_default_plugin&lt;&gt;, weightp &gt; Graph;
  typedef Graph::edge_descriptor Edge;
  typedef Graph::vertex_descriptor Vertex;

  typedef std::pair&lt;int,int&gt; E;
  const int num_nodes = 5;
  E edges[] = { E(0,2), 
                E(1,1), E(1,3), E(1,4),
                E(2,1), E(2,3), 
                E(3,4),
                E(4,0), E(4,1) };
  int weights[] = { 1, 2, 1, 2, 7, 3, 1, 1, 1};

  Graph G(num_nodes, edges, edges + sizeof(edges)/sizeof(E), weights);
  weight_property_accessor&lt;Graph&gt; weight = get_weight_accessor(G);

  typedef std::vector&lt;Edge&gt; container;
  std::vector&lt;Edge&gt; c;
  c.reserve(num_vertices(G));
  std::vector&lt;Vertex&gt; p(num_vertices(G));
  std::vector&lt;int&gt; rank(num_vertices(G));

  kruskal_minimum_spanning_tree(G, std::back_inserter(c), 
                                rank.begin(), p.begin());
  
  cout &lt;&lt; "Print the edge in MST:" &lt;&lt; endl;
  for (std::vector&lt;Edge&gt;::iterator ei = c.begin();
       ei != c.end(); ++ei) {
    cout &lt;&lt; index(source(*ei, G)) &lt;&lt; " &lt;--&gt; " 
         &lt;&lt; index(target(*ei, G))
         &lt;&lt; " with weight of " &lt;&lt; weight[*ei]
         &lt;&lt; endl;
    }
</PRE>
The output is:
<PRE>
  Print the edge in MST:
  0 &lt;--&gt; 2 with weight of 1
  1 &lt;--&gt; 3 with weight of 1
  4 &lt;--&gt; 0 with weight of 1
  4 &lt;--&gt; 3 with weight of 1
</PRE>


<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy 2000</TD><TD>
<A HREF=http://www.boost.org/people/jeremy_siek.htm>Jeremy Siek</A>, Univ.of Notre Dame (<A HREF="mailto:jsiek@lsc.nd.edu">jsiek@lsc.nd.edu</A>)
</TD></TR></TABLE>

</BODY>
</HTML> 
