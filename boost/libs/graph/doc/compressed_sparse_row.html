<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Compressed Sparse Row Graph</title>

    <STYLE TYPE="text/css">
      <!--
        .indent
        {
          padding-left: 50pt;
          padding-right: 50pt;
        }
       -->
    </STYLE>

<script language="JavaScript" type="text/JavaScript">
<!--
function address(host, user) {
        var atchar = '@';
        var thingy = user+atchar+host;
        thingy = '<a hre' + 'f=' + "mai" + "lto:" + thingy + '>' + user+atchar+host + '</a>';
        document.write(thingy);
}
//-->
</script>

  </head>
  
  <body>
    <IMG SRC="../../../boost.png" 
      ALT="C++ Boost" width="277" height="86"></img>
    <h1>Compressed Sparse Row Graph</h1>
          
    <p>The class template <code>compressed_sparse_row_graph</code> is
    a graph class that uses the compact Compressed Sparse Row (CSR)
    format to store directed graphs. While CSR graphs have much less
    overhead than many other graph formats (e.g., <a
    href="adjacency_list.html"><code>adjacency_list</code></a>), they
    do not provide any mutability: one cannot add or remove vertices
    or edges from a CSR graph. Use this format in high-performance
    applications or for very large graphs that you do not need to
    change.</p>
        
    <ul>
      <li><a href="#synopsis">Synopsis</a></li>
      <li><a href="#where">Where Defined</a></li>
      <li><a href="#member-functions">Member functions</a>
        <ul>
          <li><a href="#constructors">Constructors</a></li>
          <li><a href="#mutators">Mutators</a></li>
          <li><a href="#property-access">Property access</a></li>
        </ul></li>

      <li><a href="#non-members">Non-member functions</a>
        <ul>
          <li><a href="#vertex-access">Vertex access</a></li>
          <li><a href="#edge-access">Edge access</a></li>
          <li><a href="#property-map-accessors">Property map accessors</a></li>
        </ul></li>
    </ul>

    <a name="synopsis"></a><h2>Synopsis</h2>

    <pre>
namespace boost {

template&lt;typename VertexProperty = void,
         typename EdgeProperty = void,
         typename GraphProperty = no_property,
         typename Vertex = std::size_t,
         typename EdgeIndex = Vertex&gt;
class compressed_sparse_row_graph
{
public:
  <i>// <a href="#constructors">Graph constructors</a></i>
  <a href="#default-const">compressed_sparse_row_graph</a>();

  template&lt;typename InputIterator&gt;
  <a href="#edge-const">compressed_sparse_row_graph</a>(InputIterator edge_begin, InputIterator edge_end,
                              vertices_size_type numverts,
                              edges_size_type numedges = 0,
                              const GraphProperty&amp; prop = GraphProperty());

  template&lt;typename InputIterator, typename EdgePropertyIterator&gt;
  <a href="#edge-prop-const">compressed_sparse_row_graph</a>(InputIterator edge_begin, InputIterator edge_end,
                              EdgePropertyIterator ep_iter,
                              vertices_size_type numverts,
                              edges_size_type numedges = 0,
                              const GraphProperty&amp; prop = GraphProperty());

  template&lt;typename Graph, typename VertexIndexMap&gt;
  <a href="#graph-const">compressed_sparse_row_graph</a>(const Graph&amp; g, const VertexIndexMap&amp; vi,
                              vertices_size_type numverts,
                              edges_size_type numedges); 

  template&lt;typename Graph, typename VertexIndexMap&gt;
  compressed_sparse_row_graph(const Graph&amp; g, const VertexIndexMap&amp; vi);

  template&lt;typename Graph&gt;
  explicit <a href="#graph-const">compressed_sparse_row_graph</a>(const Graph&amp; g);

  <i>// <a href="#mutators">Graph mutators</a></i>
  template&lt;typename Graph, typename VertexIndexMap&gt;
  void <a href="#assign">assign</a>(const Graph&amp; g, const VertexIndexMap&amp; vi,
              vertices_size_type numverts, edges_size_type numedges);

  template&lt;typename Graph, typename VertexIndexMap&gt;
  void <a href="#assign">assign</a>(const Graph&amp; g, const VertexIndexMap&amp; vi);

  template&lt;typename Graph&gt;
  void <a href="#assign">assign</a>(const Graph&amp; g);

  <i>// <a href="#property-access">Property Access</a></i>
  VertexProperty&amp; <a href="#vertex-subscript">operator[]</a>(vertex_descriptor v);
  const VertexProperty&amp; <a href="#vertex-subscript">operator[]</a>(vertex_descriptor v) const;
  EdgeProperty&amp; <a href="#edge-subscript">operator[]</a>(edge_descriptor v);
  const EdgeProperty&amp; <a href="#edge-subscript">operator[]</a>(edge_descriptor v) const;
};

<i>// <a href="IncidenceGraph.html">Incidence Graph requirements</a></i>
vertex_descriptor source(edge_descriptor, const compressed_sparse_row_graph&amp;);
vertex_descriptor target(edge_descriptor, const compressed_sparse_row_graph&amp;);
std::pair&lt;out_edge_iterator, out_edge_iterator&gt; 
  out_edges(vertex_descriptor, const compressed_sparse_row_graph&amp;);
degree_size_type out_degree(vertex_descriptor v, const compressed_sparse_row_graph&amp;);

<i>// <a href="AdjacencyGraph.html">Adjacency Graph requirements</a></i>
std::pair&lt;adjacency_iterator, adjacency_iterator&gt; 
  adjacent_vertices(vertex_descriptor, const compressed_sparse_row_graph&amp;);

<i>// <a href="VertexListGraph.html">Vertex List Graph requirements</a></i>
std::pair&lt;vertex_iterator, vertex_iterator&gt; vertices(const compressed_sparse_row_graph&amp;);
vertices_size_type num_vertices(const compressed_sparse_row_graph&amp;);

<i>// <a href="EdgeListGraph.html">Edge List Graph requirements</a></i>
std::pair&lt;edge_iterator, edge_iterator&gt; edges(const compressed_sparse_row_graph&amp;);
edges_size_type num_edges(const compressed_sparse_row_graph&amp;);

<i>// <a href="#vertex-access">Vertex access</a></i>
vertex_descriptor <a href="#vertex">vertex</a>(vertices_size_type i, const compressed_sparse_row_graph&amp;);

<i>// <a href="#edge-access">Edge access</a></i>
std::pair&lt;out_edge_iterator, out_edge_iterator&gt; 
  <a href="#edge_range">edge_range</a>(vertex_descriptor u, vertex_descriptor v, const compressed_sparse_row_graph&amp;);
std::pair&lt;edge_descriptor, bool&gt; 
  <a href="#edge">edge</a>(vertex_descriptor u, vertex_descriptor v, const compressed_sparse_row_graph&amp;);
edge_descriptor <a href="#edge_from_index">edge_from_index</a>(edges_size_type i, const compressed_sparse_row_graph&amp;);

<i>// <a href="#property-map-accessors">Property map accessors</a></i>
template&lt;class <a href="./PropertyTag.html">PropertyTag</a>&gt;
property_map&lt;compressed_sparse_row_graph, PropertyTag&gt;::type
<a href="#get">get</a>(PropertyTag, compressed_sparse_row_graph&amp; g)

template&lt;class <a href="./PropertyTag.html">PropertyTag</a>&gt;
property_map&lt;compressed_sparse_row_graph, Tag&gt;::const_type
<a href="#get">get</a>(PropertyTag, const compressed_sparse_row_graph&amp; g)

template&lt;class <a href="./PropertyTag.html">PropertyTag</a>, class X&gt;
typename property_traits&lt;property_map&lt;compressed_sparse_row_graph, PropertyTag&gt;::const_type&gt::value_type
<a href="#get-x">get</a>(PropertyTag, const compressed_sparse_row_graph&amp; g, X x)

template&lt;class <a href="./PropertyTag.html">PropertyTag</a>, class X, class Value&gt;
void <a href="#put-x">put</a>(PropertyTag, const compressed_sparse_row_graph&amp; g, X x, const Value&amp; value);

template&lt;class GraphProperties, class <a href="./PropertyTag.html#GraphPropertyTag">GraphPropertyTag</a>&gt;
typename graph_property&lt;compressed_sparse_row_graph, GraphPropertyTag&gt;::type&amp;
<a href="#get_property">get_property</a>(compressed_sparse_row_graph&amp; g, GraphPropertyTag);

template&lt;class GraphProperties, class <a href="./PropertyTag.html#GraphPropertyTag">GraphPropertyTag</a>&gt;
typename graph_property&lt;compressed_sparse_row_graph, GraphPropertyTag&gt;::type const &amp;
<a href="#get_property">get_property</a>(const compressed_sparse_row_graph&amp; g, GraphPropertyTag);

template&lt;class GraphProperties, class <a href="./PropertyTag.html#GraphPropertyTag">GraphPropertyTag</a>&gt;
void <a href="#set_property">set_property</a>(const compressed_sparse_row_graph&amp; g, GraphPropertyTag,
                  const typename graph_property&lt;compressed_sparse_row_graph, GraphPropertyTag&gt;::type&amp; value);
} <i>// end namespace boost</i>
   </pre>

    <a name="where"></a><h2>Where Defined</h2>
    <p><code>boost/graph/compressed_sparse_row_graph.hpp</code></p>


    <a name="member-functions"></a><h2>Member Functions</h2>

    <a name="constructors"></a><h3>Constructors</h3>
    <pre><a name="default-const"></a>
  compressed_sparse_row_graph();
    </pre>
    <p class="indent">Constructs a graph with no vertices or edges.</p>

    <hr></hr>

    <pre><a name="edge-const"></a>
  template&lt;typename InputIterator&gt;
  compressed_sparse_row_graph(InputIterator edge_begin, InputIterator edge_end,
                              vertices_size_type numverts,
                              edges_size_type numedges = 0,
                              const GraphProperty&amp; prop = GraphProperty());
    </pre>

    <p class="indent">
      Constructs a graph with <code>numverts</code> vertices whose
      edges are specified by the iterator range <code>[edge_begin,
      edge_end)</code>. The <tt>InputIterator</tt> must be a model of
      <a
      href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>
      whose <code>value_type</code> is an <code>std::pair</code> of
      integer values. These integer values are the source and target
      vertices for the edges, and must fall within the range <code>[0,
      numverts)</code>. The edges in <code>[edge_begin,
      edge_end)</code> must be sorted so that all edges originating
      from vertex <i>i</i> preceed any edges originating from all
      vertices <i>j</i> where <i>j &gt; i</i>.
    </p>

    <p class="indent">
      The value <code>numedges</code>, if provided, tells how many
      edges are in the range <code>[edge_begin, edge_end)</code> and
      will be used to preallocate data structures to save both memory
      and time during construction.
    </p>

    <p class="indent">
      The value <code>prop</code> will be used to initialize the graph
      property.
    </p>

    <hr></hr>

    <pre><a name="edge-prop-const"></a>
  template&lt;typename InputIterator, typename EdgePropertyIterator&gt;
  compressed_sparse_row_graph(InputIterator edge_begin, InputIterator edge_end,
                              EdgePropertyIterator ep_iter,
                              vertices_size_type numverts,
                              edges_size_type numedges = 0,
                              const GraphProperty&amp; prop = GraphProperty());
    </pre>
    <p class="indent">
      This constructor constructs a graph with <code>numverts</code>
      vertices and the edges provided in the iterator range
      <code>[edge_begin, edge_end)</code>. Its semantics are identical
      to the <a href="#edge-const">edge range constructor</a>, except
      that edge properties are also initialized. The type
      <tt>EdgePropertyIterator</tt> must be a model of the <a
      href="http://www.sgi.com/tech/stl/InputIterator.html">InputIterator</a>
      concept whose <tt>value_type</tt> is convertible to
      <tt>EdgeProperty</tt>. The iterator range <tt>[ep_iter, ep_ter +
        m)</tt> will be used to initialize the properties on the edges
      of the graph, where <tt>m</tt> is distance from
      <tt>edge_begin</tt> to <tt>edge_end</tt>.
    </p>

    <hr></hr>

    <pre><a name="#graph-const"></a>
  template&lt;typename Graph, typename VertexIndexMap&gt;
  compressed_sparse_row_graph(const Graph&amp; g, const VertexIndexMap&amp; vi,
                              vertices_size_type numverts,
                              edges_size_type numedges); 

  template&lt;typename Graph, typename VertexIndexMap&gt;
  compressed_sparse_row_graph(const Graph&amp; g, const VertexIndexMap&amp; vi);

  template&lt;typename Graph&gt;
  explicit compressed_sparse_row_graph(const Graph&amp; g);
    </pre>

    <p class="indent">
      Calls the <a href="#assign"><tt>assign</tt></a> function with
      all of the arguments it is given.
    </p>

    <hr></hr>

    <a name="mutators"></a><h3>Mutators</h3>
    <pre><a name="assign"></a>
  template&lt;typename Graph, typename VertexIndexMap&gt;
  void assign(const Graph&amp; g, const VertexIndexMap&amp; vi,
              vertices_size_type numverts, edges_size_type numedges);

  template&lt;typename Graph, typename VertexIndexMap&gt;
  void assign(const Graph&amp; g, const VertexIndexMap&amp; vi);

  template&lt;typename Graph&gt;
  void assign(const Graph&amp; g);
    </pre>

    <p class="indent">
      Clears the CSR graph and builds a CSR graph in place from the
      structure of another graph. The graph type <tt>Graph</tt> must
      be a model of <a href="IncidenceGraph.html">IncidenceGraph</a>
      and have a <tt>vertex(i, g)</tt> function that retrieves the
      <i>i</i><sup>th</sup> vertex in the graph.

      <br></br><b>Parameters</b>

      <ul>
        <li><tt>g</tt>: The incoming graph.</li>
        
        <li><tt>vi</tt>: A map from vertices to indices. If not
          provided, <tt>get(vertex_index, g)</tt> will be used.</li>
        
        <li><tt>numverts</tt>: The number of vertices in the graph
          <tt>g</tt>. If not provided, <tt>Graph</tt> must be a model of
          <a href="VertexListGraph.html">VertexListGraph</a>.</li>
        
        <li><tt>numedges</tt>: The number of edges in the graph
          <tt>g</tt>. If not provided, <tt>Graph</tt> must be a model of
          <a href="EdgeListGraph.html">EdgeListGraph</a>.</li>
      </ul>
    </p>

    <hr></hr>

    <a name="property-access"></a><h3>Property Access</h3>

    <pre><a name="vertex-subscript"></a>
  VertexProperty&amp; operator[](vertex_descriptor v);
  const VertexProperty&amp; operator[](vertex_descriptor v) const;
    </pre>

    <p class="indent">
      Retrieves the property value associated with vertex
      <tt>v</tt>. Only valid when <tt>VertexProperty</tt> is a class
      type that is not <tt>no_property</tt>.
    </p>

    <hr></hr>

    <pre><a name="edge-subscript">
  EdgeProperty&amp; operator[](edge_descriptor v);
  const EdgeProperty&amp; operator[](edge_descriptor v) const;
    </pre>

    <p class="indent">
      Retrieves the property value associated with edge
      <tt>v</tt>. Only valid when <tt>EdgeProperty</tt> is a class
      type that is not <tt>no_property</tt>.
    </p>

    <hr></hr>
    <a name="non-members"></a><h2>Non-member Functions</h2>

    <a name="vertex-access"></a><h3>Vertex access</h3>

    <pre><a name="vertex"></a>
  vertex_descriptor vertex(vertices_size_type i, const compressed_sparse_row_graph&amp;);
    </pre>
    <p class="indent">
      Retrieves the <i>i</i><sup>th</sup> vertex in the graph in
      constant time.
    </p>

    <hr></hr>

    <a name="edge-access"></a><h3>Edge access</h3>
    <pre><a name="edge_range"></a>
  std::pair&lt;out_edge_iterator, out_edge_iterator&gt; 
    edge_range(vertex_descriptor u, vertex_descriptor v, const compressed_sparse_row_graph&amp;);
    </pre>

    <p class="indent">
      Returns all edges from <tt>u</tt> to <tt>v</tt>. Requires time
      linear in the number of edges outgoing from <tt>u</tt>.
    </p>

    <hr></hr>

    <pre><a name="edge"></a>
  std::pair&lt;edge_descriptor, bool&gt; 
    edge(vertex_descriptor u, vertex_descriptor v, const compressed_sparse_row_graph&amp;);
    </pre>

    <p class="indent">
      If there exists an edge <i>(u, v)</i> in the graph, returns the
      descriptor for that edge and <tt>true</tt>; otherwise, the
      second value in the pair will be <tt>false</tt>. If multiple
      edges exist from <tt>u</tt> to <tt>v</tt>, the first edge will
      be returned; use <a href="#edge_range"><tt>edge_range</tt></a>
      to retrieve all edges.
    </p>

    <hr></hr>

    <pre><a name="edge_from_index"></a>
  edge_descriptor edge_from_index(edges_size_type i, const compressed_sparse_row_graph&amp;);
    </pre>

    <p class="indent">
      Returns the <i>i</i><sup>th</sup> edge in the graph. This
      operation requires logarithmic time in the number of vertices.
    </p>

    <hr></hr>

    <h3><a name="property-map-accessors">Property Map Accessors</a></h3>

    <pre><a name="get"></a>
template&lt;class <a href="./PropertyTag.html">PropertyTag</a>&gt;
property_map&lt;compressed_sparse_row_graph, PropertyTag&gt;::type
get(PropertyTag, compressed_sparse_row_graph&amp; g)

template&lt;class <a href="./PropertyTag.html">PropertyTag</a>&gt;
property_map&lt;compressed_sparse_row_graph, Tag&gt;::const_type
get(PropertyTag, const compressed_sparse_row_graph&amp; g)
    </pre>
    
    <p class="indent">
      Returns the property map object for the vertex property
      specified by <TT>PropertyTag</TT>. The <TT>PropertyTag</TT> must
      be a member pointer to access one of the fields in
      <tt>VertexProperty</tt> or <tt>EdgeProperty</tt>.
    </p>

    <hr></hr>

    <pre><a name="get-x"></a>
template&lt;class <a href="./PropertyTag.html">PropertyTag</a>, class X&gt;
typename property_traits&lt;property_map&lt;compressed_sparse_row_graph, PropertyTag&gt;::const_type&gt::value_type
get(PropertyTag, const compressed_sparse_row_graph&amp; g, X x)
    </pre>

    <p class="indent">
      This returns the property value for <tt>x</tt>, where <tt>x</tt>
      is either a vertex or edge descriptor.
    </p>

    <hr></hr>

    <pre><a name="put-x"></a>
template&lt;class <a href="./PropertyTag.html">PropertyTag</a>, class X, class Value&gt;
void put(PropertyTag, const compressed_sparse_row_graph&amp; g, X x, const Value&amp; value);
    </pre>

    <p class="indent">
      This sets the property value for <tt>x</tt> to
      <tt>value</tt>. <tt>x</tt> is either a vertex or edge
      descriptor.  <tt>Value</tt> must be convertible to <tt>typename
      property_traits&lt;property_map&lt;compressed_sparse_row_graph,
      PropertyTag&gt;::type&gt::value_type</tt>
    </p>

    <hr></hr>

    <pre><a name="get_property"></a>
template&lt;class GraphProperties, class <a href="./PropertyTag.html#GraphPropertyTag">GraphPropertyTag</a>&gt;
typename graph_property&lt;compressed_sparse_row_graph, GraphPropertyTag&gt;::type&amp;
get_property(compressed_sparse_row_graph&amp; g, GraphPropertyTag);

template&lt;class GraphProperties, class <a href="./PropertyTag.html#GraphPropertyTag">GraphPropertyTag</a>&gt;
typename graph_property&lt;compressed_sparse_row_graph, GraphPropertyTag&gt;::type const &amp;
get_property(const compressed_sparse_row_graph&amp; g, GraphPropertyTag);
    </pre>

    <p class="indent">
      Return the property specified by <tt>GraphPropertyTag</tt> that
      is attached to the graph object <tt>g</tt>. 
    </p>

    <hr></hr>

    <pre><a name="set_property"></a>
template&lt;class GraphProperties, class <a href="./PropertyTag.html#GraphPropertyTag">GraphPropertyTag</a>&gt;
void set_property(const compressed_sparse_row_graph&amp; g, GraphPropertyTag,
                  const typename graph_property&lt;compressed_sparse_row_graph, GraphPropertyTag&gt;::type&amp; value);
    </pre>

    <p class="indent">
      Set the property specified by <tt>GraphPropertyTag</tt> that
      is attached to the graph object <tt>g</tt>.
    </p>

<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy; 2005</TD><TD>
Jeremiah Willcock, Indiana University (<script language="Javascript">address("osl.iu.edu", "jewillco")</script>)<br>
<A HREF="../../../people/doug_gregor.html">Doug Gregor</A>, Indiana University (<script language="Javascript">address("cs.indiana.edu", "dgregor")</script>)<br>
  <A HREF=http://www.osl.iu.edu/~lums>Andrew Lumsdaine</A>,
Indiana University (<script language="Javascript">address("osl.iu.edu", "lums")</script>)
</TD></TR></TABLE>
  </body>
</html>
