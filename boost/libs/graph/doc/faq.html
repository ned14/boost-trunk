<HTML>
<!--
  -- Copyright (c) Jeremy Siek, Lie-Quan Lee, and Andrew Lumsdaine 2000
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  We make no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
<Head>
<Title>Boost Graph Library: FAQ</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
        ALINK="#ff0000"> 
<IMG SRC="../../../c++boost.gif" 
     ALT="C++ Boost" width="277" height="86"> 

<BR Clear>

<h1>Frequently Asked Questions</h1>


<ol>

<li>Why does the algorithm X work with <tt>adjacency_list</tt> where
 <tt>VertexList=vecS</tt> but not when <tt>VertexList=listS</tt>? <br><br>
 Often the reason is that the algorithm expects to find the
 <tt>vertex_index</tt> property stored in the graph. When
 <tt>VertexList=vecS</tt>, the <tt>adjacency_list</tt> automatically
 has a <tt>vertex_index</tt> property. However, when <tt>VertexList=listS</tt>
 this is not the case, and the <tt>vertex_index</tt> property must be
 explicitly added, and initialized. For example,
<pre>
  // specify the graph type
  typedef adjacency_list&lt;listS, listS, undirectedS,
                         property&lt;vertex_index_t, std::size_t&gt;,
                         no_property
                        &gt; graph_t;

  // construct a graph object
  graph_t G(num_nodes);
  // obtain a property map for the vertex_index property
  property_map&lt;graph_t, vertex_index_t&gt;::type
    index = get(vertex_index, G);
  // initialize the vertex_index property values
  graph_traits&lt;graph_t&gt;::vertex_iterator vi, vend;
  graph_traits&lt;graph_t&gt;::vertices_size_type cnt = 0;
  for(tie(vi,vend) = vertices(G); vi != vend; ++vi)
    put(index, *vi, cnt++);
</pre>
</li>

<li>When using algorithm X, why do I get an error about a property
not being found, such as:
<pre>
../../../boost/concept_check.hpp:209: no match for
`boost::detail::error_property_not_found & == 
 boost::detail::error_property_not_found &'
</pre>
or a message such as:
<pre>
../../..\boost/graph/depth_first_search.hpp(78) : error C2664: 'white'
: cannot convert parameter 1 from 
 'struct boost::detail::error_property_not_found'
 to 'enum boost::default_color_type'
</pre>

The reason is that the algorithm expected to find some property (like color or
weight) attached to the vertices or edges of the graph, but didn't
find it. You need to either add an interior property to the graph, or
create an exterior property map for the property and pass it as an
argument to the algorithm.</li>



</ol>
