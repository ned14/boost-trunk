<HTML>
<!--
  -- Copyright (c) Lie-Quan Lee and Jeremy Siek, 2001
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
<Head>
<Title>Boost Graph Library: Minimum Degree Ordering</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
        ALINK="#ff0000"> 
<IMG SRC="../../../c++boost.gif" 
     ALT="C++ Boost" width="277" height="86"> 

<BR Clear>

<H1><A NAME="sec:mmd">
<TT>minimum_degree_ordering</TT>
</H1>


<P>
<DIV ALIGN="LEFT">
<TABLE CELLPADDING=3 border>
<TR><TH ALIGN="LEFT"><B>Graphs:</B></TH>
<TD ALIGN="LEFT">directed</TD>
</TR>
<TR><TH ALIGN="LEFT"><B>Properties:</B></TH>
<TD ALIGN="LEFT">out degree</TD>
</TR>
<!--
<TR><TH ALIGN="LEFT"><B>Complexity:</B></TH>
<TD ALIGN="LEFT">time: <i>O(log(m)|E|)</i> where <i>m = max { degree(v) | v in V }</i> </TD>
</TR>
-->
</TABLE>
</DIV>


<pre>
  template &lt;class AdjacencyGraph, class OutDegreeMap,
           class InversePermutationMap, 
           class PermutationMap, class SuperNodeSizeMap, class VertexIndexMap&gt;
  void minimum_degree_ordering
    (AdjacencyGraph& G,
     OutDegreeMap outdegree,
     InversePermutationMap inverse_perm,
     PermutationMap perm, 
     SuperNodeSizeMap supernode_size, int delta, VertexIndexMap id) 
</pre>

The minimum degree ordering algorithm &nbsp; [<A
HREF="bibliography.html#LIU:MMD">21</A>, <A
href="bibliography.html#George:evolution">35</a>] is a fill-in
reduction reordering algorithm.  It chooses the vertex with minimum
degree in the graph at each step of simulating Gaussian elimination
process. This implementation provided a number of enhancements
including mass elimination, incomplete degree update, multiple
elimination, and external degree. See&nbsp;[<A
href="bibliography.html#George:evolution">35</a>] for a historical
survey of the minimum degree algorithm.

<p>
The graph <TT>G</TT> corresponding to a symmetric matrix <TT>A</TT>
should be directed one instead of a undirected graph in this
implementation. Therefore, nonzero entry <TT>A(i, j)</TT> corresponds
two directed edges (<TT>e(i,j)</TT> and <TT>e(j,i)</TT>) in <TT>G</TT>.

<p>
The output of the algorithm are the vertices in the new ordering.
<pre>
  inverse_perm[new_index[u]] == old_index[u]
</pre>
<p> and the permutation from the old index to the new index. 
<pre>
  perm[old_index[u]] == new_index[u]
</pre>
<p>The following equations are always held.
<pre>
  for (size_type i = 0; i != inverse_perm.size(); ++i)
    perm[inverse_perm[i]] == i;
</pre>

<h3>Parameters</h3>

<ul>

<li> <tt>AdjacencyGraph&amp; G</tt> &nbsp;(IN) <br> 
  A directed graph. The graph's type must be a model of <a
  href="./AdjacencyGraph.html">Adjacency Graph</a>,
  <a
  href="./VertexListGraph.html">Vertex List Graph</a>,
  and <a href="./MutableIncidenceGraph.html">Mutable Incidence Graph</a>.
  In addition, the functions <tt>num_vertices()</tt> and
  <TT>out_degree()<TT> are required.

<li> <tt>OutDegreeMap outdegree</tt> &nbsp(WORK) <br>
  This is used internally to store the out degree of vertices.  This
  must be a <a href="../../property_map/LvaluePropertyMap.html">
  LvaluePropertyMap</a> with key type the same as the vertex
  descriptor type of the graph, and with a value type that is an
  integer type.

<li> <tt>InversePermutationMap inverse_perm</tt> &nbsp(OUT) <br> 
  The new vertex ordering, given as the mapping from the
  new indices to the old indices (an inverse permutation).
  This must be an <a href="../../property_map/LvaluePropertyMap.html">
  LvaluePropertyMap</a> with a value type and key type a signed integer. 

<li> <tt>PermutationMap perm</tt> &nbsp(OUT) <br> 
  The new vertex ordering, given as the mapping from the
  old indices to the new indices (a permutation).
  This must be an <a href="../../property_map/LvaluePropertyMap.html">
  LvaluePropertyMap</a> with a value type and key type a signed integer. 

<li> <tt>SuperNodeSizeMap supernode_size</tt> &nbsp(WORK/OUT) <br> 
  This is used internally to record the size of supernodes and is also
  useful information to have. This is a <a
  href="../../property_map/LvaluePropertyMap.html">
  LvaluePropertyMap</a> with an unsigned integer value type and key
  type of vertex descriptor.

<li> <tt>int delta</tt> &nbsp(IN) <br> 
  Multiple elimination control variable. If it is larger than or equal
  to zero then multiple elimination is enabled. The value of
  <tt>delta</tt> specifies the difference between the minimum degree
  and the degree of vertices that are to be eliminated.
  
<li> <tt>VertexIndexMap id</tt> &nbsp(IN) <br> 
  Used internally to map vertices to their indices. This must be a <a
  href="../../property_map/ReadablePropertyMap.html"> Readable
  Property Map</a> with key type the same as the vertex descriptor of
  the graph and a value type that is some unsigned integer type.

</ul>


<h3>Example</h3>

See <a
href="../example/minimum_degree_ordering.cpp"><tt>example/minimum_degree_ordering.cpp</tt></a>.

<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy 2001</TD><TD>
<A HREF="../../../people/liequan_lee.htm">Lie-Quan Lee</A>, Univ.of Notre Dame (<A HREF="mailto:llee1@lsc.nd.edu">llee1@lsc.nd.edu</A>) <br>
<A HREF="../../../people/jeremy_siek.htm">Jeremy Siek</A>, Univ.of Notre Dame (<A HREF="mailto:jsiek@lsc.nd.edu">jsiek@lsc.nd.edu</A>)
</TD></TR></TABLE>

</BODY>
</HTML> 
