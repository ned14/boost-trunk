<HTML>
<!--
  -- Copyright (c) Jeremy Siek 2000
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Jeremy Siek makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
<Head>
<Title>Boost Graph Library: Prim Minimum Spanning Tree</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
        ALINK="#ff0000"> 
<IMG SRC="../../../c++boost.gif" 
     ALT="C++ Boost" width="277" height="86"> 

<BR Clear>



<H1><A NAME="sec:prim"></A>
<TT>prim_minimum_spanning_tree</TT>
</H1>

<P>
<DIV ALIGN="left">
<TABLE CELLPADDING=3 border>
<TR><TH ALIGN="LEFT"><B>Graphs:</B></TH>
<TD ALIGN="LEFT">undirected</TD>
</TR>
<TR><TH ALIGN="LEFT"><B>Properties:</B></TH>
<TD ALIGN="LEFT">distance, weight, color, vertex id</TD>
</TR>
<TR><TH ALIGN="LEFT"><B>Complexity:</B></TH>
<TD ALIGN="LEFT"><i>O(E log V)</i></TD>
</TR>
</TABLE>
</DIV>

<P>
<PRE>
(1)
template &lt;class VertexListGraph, class Vertex&gt;
void prim_minimum_spanning_tree(VertexListGraph&amp; G, Vertex s);

(2)
template &lt;class VertexListGraph, class Vertex, class Distance&gt;
void prim_minimum_spanning_tree(VertexListGraph&amp; G, Vertex s, Distance d);

(3)
template &lt;class VertexListGraph, class Vertex,
          class Distance, class Visitor&gt;
void prim_minimum_spanning_tree(VertexListGraph&amp; G, Vertex s, 
                                Distance d, Visitor visit);

(4)
template &lt;class VertexListGraph, class Vertex, class Visitor, 
          class Distance, class Weight, class Color, class ID&gt;
void prim_minimum_spanning_tree(VertexListGraph&amp; G, Vertex s, 
                                Distance d, Weight w, Color c, ID id,
                                Visitor visit);
</PRE>

<P>
This is Prim's algorithm&nbsp;[<A
HREF="bibliography.html#prim57:_short">25</A>,<A
HREF="bibliography.html#clr90">8</A>,<A
HREF="bibliography.html#tarjan83:_data_struct_network_algo">27</A>,<A
HREF="bibliography.html#graham85">15</A>] for solving the minimum
spanning tree problem for an undirected graph with weighted edges. See
Section <A
HREF="graph_theory_review.html#sec:minimum-spanning-tree">Minimum
Spanning Tree Algorithms</A> for a definition of the minimum spanning
tree problem. The implementation is simply a call to <a
href="./uniform_cost_search.html"><TT>uniform_cost_search()</TT></a>
with the appropriate choice of comparison and combine functors.

<P>

<H3>Where Defined</H3>

<P>
<a href="../../../boost/graph/prim_minimum_spanning_tree.hpp"><TT>boost/graph/prim_minimum_spanning_tree.hpp</TT></a>

<P>

<H3>Requirements on Types</H3>

<P>

<UL>
<LI>The type <TT>VertexListGraph</TT> must be a model of <a href="./VertexListGraph.html">VertexListGraph</a>.
</LI>
<LI>The type <TT>Vertex</TT> must be convertible to type <TT>boost::graph_traits&lt;VertexListGraph&gt;::vertex_descriptor</TT>.
</LI>
<LI>The type <TT>Visitor</TT> must be a model of <I>Visitor</I>.
</LI>
<LI>The type <TT>Distance</TT> must be a model of
    <a href="../../property_map/ReadWritePropertyMap.html">ReadWritePropertyMap</a>. The vertex descriptor type of
     the graph needs to be usable as the key type of the distance
     map. The value type of the distance map must be
     <I>LessThanComparable</I>.
</LI>
<LI>The type <TT>Weight</TT> must be a model of
     <a href="../../property_map/ReadablePropertyMap.html">ReadablePropertyMap</a>. The edge descriptor type of
     the graph needs to be usable as the key type for the weight
     map. The value type for the map must be
     <I>Addable</I> with the value type of the distance map.
</LI>
<LI>The type <TT>Color</TT> must be a model of
     <a href="../../property_map/ReadWritePropertyMap.html">ReadWritePropertyMap</a>. A vertex descriptor must be
     usable as the key type of the map, and the value type of the
     map must be a model of <I>ColorValue</I>.
</LI>
<LI>The type <TT>ID</TT> must be a model of
     <a href="../../property_map/ReadablePropertyMap.html">ReadablePropertyMap</a>. The value type of <TT>ID</TT>
     must be an integer type. The vertex descriptor type of the graph
     needs to be usable as the key type of the ID map.
</LI>
</UL>

<P>

<H3>Complexity</H3>

<P>
The time complexity is <i>O(E log V)</i>.

<P>

<H3>Example</H3>

<P>
The source code for this example is in <a
href="../example/prim.cpp"><TT>examples/prim.cpp</TT></a>.

<P>
<PRE>
  int main(int , char* [])
  {
    using namespace boost;
    typedef adjacency_list&lt;vecS, vecS, undirectedS, 
	 property&lt;vertex_color_t, default_color_type,
	   property&lt;vertex_distance_t,int&gt; &gt;, property&lt;edge_weight_t,int&gt; &gt; 
      Graph;
    typedef graph_traits&lt;Graph&gt;::vertex_descriptor Vertex;
    typedef std::pair&lt;int,int&gt; E;
    const int num_nodes = 9;
    char name[] = &quot;abcdefghi&quot;;
    enum { a, b, c, d, e, f, g, h, i }; 
    E edges[] = { E(a,b), E(a,h),
		  E(b,h), E(b,c),
		  E(c,d), E(c,f), E(c,i),
		  E(d,e), E(d,f),
		  E(e,f), 
		  E(f,g),
		  E(g,i), E(g,h),
		  E(h,i) };
    int weights[] = { 4, 8,
		      11, 8,
		      7, 4, 2,
		      9, 14,
		      10,
		      2,
		      6, 1,
		      7 };

    Graph G(num_nodes, edges, edges + sizeof(edges)/sizeof(E), weights);

    std::vector&lt;Vertex&gt; p(num_vertices(G));
    Vertex src = *(vertices(G).first);
    p[src] = src;
    prim_minimum_spanning_tree
      (G, src, get(vertex_distance, G),
       make_ucs_visitor(record_predecessors(&p[0], on_edge_relaxed())));

    for ( std::vector&lt;Vertex&gt;::iterator vi = p.begin();
	  vi != p.end(); ++vi)
      std::cout &lt;&lt; &quot;parent[&quot; &lt;&lt; name[vi - p.begin()]
		&lt;&lt; &quot;] = &quot; &lt;&lt; name[*vi] &lt;&lt; std::endl;
    return 0;
  }
</PRE>
The output is:
<PRE>
  parent[a] = a
  parent[b] = a
  parent[c] = f
  parent[d] = c
  parent[e] = d
  parent[f] = g
  parent[g] = h
  parent[h] = a
  parent[i] = c
</PRE>



<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy 2000</TD><TD>
<A HREF="../../../people/jeremy_siek.htm">Jeremy Siek</A>, Univ.of Notre Dame (<A HREF="mailto:jsiek@lsc.nd.edu">jsiek@lsc.nd.edu</A>)
</TD></TR></TABLE>

</BODY>
</HTML> 
