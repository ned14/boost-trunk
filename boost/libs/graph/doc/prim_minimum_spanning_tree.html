<HTML>
<!--
  -- Copyright (c) Jeremy Siek 2000
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Jeremy Siek makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
<Head>
<Title>Boost Graph Library: Prim Minimum Spanning Tree</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
        ALINK="#ff0000"> 
<IMG SRC="../../../c++boost.gif" 
     ALT="C++ Boost" width="277" height="86"> 

<BR Clear>



<H1><A NAME="sec:prim"></A>
<TT>prim_minimum_spanning_tree</TT>
</H1>

<P>
<DIV ALIGN="left">
<TABLE CELLPADDING=3 border>
<TR><TH ALIGN="LEFT"><B>Graphs:</B></TH>
<TD ALIGN="LEFT">undirected</TD>
</TR>
<TR><TH ALIGN="LEFT"><B>Properties:</B></TH>
<TD ALIGN="LEFT">distance, weight, color, vertex id</TD>
</TR>
<TR><TH ALIGN="LEFT"><B>Complexity:</B></TH>
<TD ALIGN="LEFT"><i>O(E log V)</i></TD>
</TR>
</TABLE>
</DIV>

<P>
<PRE>
(1)
template &lt;class VertexListGraph, class Vertex&gt;
void prim_minimum_spanning_tree(VertexListGraph&amp; G, Vertex s);

(2)
template &lt;class VertexListGraph, class Vertex, class Distance&gt;
void prim_minimum_spanning_tree(VertexListGraph&amp; G, Vertex s, Distance d);

(3)
template &lt;class VertexListGraph, class Vertex,
          class Distance, class Visitor&gt;
void prim_minimum_spanning_tree(VertexListGraph&amp; G, Vertex s, 
                                Distance d, Visitor visit);

(4)
template &lt;class VertexListGraph, class Vertex, class Visitor, 
          class Distance, class Weight, class Color, class ID&gt;
void prim_minimum_spanning_tree(VertexListGraph&amp; G, Vertex s, 
                                Distance d, Weight w, Color c, ID id,
                                Visitor visit);
</PRE>

<P>
This is Prim's algorithm&nbsp;[<A
HREF="bibliography.html#prim57:_short">25</A>,<A
HREF="bibliography.html#clr90">8</A>,<A
HREF="bibliography.html#tarjan83:_data_struct_network_algo">27</A>,<A
HREF="bibliography.html#graham85">15</A>] for solving the minimum
spanning tree problem for an undirected graph with weighted edges. See
Section <A
HREF="graph_theory_review.html#sec:minimum-spanning-tree">Minimum
Spanning Tree Algorithms</A> for a definition of the minimum spanning
tree problem. The implementation is simply a call to <a
href="./uniform_cost_search.html"><TT>uniform_cost_search()</TT></a>
with the appropriate choice of comparison and combine functors.

<P>

<H3>Where Defined</H3>

<P>
<a href="../../../boost/graph/prim_minimum_spanning_tree.hpp"><TT>boost/graph/prim_minimum_spanning_tree.hpp</TT></a>

<P>

<H3>Requirements on Types</H3>

<P>

<UL>
<LI>The type <TT>VertexListGraph</TT> must be a model of <a href="./VertexListGraph.html">VertexListGraph</a>.
</LI>
<LI>The type <TT>Vertex</TT> must be convertible to type <TT>boost::graph_traits&lt;VertexListGraph&gt;::vertex_descriptor</TT>.
</LI>
<LI>The type <TT>Visitor</TT> must be a model of <I>Visitor</I>.
</LI>
<LI>The type <TT>Distance</TT> must be a model of
    <a href="../../property_map/ReadWritePropertyMap.html">ReadWritePropertyMap</a>. The vertex descriptor type of
     the graph needs to be usable as the key type of the distance
     map. The value type of the distance map must be
     <I>LessThanComparable</I>.
</LI>
<LI>The type <TT>Weight</TT> must be a model of
     <a href="../../property_map/ReadablePropertyMap.html">ReadablePropertyMap</a>. The edge descriptor type of
     the graph needs to be usable as the key type for the weight
     map. The value type for the map must be
     <I>Addable</I> with the value type of the distance map.
</LI>
<LI>The type <TT>Color</TT> must be a model of
     <a href="../../property_map/ReadWritePropertyMap.html">ReadWritePropertyMap</a>. A vertex descriptor must be
     usable as the key type of the map, and the value type of the
     map must be a model of <I>ColorValue</I>.
</LI>
<LI>The type <TT>ID</TT> must be a model of
     <a href="../../property_map/ReadablePropertyMap.html">ReadablePropertyMap</a>. The value type of <TT>ID</TT>
     must be an integer type. The vertex descriptor type of the graph
     needs to be usable as the key type of the ID map.
</LI>
</UL>

<P>

<H3>Complexity</H3>

<P>
The time complexity is <i>O(E log V)</i>.

<P>

<H3>Example</H3>

<P>
The source code for this example is in <a
href="../example/prim.cpp"><TT>examples/prim.cpp</TT></a>.

<P>
<PRE>
  typedef adjacency_list &lt; vecS, vecS, undirectedS, 
          distance_property&lt;&gt;, weight_property&lt;int&gt; &gt; Graph;
  typedef std::pair&lt;int,int&gt; E;
  const int num_nodes = 5;
  E edges[] = { E(0,2), 
                E(1,1), E(1,3), E(1,4),
                E(2,1), E(2,3),
                E(3,4),
                E(4,0) };
  int weights[] = { 1, 2, 1, 2, 7, 3, 1, 1};
  Graph G(num_nodes, edges, edges + sizeof(edges)/sizeof(E), weights);

  std::vector&lt;Graph::vertex_descriptor&gt; p(num_vertices(G));
  prim_minimum_spanning_tree(G, *(vertices(G).first),
                             visit_predecessor_ptr(p.begin()));

  for ( std::vector&lt;Graph::vertex_descriptor&gt;::iterator i = p.begin();
        i != p.end(); ++i)
    if (*i != Graph::vertex_descriptor() ) 
      cout &lt;&lt; "parent[" &lt;&lt; i - p.begin() 
           &lt;&lt; "] = " &lt;&lt; id_property_map()[*i] &lt;&lt; endl;
    else
      cout &lt;&lt; "parent[" &lt;&lt; i - p.begin() &lt;&lt; "] = no parent" &lt;&lt; endl;
</PRE>
The output is:
<PRE>
  parent[0] = 0
  parent[1] = 3
  parent[2] = 0
  parent[3] = 4
  parent[4] = 0
</PRE>



<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy 2000</TD><TD>
<A HREF=http://www.boost.org/people/jeremy_siek.htm>Jeremy Siek</A>, Univ.of Notre Dame (<A HREF="mailto:jsiek@lsc.nd.edu">jsiek@lsc.nd.edu</A>)
</TD></TR></TABLE>

</BODY>
</HTML> 
