<HTML>
<!--
  -- Copyright (c) Jeremy Siek 2000
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Jeremy Siek makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
<Head>
<Title>Uniform Cost Search</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
        ALINK="#ff0000"> 
<IMG SRC="../../../c++boost.gif" 
     ALT="C++ Boost" width="277" height="86"> 

<BR Clear>

<H1><A NAME="sec:uniform-cost-search"></A>
<TT>uniform_cost_search</TT>
</H1>

<P>
<DIV ALIGN="left">
<TABLE CELLPADDING=3 border>
<TR><TH ALIGN="LEFT"><B>Graphs:</B></TH>
<TD ALIGN="LEFT">directed</TD>
</TR>
<TR><TH ALIGN="LEFT"><B>Properties:</B></TH>
<TD ALIGN="LEFT">color, distance, weight, vertex index</TD>
</TR>

<TR><TH ALIGN="LEFT"><B>Complexity:</B></TH>
<TD ALIGN="LEFT">time: <i>O((V + E) log V)</i>
</TD>
</TR>

<TR><TH ALIGN="LEFT"><B>Where Defined:</B></TH>
<TD ALIGN="LEFT">
<a href="../../../boost/graph/uniform_cost_search.hpp"><TT>boost/graph/uniform_cost_search.hpp</TT></a>
</TD>
</TR>


</TABLE>
</DIV>

<P>
<PRE>
  (1)
  template &lt;class <a href="./VertexListGraph.html">VertexListGraph</a>, class <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">BinaryPredicate</a>, 
            class <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">BinaryFunction</a>&gt;
  void
  uniform_cost_search(VertexListGraph& g, 
     typename graph_traits&lt;VertexListGraph&gt;::vertex_descriptor s, 
     BinaryPredicate compare, BinaryFunction combine);

  (2)
  template &lt;class <a href="./VertexListGraph.html">VertexListGraph</a>, class <a href="#DistanceMap">DistanceMap</a>, class <a href="#WeightMap">WeightMap</a>,
            class <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">BinaryPredicate</a>, class <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">BinaryFunction</a>&gt;
  void
  uniform_cost_search(VertexListGraph& g,
    typename graph_traits&lt;VertexListGraph&gt;::vertex_descriptor s, 
    DistanceMap distance, WeightMap weight,
    BinaryPredicate compare, BinaryFunction combine);

  (3)
  template &lt;class <a href="./VertexListGraph.html">VertexListGraph</a>,
            class <a href="#DistanceMap">DistanceMap</a>, class <a href="#WeightMap">WeightMap</a>, class <a href="#ColorMap">ColorMap</a>, class <a href="#VertexIndexMap">VertexIndexMap</a>,
            class <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">BinaryPredicate</a>, class <a href="http://www.sgi.com/tech/stl/BinaryFunction.html">BinaryFunction</a>,
            class <a href="./UniformCostVisitor.html">UniformCostVisitor</a>&gt;
  void
  uniform_cost_search(VertexListGraph& g,
    typename graph_traits&lt;VertexListGraph&gt;::vertex_descriptor  s,
    DistanceMap distance, WeightMap weight, ColorMap color, VertexIndexMap id, 
    BinaryPredicate compare, BinaryFunction combine,
    UniformCostVisitor vis);
</PRE>

<P>
This function solves a generalized version of the single-source
shortest paths problem. In particular, the algorithm used is a
generalized version of <a href="./dijkstra_shortest_paths.html">
Dijkstra's single-source shortest paths</a> algorithm.  In Dijkstra's
algorithm the ``cost'' is the edge weight. With
<TT>uniform_cost_search()</TT> the user supplies the meaning of
``cost'' through the <TT>compare</TT> and <tt>combine</tt> function
objects. For Dijkstra's algorithm <TT>compare</tt> is
<tt>std::less&lt;D&gt;</TT> and <tt>combine</tt> is
<tt>std::plus&lt;W&gt;</tt>.

<p>If you want to solve the single-source shortest paths problem for
integer edge weights, where all edge weights are equal to 1, then use
<a href="./breadth_first_search.html">
<tt>breadth_first_search()</tt></a> instead (it is faster) with a <a
href="./distance_recorder.html"><tt>distance_recorder</tt></a>.


<P>
<TT>uniform_cost_search()</TT> does not initialize the distance
properties of the graph, so they must be pre-initialized to a maximum
value (with respect to the predicate). Typically
<tt>std::numeric_limits&lt;D&gt;::max()</tt> is a good value. Also,
the source vertex <tt>s</tt> must be initialized to have zero
distance. The following code is an example of how one might initialize
the distance properties prior to calling
<TT>uniform_cost_search()</TT> .

<pre>
  typedef typename property_traits&lt;DistanceMap&gt;::value_type D;
  typename boost::graph_traits&lt;Graph&gt;::vertex_iterator ui, ui_end;
  for (tie(ui, ui_end) = vertices(G); ui != ui_end; ++ui)
    put(distance, *ui, std::numeric_limits&lt;D&gt;::max());

  put(distance, s, D());
</pre>

<p>
The <tt>ColorMap</tt> is used to keep track of which vertices have
been visited. Traditionally, implementation of Dijkstra's algorithm do
not use a color map and instead use the distance map for this purpose.
When generalizing to a uniform-cost search, it is better to separate
out the responsibilities.

<p>
The implementation of <TT>uniform_cost_search()</TT>
consists mainly of a call to version (3) of <a
href="./breadth_first_search.html"><TT>breadth_first_search()</TT></a>.


<P>

<H3>Requirements on Types</H3>

<P>

<UL>
<LI>The graph type must be a model of <a
href="./VertexListGraph.html">Vertex List Graph</a>.

<P>
</LI>
<LI>The <TT>BinaryPredicate</TT> type must be a model of <a
      href="http://www.sgi.com/tech/stl/BinaryPredicate.html">Binary Predicate</a>
      and have argument types that match the value type of the
      <TT>DistanceMap</TT> property map.

<P>
</LI>
<LI>The <TT>BinaryFunction</TT> type must be a model of <a
     href="http://www.sgi.com/tech/stl/BinaryFunction.html">Binary Function</a>. The first argument type of the binary function must match the value
      type of the <TT>DistanceMap</TT> property map and the second
      argument type must match the value type of the <TT>WeightMap</TT>
      property map.  The result type must be the same type as the
      distance value type.

<P>
</LI>
<LI>In version (1) the graph must be a <a
    href="./PropertyGraph.html">Property Graph</a> for
    <TT>vertex_distance_t</TT> where the property map for the graph
    meets the same requirements as for <TT>DistanceMap</TT>. The graph
    must also be a <a
    href="./PropertyGraph.html">Property Graph</a> for
    <TT>edge_weight_t</TT> where the property map for the grpah
    meets the same requirements for <TT>WeightMap</TT> below.

<P>
</LI>
<LI>In version (1) and (2) the graph must be a <a
    href="./PropertyGraph.html">Property Graph</a> for
    <TT>vertex_color_t</TT> and <TT>vertex_index_t</TT>, where the property
    map for the graph meet the same requirements as for
    <TT>ColorMap</TT> and <TT>VertexIndexMap</TT> below.

<P>
</LI>
<LI><a name="DistanceMap">The type <TT>DistanceMap</TT> must be a model of <a
    href="../../property_map/ReadWritePropertyMap.html">Read/Write Property Map</a>. The
    vertex descriptor type of the graph needs to be usable as the key
    type of the distance map.</a>

<P>
</LI>
<LI><a name="WeightMap">The type <TT>WeightMap</TT> must be a model of <a
     href="../../property_map/ReadablePropertyMap.html">Readable Property Map</a>. The
     edge descriptor type of the graph needs to be usable as the key
     type for the weight map.</a>

<P>
</LI>
<LI><a name="ColorMap">The type <TT>ColorMap</TT> must be a model of <a
     href="../../property_map/ReadWritePropertyMap.html">Read/Write Property Map</a>. A
     vertex descriptor must be usable as the key type of the map,
     and the value type of the map must be a model of
     <a href="./ColorValue.html">Color Value</a>.</a>

<P>
</LI>
<LI><a name="VertexIndexMap"> The type <TT>VertexIndexMap</TT> must be
     a model of <a href="../../property_map/ReadablePropertyMap.html">
     Readable Property Map</a>. The value type of
     <TT>VertexIndexMap</TT> must be an integer type. The vertex
     descriptor type of the graph needs to be usable as the key type
     of the index map.</a>

<P>
</LI>
<LI>The type <TT>UniformCostVisitor</TT> must be a model of <a
href="./UniformCostVisitor.html">Uniform Cost Visitor</a>.
</LI>
</UL>

<P>

<H3>Complexity</H3>

<P>
The time complexity is <i>O((V + E) log V)</i>, or just <i>O(E log V)</i>
if all vertices are reachable from the source.

<P>

<H3>Example</H3>

<P>
See the <A
HREF="file_dependency_example.html#sec:parallel-compilation"> Parallel
Compilation</A> section of the File Dependency Example.

<P>


<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy 2000</TD><TD>
<A HREF="../../../people/jeremy_siek.htm">Jeremy Siek</A>, Univ.of Notre Dame (<A HREF="mailto:jsiek@lsc.nd.edu">jsiek@lsc.nd.edu</A>)
</TD></TR></TABLE>

</BODY>
</HTML> 
