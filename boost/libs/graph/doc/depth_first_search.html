<HTML>
<!--
  -- Copyright (c) Jeremy Siek, Lie-Quan Lee, and Andrew Lumsdaine 2000
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  We make no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
<Head>
<Title>Boost Graph Library: Depth-First Search</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
        ALINK="#ff0000"> 
<IMG SRC="../../../c++boost.gif" 
     ALT="C++ Boost" width="277" height="86"> 

<BR Clear>

<H1><A NAME="sec:depth-first-search"></A>
<TT>depth_first_search</TT>
</H1>

<P>
<PRE>
(1)
template &lt;class <a href="./VertexListGraph.html">VertexListGraph</a>, class class P, class T, class R&gt;
void depth_first_search(VertexListGraph&amp; G, const bgl_named_params&lt;P, T, R&gt;&amp; params);
</PRE>

<P>
The <TT>depth_first_search()</TT> algorithm performs a depth-first
search (DFS) on a graph, invoking the methods of the graph search
visitor at the appropriate event-points. A depth-first search visits
all the vertices in a graph, starting with some arbitrary vertex and
then always choosing the next adjacent unvisited vertex. Once the DFS
reaches a vertex with no unvisited neighbors it backtracks to one of
the previous vertices and continues from there. Once all of the
vertices in the same connected component have been visited, another
arbitrary unvisited vertex is choosen and the depth-first search
resumes. A more detailed explanation of DFS is given in Section <A
HREF="./graph_theory_review.html#sec:dfs-algorithm">Depth-First
Search</A>. The depth-first exploration of each connected component is
implemented by the function <a
href="./depth_first_visit.html"><tt>depth_first_visit()</tt></a>.


<p>
The <tt>DFSVisitor</tt> supplied by the user determines what
actions are taken at each event-point within the algorithm.

<p>
The <tt>ColorMap</tt> is used by the algorithm to keep track
of which vertices have been visited.

<P>
DFS is used as the kernel for several other graph algorithms,
including <a
href="./topological_sort.html"><tt>topological_sort</tt></a> and two
of the connected component algorithms.

<P>

<H3>Where Defined</H3>

<P>
<a href="../../../boost/graph/depth_first_search.hpp"><TT>boost/graph/depth_first_search.hpp</TT></a>

<h3>Parameters</h3>

IN: <tt>VertexListGraph&amp; g</tt>
<blockquote>
  A directed or undirected graph. The graph type must
  be a model of <a href="./VertexListGraph.html">Vertex List Graph</a>.
</blockquote>


<h3>Named Parameters</h3>

IN: <tt>visitor(DFSVisitor vis)</tt>
<blockquote>
  A visitor object that is invoked inside the algorithm at the
  event-points specified by the <a href="./DFSVisitor.html">DFS
  Visitor</a> concept.<br> <b>Default:</b>
  <tt>dfs_visitor&lt;null_visitor&gt;</tt>
</blockquote>

UTIL/OUT: <tt>color_map(ColorMap color)</tt>
<blockquote>
  This is used by the algorithm to keep track of its progress through
  the graph. The type <tt>ColorMap</tt> must be a model of <a
  href="../../property_map/ReadWritePropertyMap.html">Read/Write
  Property Map</a> and its key type must be the graph's vertex
  descriptor type and the value type of the color map must model
  <a href="./ColorValue.html">ColorValue</a>.<br>
  <b>Default:</b> an <a
  href="../../property_map/iterator_property_map.html">
  </tt>iterator_property_map</tt></a> created from a
  <tt>std::vector</tt> of <tt>default_color_type</tt> of size
  <tt>num_vertices(g)</tt> and using the <tt>i_map</tt> for the index
  map.
</blockquote>

IN: <tt>vertex_index_map(VertexIndexMap i_map)</tt>
<blockquote>
  This maps each vertex to an integer in the range <tt>[0,
  num_vertices(g))</tt>. This parameter is only necessary when the
  default color property map is used. The type <tt>VertexIndexMap</tt>
  must be a model of <a
  href="../../property_map/ReadablePropertyMap.html">Readable Property
  Map</a>. The value type of the map must be an integer type. The
  vertex descriptor type of the graph needs to be usable as the key
  type of the map.<br>

  <b>Default:</b> <tt>get(vertex_index, g)</tt>
</blockquote>

<P>

<H3><A NAME="SECTION001340300000000000000">
Complexity</A>
</H3>

<P>
The time complexity is <i>O(E + V)</i>.

<P>

<H3>Example</H3>

<P>
The example is in <a href="../example/dfs_basics.cpp">
<TT>examples/dfs_basics.cpp</TT></a> shows DFS applied to the graph in
<A HREF="./graph_theory_review.html#fig:dfs-example">Figure 1</A>.

<h3>See Also</h3>

<a href="./depth_first_visit.html"><tt>depth_first_visit</tt></a>


<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy 2000</TD><TD>
<A HREF="../../../people/jeremy_siek.htm">Jeremy Siek</A>,
Univ.of Notre Dame (<A
HREF="mailto:jsiek@lsc.nd.edu">jsiek@lsc.nd.edu</A>)<br>
<A HREF="../../../people/liequan_lee.htm">Lie-Quan Lee</A>, Univ.of Notre Dame (<A HREF="mailto:llee1@lsc.nd.edu">llee1@lsc.nd.edu</A>)<br>
<A HREF=http://www.lsc.nd.edu/~lums>Andrew Lumsdaine</A>,
Univ.of Notre Dame (<A
HREF="mailto:lums@lsc.nd.edu">lums@lsc.nd.edu</A>)
</TD></TR></TABLE>

</BODY>
</HTML> 
