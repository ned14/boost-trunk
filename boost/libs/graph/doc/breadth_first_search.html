<HTML>
<!--
  -- Copyright (c) Jeremy Siek 2000, 2001
  --
  -- Permission to use, copy, modify, distribute and sell this software
  -- and its documentation for any purpose is hereby granted without fee,
  -- provided that the above copyright notice appears in all copies and
  -- that both that copyright notice and this permission notice appear
  -- in supporting documentation.  Silicon Graphics makes no
  -- representations about the suitability of this software for any
  -- purpose.  It is provided "as is" without express or implied warranty.
  -->
<Head>
<Title>Boost Graph Library: Breadth-First Search</Title>
<BODY BGCOLOR="#ffffff" LINK="#0000ee" TEXT="#000000" VLINK="#551a8b" 
        ALINK="#ff0000"> 
<IMG SRC="../../../c++boost.gif" 
     ALT="C++ Boost" width="277" height="86"> 

<BR Clear>

<H1><A NAME="sec:bfs">
<TT>breadth_first_search</TT>
</H1>

<P>
<PRE>
  template &lt;class <a href="./VertexListGraph.html">VertexListGraph</a>, class P, class T, class R&gt;
  void breadth_first_search(VertexListGraph& G, 
    typename graph_traits&lt;VertexListGraph&gt;::vertex_descriptor s, 
    const bgl_named_params&lt;P, T, R&gt;&amp; params);
</PRE>

<P>
The breadth-first search (BFS) algorithm is not really an algorithm in
the sense that it has a particular purpose.  Instead BFS is more like
an algorithm <I>pattern</I>. One can do many different things with
BFS. For example, the BFS pattern is used in the BGL to build several
other algorithms: Dijkstra's shortest paths, Prim's Minimum Spanning
Tree and best-first search. The definition of a <I>breadth-first
search</I> is given in Section <A
HREF="./graph_theory_review.html#sec:bfs-algorithm">Breadth-First
Search</A>.

<P>
The BGL BFS functions are highly parameterized so that they can be
used in a wide variety of places.  The way to customize the BFS
algorithm to perform different operations is to supply a visitor,
which is a function object with multiple functions. Each member
function of the visitor gets invoked at special times during the
algorithm as specified by the <a href="./BFSVisitor.html">BFS
Visitor</a> concept. Also, visitors can be layered on top of each
other so that one can do lots of things during a single run of
BFS. See the <a href="./bfs_visitor.html">bfs_visitor</a> class and
the <A HREF="./EventVisitor.html">EventVisitor</A> concept for more
details.

<P>
Another way to customize the BFS algorithm is change the type of queue
used. For instance, <a
href="./dijkstra_shortest_paths.html"><TT>dijkstra_shortest_paths()</TT></a>
uses a priority queue.

<p>
The <tt>ColorMap</tt> is used by BFS to keep track of which vertices
have been visited. At the beginning of the algorithm all vertices are
white. As the algorithm proceeds, vertices are colored gray as they
are inserted into the queue, and then colored black when they are
finished and removed from queue.

<P>

<H3>Where Defined</H3>

<P>
<a href="../../../boost/graph/breadth_first_search.hpp"><TT>boost/graph/breadth_first_search.hpp</TT></a>

<P>

<h3>Parameters</h3>

IN: <tt>VertexListGraph&amp; g</tt>
<blockquote>
  A directed or undirected graph. The graph type must
  be a model of <a href="./VertexListGraph.html">Vertex List Graph</a>.
</blockquote>

IN: <tt>vertex_descriptor s</tt>
<blockquote>
  The source vertex where the search is started.
</blockquote>


<h3>Named Parameters</h3>

IN: <tt>visitor(BFSVisitor vis)</tt>
<blockquote>
  A visitor object that is invoked inside the algorithm at the
  event-points specified by the <a href="BFSVisitor.html">BFS
  Visitor</a> concept.<br> <b>Default:</b>
  <tt>bfs_visitor&lt;null_visitor&gt;</tt>
</blockquote>

UTIL/OUT: <tt>color_map(ColorMap color)</tt>
<blockquote>
  This is used by the algorithm to keep track of its progress through
  the graph. The type <tt>ColorMap</tt> must be a model of <a
  href="../../property_map/ReadWritePropertyMap.html">Read/Write
  Property Map</a> and its key type must be the graph's vertex
  descriptor type and the value type of the color map must model
  <a href="./ColorValue.html">ColorValue</a>.<br>
  <b>Default:</b> an <a
  href="../../property_map/iterator_property_map.html">
  </tt>iterator_property_map</tt></a> created from a
  <tt>std::vector</tt> of <tt>default_color_type</tt> of size
  <tt>num_vertices(g)</tt> and using the <tt>i_map</tt> for the index
  map.
</blockquote>

IN: <tt>vertex_index_map(VertexIndexMap i_map)</tt>
<blockquote>
  This maps each vertex to an integer in the range <tt>[0,
  num_vertices(g))</tt>. This parameter is only necessary when the
  default color property map is used. The type <tt>VertexIndexMap</tt>
  must be a model of <a
  href="../../property_map/ReadablePropertyMap.html">Readable Property
  Map</a>. The value type of the map must be an integer type. The
  vertex descriptor type of the graph needs to be usable as the key
  type of the map.<br>

  <b>Default:</b> <tt>get(vertex_index, g)</tt>
</blockquote>

UTIL: <tt>buffer(Buffer&amp; Q)</tt>
<blockquote>
  The queue used to determine the order in which vertices will be
  discovered.  If a FIFO queue is used, then the traversal will
  be according to the usual BFS ordering. Other types of queues
  can be used, but the traversal order will be different.
  For example Dijkstra's algorithm can be implemented
  using a priority queue. The type <tt>Buffer</tt> must be a model of
  <a href="./Buffer.html">Buffer</a>.<br>
  <b>Default:</b> <tt>boost::queue</tt>
</blockquote>  


<H3><A NAME="SECTION001330300000000000000">
Complexity</A>
</H3>

<P>
The time complexity is <i>O(E + V)</i>. 

<P>

<H3><A NAME="SECTION001330400000000000000">
Example</A>
</H3>

<P>
The example in <a
href="../example/bfs_basics.cpp"><TT>examples/bfs_basics.cpp</TT></a>
demonstrates using the BGL Breadth-first search algorithm on the graph
from <A HREF="./graph_theory_review.html#fig:bfs-example">Figure
5</A>.


<h3>See Also</h3>

<a href="./bfs_visitor.html"><tt>bfs_visitor</tt></a> and
<a href="./depth_first_search.html"><tt>depth_first_search()</tt></a>


<br>
<HR>
<TABLE>
<TR valign=top>
<TD nowrap>Copyright &copy 2000</TD><TD>
<A HREF="../../../people/jeremy_siek.htm">Jeremy Siek</A>, Univ.of Notre Dame (<A HREF="mailto:jsiek@lsc.nd.edu">jsiek@lsc.nd.edu</A>)
</TD></TR></TABLE>

</BODY>
</HTML> 
