<?xml version="1.0" standalone="yes"?>
<!DOCTYPE library PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
     "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd"
[
    <!ENTITY % entities SYSTEM "program_options.ent" >
    %entities;
]>
<section id="program_options.overview">
  <title>Library overview</title>

  <para>In the previous section, we've seen several examples of library usage.
    This section will describe overall library design: what are the primary 
    components and what do they do.
  </para>

  <para>The library has three main components:
    <itemizedlist>
      <listitem>
        <para>The options description component, which describes the allowed options
          and what to do with the values of the options.
        </para>
      </listitem>
      <listitem>
        <para>The parsers component, which uses this information to find option names
          and values in the input sources and return them. 
        </para>
      </listitem>
      <listitem>
        <para>The storage component, which provides the
          interface to access the value of an option. It also converts the string
          representation of values that parsers return into desired C++ types.
        </para>
      </listitem>
    </itemizedlist>
  </para>

  <para>To be a little more concrete, the <code>options_description</code>
  class is from the options description component, the
  <code>parse_command_line</code> function is from the parsers component, and the
  <code>variables_map</code> class is from the storage component. </para>

  <para>We've learned how those components can be used by the
  <code>main</code> function to parse command line and config file. Before
  going into the details of each component, a few notes about the world outside of
  <code>main</code>
  </para>

  <para>
    For that outside world, the storage component is the most important. It
    provides a class which stores all option values and that class can be
    freely passed around your program to modules which need access to the
    options. All the other components can be used only in the place where
    actual parsing is the done. However, it might also make sense to make the
    individual program modules describe their options and pass them to main
    module, which will merge all options together. Of course, this is only
    important when the number of options is large and declaring them in one
    place becomes troublesome.
  </para>

<!--
  <para>The design looks very simple and straight-forward, but it is worth
  noting some important points:
    <itemizedlist>
      <listitem>
        <para>The options description is not tied to specific source. Once
        options are described, all parsers can use that description.</para>
      </listitem>
      <listitem>
        <para>The parsers are intended to be fairly dump. They just
          split the input into (name, value) pairs, using strings to represent
          names and values. No meaningfull processing of values is done.
        </para>
      </listitem>
      <listitem>
        <para>The storage component is focused on storing options values. It 
        </para>
      </listitem>
  

    </itemizedlist>

  </para>
-->

  <section>
    <title>Options description component</title>

    <para>The options description component has three main classes:
      &option_description;, &value_semantic; and &options_description;. The
      first two together describe a single option. The &option_description;
      class contains the option's name, description and a pointer to &value_semantic;,
      which, in turn, knows the type of the option's value and can parse the value,
      apply the default value, and so on. The &options_description; class is a
      container for instances of &option_description;.
    </para>

    <para>For almost every library, those classes could be created in a
      conventional way: that is, you'd create new options using constructors and
      then call <code>insert</code> method of &options_description;. However,
      that's overly verbose for declaring 20 or 30 options. This concern led
      to creation of the syntax that you've already seen:
<programlisting>
options_description desc;
desc.add_options()
    ("help", "produce help")
    ("optimization", value&lt;int&gt;()->default_value(10), "optimization level")
    ;
</programlisting>      
    </para>

    <para>The call to the <code>value</code> function creates an instance of
    suitable class, derived from <code>options_semantic</code>. Calling member
    functions of that instance allows one to specify additional information (this
    essentially emulates named parameters to the constructor). Calls to
    <code>operator()</code> on the object returned by <code>add_options</code>
    forward arguments to the constructor of the <code>option_description</code>
    class and add the new instance.</para>

    <!-- Note that the classes are not modified during parsing -->
          
  </section>

  <section>
    <title>Parsers component</title>

    <para>The parsers component splits input sources into (name, value) pairs.
      Each parser looks for possible options and consults the options
      description component to determine if the option is know and how the value
      can be specified. In the simplest case, the name is explicitly specified,
      which allows the library to decide if such option is known. If it is known, the
      &value_semantic; instance tells how the value can be specified. Common
      cases are when the value is explicitly specified by the user, and when
      the value cannot be specified by the user, but the presense of the
      option implies some value (for example, <code>true</code>). So, the
      parser checks that the value is specified when needed and not specified
      when not needed, and returns new (name, value) pair.
    </para>

    <para>
      To invoke a parser you typically call a function, passing options
      desription and command line or config_file or something else.
      The results of parsing are returned as an instance of the &parsed_options;
      class. Typically, it's passed directly to the storage
      component. However, it also can be used to add some special processing,
      for example, if the order in which options are specified is important.                  
    </para>

    <para>
      There are three exceptions to the above model -- all related to tradional
      usage of the command line. While they require some support from the options
      description component, the additional complexity is tolerable.
      <itemizedlist>
        <listitem>
          <para>The name specified on the command line can be
            different from the option name -- it's common to provide a "short option
            name" alias to a longer name. It's also common to allow an abbreviated name
            to be specified on the command line.
          </para>
        </listitem>
        <listitem>
          <para>Sometimes it's desirable to specify value as several
          tokens. For example, an option "--email-recipient" can be followed
          by several emails, each as a separate command line token. This
          behaviour is supported, though it can lead to parsing ambiguities
          and is not enabled by default.
          </para>
        </listitem>
        <listitem>
          <para>The command line can contain positional options -- i.e. elements
            which don't have any name. The command line parser provides a
            mechanism to guess names for such options, as we've seen in the
            tutorial.
          </para>
        </listitem>
      </itemizedlist>
    </para>      
    
  </section>


  <section>
    <title>Storage component</title>

    <para>The storage component is responsible for:
      <itemizedlist>
        <listitem>
          <para>Storing the final values of an option into a special class and in
            regular variables</para>
        </listitem>
        <listitem>
          <para>Handling priorities among different sources.</para>
        </listitem>

        <listitem>
          <para>Calling user-specified <code>notify</code> functions with the final
         values of options.</para>
        </listitem>
      </itemizedlist>
    </para>

    <para>Let's consider an example:
      <programlisting>
        variables_map vm;
        store(parse_command_line(argc, argv, desc), vm);
        store(parse_config_file("example.cfg", desc), vm);
        finish(vm);
      </programlisting>
      The <code>variables_map</code> class is used to store the option
      values. The two calls to the <code>store</code> function add values
      found on the command line and in the config file. Finally the call to 
      <code>notify</code> function runs user-specified notify functions and
      stores values into regular variables, if needed. 
    </para>

    <para>The priority is handled
      in a simple way: the <code>store</code> function will not change the value
      of an option if it's already assigned. In this case, if the command line
      specifies a value for an option, that value will be preferred to the
      value specified in config file.
    </para>

    <warning>
      <para>Don't forget to call the <code>notify</code> function after you've
      stored all parsed values.</para>
    </warning>

  </section>

  <section>
    <title>Annotated list of symbols</title>
    
    <para>The following table describes all the important symbols in the
      library, for quick access.</para>
    
    <informaltable pgwide="1">
        
      <tgroup cols="2">
        <colspec colname='c1'/>
        <colspec colname='c2'/>
        <thead>
          
          <row>            
            <entry>Symbol</entry>
            <entry>Description</entry>
          </row>
        </thead>
        
        <tbody>
          
          <row>            
            <entry namest='c1' nameend='c2'>Options description component</entry>
          </row>
          
          <row>
            <entry>&options_description;</entry>
            <entry>describes a number of options</entry>
          </row>
          <row>
            <entry>&value;</entry>
            <entry>defines the option's value</entry>
          </row>

          <row>            
            <entry namest='c1' nameend='c2'>Parsers component</entry>
          </row>
          
          <row>
            <entry>&parse_command_line;</entry>
            <entry>parses command line</entry>
          </row>
          <row>
            <entry>&parse_config_file;</entry>
            <entry>parses config file</entry>
          </row>

          <row>
            <entry>&parse_environment;</entry>
            <entry>parses environment</entry>
          </row>

          <row>            
            <entry namest='c1' nameend='c2'>Storage component</entry>
          </row>

          <row>
            <entry>&variables_map;</entry>
            <entry>storage for option values</entry>
          </row>
   
        </tbody>
      </tgroup>
      
    </informaltable>
    
  </section>
  
</section>

<!--
     Local Variables:
     mode: xml
     sgml-indent-data: t     
     sgml-parent-document: ("program_options.xml" "section")
     sgml-set-face: t
     End:
-->