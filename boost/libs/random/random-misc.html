
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

<title>Boost Random Number Generator Library (Miscellaneous)</title>
</head>

<body bgcolor="#FFFFFF" text="#000000">

<h1>Random Number Generator Library --- Miscellaneous Decorators</h1>

<ul>
<li><a href="#random_number_generator">Class template
<code>random_number_generator</code></a>
<li><a href="#generator_iterator">Class template
<code>generator_iterator</code></a>
</ul>

<h2>Introduction</h2>

These decorator class templates allow adaptation of the random number
generators and distribution functions to concepts found in the C++
Standard Library, in particular the RandomNumberGenerator and the
InputIterator concepts.  The latter adaptation is useful, because the
the basic random number generators do not implement the InputIterator
requirements per se, in contrast to the distribution functions.


<h2><a name="synopsis">Synopsis</a> of miscellaneous decorators in
header <code>&lt;boost/random.hpp&gt;</code></h2>

<pre>
namespace boost {
  template&lt;class UniformRandomNumberGenerator, class IntType = long&gt;
  class random_number_generator;
  template&lt;class Generator&gt;
  class generator_iterator;
} // namespace boost
</pre>


<h2><a name="random_number_generator">Class template
<code>random_number_generator</code></a></h2>

<h3>Synopsis</h3>
<pre>
template&lt;class UniformRandomNumberGenerator, class IntType = long&gt;
class random_number_generator
{
public:
  typedef UniformRandomNumberGenerator base_type;
  typedef IntType argument_type;
  typedef IntType result_type;
  random_number_generator(base_type & rng);
  result_type operator()(argument_type n);
};
</pre>

<h3>Description</h3>

Instantiations of class template <code>random_number_generator</code>
model a RandomNumberGenerator (std:25.2.11 [lib.alg.random.shuffle]).
On each invocation, it returns a uniformly distributed integer in
the range [0..<code>n</code>).
<p>
The template parameter <code>IntType</code> shall denote some
integer-like value type.
<p>

<em>Note:</em> I consider it unfortunate that the C++ Standard uses
the name RandomNumberGenerator for something rather specific.

<h3>Members</h3>

<pre>random_number_generator(base_type & rng)</pre>

<strong>Effects:</strong> Constructs a
<code>random_number_generator</code> functor with the given uniform
random number generator as the underlying source of random numbers.

<pre>result_type operator()(argument_type n)</pre>

<strong>Returns:</strong> The value of
<code>uniform_int&lt;base_type&gt;(rng, 0, n-1)()</code>.


<h2><a name="generator_iterator">Class template
<code>generator_iterator</code></a></h2>

<h3>Synopsis</h3>
<pre>
template&lt;class Generator&gt;
class generator_iterator
  : equality_comparable&lt;generator_iterator&lt;Generator&gt; &gt;,
  incrementable&lt;generator_iterator&lt;Generator&gt; &gt;,
  dereferenceable&lt;generator_iterator&lt;Generator&gt;,
      typename Generator::result_type&gt;
{
public:
  typedef typename Generator::result_type value_type;
  typedef std::ptrdiff_t difference_type;
  typedef const typename Generator::result_type * pointer;
  typedef const typename Generator::result_type & reference;
  typedef std::input_iterator_tag iterator_category;

  explicit generator_iterator(Generator & g);
  generator_iterator& operator++();
  reference operator*() const;
  friend bool operator==(const generator_iterator&lt;Generator&gt;& x, 
			 const generator_iterator&lt;Generator&gt;& y);
};
</pre>

<h3>Description</h3>

Instantiations of class template <code>generator_iterator</code>
satisfy the input iterator requirements (std:24.1.1
[lib.input.iterators]).  It allows iterator-like access to a
generator, e.g. a NumberGenerator.  Note that all distribution
functions now satisfy the input iterator requirements as-is.  However,
the base generators do not.

<h3>Members</h3>

<pre>explicit generator_iterator(Generator & g)</pre>

<strong>Effects:</strong> Constructs a <code>generator_iterator</code>
with <code>g</code> as the underlying generator. Invokes the
underlying generator functor.

<pre>generator_iterator& operator++()</pre>

<strong>Effects:</strong> Invokes the underlying generator functor.
<p>
<strong>Returns:</strong> <code>*this</code>

<pre>reference operator*() const</pre>

<strong>Returns:</strong> The value of the last invocation of the
underlying generator functor.

<h3>Overloaded global operators</h3>

<pre>bool operator==(const generator_iterator&lt;Generator&gt;& x, 
	         const generator_iterator&lt;Generator&gt;& y)</pre>

<strong>Returns:</strong> <code>true</code> if and only if the
<code>x</code> and <code>y</code> have been initialized with a
reference to the same generator functor and <code>*x == *y</code>.

<h3>Example</h3>

The following program shows how <code>generator_iterator</code>
transforms a generator into an input iterator.

<pre>
#include &lt;iostream>
#include &lt;boost/random.hpp>

class my_generator
{
public:
  typedef int result_type;
  my_generator() : state(0) { }
  int operator()() { return ++state; }
private:
  int state;
};

int main()
{
  my_generator gen;
  boost::generator_iterator&lt;my_generator> it(gen);
  for(int i = 0; i &lt; 10; ++i, ++it)
    std::cout &lt;&lt; *it &lt;&lt; std::endl;
}
</pre>

<p>
<hr>
Jens Maurer, 2001-01-30

</body>
</html>
