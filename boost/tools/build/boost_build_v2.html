<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">

<html>
  <head>
    <meta name="generator" content=
    "HTML Tidy for Linux/x86 (vers 1st March 2002), see www.w3.org">
    <!--tidy options: -i -wrap 78 -->
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

    <title>Boost.Build v2 user manual</title>
<style type="text/css">
        hr { color: black }
        p.revision { text-align: right; font-style: italic }
        pre.code { margin-left: 2em } 
        pre.output { margin-left: 2em }
        img.banner { border: 0; float: left }
        h1 { text-align: right }
        br.clear { clear: left }
        p.alert { color: red }
        table { align: center; border: thin; }
</style>
  </head>

  <body>
    <p><a href="../../index.htm"><img class="banner" height="86" width="277"
    alt="C++ Boost" src="../../c++boost.gif"></a></p>

    <h1>Boost.Build v2 user manual<br class="clear">
    </h1>
    <hr>

    <p class="alert">This is preliminary version intended to document
    everything implemeneted but not yet ready for any practical use.</p>
    <hr>

    <dl class="page-index">
      <dt><a href="#sec-reference">Reference documentation</a></dt>

      <dd>
        <dl class="page-index">
          <dt><a href="#features_properties">Features and properties</a></dt>

          <dt><a href="#initialization">Initialization</a></dt>

          <dt><a href="#command_line">Command line</a></dt>

          <dt><a href="#projects">Projects</a></dt>

          <dt><a href="#targets">Targets</a></dt>

          <dt><a href="#build_process">Build process</a></dt>
        </dl>
      </dd>
    </dl>
    <hr>

    <h2><a name="sec-reference">Reference</a></h2>

    <h3><a name="features_properties">Features and properties</a></h3>

    <h4>Definition</h4>

    <p>TODO: give a name and describe the property set joined with slashes. I
    use the term "property path" somewhere below.</p>

    <h4>Link compatible and imcompatible properties</h4>

    <h4>Definition of property refinement</h4>

    <h3><a name="initialization">Initialization</a></h3>

    <h3><a name="command_line">Command line</a></h3>

    <p>Boost.Build extends Jam's command line in two ways. First, command
    line arguments can be used not only to specify targets to build, but also
    to specify build variants or arbitrary build request. Second, there are
    additional command line options.</p>

    <h4>Command line arguments</h4>
    Command line arguments specify targets and build request using the
    following rules. 

    <ul>
      <li>An argument which does not contain slashes or the "=" symbol is
      either a value of an implicit feature, or target to be build. It is
      taken to be value of a feature if appropriate feature exists.
      Otherwise, it is considered target name.</li>

      <li>
        An argument with either slashes or the "=" symbol specifies build
        properties. It is converted into a set of build properties as
        follows: 

        <ul>
          <li>The argument is split at each slash.</li>

          <li>
            Each component is converted into a set of properties. If
            component is a value of implicit feature, it is not changed.
            Otherwise, it should have the form 
<pre>
    &lt;feature-name&gt;=&lt;feature-value&gt;[","&lt;feature-value&gt;]*
   
</pre>
            For each specified value, a propertry with that value and the
            specified feature name is added to the set.
          </li>

          <li>Property sets for each of the component are set-theoretically
          multiplicated.</li>
        </ul>
      </li>
    </ul>
    For example, the command line 
<pre>
    target1 debug gcc/runtime-link=dynamic,static
   
</pre>
    would cause target called <tt>target1</tt> to be rebuild in debug mode,
    except that for gcc, both dynamically and statically linked binaries
    would be created. 

    <p>TODO: should allow</p>
<pre>
    target1 debug gcc,borland/runtime-link=static
   
</pre>
    to work. 

    <h4>Command line options</h4>

    <p>All of the Boost.Build options start with the "--" prefix. They are
    described in the following table.</p>

    <table align="center">
      <caption>
        Command line options
      </caption>

      <thead>
        <tr>
          <th>Option</th>

          <th>Description</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td><tt>--debug</tt></td>

          <td>Enables internal checks.</td>
        </tr>

        <tr>
          <td><tt>--dump-projects</tt></td>

          <td>Cause the project structure to be output.</td>
        </tr>

        <tr>
          <td><tt>--help</tt></td>

          <td>Access to the online help system. This prints general information
          on how to use the help system with additional --help* options.</td>
        </tr>
      </tbody>
    </table>

    <h3><a name="projects">Projects</a></h3>

    <p>Boost.Build considers every software it build as organized into
    projects, which corresponds to a single Jamfile. The project are
    organized in a hierarchical structure, so for each project we can talk
    about parent project, which is always unique and a number of subprojects.
    (TODO: project root).</p>

    <h4>Project attributes</h4>

    <p>For each project, there are several attributes.</p>

    <p><em>Project id</em> is used to denote the project from other project.
    Each project id is a hierarchical path, such as "boost/thread". When
    project-id need to be referred from other projects there are two
    alternatives:</p>

    <ul>
      <li>Use absolute proejct-id, which starts with "/", for example
      <tt>/boost/thread</tt>.</li>

      <li>Use relative project-id, which is appended to the project-id of the
      project where it is used.</li>
    </ul>
    <br>
     <br>
     

    <p><em>Source location</em> specifies directory where sources for the
    project are located.</p>

    <p><em>Project requirements</em> are requirements that apply to all the
    targets in the projects as well as all subprojects.</p>

    <p><em>Default build</em> is the build request that should be used when
    no build request is specified explicitly.</p>

    <p>The default values for those attributes are given in the table below.
    In order to affect them, Jamfile may call the <tt>project</tt> rule. The
    rule has this syntax:</p>
<pre>
    project id : &lt;attributes&gt; ;
   
</pre>
    Here, attributes is a sequence of (attribute-name, attribute-value)
    pairs. The list of attribute names along with its handling is shown in
    the table below. For example, it it possible to write: 
<pre>
    project tennis 
        : requirements &lt;threading&gt;multi 
        : default-build release
        ;
   
</pre>

    <table>
      <tr>
        <th>Attribute</th>

        <th>Name for the 'project' rule</th>

        <th>Default value</th>

        <th>Handling by the 'project' rule</th>
      </tr>

      <tr>
        <td>Project id</td>

        <td>none</td>

        <td>none</td>

        <td>Assigned from the first parameter of the 'project' rule. It is
        assumed to denote absolute project id.</td>
      </tr>

      <tr>
        <td>Source location</td>

        <td><tt>source-location</tt></td>

        <td>The location of jamfile for the project</td>

        <td>Sets to the passed value</td>
      </tr>

      <tr>
        <td>Requirements</td>

        <td><tt>requirements</tt></td>

        <td>The parent's requirements</td>

        <td>The parent's requirements are refined with the passed requirement
        and the result is used as the project requirements.</td>
      </tr>

      <tr>
        <td>Default build</td>

        <td><tt>default-build</tt></td>

        <td>TODO</td>

        <td>Sets to the passed value</td>
      </tr>
    </table>

    <h4>Project relationship</h4>

    <p>There are three kinds of project relationships.</p>

    <p>First is parent-child. This relationship is established implicitly:
    parent directories of a project are searched, and the first found Jamfile
    is assumed to define the parent project. The parent-child relationship
    affects only attribute values for the child project.</p>

    <p>Second is build relationship. Some project may request to recursively
    build other projects. Those project need not be child projects. The
    <tt>build-project</tt> rule is used for that:</p>
<pre>
    build-project src ;   
</pre>

    <p>The third kind is the 'use' relationship. In means that one project
    uses targets from another. It is possible to just refer to target in
    other projects using target id. However, if target id uses project id, it
    is required that the project id is known. The <tt>use-project</tt> rule
    is employed to guarantee that.</p>
<pre>
    use-project ( id : location )
   
</pre>
    It loads the project at the specified location, which makes its project
    id available in the project which invokes the rule. It is required that
    the <tt>id</tt> parameter passed to the <tt>use-project</tt> rule be
    equal to the id that the loaded project declared. At this moment, the
    <tt>id</tt> paremeter should be absolute project id. 

    <h3><a name="targets">Targets</a></h3>

    <h4>Main targets and main target alternatives</h4>

    <p><em>Main target</em> is a named entity which can be build, for example
    a named executable file. To declare a main target, user invokes some of
    the <a href="#main_target_rules">main target rules</a>, passing it things
    like list of source and requirement.</p>

    <p>It is possible to have different list of sources for different
    toolsets, therefore it is possible to invoce main target rules several
    times for a single main target. For example:</p>
<pre>
    exe a.exe : a_gcc.cpp : &lt;toolset&gt; ;
    exe a.exe : a.cpp ;
</pre>
    Each call to the 'exe' rule defines a new <em>main target
    alternative</em> for the main target <tt>a.exe</tt>. In this case, the
    first alternative will be used for the <tt>gcc</tt> toolset, while the
    second alternative will be used in other cases. TODO: document the exact
    selection method under "Build process" below. 

    <h4>Target identifiers and references</h4>

    <p>Target identifier is used to denote a target. It is described by the
    following grammar:</p>
<pre>
    target-id -&gt; project-reference local-target-name
    project-reference -&gt; [jamfile-location] [ "@" [project-id] ]
    jamfile-location -&gt; pathname 
    project-id -&gt; pathname
    local-target-name -&gt; identifier
</pre>
    For example, valid target ids might be: 
<pre>
    a
    lib/b
    @/boost/thread
    /home/ghost/build/lr_library@parser/lalr1
</pre>
    To map the target id into target, the project where that target is
    contained is first found: 

    <ol>
      <li>If <tt>project-reference</tt> is empty, then the current project is
      used &mdash; i.e. the project there the target id occurs.</li>

      <li>If the project id is absolute, the project with that id is
      used.</li>

      <li>If the project id is relative, it is treated relatively to
      project-id of the project at <tt>jamfile-location</tt>. If that project
      does not declare project id, it is an error.</li>
    </ol>
    After that, the target given by <tt>local-target-name</tt> in the found
    project is used. 

    <p>Target reference is used to specify a source target, and may
    additionally specify desired properties for that target. It has this
    syntax:</p>
<pre>
    target-reference -&gt; target-id [ "/" requested-properties ]
    requested-properties -&gt; property-path
</pre>
    For example, 
<pre>
    exe compiler : compiler.cpp libs/cmdline/&lt;optimization&gt;space ;
</pre>
    would cause the version of <tt>cmdline</tt> library, optimized to space,
    to be linked in even if the <tt>compile</tt> executable is build with
    speed optimization. 

    <h5>Ambiguity resolution</h5>

    <p>Target reference may have the same form as a pathname, for example
    <tt>lib/a</tt>. In order to determine if this is target reference or
    pathname, it is checked if there's a jamfile in the specified path. If
    there is one, it is loaded and if the specified target is declared by
    that project it is used. Otherwise, we just treat the target reference as
    file name.</p>

    <h3><a name="build_process">Build process</a></h3>

    <p>The build works in this way. On startup, the project in the current
    directory is read. As the result a tree of projects is constructed. After
    that, the build request is constructed from the command line. Then, the
    steps are:</p>

    <ol>
      <li>The project in the current dir is passed the build request. If the
      build request does not satisfy the project's requirements, a warning is
      issued and the build of the project is skipped. Otherwise, the process
      is repeated recusrively for all subprojects.</li>

      <li>
        An attempts to make all the main targets in the project is performed.
        For each main target: 

        <ol>
          <li>All main target alternatives which requirements are satisfied
          by the build request are enumerated.</li>

          <li>If there are several such alternatives, the one which longer
          requirements list is selected.</li>
        </ol>
      </li>

      <li>
        For each selected alternative 

        <ol>
          <li>Each target reference in the source list are recursively
          constructed.</li>

          <li>The dependency graph for the target is constructed by running
          so called matching process, using generated source targets and
          ordinary sources.</li>
        </ol>
      </li>
    </ol>

    <p>The dependency graph constructed for each target is build of so called
    "virtual targets", which do not yet correspond to jam's targets. It is
    therefore converted to jam's dependency graph which is then build.</p>

    <p>The paths for build targets are determined with a method having two
    properties. First, non-free features are represented in path. Second,
    free features are not represented in path (because that would make them
    overly long), but two targets with different free features are never
    mixed. Each project has a base directory for all its target.</p>

    <p>Path for each target is relative to the base and has two components.
    The first component represents all non-free features used to build the
    target. If the set of free properties used to build the target is equal
    to the set of free properties in the project's requirements, then the
    second component is empty. Otherwise, the second part has the form
    "main_target-&lt;name&gt;", where "name" is the name of main target which
    build required the current target.</p>

    <p>For example, we might have these paths:</p>
<pre>
    debug/optimization-off
    debug/main-target-a
   
</pre>
    <hr>

    <p class="revision">Last modified: July 7, 2002</p>

    <p>&copy; Copyright Vladimir Prus 2002. Permission to copy, use, modify,
    sell and distribute this document is granted provided this copyright
    notice appears in all copies. This document is provided ``as is'' without
    express or implied warranty, and with no claim as to its suitability for
    any purpose.</p>
  </body>
</html>

