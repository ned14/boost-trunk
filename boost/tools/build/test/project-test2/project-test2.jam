import project ;
import targets ;
import assert ;
import class : class new ;
import feature : feature compose ;
import build-request ;
import property ;

feature toolset : : implicit ;
feature optimization : off space speed ;
feature runtime-link : dynamic static : link-incompatible ;
feature rtti : on off : link-incompatible ;
feature threading : single multi : link-incompatible ;
feature "include" : : free path ;
feature variant : debug release : implicit composite ;

compose <variant>debug : <optimization>off ;
compose <variant>release : <optimization>on ;

rule main-target-class ( name : project : requirements * )
{
    basic-target.__init__ $(name) : $(project) : : $(requirements) ;

    import class : new ;

    rule construct ( source-targets * : properties * )
    {
        local t = [ new virtual-target $(self.local-name)
                    : $(self.project) : $(properties) ] ;
        local a = [ new action $(t) : : project-test2.touch-file : $(properties) ] ;
        $(t).action $(a) ;
        return $(t) ;
    }

}

class main-target-class : basic-target ;

rule touch-file ( targets + : sources * : properties * )
{
    PROPERTIES on $(targets) = $(properties) ;
}

actions touch-file
{
    echo " $(PROPERTIES) ">$(<)
}


rule main-target ( name : requirements * )
{
    local project = [ CALLER_MODULE ] ;
    local ptarget = [ $(project).target ] ;

    local target = [ $(ptarget).main-target $(name) ] ;

    $(target).add-variant
        [ new main-target-class $(name) : $(project) : $(requirements) ] ;
}

IMPORT $(__name__) : main-target : : main-target ;


rule MakeLocate
{
    if $(>)
    {
        LOCATE on $(<) = $(>) ;
        Depends $(<) : $(>[1]) ;
        MkDir $(>[1]) ;
    }
}

rule MkDir
{
    # If dir exists, don't update it
    # Do this even for $(DOT).

    NOUPDATE $(<) ;

    if $(<) != $(DOT) && ! $($(<)-mkdir)
    {
        local s ;

        # Cheesy gate to prevent multiple invocations on same dir
        # MkDir1 has the actions
        # Arrange for jam dirs

        $(<)-mkdir = true ;
        MkDir1 $(<) ;
        Depends dirs : $(<) ;

        # Recursively make parent directories.
        # $(<:P) = $(<)'s parent, & we recurse until root

        s = $(<:P) ;

        if $(NT)
        {
            switch $(s)
        {
        case *:   : s = ;
        case *:\\ : s = ;
        }
        }

        if $(s) && $(s) != $(<)
        {
        Depends $(<) : $(s) ;
        MkDir $(s) ;
        }
        else if $(s)
        {
            NOTFILE $(s) ;
        }

    }
}

actions MkDir1
{
    mkdir $(<)
}

IMPORT $(__name__) : MakeLocate MkDir : : MakeLocate MkDir ;

root = [ project.load "." ] ;
root-target = [ $(root).target ] ;

expanded = [ feature.split [ build-request.expand debug <rtti>on ] ] ;
local targets = [ $(root-target).generate $(expanded) ] ;

local actual ;
for t in $(targets)
{
    actual += [ $(t).actualize ] ;
}
DEPENDS all : $(actual) ;





