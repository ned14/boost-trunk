#  Copyright (C) Vladimir Prus 2002. Permission to copy, use, modify, sell and
#  distribute this software is granted provided this copyright notice appears in
#  all copies. This software is provided "as is" without express or implied
#  warranty, and with no claim as to its suitability for any purpose.

#  This module defines the 'stage' rule, used to copy a set of targets to
#  a single location
#
#  Typical usage:
#
#  stage dist : hello_world : <location>/usr/bin ;
#
#  The source target will be copied to the specified location. Some targets will
#  we specially processed. In particular, binaries will be relinked. Free properties
#  from stage dist will be included to properties used for relinking. For example
#
#  stage dist : hello_world : <location>/usr/bin <dll-path>/opt/lib ;
# 
#  will cause 'hello_world' to be relinked to the new location, and <dll-path>
#  property will be added when relinking.
#
#  Two properties specifically control 'stage' rule.
# 
#  - <location> tells where to put targets. If not specified, directory
#    with the same name as stage name will be used.
#  
#  - <name> tells the new name of the staged target. In this case, only
#    one target can be specified in sources.

import targets ;
import class : class new xnew ;
import property ;
import errors : error ;
import type : type ;
import type ;
import regex ;
import generators ;

xclass stage-target-class : basic-target
{
    import feature project type errors generators ;    
    import class : xnew ;
    
    rule __init__ ( name-and-dir : project : sources * : requirements * : default-build * )
    {
        basic-target.__init__ $(name-and-dir) : $(project) : $(sources) : $(requirements) 
          : $(default-build) ;
    }
        
    rule construct ( source-targets * : property-set )
    {
        local name = [ $(property-set).get <name> ] ;
        if $(name) && $(source-targets[2])
        {
            errors.error "<name> property cannot be specified when staging several targets" ;
        }
                        
        local location = [ feature.get-values <location> : 
            [ $(property-set).raw ] ] ;
        if ! $(location)
        {
            location = [ project.path-relative-to-project-location $(self.name)
              $(self.project) ] ;
        }
                
        local result ;
        for local i in $(source-targets)
        {
            local i2 ; # Staged target(s)
            
            local t = [ $(i).type ] ;           
            
            # See if something special should be done when staging this
            # type. It is indicated by presense of special "staged" type            
            if $(t) && [ type.registered STAGED_$(t) ]
            {
                i2 = [ generators.construct $(self.project) : STAGED_$(t) :
                      $(property-set) : $(i) ] ;
                if ! $(i2)
                {                    
                    errors.error "Unable to generate staged version of " [ $(i).str ] ;
                }                
            }
            else             
            {                
                local n = [ $(i).name ] ;
                if $(name)
                {
                    n = $(name) ;
                }
                
                i2 = [ xnew file-target $(n:D=) : [ $(i).type ] 
                  : $(self.project) ] ;
                local a = [ xnew action $(i2) : $(i) : common.copy ] ;
                $(i2).suffix [ $(i).suffix ] ;
                $(i2).action $(a) ;
            }
            
            # FIXME: Since we can have <location> property, it might be better
            # to use it to distinguish staged copies with different locations.
            $(i2).set-path $(location) ;
            result += [ virtual-target.register $(i2) ] ;
        }
        return $(result) ;
    }   
    
    # Don't do nothing.
    rule check-for-unused-sources ( result * : sources * )
    {        
    }
    
}

# Declare staged version of the EXE type. Generator for this type will
# cause relinking to the new location.
type.register STAGED_EXE : : EXE ;

xclass stage-exe-generator : generator
{
    import type property-set modules ;    
    
    rule __init__ ( )
    {
        generator.__init__ stage-exe : EXE : STAGED_EXE ;
    }
    
    rule run ( project name ? : property-set : source : multiple ? )
    {
        # FIXME: this must become some rule in virtual-target module
        # we're cloning the target and action.        
        local n = [ $(source).name ] ;
        local cloned-target = [ class.xnew file-target $(n:D=) : [ $(source).type ] 
                  : $(project) ] ;
        local d = [ $(source).dependencies ] ;
        if $(d)
        {            
            $(cloned-target).depends $(d) ;
        }                    
        $(cloned-target).root [ $(source).root ] ;
        $(cloned-target).dg [ $(source).dg ] ;
        
          
        local action = [ $(source).action ] ;        
        local action-class = [ modules.peek $(action) : __class__ ] ;

        # Add our free properties to the property set, so that 
        # stage can affect the relinking details.
        local ps = [ $(action).properties-ps ] ;
        local new-ps = [ $(ps).add [ property-set.create [ $(property-set).free ] ] ] ;
        local cloned-action = [ class.xnew $(action-class) $(cloned-target) : 
          [ $(action).sources ] : [ $(action).action-name ] : $(new-ps) ] ;
        
        $(cloned-target).action $(cloned-action) ;
        
        return $(cloned-target) ;
    }    
}

generators.register [ xnew stage-exe-generator ] ;



# Declares a stage target. When build, it will construct all sources
# and place in one directory. The directory can be specified in requirements
# with 'location' property. If not specified, the directory name will be
# the same as target name, relative to the project where the target 
# is declared.
rule stage ( name : sources * : requirements * : default-build * )
{
    local project = [ CALLER_MODULE ] ;
    
    targets.main-target-alternative
      [ xnew stage-target-class $(name) : $(project) : $(sources)
        : [ targets.main-target-requirements $(requirements) : $(project) ] 
        : [ targets.main-target-default-build $(default-build) : $(project) ] 
      ] ;
}

IMPORT $(__name__) : stage : : stage ;



