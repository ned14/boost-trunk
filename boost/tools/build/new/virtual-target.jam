#  Copyright (C) Vladimir Prus 2002. Permission to copy, use, modify, sell and
#  distribute this software is granted provided this copyright notice appears in
#  all copies. This software is provided "as is" without express or implied
#  warranty, and with no claim as to its suitability for any purpose.

#  Implements virtual targets, which correspond to actual files created during
#  build, but are not yet target in Jam sense. They are needed, for example,
#  when searching for possible transormation sequences, when it's not known
#  if particular target should be create at all.

import class : class new ;
import type ;

# Class which represents a virtual target
rule virtual-target ( name : type ? : project 
                      : subvariant * # Property sets which define this subvariant
                     )
{
    self.name = $(name) ;
    self.type = $(type) ;
    self.subvariant = [ property.remove free incidental : $(subvariant) ] ;
    self.project = $(project) ;

    self.includes  = ;
    self.dependencies = ;
    self.action = ;

    self.actual-name = ;


    # Name of the target
    rule name ( ) { return $(self.name) ; }
    
    rule type ( ) { return $(self.type) ; }
    
    # Sets the suffix. When generating target name, it will be used in preference to
    # the suffix that is associated with 'type'
    rule suffix ( suffix ? ) 
    {
        if $(suffix)
        {            
            self.suffix = $(suffix) ;
        }
        return $(self.suffix) ;
    }
        
    # Property set that distinguished different variants of a target.
    # May be a subset of the property set that is used for building.
    # Determines the location of target, in an unspecified way.
    rule subvariant ( ) { return $(self.subvariant) ; }

    # Project where this target was declared
    rule project ( ) { return $(self.project) ; }

    rule dependencies ( ) { return $(self.dependencies) ; }
    rule depends ( d + )
    {
        self.dependencies = [ sequence.merge $(self.dependencies)
                               : [ sequence.insertion-sort $(d) ] ] ;
    }
    
    # If 'a' is supplied, sets action to 'a'.
    # Returns the action currently set.
    rule action ( a ? )
    {
        if $(a) 
        {
            self.action = $(a) ;
        }
        return $(self.action) ;
    }

    # Sets the dependency graph this target is part of.
    # 'dg' is an instance of 'subvariant-dg' class.
    rule dg ( dg ? )
    {
        if $(dg)
        {
            self.dg = $(dg) ;
        }
        return $(self.dg) ;
    }
    
    # Specified an extra element to be added to the target path.
    rule extra-path ( p ) 
    {
        self.extra-path = $(p) ;
    }

    # Generates all the actual targets and build instructions needed to build
    # this target. Returns the actual target name. Can be called several times.
    # Does no processing for other targets that 'action' will generate.
    # Rationale: we might need only one file from the set created by an
    # action, and there's no need to run the action if the file is up-to-date,
    # only because some other file in set is out-of-date.
    rule actualize ( scanner ? )
    {        
        # When we have explicitly specified target, we need to create a 
        # target and associate scanner with it.
        # There may be many different scanners, but there's only one
        # generating action. Therefore, generating action actualizes this
        # target without any scanner. Actual target with scanners will
        # depend on actual target without scanner. 
        actualize-no-scanner ; 

        local actual-name = [ actual-name ] ;

        if ! $(scanner)
        {
            return $(actual-name) ;
        }
        else 
        {
            local g = [ sequence.join 
                [ utility.ungrist $(actual-name:G) ] $(scanner) : - ] ;
            local name = $(actual-name:G=$(g)) ;


            if ! $(self.made.$(name)) {

                self.made.$(name) = true ;
                DEPENDS $(name) : $(actual-name) ;
                BINDRULE on $(name) = virtual-target.remember-binding ;

                if [ action ] {                
                    LOCATE on $(name) = [ path ] ;
                } else {
                    SEARCH on $(name) = [ path.native 
                        [ project.attribute $(self.project) source-location ] ] ;
                }

                scanner.install $(scanner) : $(name) $(__name__) ;
            }
            return $(name) ;            
        }
    }

    local rule actualize-no-scanner ( )
    {
        local name = [ actual-name ] ;

        if ! $(self.made.$(name)) {

            self.made.$(name) = true ;
            
            for local i in $(dependencies) {
                DEPENDS $(name) : [ $(i).actualize ] ;
            }
            BINDRULE on $(name) = virtual-target.remember-binding ;

            local a = [ action ] ;
            if $(a) {
                if $(name:D)
                {
                    errors.error 
                         "name for constructed target includes directory" ;
                }                
                $(a).actualize ;                
                local path = [ path ] ;
                LOCATE on $(name) = $(path) ;
                DEPENDS $(name) : $(path) ;
                common.MkDir $(path) ;
                common.Clean clean : $(name) ;
            } else {
                SEARCH on $(name) =
                    [ path.native [ project.attribute $(self.project) source-location ] ] ;
            }
        }                
    }
        
    rule str ( )
    {        
        local action = [ action ] ;
        local filename = [ sequence.join $(self.name) "."  $(self.type) ] ;
        if $(action) 
        {
            local sources = [ $(action).sources ] ;
            
            local ss ;
            for local s in $(sources)
            {
                ss += [ $(s).str ] ;
            }
                                    
            local name =  [ $(action).action-name ] ;
            return "{" $(name)-$(filename) $(ss) "}" ;
        }
        else
        {
            return "{" $(filename) "}" ;
        }
    }    

    rule less ( a )
    {
        if [ str ] < [ $(a).str ] 
        {
            return true ;
        }
    }

    rule equal ( a )
    {
        if [ str ] = [ $(a).str ]
        {
            return true ;
        }
    }        

# private:
    rule actual-name ( )
    {
        if ! $(self.actual-name)
        {
            local project-location = [ project.attribute $(self.project) location ] ;
            local location-grist =
                [ sequence.join [ regex.split $(project-location) "/" ] : "!" ] ;
            local property-grist =
                [ property.as-path $(self.subvariant) ] ;
            # Set empty value to avoid eating adjacent text
            local grist = $(location-grist)/$(property-grist) ;
            if ! $(self.subvariant) {
               grist = $(location-grist) ;
            }
            if $(self.suffix)
            {
                self.actual-name = [ sequence.join <$(grist)>$(self.name) 
                $(self.suffix) : "." ] ;
            }
            else if $(self.type)
            {                
                self.actual-name = [ sequence.join <$(grist)>$(self.name) 
                  [ type.generated-target-suffix $(self.type) ] : "." ] ;
            }
            else
            {
                self.actual-name = <$(grist)>$(self.name) ;
            }                        
        }
        return $(self.actual-name) ;
    }
    
    # Returns the directory for this target
    rule path ( )
    {
        local path = [ path.join [ project.attribute $(self.project) location ] 
          "bin" [ property.as-path [ subvariant ] ] 
            $(self.extra-path) ] ;
        return [ path.native $(path) ] ;
     }
    
}
class virtual-target ;

# Returns the binding for the given actual target.
# CONSIDER: not sure this rule belongs here.
rule binding ( target )
{
    return $(.binding.$(target)) ;
}


rule remember-binding ( target : bound-path )
{
    .binding.$(target) = $(bound-path) ;
}


# Class which represents an action.
# Both 'targets' and 'sources' should list instances of 'virtual-target'.
# Action name should name a rule with this prototype
#     rule action-name ( targets + : sources * : properties * )
# Targets and sources are passed as actual jam targets. The rule may
# not establish dependency relationship, but should do everything else.
rule action ( targets + : sources * : action-name : properties * )
{
    self.targets = $(targets) ;
    self.sources = $(sources) ;
    self.action-name = $(action-name) ;
    self.properties = $(properties) ;

    rule targets ( )
    {
        return $(self.targets) ;
    }

    rule sources ( )
    {
        return $(self.sources) ;
    }

    rule action-name ( )
    {
        return $(self.action-name) ;
    }

    rule properties ( )
    {
        return $(self.properties) ;
    }

    # Generates actual build instructions.
    rule actualize ( )
    {
        if ! $(self.actualized)
        {
            self.actualized = true ;

            local properties = [ adjust-properties [ properties ] ] ;
            
            local actual-targets ;
            for local i in [ targets ]
            {
                actual-targets += [ $(i).actualize ] ;
            }

            local actual-sources ;
            for local i in [ sources ]
            {                
                local scanner ;
                if [ $(i).type ]
                {                    
                    scanner = 
                      [ type.get-scanner [ $(i).type ] : $(properties) ] ;
                }                
                actual-sources += [ $(i).actualize $(scanner) ] ;
             }
 
             DEPENDS $(actual-targets) : $(actual-sources) ;            

            $(self.action-name)
              $(actual-targets) : $(actual-sources) : $(properties) ;
        }        
    }    
    
    # Determined real properties when trying building with 'properties'.
    # This is last chance to fix properties, for example to adjust includes
    # to get generated headers correctly. Default implementation returns
    # its argument.
    rule adjust-properties ( properties * )
    {
        return $(properties) ;
    }
    
    
    rule set-targets ( targets * )
    {
        self.targets = $(targets) ;
    }    
}
class action ;

# Creates a virtual target with approariate name and type from 'file'.
# If a target with that name in that project was already created, returns that already
# created target.
# FIXME: more correct way would be to compute path to the file, based on name and source location
# for the project, and use that path to determine if the target was already created.
# TODO: passing project with all virtual targets starts to be annoying.
rule from-file ( file : project )
{
    if $(.files.$(file).$(project))
    {
        return $(.files.$(file).$(project)) ;
    }
    else
    {        
        local name = $(file:S=) ;
        local type = [ type.type $(file:S) ] ;
        local result ;
        if ! $(type)
        {
            # warning "cannot determine type for file $(file)" ;
            result = [ new virtual-target $(file) :  : $(project) ] ;            
        }
        else
        {      
            local v = [ new virtual-target $(name) : $(type) : $(project) ] ;    
            $(v).suffix [ MATCH ^.(.*)$ : $(file:S) ] ;
            result = $(v) ;
        }    
        .files.$(file).$(project) = $(result) ;
        return $(result) ;
    }    
}

# Registers a new virtual target. Checks if there's already registered target, with the same
# name, type, project and subvariant properties, and also with the same sources
# and equal action. If such target is found it is retured and 'target' is not registers.
# Otherwise, 'target' is registered and returned.
rule register ( target )
{
    local signature = [ sequence.join 
        [ $(target).project ] [ $(target).name ] [ $(target).type ] [ $(target).subvariant ] : - ] ;
    local result ;
    for local t in $(.cache.$(signature))
    {
        local a1 = [ $(t).action ] ;
        local a2 = [ $(target).action ] ;
        
        if ! $(result)
        {
            if ! $(a1) && ! $(a2)
            {
                result = $(t) ;
            }
            else if $(a1) && $(a2) && [ $(a1).action-name ] = [ $(a2).action-name ] 
              && [ $(a1).properties ] = [ $(a2).properties ] && [ $(a1).sources ] = [ $(a2).sources ] 
            {
                result = $(t) ;
            }          
        }        
    }          
    if ! $(result)
    {        
        .cache.$(signature) += $(target) ;    
        result = $(target) ;
    }
    
    return $(result) ;
}

# Traverses the dependency graph of 'target' and return all targets that will
# be created before this one is created.
rule traverse ( target )
{
    local result ;
    if [ $(target).action ]
    {
        local action = [ $(target).action ] ;
        # This includes 'target' as well
        result += [ $(action).targets ] ;

        for local t in [ $(action).sources ] 
        {
            result += [ traverse $(t) ] ;
        }        
    }
    return $(result) ;
}


# Clones a virtual target, copying all fields that can be set in ctor, setting
# project of new targets to 'project'. 
# If 'dont-recurse' is not set, clones action as well, which causes cloning
# of every target and action accessing from 'target'.
# Parameters 'project', 'name', 'type' and 'suffix' specify the lonely
# source target that should be substituted into the template.
rule clone-template ( target dont-recurse ? : project name type suffix )
{
    local old-name = [ $(target).name ] ;
    local new-name = $(old-name) ;
    local m = [ MATCH (.*)(%)(.*) : $(old-name) ] ;
    if $(m)
    {
        if [ $(target).action ]
        {
            new-name = [ sequence.join $(m[1]) $(name:D=) $(m[3]) ] ;
        }
        else
        {            
            new-name = [ sequence.join $(m[1]) $(name) $(m[3]) ] ;
        }        
    }
    
    
    local cloned = [ new virtual-target $(new-name) : [ $(target).type ] :
                                $(project) : [ $(target).subvariant ] ] ;    
    
    if ! $(dont-recurse) && [ $(target).action ]
    {
        local cloned-action = [ clone-action-template [ $(target).action ] $(target) $(cloned) $(project) $(name) 
          $(type) $(suffix)
        ] ;
        
        cloned-targets = $(cloned) ;
        for t in [ $(cloned-action).targets ]
        {
            if $(t) != $(target)
            {
                cloned-targets += [ clone-template $(t) dont-recurse : $(project) $(name) $(type) $(suffix) ] ;
            }                
        }   
        local cloned-targets2 ;
        for local t in $(cloned-targets)
        {
            $(t).action $(cloned-action) ;
            
            cloned-targets2 += [ register $(t) ] ;
            
        }
        $(cloned-action).set-targets $(cloned-targets2) ;            
        cloned = $(cloned-targets2[1]) ;
    }
    else
    {
        cloned = [ register $(cloned) ] ;
    }
    
    if $(old-name) = % && ! [ $(cloned).action ] && [ $(cloned).type ] = $(type)
    {
        $(cloned).suffix $(suffix) ;
    }
    
    return $(cloned) ;
}

# Clones an action template: helper for clone-template above.
local rule clone-action-template ( action from cloned-from project name type suffix )
{
    local targets ;
    local sources ; 
    
    for local t in [ $(action).sources ]
    {
        sources += [ clone-template $(t) : $(project) $(name) $(type) $(suffix) ] ; 
    }
    
    local action-class = [ modules.peek $(action) : __class__ ] ;

    local cloned = [ new $(action-class) [ $(action).targets ] : $(sources) 
                     : [ $(action).action-name ] : [ $(action).properties ] ] ;
    
    return $(cloned) ;    
}

local rule subvariant-dg ( main-target : properties * : virtual-targets * )
{
    self.main-target = $(main-target) ;
    self.properties = $(properties) ;
    self.virtual-targets = $(virtual-targets) ;

    rule all-target-directories ( )
    {
        local result ;
        for local t in $(self.virtual-targets) 
        {
            result = [ sequence.merge $(result) : [ $(t).path ] ] ;
        }
        return $(result) ;                
    }    
}

class subvariant-dg ;

