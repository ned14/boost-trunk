#  Copyright (C) Vladimir Prus 2002. Permission to copy, use, modify, sell and
#  distribute this software is granted provided this copyright notice appears in
#  all copies. This software is provided "as is" without express or implied
#  warranty, and with no claim as to its suitability for any purpose.


#   Supports 'abstract' targets, which are targets explicitly defined in Jamfile.
#
#   Abstract targets are represented by classes derived from 'abstract-target' class. 
#   The first abstract target is 'project-target', which is created for each
#   Jamfile, and can be obtained by the 'target' rule in the Jamfile's module.
#   (see project.jam). 
#
#   Project targets keep a list of 'main-target' instances.
#   A main target is what the user explicitly defines in a Jamfile. It is
#   possible to have several definitions for a main target, for example to have
#   different lists of sources for different platforms. So, main targets
#   keep a list of alternatives.
#
#   Each alternative is an instance of 'abstract-target'. When a main target
#   subvariant is defined by some rule, that rule will decide what class to
#   use, create an instance of that class and add it to the list of alternatives
#   for the main target.
#
#   Rules supplied by the build system will use only targets derived
#   from 'basic-target' class, which will provide some default behaviour.
#   There will be two classes derived from it, 'make-target', created by the
#   'make' rule, and 'typed-target', created by rules such as 'exe' and 'dll'.

#
#                         +------------------------+
#                         |abstract-target         |
#                         +========================+
#                         |name                    |
#                         |project                 |                                   
#                         |                        |                                   
#                         |generate(properties) = 0|                                   
#                         +-----------+------------+                                   
#                                     |                                                
#                                     ^                                                
#                                    / \                                               
#                                   +-+-+                                              
#                                     |                                                
#                                     |                                                
#            +------------------------+------+------------------------------+          
#            |                               |                              |          
#            |                               |                              |          
# +----------+-----------+            +------+------+                +------+-------+  
# | project-target       |            | main-target |                | basic-target |  
# +======================+ 1        * +=============+  alternatives  +==============+  
# | generate(properties) |o-----------+ generate    |<>------------->| generate     |  
# | main-target          |            +-------------+                | construct = 0|
# | reference-properties |                                           +--------------+  
# +----------------------+                                                  |          
#                                                                           ^          
#                                                                          / \         
#                                                                         +-+-+        
#                                                                           |          
#                                                                           |          
#                 ...--+----------------+------------------+----------------+---+      
#                      |                |                  |                    |      
#                      |                |                  |                    |      
#               ... ---+-----+   +------+-------+   +------+------+    +--------+-----+
#                            |   | typed-target |   | make-target |    | stage-target |
#                            .   +==============+   +=============+    +==============+
#                            .   | construct    |   | construct   |    | construct    |
#                                +--------------+   +-------------+    +--------------+

import sequence ;
import class : class new ;
import regex ;
import property ;
import errors ;
import common ;


# Base class for all abstract targets.
rule abstract-target ( name      # name of the target in Jamfile
                       : project # the project module where the target is declared
                     )
{
    # Note: it might seem that we don't need either name or project at all.
    # However, there are places where we really need it. One example is error
    # messages which should name problematic targets. Another is setting correct
    # paths for sources and generated files.

    self.name = $(name) ;
    self.project = $(project) ;
    
    # Returns the name of this target.
    rule name ( )
    {
        return $(self.name) ;
    }
    
    # Returns the project for this target.
    rule project ( )
    {
        return $(self.project) ;
    }
        
    # Returns a user-readable name for this target.
    rule full-name ( )
    {
        local location = [ project.attribute $(self.project) location ] ;
        return $(location)/$(self.name) ;
    }

    # Adds one more direct build request for this target. If later generate
    # is called with the same non-free non-incidental properties as in one
    # of direct build requests, then that build request is used instead.
    rule direct-build-request ( properties * )
    {
    }
    
    # Takes properties in split form ("<feature1>foo <feature2>bar").
    # Generates virtual targets for this abstract target, using the specified properties,
    # unless a different value of some feature is required by the target. The properties
    # on returned virtual targets should be link-compatible with the requested ones.
    # On success, returns a list of virtual targets. If it not possible to build anything, 
    # issues a warning and returns empty list, or issues an error.
    #
    # If 'properties' are empty, performs default build of this target, in a way specific
    # to derived class.
    rule generate ( properties * )
    {
        errors.error "method should be defined in derived classes" ;
    }
}
class abstract-target ;

#  Project target class (derived from 'abstract-target')
rule project-target ( name : project : requirements * : default-build * )
{
    abstract-target.__init__ $(name) : $(project) ;

    self.requirements = $(requirements) ;
    self.default-build = $(default-build) ;

    rule direct-build-request ( properties * )
    {
        for local name in $(self.main-targets)
        {
            local t = [ main-target $(name) ] ;
            result += [ $(t).direct-build-request $(properties) ] ;
        }
        for local pn in [ project.attribute $(self.project) projects-to-build ]
        {
            local p = [ project.module-name $(pn) ] ;
            local t = [ project.target [ project.attribute $(p) location ] ] ;
            result += [ $(t).direct-build-request $(properties) ] ;
        }            
    }
    
    # Generates all possible targets contained in this project.
    rule generate ( properties * )
    {
        # Project properties are directly imposed on all main targets.
        # However, we'd need to check if this project can be build at
        # all.
        local xproperties = 
          [ property.refine $(properties) : $(self.requirements) ] ;
        if $(xproperties[1]) = "@error"
        {
            local id = [ project.attribute $(self.project) id ] ;
            if $(id) 
            {                
                print.wrapped-text "warning: skipping build of project" $(id)
                  "at" [ project.attribute $(self.project) location ] ;
            }
            else
            {
                print.wrapped-text "warning: skipping build of project at"
                  [ project.attribute $(self.project) location ] ;
            }            
        }
        else 
        {            
            local result ;
            for local name in $(self.main-targets)
            {
                local t = [ main-target $(name) ] ;
                result += [ $(t).generate $(properties) ] ;
            }
            local self-location = [ project.attribute $(self.project) location ] ;
            for local pn in [ project.attribute $(self.project) projects-to-build ]
            {
                local p = [ project.module-name [ path.join $(self-location) $(pn) ] ] ;
                local t = [ project.target [ project.attribute $(p) location ] ] ;
                result += [ $(t).generate $(properties) ] ;
            }
            return $(result) ;
        }        
    }

    # Returns a 'main-target' class instance corresponding to the 'name'.
    # Creates the instance if needed.
    rule main-target ( name )
    {
        if ! $(self.main-target.$(name))
        {
            self.main-targets += $(name) ;
            self.main-target.$(name) =
                [ new main-target $(name) : $(self.project) ] ;
        }
        return $(self.main-target.$(name)) ;
    }

    # Tells if a main target with the specified name exists.
    rule has-main-target ( name )
    {
        if $(self.main-target.$(name)) 
        {
            return true ;
        } 
    }
    
    # Returns the properties which would be used for a main
    # target in this project, if generation with
    # 'properties' is requested, and that main target 
    # does not have any requirements of its own.
    rule reference-properties ( properties * )
    {
        # Note that free properties can appear on 'properties' only
        # from direct build request, because free properties are not
        # allowed to be propagated.
                
        local ref = [ project.attribute $(self.project) requirements ] ;
        ref = [ property.refine $(properties) : $(ref) ] ;
        ref = [ property.evaluate-conditionals $(ref) ] ;
        ref = [ property.take free : [ property.remove incidental : $(ref) ] ] ;
        ref = [ targets.generate-dependencies $(ref) : $(self.project) ] ;
        return $(ref) ;
    }
    
}
class project-target : abstract-target ;

# A named top-level target in Jamfile
rule main-target ( name : project )
{
    import errors : error ;
    import numbers : range ;

    abstract-target.__init__ $(name) : $(project) ;

    # Add a new alternative for this target
    rule add-alternative ( target )
    {
        self.alternatives += $(target) ;
    }

    rule direct-build-request ( properties * )
    {
        local base = [ property.remove free incidental : $(properties) ] ;
        local ep = $(self.direct-request.$(base:J=-)) ;
        if $(ep) && $(ep) != $(properties) 
        {
            error "Conflicting direct build requests" $(ep) "and" $(properties) ;
        }
        else
        {
            self.direct-request.$(base:J=-) = $(properties) ;
        }                
    }
    

    # Select an alternative for this main target, by finding all alternatives
    # which requirements are satisfied by 'properties' and picking the one with
    # longest requirements set.
    # Returns the result of calling 'generate' on that alternative.
    rule generate ( properties * )
    {
        local base = [ property.remove free incidental : $(properties) ] ;
        local ep = $(self.direct-request.$(base:J=-)) ;
        if $(ep) 
        {
            properties = $(ep) ;
        }
        
        # Try to generate all the alternatives.
        local alternatives = [ new vector ] ;

        for local v in $(self.alternatives)
        {
            local vtargets = [ $(v).generate $(properties) ] ;
            if $(vtargets) && $(vtargets[1]) != "@error"
            {
                $(alternatives).push-back [ new vector $(v) $(vtargets) ] ;
            }
        }
        if [ $(alternatives).empty ]
        {
            # TODO: probably, should explain, for each alternative, 
            # why it can't be build.
            print.wrapped-text 
                "warning: skipped build of" [ full-name ]
                "with properties" $(properties) ;
        } else {            
        local result ;
        if [ $(alternatives).size ] = 1 
        {  
            result = [ $(alternatives).get-at 1 ] ;
            result = $(result[2-]) ;
        }
        else
        {
            # Find the alternative with the longest set of non-free and 
            # non-indicental requirements and are in 'properties'
            local r = [ $(alternatives).indices ] ;

            # First compute the length of requirements sets
            local req-length ;
            for local p in $(r) 
            {
                local target = [ $(alternatives).at $(p) : 1 ] ;
                # FIXME: in general, 'abstract-target' derivatives might not
                # have 'requirements' method. 
                # assert.equal [ is-a $(target) : basic-target ] : true ;
                local req = [ $(target).requirements ] ;
                req = [ property.remove free incidental : $(req) ] ;
                req-length += [ sequence.length 
                    [ set.intersection $(req) : $(properties) ] ] ;
            }
                        
            local best = [ sequence.select-highest-ranked $(r) : $(req-length) ] ;
                        
            if ! $(best[2]) 
            {                
                local index = $(best[1]) ;
                result = [ $(alternatives).get-at $(index) ] ;
                result = $(result[2-]) ;
            } 
            else
            {
                error "Ambiguous alternatives for main target" [ full-name ]  ;
            }                    
        } 
                  
        # Mark all targets in result as roots
        for local t in $(result)
        {
            $(t).root true ;
        }
        
        # Process all vtargets that will be created if this main target
        # is created.
        local all-targets = 
            [ sequence.transform virtual-target.traverse : $(result) ] ; 
        local dg = [ new subvariant-dg $(__name__) : $(properties) : $(all-targets) ] ;
        for local v in $(all-targets)          
        {
            $(v).dg $(dg) ;            
        }                

        # Now return virtual targets for the only alternative
        return $(result) ;
        }        
    }
}

class main-target : abstract-target ;

# Attempts to generate the target given by target
# reference.
rule generate ( target-reference # Target reference
    : project                    # Project where the reference is made
    : properties *               # Properties of the main target that 
                                 # makes the reference
   )
{
    # Separate target name from properties override
    local split = [ MATCH "^([^<]*)(/(<.*))?$" : $(target-reference) ] ;
    local id = $(split[1]) ;
    local sproperties = ;
    if $(split[3])
    {
        sproperties = [ property.make [ feature.split $(split[3]) ] ] ;
        sproperties = [ feature.expand-composites $(sproperties) ] ;
    }

    # Check if such target exists
    local main-target = 
      [ project.find-target $(id) : [ project.attribute $(project) location ] ] ;
        
    if $(main-target) {
        # Take properties which should be propagated and refine them
        # with source-specific requirements.
        local propagated = [ property.take propagated : $(properties) ] ;
        local rproperties = [ property.refine $(propagated) : $(sproperties) ] ;
        if $(rproperties[1]) = "@error"
        {
            errors.error
              "When building" [ full-name ] " with properties " $(properties) :
                "Invalid properties specified for " $(source) ":"
                  $(rproperties[2-]) ;
        }
        return [ $(main-target).generate $(rproperties) ] ;        
    }    
}

# Returns a list of properties, where all dependency properties are
# replaced as follows:
# - the value of dependency property is treated as target reference,
#   which is generated with 'properties' + 'extra-properties'
# - the created virtual target's become replace the property value,
#    for example <library>a/b might become 
#    <library>object(virtual-target)@1
# In addition, use requirements for all created virtual targets
# are added to the properties.
#
# The purpose of 'extra-properties' is to be able to replace dependency
# features only in certain set of properties, which does not include
# all build properties. A concrete example is when we process use properties.
# Dependency features must be replaced using full build properties of target,
# but we don't want to add build properties to use requirements.
rule generate-dependencies ( properties * : project : extra-properties * )
{
    local xproperties ;
    for local p in $(properties)
    {
        if dependency in [ feature.attributes $(p:G) ]
        {
            local g = [ targets.generate $(p:TG=) : $(project) 
              : $(properties) $(extra-properties) ] ;
            if ! $(g) 
            {
                errors.error "cannot generate dependency " $(p) ;
            }
            xproperties += $(p:G)$(g) [ $(g).use-requirements ] ;
        }
        else
        {
            xproperties += $(p) ;
        }                        
    }
    return $(xproperties) ;
}



# Implements the most standard way of constructing main target
# alternative from sources. Allows sources to be either file or
# other main target and handles generation of those dependency
# targets.
rule basic-target ( name : project
                    : sources * : requirements * : default-build * : use-requirements * )
{
    import build-request ;
    import virtual-target ;

    abstract-target.__init__ $(name) : $(project) ;

    self.sources = $(sources) ;
    self.requirements = $(requirements) ;
    self.default-build = $(default-build) ;
    self.use-requirements = $(use-requirements) ;

    if $(sources:G)
    {
        errors.error "gristed element in sources for" [ full-name ] ;
    }
    

    # Applies default-build if 'properties' are empty or 
    # have only single <toolset> element.
    # Generates sources. Calls 'construct'
    # This method should not be overriden.
    #
    rule generate ( properties * )
    {
        if ! $(properties) || $(properties:G) = <toolset>
        {
            # CONSIDER: I'm really not sure if this is correct...
            # FIXME: as in 'build-system' we stick default toolset
            properties = [ build-request.expand $(properties) 
                           $(self.default-build) ] ;
            
            local result = ;
            for local p in $(properties)
            {
                result += [ generate [ feature.split $(p) ] ] ;
            }
            return $(result) ;
        } else {

            property-path = [ property.as-path 
                [ property.remove free incidental : $(properties) ] ] ;
            if ! $(property-path) 
            {
                property-path = X ;
            }
            if ! $(self.generated.$(property-path)) 
            {
                local rproperties =
                    [ property.refine $(properties) : $(self.requirements) ] ;

                rproperties = [ property.evaluate-conditionals $(rproperties) ] ;
                                
                if $(rproperties[1]) != "@error"                    
                {
                    # TODO: issue a warning when requirements change properties, but
                    # link-compatibility is still not broken.
                    
                    # Generate dependency requirements. Here, we generate only 
                    # denepdency requirements specified for this targets. Dependency
                    # requirements may also code from dependencies. However, when they
                    # come from dependencies, the value is not target id, but rather
                    # virtual target names, so generators.construct can use them.

                    local xproperties = 
                      [ targets.generate-dependencies $(rproperties) : $(self.project) ] ;


                    local source-targets ;
                    for local s in $(self.sources)
                    {
                        # Try treating this source as reference to main target
                        local more-targets = 
                          [ targets.generate $(s) : $(self.project) : $(properties) ] ;
                        if $(more-targets)
                        {
                            source-targets += $(more-targets) ;
                        }
                        else 
                        {
                            # Just a source file
                            source-targets += [ virtual-target.from-file $(s) : $(self.project) ] ;                            
                        }
                    } 
                    
                    self.generated.$(property-path) = 
                        [ construct $(source-targets) : $(xproperties) ] ;                             
                    
                    # Apply use requirement of this target to all generated
                    # virtual targets.
                    local xuse-requirements = 
                      [ targets.generate-dependencies $(self.use-requirements) 
                        : $(self.project) : $(rproperties) ] ;
                    
                    for local e in $(self.generated.$(property-path))                    
                    {
                        $(e).set-use-requirements $(xuse-requirements) ;
                    }                    
                } 
                else
                {
                    self.generated.$(property-path) = $(rproperties) ;
                }       
            }                
            return $(self.generated.$(property-path)) ;
        }
    }
        
    # Constructs the virtual targets for this abstract targets and
    # the dependecy graph. Returns the list of virtual targets.
    # Should be overrided in derived classes.
    rule construct ( source-targets * : properties * )
    {
        errors.error "method should be defined in derived classes" ;
    }

    # Returns the requirements for this target
    rule requirements ( )
    {
        return $(self.requirements) ;
    }
}

class basic-target : abstract-target ;

rule typed-target ( name : project : type 
    : sources * : requirements * : default-build * : use-requirements * )
{
    basic-target.__init__ $(name) : $(project) 
      : $(sources) : $(requirements) : $(default-build) : $(use-requirements) ;
    
    self.type = $(type) ;
    
    rule construct ( source-targets * : properties * )
    {
        local r = [ generators.construct $(self.project) $(self.name) : $(self.type) 
          : $(properties) # [ feature.expand
              <main-target-type>$(self.type)
          # ]
            : $(source-targets) 
            : allow-composing ] ;
        if ! $(r)
        {
            errors.error "unable to construct" [ full-name ] ;
        }
        
        return $(r) ;
    }            
}
                    
class typed-target : basic-target ;

# Returns the requirement to use when declaring a main target,
# which are obtained by
# - translating all specified property paths, and
# - refining project requirements with the one specified for the target
rule main-target-requirements ( 
  specification * # Properties explicitly specified for a main target
  : project       # Project where the main target is to be declared
      )
{
    local loc = [ project.attribute $(project) location ] ;
    local requirements = [ property.translate-paths $(specification) : $(loc) ] ; 
    local project-requirements = [ project.attribute $(project) requirements ] ;
    requirements = [ property.refine $(project-requirements) : $(requirements) ] ;
    if $(requirements[1]) = "@error" 
    {
        errors.error "Conflicting requirements for target:" $(requirements) ;
    }
    return $(requirements) ;
}

# Returns the use requirement to use when declaraing a main target,
# which are obtained by
# - translating all specified property paths, and
# - adding project's use requirements
rule main-target-use-requirements (
  specification * # Use-properties explicitly specified for a main target
  : project       # Project where the main target is to be declared
     )
{
    local loc = [ project.attribute $(project) location ] ;         
    local project-use-requirements = [ project.attribute $(project) use-requirements ] ;

    local use-requirements = [ property.translate-paths $(specification) : $(loc) ] ;
    use-requirements += $(project-use-requirements) ;

    return $(use-requirements) ;
}

# Return the default build value to use when declaring a main target,
# which is obtained by using specified value if not empty and parent's
# default build attribute otherwise.
rule main-target-default-build (
  specification * # Default build explicitly specified for a main target
  : project       # Project where the main target is to be declared
     )
{
    if $(specification)
    {
        return $(specification) ;
    }
    else
    {
        return [ project.attribute $(project) default-build ] ;        
    }    
}         

# Registers the specified target as a main target alternatives.
# Gets project and name for 'target', obtains main target
# from them, and adds targets to the list of alternatives for
# the main target.
rule main-target-alternative ( target ) 
{               
    local location = [ project.attribute [ $(target).project ] location ] ;
    local ptarget = [ project.target $(location) ] ;
    local mtarget = [ $(ptarget).main-target [ $(target).name ] ] ;

    $(mtarget).add-alternative $(target) ;
}
