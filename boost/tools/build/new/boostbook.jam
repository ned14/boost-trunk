import class : class new ;
import common ;
import targets ;
import feature ;
import generators ;
import property ;
import property-set ;
import regex ;
import scanner ;

feature.feature xsl:param : : free ;
feature.feature format : html onehtml man pdf ps docbook fo 
  : incidental implicit composite ;

type.register XML : xml ;
type.register DOCBOOK : docbook ; 
type.register HTML : html ;
type.register FO : fo ;
type.register PDF : pdf ;
type.register PS : ps ;
type.register XSLT : xsl ;
type.register HTMLDIR ;
type.register MANPAGES ;

# Generates handle -> * rules a bit strangely, so don't try to use them for now
#generators.register-standard boostbook.xslt : XML XSLT : * ;

generators.register-standard boostbook.boostbook-to-docbook : XML : DOCBOOK ;
generators.register-standard boostbook.docbook-to-onehtml : DOCBOOK : HTML ;
generators.register-standard boostbook.docbook-to-htmldir : DOCBOOK : HTMLDIR ;
generators.register-standard boostbook.docbook-to-manpages : DOCBOOK : MANPAGES ;
generators.register-standard boostbook.docbook-to-fo : DOCBOOK : FO ;
generators.register-standard boostbook.fo-to-print : FO : PDF ;
generators.register-standard boostbook.fo-to-print : FO : PS ;

rule xslt ( target : source stylesheet : properties * )
{ 
  local flags ;
  for local param in [ feature.get-values <xsl:param> : $(properties) ]
  {
    local namevalue = [ regex.split $(param) "=" ] ;
    flags += --stringparam $(namevalue[1]) $(namevalue[2]) ;
  }

  STYLESHEET on $(target) = $(stylesheet) ;
  FLAGS on $(target) = $(flags) ;
  xslt-xsltproc $(target) : $(source) ;
}

rule xslt-dir ( target : source stylesheet : properties * : dirname )
{ 
  local flags ;
  for local param in [ feature.get-values <xsl:param> : $(properties) ]
  {
    local namevalue = [ regex.split $(param) "=" ] ;
    flags += --stringparam $(namevalue[1]) $(namevalue[2]) ;
  }

  # Make sure we create this path.
  # TBD: this is NOT correct, but it works for now...
  LOCATE on $(target) = $(dirname) ;
  DEPENDS $(target) : $(dirname) ;
  common.MkDir $(dirname) ;

  STYLESHEET on $(target) = $(stylesheet) ;
  FLAGS on $(target) = $(flags) ;
  DIRECTORY on $(target) = $(dirname) ;
  xslt-xsltproc-dir $(target) : $(source) ;
}

rule boostbook-to-docbook ( target : source : properties * )
{
  local dir = [ modules.peek : BOOST_ROOT ] ;
  xslt $(target) : $(source) "$(dir)/tools/boostbook/xsl/docbook.xsl" : $(properties) ;
}

rule docbook-to-onehtml ( target : source : properties * )
{
  local dir = [ modules.peek : BOOST_ROOT ] ;
  xslt $(target) : $(source) "$(dir)/tools/boostbook/xsl/html-single.xsl" : $(properties) ;
}

rule docbook-to-htmldir ( target : source : properties * )
{
  local dir = [ modules.peek : BOOST_ROOT ] ;
  xslt-dir $(target) : $(source) "$(dir)/tools/boostbook/xsl/html.xsl" : $(properties) : html ;
}

rule docbook-to-manpages ( target : source : properties * )
{
  local dir = [ modules.peek : BOOST_ROOT ] ;
  xslt-dir $(target) : $(source) "$(dir)/tools/boostbook/xsl/manpages.xsl" : $(properties) : man ;
}

rule docbook-to-fo ( target : source : properties * )
{
  local dir = [ modules.peek : BOOST_ROOT ] ;
  xslt $(target) : $(source) "$(dir)/tools/boostbook/xsl/fo.xsl" : $(properties) ;
}

rule fo-to-print ( target : source : properties * )
{
  local dir = [ modules.peek : BOOST_ROOT ] ;
  JAVA_HOME on $(target) = [ modules.peek : JAVA_HOME ] ;
  FOP_DIR on $(target) = [ modules.peek : FOP_DIR ] ;
  fop $(target) : $(source) ;
}

actions fop
{
  JAVA_HOME=$(JAVA_HOME) $(FOP_DIR)/fop.sh $(>) $(<)
}

rule xml-catalog-action ( target : property-set ? )
{
  action.__init__ $(target) : : generate-xml-catalog : $(property-set) ;

  rule actualize ( )
  {
    if ! $(self.actualized)
    {
      self.actualized = true ;
      boostbook.write-xml-catalog-1 $(self.target) : "foobar" ;
    }
  }
}

class xml-catalog-action : action ;

actions write-xml-catalog-1
{
    echo "$(>)" > "$(<)"
}

actions piecemeal write-xml-catalog-2
{
    echo "$(>)" >> "$(<)"
}

rule boostbook-target-class ( name : project : sources * : requirements * 
                              : default-build * )
{
  basic-target.__init__ $(name) : $(project) : $(sources) : $(requirements)
                         : $(default-build) ;

  rule construct ( source-targets * : property-set )
  {
    # Not working :(
#    local path = [ project.attribute $(self.project) location ] ;
#    local catalog = [ new file-target catalog : XML : $(self.project) ] ;
#    $(catalog).action [ new xml-catalog-action $(catalog) : $(property-set) ] ;
#    $(catalog).set-path $(path) ;
#    $(catalog).set-actual-name "$(path)/catalog.xml" ;

    local properties = [ $(property-set).raw ] ;

    local format = [ feature.get-values <format> : $(properties) ] ;
    local targets = ;

    local type = none ;
    local manifest ; 
    switch $(format) 
    {
      case html    : 
      {
        type = HTMLDIR ;
        manifest = HTML.manifest ;
      }

      case onehtml : type = HTML ;
 
      case man : 
      {
        type = MANPAGES ;
        manifest = man.manifest ;
      }

      case docbook : type = DOCBOOK ;
      case fo      : type = FO ;
      case pdf     : type = PDF ;
      case ps      : type = PS ;
    }

    if $(manifest)
    {
      for local i in $(source-targets) 
      {
        local base-target = [ generators.construct $(self.project) 
                              : DOCBOOK : $(property-set) : $(i) ] ;
        local target = [ generators.construct $(self.project) $(manifest)
                         : $(type) : $(property-set) : $(base-target) ] ;
        targets += $(target) ;
      }
    }
    else {
      for local i in $(source-targets) 
      {
        local target = [ generators.construct $(self.project)
                         : $(type) : $(property-set) : $(i) ] ;
        targets += $(target) ;
      }
    }

    return $(targets) ;
  }
}

class boostbook-target-class : basic-target ;

rule boostbook ( target-name : source : requirements * : default-build * )
{ 
  local project = [ CALLER_MODULE ] ;

  targets.main-target-alternative 
    [ new boostbook-target-class $(target-name) : $(project) : $(source) 
        : [ targets.main-target-requirements $(requirements) : $(project) ]
        : [ targets.main-target-default-build $(default-build) : $(project) ] 
    ] ;
}

actions xslt-xsltproc
{
  XML_CATALOG_FILES=catalog.xml xsltproc $(FLAGS) --xinclude -o $(<) $(STYLESHEET) $(>)
}

actions xslt-xsltproc-dir
{
  XML_CATALOG_FILES=catalog.xml xsltproc $(FLAGS) --xinclude -o $(DIRECTORY)/ $(STYLESHEET) $(>)
}

#############################################################################
# XML Catalog Generation
#############################################################################


# XInclude scanner. Mostly stolen from c-scanner :)
# Note that this assumes an "xi" prefix for XIncludes. This isn't always the
# case for XML documents, but we'll assume it's true for anything we encounter.
rule xinclude-scanner ( includes * )
{
  scanner.__init__ ;

  rule pattern ( )
  {
    return "xi:include[ ]*href=\"([^\"]*)\"" ;
  }

  rule process ( target : matches * )
  {
    local target_path = [ path.native [ path.parent [ path.make
                          [ virtual-target.binding $(target) ] ] ] ] ;

    for local i in $(matches) 
    {
      local i2 = [ SEARCH_FOR_TARGET $(i) : $(target_path) ] ;
      INCLUDES $(target) : $(i2) ;
    }

    BINDRULE on $(matches) = virtual-target.remember-binding ;

    for local j in $(matches)
    {
      scanner.install $(__name__) : $(j) : $(target) ; 
    }
  }
}

class xinclude-scanner : scanner ;
scanner.register xinclude-scanner ;
type.set-scanner XML : xinclude-scanner ;