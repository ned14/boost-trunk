#  Copyright (C) Vladimir Prus 2002. Permission to copy, use, modify, sell and
#  distribute this software is granted provided this copyright notice appears in
#  all copies. This software is provided "as is" without express or implied
#  warranty, and with no claim as to its suitability for any purpose.

#  Defines standard features and rules.

import class : class new ;

import feature : feature compose ;
import type ;
import scanner ;
import generators ;
import regex ;
import virtual-target ;
import os ;
import stage ;
import prebuilt ;
import toolset ;
import errors : error ;
import symlink ;

feature toolset : : implicit propagated link-incompatible symmetric ;
feature shared : false true : propagated ;
feature optimization : off on : propagated ;
feature threading : single multi : link-incompatible propagated ;
feature rtti : on off : link-incompatible propagated ;
feature debug-symbols : on off : propagated ;
feature define : : free ;
feature "include" : : free path ;
feature cxxflags : : free ;

feature dependency : : free dependency ;
feature library : : free dependency ;
feature find-library : : free ;
feature library-path : : free path ;
feature library-file : : free path ;

feature variant : : implicit composite propagated symmetric ;

# Declares a new variant.
# First determines explicit properties for this variant, by
# refining parents' explicit properties with the passed explicit
# properties. The result is remembered and will be used if
# this variant is used as parent.
#
# Second, determines the full property set for this variant by
# adding to the explicit properties default values for all properties 
# which neither present nor are symmetric.
#
# Lastly, makes appropriate value of 'variant' property expand
# to the full property set.
rule variant ( name           # Name of the variant
    : parents-or-properties * # Specifies parent variants, if 
                              # 'explicit-properties' are given,
                              # and explicit-properties otherwise.
    : explicit-properties *   # Explicit properties.
    )
{
    local parents ;
    if ! $(explicit-properties)
    {
        if $(parents-or-properties[1]:G)
        {
            explicit-properties = $(parents-or-properties) ;
        }
        else
        {
            parents = $(parents-or-properties) ;
        }
    }
    else
    {
        parents = $(parents-or-properties) ;
    }

    # The problem is that we have to check for conflicts
    # between base variants.
    if $(parents[2])
    {
        error "multiple base variants are not yet supported" ;
    }
    
    local inherited ;
    # Add explicitly specified properties for parents
    for local p in $(parents)
    {
        # TODO: the check may be sticter
        if ! [ feature.is-implicit-value $(p) ]
        {
            error "Invalid base varaint" $(p)  ;
        }
        
        inherited += $(.explicit-properties.$(p)) ;
    }
    explicit-properties = [ property.refine $(inherited) : $(explicit-properties) ] ;
    
    # Record explicitly specified properties for this variant
    # We do this after inheriting parents' properties, so that
    # they affect other variants, derived from this one.
    .explicit-properties.$(name) = $(explicit-properties) ;
       
    local fool-properties = [ feature.add-defaults $(explicit-properties) ] ;
    
    # Eliminate all symmetric features.    
    local full-properties2 ;
    for local p in $(fool-properties)
    {
        if ! symmetric in [ feature.attributes $(p:G) ]
        {
            full-properties2 += $(p) ;
        }        
    }
        
    feature.extend variant : $(name) ;
    feature.compose <variant>$(name) : $(full-properties2) ;    
}
IMPORT $(__name__) : variant : : variant ;

variant debug : <optimization>off <debug-symbols>on ;
variant release : <optimization>on <debug-symbols>off ;

type.register LIB : : : main ;

# register the given type on the specified OSes, or on remaining OSes
# if os is not specified.
local rule declare-type ( os * : type : suffixes * : base-type ? : main ? ) 
{
    if ! [ type.registered $(type) ]
    {
        if ( ! $(os) ) || [ os.name ] in $(os)
        {
            type.register $(type) : $(suffixes) : $(base-type) : $(main) ;
        }
    }
}

declare-type NT : STATIC_LIB : a : LIB : main ;
declare-type : STATIC_LIB : a : LIB : main ;

declare-type NT : SHARED_LIB : dll : LIB : main ;
declare-type : SHARED_LIB : so : LIB : main ;

declare-type NT CYGWIN : EXE : exe : : main ;
declare-type : EXE : : : main ;

declare-type NT : PYTHON_EXTENSION : pyd : SHARED_LIB : main ;
declare-type CYGWIN : PYTHON_EXTENSION : dll : SHARED_LIB : main ;
declare-type : PYTHON_EXTENSION : so : SHARED_LIB : main ;

type.register CPP : cpp cxx ;

rule c-scanner ( includes * )
{
    scanner.__init__ ;
    self.includes = $(includes) ;

    rule pattern ( )
    {
        return "#include[ ]*(<(.*)>|\"(.*)\")" ;
    }

    rule process ( target : matches * )
    {
        local angle = [ regex.transform $(matches) : "<(.*)>" ] ;
        local quoted = [ regex.transform $(matches) : "\"(.*)\"" ] ;

        # CONSIDER: the new scoping rule seem to defeat "on target" variables.
        local g = [ on $(target) return $(HDRGRIST) ] ;  
        local b = [ path.native [ path.parent [ path.make
                      [ virtual-target.binding $(target) ] ] ] ] ;

        # Attach binding of including file to included targets.
        # When target is directly created from virtual target
        # this extra information is unnecessary. But in other
        # cases, it allows to distinguish between two headers of the 
        # same name included from different places.      
        # We don't need this extra information for angle includes,
        # since they should not depend on including file (we can't
        # get literal "." in include path).
        local g2 = $(g)"#"$(b) ;
       
        angle = $(angle:G=$(g)) ;
        quoted = $(quoted:G=$(g2)) ;

        for local i in $(angle)
        {            
            local i2 = [ SEARCH_FOR_TARGET $(i) : $(self.includes:G=) ] ;
            INCLUDES $(target) : $(i2) ;
            if $(i2) = $(i)
            {
                NOCARE $(i) ;
                SEARCH on $(i) = $(self.includes:G=) ;
            }
        }
        
        for local i in $(quoted)
        {
            local path = $(b) $(self.includes:G=) ;
            local i2 = [ SEARCH_FOR_TARGET $(i) : $(path) ] ;
            INCLUDES $(target) : $(i2) ;
            if $(i2) = $(i)
            {
                NOCARE $(i) ;
                SEARCH on $(i) = $(path) ;
            }
        }

        BINDRULE on $(angle) $(quoted) = virtual-target.remember-binding ;

        # Just propagate current scanner to includes, in a hope
        # that includes do not change scanners. 
        for local a in $(angle)
        {            
            scanner.install $(__name__) : $(a) : $(target) ;
        }
    }        
}

class c-scanner : scanner ;
scanner.register c-scanner : include ;

type.set-scanner CPP : c-scanner ;


type.register H : h ;
type.register C : c ;
type.register OBJ : o : : main ;

# Generator for 'lib' target, which relays to generators for either
# "STATIC_LIB" or "SHARED_LIB", depending on the value of 
# "shared" feature.
rule lib-generator ( ) 
{
    composing-generator.__init__ lib-generator : unknown-source-type : LIB : <main-target-type>LIB ;
    
    rule run ( project name ? : properties * : sources + )
    {
        # Determine the needed target type
        local actual-type ;
        if <shared>true in $(properties)
        {
            actual-type = SHARED_LIB ;
        }
        else 
        {
            actual-type = STATIC_LIB ;
        }
        # Construct the target. Pass 'allow-composing', since generators for 
        # library types are composing and we need to find them.
        return [ generators.construct $(project) $(name) : $(actual-type) : $(properties)
          : $(sources) : allow-composing ] ;
    }
}

class lib-generator : composing-generator ;

generators.register [ new lib-generator ] ;

rule compile-action ( targets + : sources * : action-name : properties * )
{
    action.__init__ $(targets) : $(sources) : $(action-name) : $(properties) ;
    
    rule adjust-properties ( properties * )
    {
        local dg = [ $(self.targets[1]).dg ] ;
        local target-paths = [ $(dg).all-target-directories ] ;    
        # Note that target-paths here are already relative to invocation
        # directory, and can be used as-is.
        
        return $(properties) $(target-paths:G=include) ;
    }    
}

class compile-action : action ;

rule C-compiling-generator ( id : source-types + : target-types + :
                             requirements * )
{
    generator.__init__ $(id) : $(source-types) : $(target-types) :
                       $(requirements) ;

    rule action-class ( )
    {
        return compile-action ;
    }
}

class C-compiling-generator : generator ;


rule register-c-compiler ( id : source-types + : target-types + :
                            requirements * )
{
    local g = [ new C-compiling-generator $(id) : $(source-types) 
                : $(target-types) : $(requirements) ] ;
    generators.register $(g) ;
}

# FIXME: this is ugly, should find a better way (we'd want client code to
# register all generators as "generator.some-rule", not with "some-module.some-rule".)
IMPORT $(__name__) : register-c-compiler : : generators.register-c-compiler ;






