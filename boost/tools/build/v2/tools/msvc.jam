# Copyright 2003 David Abrahams.
# Copyright 2005 Vladimir Prus.
#
# Use, modification and distribution is subject to the Boost Software
# License Version 1.0. (See accompanying file LICENSE_1_0.txt or
# http://www.boost.org/LICENSE_1_0.txt)

import property ;
import generators ;
import os ;
import type ;
import toolset : flags ;
import errors : error ;
import feature : feature get-values ;
import path ;
import sequence : unique ;
import common ;
import "class" : new ;
import rc ;

if [ MATCH (--debug-configuration) : [ modules.peek : ARGV ] ]
{
    .debug-configuration = true ;
}

feature.extend toolset : msvc ;

feature.subfeature toolset msvc : vendor
  : intel
  : propagated optional
  # intel and msvc supposedly have link-compatible objects... remains
  # to be seen, though ;-)
  ;

# List of all registered configurations
.versions = [ new configurations ] ;

RM =  [ common.rm-command ] ;


# Initialize the toolset for a specific version. As the result, path to
# compiler and, possible, program names are set up, and will be used when
# that version of compiler is requested. For example, you might have::
#
#    using msvc : 6.5 : X:/some_dir ;
#    using msvc : 7.0 : Y:/some_dir ;
#    using msvc : : Z:/some_dir
#
# If you have "msvc-6.5" in build request, the version from X: drive will be used,
# and if you put only "msvc", then drive "Z:" will be used. Note that it's not possible
# the specify that by default, version 7.0 must be used --- you should use 'using'
# without version number for that effect. 
#    
# version -- 
# path -- 
#
# When invoking tools, we'll first run vcvars32.bat from the configured path and
# then cl/link, without path.   
#
# Note: for free VC7.1 tools, we don't correctly find vcvars32.bar when user
# explicitly provides a path.
rule init ( 
    version ? # the msvc version which is being configured. When omitted
            # the tools invoked when no explicit version is given will be configured.
    : command * 
    # the command to invoke the compiler. If not specified:
    #       - if version is given, default location for that version will be searched
    # 
    #       - if version is not given, default locations for 7.1, 7.0 and 6.* will 
    #              be searched    
    # 
    #       - if compiler is not found in default locations, PATH will be searched.    
    : options * 
    # options can include <setup>, <compiler>, <assembler>, <linker> and <resource-compiler>
)
{
    if $(command)
    {
        options += <command>$(command) ;
    }

    configure $(version) : $(options) ;
}


# 'configure' is a newer version of 'init'. The parameter 'command' is passed as 
# a part of the 'options' list.
rule configure (
    version ? :
    options * 
    )
{
    switch $(version)
    {
        case all :
            if $(options)
            {
                error "msvc: options should be empty when 'all' is specified" ;
            }

            # use all detected versions
            for local v in [ $(.versions).all ]
            {
                configure-really $(v) ;
            }

        case "default" :
            configure-really : $(options) ;

        case * :
            configure-really $(version) : $(options) ;
    }
}


local rule configure-really (
    version ? :
    options *
    )
{
    # If no version supplied use the default configuration. Note that condition 
    # remains versionless.
    local v = $(version) ;
    if ! $(v)
    {
        # take the first detected version
        version = [ $(.versions).all ] ;
        version = $(version[1]) ;

        # Note: 'version' can still be empty at this point if no versions were 
        # detected.
        version ?= "default" ;
    }

    # Check whether selected configuration is used already
    if $(version) in [ $(.versions).used ]
    {
        # Allow multiple 'toolset.usage' calls for the same configuration
        # if the identical sets of options are used 
        if $(options) && ( $(options) != [ $(.versions).get $(version) : options ] )
        {
            error "msvc: the toolset version '$(version)' is configured already" ;
        }
    }
    else
    {
        # Register a new configuration 
        $(.versions).register $(version) ;

        # Set new options if any
        if $(options)
        {
            $(.versions).set $(version) : options : $(options) ;
        }

        # Mark the configuration as 'used'.
        $(.versions).use $(version) ;

        # Get auto-detected or user-supplied options 
        options = [ $(.versions).get $(version) : options ] ;

        # Generate condition and save it
        local condition = [ common.check-init-parameters msvc : 
            version $(v) ] ;

        $(.versions).set $(version) : condition : $(condition) ;

        local command = [ get-values <command> : $(options) ] ;

        # setup will be used if a path has been specified.  If setup is
        # not specified, vcvars32.bat will be used instead.
        setup = [ get-values <setup> : $(options) ] ;
        setup ?= vcvars32.bat ;    
        compiler = [ get-values <compiler> : $(options) ] ;
        compiler ?= cl ;
        linker = [ get-values <linker> : $(options) ] ;
        linker ?= link ;
        resource-compiler = [ get-values <resource-compiler> : $(options) ] ;
        resource-compiler ?= rc ;
        assembler = [ get-values <assembler> : $(options) ] ;
        assembler ?= ml ;
        
        # If version is specified, we try to search first in default paths,
        # and only then in PATH.
        command = [ common.get-invocation-command msvc : cl.exe : $(command)
          : [ default-paths $(version) ] : $(version) ] ;
        
        common.handle-options msvc : $(condition) : $(command) : $(options) ;
            
        if $(command)
        {        
            command = [ common.get-absolute-tool-path $(command[-1]) ] ;
        }
        local root = $(command:D) ;
                      
        setup = $(root)\\bin\\$(setup) ;
        
        # CONSIDER: What's the point of 'call'. Can we invoke the script directly?
        setup = "call \""$(setup)"\" > nul " ;
        
        if [ os.name ] = NT
        {
            setup = $(setup)"
" ;
        }
        else
        {
            setup = "cmd /S /C "$(setup)" \"&&\" " ;
        }

        # prefix with setup, or quoted path if any
        local prefix = $(setup) ;
        
        flags msvc.compile .CC $(condition) : $(prefix)$(compiler) ;
        flags msvc.compile .RC $(condition) : $(prefix)$(resource-compiler) ;
        flags msvc.compile .ASM $(condition) : $(prefix)$(assembler) ;
        flags msvc.link .LD $(condition) : $(prefix)$(linker) ;
        flags msvc.archive .LD $(condition) : $(prefix)$(linker) ;
        
        if ! $(version) 
        {
            # Even if version is not explicitly specified, try to detect the version
            # from the path.
            if [ MATCH "(Microsoft Visual Studio 8)" : $(command) ]
            {
                version = 8.0 ;
            }                 
            else if [ MATCH "(NET 2003[\/\\]VC7)" : $(command) ]
            {
                version = 7.1 ;
            }
            else if [ MATCH "(Microsoft Visual C\\+\\+ Toolkit 2003)" : $(command) ]
            {
                version = 7.1toolkit ;
            }
            else if [ MATCH "(.NET[\/\\]VC7)" : $(command) ]
            {
                version = 7.0 ;
            }
            else
            {
                version = 6.0 ;
            }                
        }
                    
        # Starting with versions 7.0, the msvc compiler have the /Zc:forScope
        # and /Zc:wchar_t options that improve C++ standard conformance, but
        # those options are off by default.
        # If we're sure that msvc version is at 7.*, add those options explicitly.
        # We can be sure either if user specified version 7.* explicitly,
        # or if the installation path contain 7.* (this is checked above).
        if ! [ MATCH ^(6\\.) : $(version) ]
        {
            flags msvc.compile CFLAGS $(condition) : /Zc:forScope /Zc:wchar_t ;
        }
        
        # 8.0 deprecates some of the options
        if ! [ MATCH ^([67]\\.) : $(version) ]
        {
            flags msvc.link MANIFEST $(condition) : "mt -nologo -manifest " ;
            flags msvc.link OUTPUTRESOURCE $(condition) : "-outputresource:" ;
        }
        else
        {
            flags msvc.compile CFLAGS $(condition)/<optimization>speed $(condition)/<optimization>space : /Ogiy /Gs ;
            flags msvc.compile CFLAGS $(condition)/<optimization>speed : /Ot ;
            flags msvc.compile CFLAGS $(condition)/<optimization>space : /Os ;
        }
    }
}


# Returns the default installation path for the given version. 
local rule default-path ( version )
{
    # Use auto-detected path if possible 
    local path = [ get-values <command> : 
        [ $(.versions).get $(version) : options ] ] ;

    if $(path)
    {
        path = $(path:D) ;
    }
    else
    {
        # Check environment
        if $(.version-$(version)-env)
        {
            local vc-path = [ os.environ $(.version-$(version)-env) ] ;
            if $(vc-path)
            {
                vc-path = [ path.make $(vc-path) ] ;
                vc-path = [ path.join $(vc-path) $(.version-$(version)-envpath) ] ;
                vc-path = [ path.native $(vc-path) ] ;

                path = $(vc-path) ;
            }
        }

        # Check default path
        if ! $(path) && $(.version-$(version)-path)
        {
            path = [ path.native [ path.join $(.ProgramFiles) $(.version-$(version)-path) ] ] ;
        }
    }

    return $(path) ;
}

# Returns either the default installation path (if 'version' is not empty) or list of all 
# known default paths (if no version is given)
rule default-paths ( version ? )
{
    local possible-paths ;
    
    if $(version)
    {
        default-path += [ default-path $(version) ] ;
    }
    else
    {
        for local i in $(.known-versions)
        {
            default-path += [ default-path $(i) ] ;
        }
    }

    return $(possible-paths) ;
}


# Declare generators

# is it possible to combine these?
# make the generators non-composing, so that they don't convert each source
# into separate rsp file.
generators.register-linker msvc.link : OBJ SEARCHED_LIB STATIC_LIB IMPORT_LIB : EXE : <toolset>msvc ;
generators.register-linker msvc.link.dll : OBJ SEARCHED_LIB STATIC_LIB IMPORT_LIB : SHARED_LIB IMPORT_LIB : <toolset>msvc ;
  
generators.register-archiver msvc.archive : OBJ : STATIC_LIB : <toolset>msvc ;
generators.register-c-compiler msvc.compile.c++ : CPP : OBJ : <toolset>msvc ;
generators.register-c-compiler msvc.compile.c : C : OBJ : <toolset>msvc ;
generators.register-standard msvc.compile.rc : RC : OBJ(%_res) : <toolset>msvc ;
generators.override msvc.compile.rc : rc.resource-compile ;
generators.register-standard msvc.compile.asm : ASM : OBJ : <toolset>msvc ;

#
# Declare flags and action for compilation
#
feature.feature debug-store : object database : propagated ;

flags msvc.compile CFLAGS <optimization>speed : /O2 ;
flags msvc.compile CFLAGS <optimization>space : /O1 ;

flags msvc.compile CFLAGS <debug-symbols>on/<debug-store>object : /Z7 ;
flags msvc.compile CFLAGS <debug-symbols>on/<debug-store>database : /Zi ;
flags msvc.compile CFLAGS <optimization>off : /Od ;
flags msvc.compile CFLAGS <inlining>off : /Ob0 ;
flags msvc.compile CFLAGS <inlining>on : /Ob1 ;
flags msvc.compile CFLAGS <inlining>full : /Ob2 ;

flags msvc.compile CFLAGS <warnings>on : /W3 ;
flags msvc.compile CFLAGS <warnings>off : /W0 ;
flags msvc.compile CFLAGS <warnings>all : /W4 /Wp64 ;
flags msvc.compile CFLAGS <warnings-as-errors>on : /WX ;

flags msvc.compile C++FLAGS  <exception-handling>on/<asynch-exceptions>off/<extern-c-nothrow>off : /EHs ;
flags msvc.compile C++FLAGS  <exception-handling>on/<asynch-exceptions>off/<extern-c-nothrow>on : /EHsc ;
flags msvc.compile C++FLAGS  <exception-handling>on/<asynch-exceptions>on/<extern-c-nothrow>off : /EHa ;
flags msvc.compile C++FLAGS  <exception-handling>on/<asynch-exceptions>on/<extern-c-nothrow>on : /EHac ;

flags msvc.compile CFLAGS <rtti>on : /GR ;
flags msvc.compile CFLAGS <runtime-debugging>off/<runtime-link>shared : /MD ;
flags msvc.compile CFLAGS <runtime-debugging>on/<runtime-link>shared : /MDd ;

flags msvc.compile CFLAGS <runtime-debugging>off/<runtime-link>static/<threading>single : /ML ;
flags msvc.compile CFLAGS <runtime-debugging>on/<runtime-link>static/<threading>single : /MLd ;
flags msvc.compile CFLAGS <runtime-debugging>off/<runtime-link>static/<threading>multi : /MT ;
flags msvc.compile CFLAGS <runtime-debugging>on/<runtime-link>static/<threading>multi : /MTd ;

flags msvc.compile USER_CFLAGS <cflags> : ;
flags msvc.compile.c++ USER_CFLAGS <cxxflags> : ;

flags msvc.compile PDB_CFLAG <debug-symbols>on/<debug-store>database : /Fd ;  # not used yet

flags msvc.compile DEFINES <define> ;
flags msvc.compile UNDEFS <undef> ;
flags msvc.compile INCLUDES <include> ;

flags msvc.compile.c++ C++FLAGS : /wd4675 ;

# The actions differ only by explicit selection of input language
actions compile.c bind RSP
{
    $(.CC) /Zm800 -nologo -TC -U$(UNDEFS) $(CFLAGS) $(USER_CFLAGS) @"$(RSP:W)" -c -Fo"$(<[1]:W)" && $(RM) "$(RSP)"
}
actions compile.c++ bind RSP
{
    $(.CC) /Zm800 -nologo -TP -U$(UNDEFS) $(CFLAGS) $(C++FLAGS) $(USER_CFLAGS) @"$(RSP:W)" -c -Fo"$(<[1]:W)" && $(RM) "$(RSP)" 
}

actions compile.rc
{
    $(.RC) -l 0x409 -U$(UNDEFS) -D$(DEFINES) -I"$(INCLUDES)" -fo "$(<:W)" "$(>:W)"
}

# Declare flags and action for the assembler

flags msvc.compile.asm USER_ASMFLAGS <asmflags> : ;

#
# for the assembler the following options are turned on by default:
#
# -coff  generate COFF format object file (compatible with cl.exe output)
# -Zp4   align structures to 4 bytes
# -Cp    preserve case of user identifiers
# -Cx    preserve case in publics, externs

actions compile.asm
{
    $(.ASM) -nologo -c -coff -Zp4 -Cp -Cx $(USER_ASMFLAGS) -Fo "$(<:W)" "$(>:W)"
}

# Declare flags and action for linking
flags msvc.link PDB_LINKFLAG <debug-symbols>on/<debug-store>database : /PDB: ; # not used yet
flags msvc.link LINKFLAGS <debug-symbols>on : /DEBUG ;
flags msvc.link DEF_FILE <def-file> ;
# The linker disables the default optimizations when using /DEBUG. Whe have
# to enable them manually for release builds with debug symbols.
flags msvc LINKFLAGS <debug-symbols>on/<runtime-debugging>off : /OPT:REF,ICF ;

flags msvc LINKFLAGS <user-interface>console : /subsystem:console ;
flags msvc LINKFLAGS <user-interface>gui : /subsystem:windows ;
flags msvc LINKFLAGS <user-interface>wince : /subsystem:windowsce ;
flags msvc LINKFLAGS <user-interface>native : /subsystem:native ;
flags msvc LINKFLAGS <user-interface>auto : /subsystem:posix ;

flags msvc LINKFLAGS <main-target-type>LIB/<link>shared : /DLL ;

flags msvc.link USER_LINKFLAGS <linkflags> ;
flags msvc.link LINKPATH <library-path> ;


flags msvc.link FINDLIBS_ST <find-static-library> ;
flags msvc.link FINDLIBS_SA <find-shared-library> ;
flags msvc.link LIBRARY_OPTION <toolset>msvc : "" : unchecked ;


rule archive ( targets + : sources * : properties * )    
{
    common.response-file $(targets) : $(sources) : $(targets[2]) : $(properties) ;             
}

rule link ( targets + : sources * : properties * )
{
    common.response-file $(targets) : $(sources) : $(targets[2]) 
      : $(properties) ;
}

rule link.dll ( targets + : sources * : properties * )
{
    common.response-file $(targets) : $(sources) : $(targets[3]) : $(properties) ;
    DEPENDS $(<) : [ on $(<) return $(DEF_FILE) ] ;
}    

# Declare action for creating static libraries
# If library exists, remove it before adding files. See
# http://article.gmane.org/gmane.comp.lib.boost.build/4241    
# for rationale.
if [ os.name ] in NT
{    
    # The 'DEL' command would issue a message to stdout
    # if the file does not exist, so need a check.
    actions archive bind RSP
    {  
        if exist "$(<[1])" DEL "$(<[1])"  
        $(.LD) /lib /NOLOGO /out:"$(<[1])" @"$(RSP)" && $(RM) "$(RSP)"
    }
}
else
{
    actions archive bind RSP
    {  
        $(RM) "$(<[1])"
        $(.LD) /lib /NOLOGO /out:"$(<[1])" @"$(RSP)" && $(RM) "$(RSP)"
    }
}
        
# incremental linking a DLL causes no end of problems: if the
# actual exports don't change, the import .lib file is never
# updated. Therefore, the .lib is always out-of-date and gets
# rebuilt every time. I'm not sure that incremental linking is
# such a great idea in general, but in this case I'm sure we
# don't want it.

# Windows Manifests is a new way to specify dependencies 
# on managed DotNet assemblies and Windows native DLLs. The 
# manifests are embedded as resourses and are useful in 
# any PE targets (both DLL and EXE)

actions link bind DEF_FILE RSP
{
    $(.LD) /NOLOGO $(LINKFLAGS) /out:"$(<[1]:W)" /INCREMENTAL:NO /LIBPATH:"$(LINKPATH:W)" $(USER_LINKFLAGS) @"$(RSP:W)" && $(RM) "$(RSP)"
    $(MANIFEST)$(<[1]).manifest $(OUTPUTRESOURCE)$(<[1]);#2
}

actions link.dll bind DEF_FILE RSP
{
    $(.LD) /NOLOGO $(LINKFLAGS) /out:"$(<[1]:W)" /INCREMENTAL:NO /IMPLIB:"$(<[2]:W)" /LIBPATH:"$(LINKPATH:W)" /def:$(DEF_FILE) $(USER_LINKFLAGS) @"$(RSP:W)" && $(RM) "$(RSP)"
    $(MANIFEST)$(<[1]).manifest $(OUTPUTRESOURCE)$(<[1]);#2
}

rule compile.c++ ( targets + : sources * : properties * )
{
    common.response-file $(targets) : $(sources) : $(response-file) : $(properties) ;
}

rule compile.c ( targets + : sources * : properties * )
{
    common.response-file $(targets) : $(sources) : $(targets[2]) : $(properties) ;
}


#
# Autodetection code
#     detects versions listed as '.known-versions' using registry, environment 
#     and checking default paths. Supports both native Windows and Cygwin.
#

.ProgramFiles = [ path.make [ common.get-program-files-dir ] ] ;

.known-versions             = 8.0 7.1 7.1toolkit 7.0 6.0 ;
 
# Name of the registry key that contains Visual C++ installation path
#   (relative to "HKEY_LOCAL_MACHINE\SOFTWARE\\Microsoft\VisualStudio\x.y\Setup"
.version-6.0-reg            = "Microsoft Visual C++" ;
.version-7.0-reg            = "VC" ;
.version-7.1-reg            = "VC" ;
.version-8.0-reg            = "VC" ;

# Visual C++ Toolkit 2003 do not store its installation path in the registry.
# The environment variable 'VCToolkitInstallDir' and the default installation 
# path will be checked instead.
.version-7.1toolkit-path    = "Microsoft Visual C++ Toolkit 2003" "bin" ;
.version-7.1toolkit-env     = VCToolkitInstallDir ;

# Path to the folder containing "cl.exe" relative to the value of the corresponding 
# environment variable
.version-7.1toolkit-envpath = "bin" ;


# Validates given path, registers found configuration and prints debug information 
# about it.
local rule register-configuration ( version : path ? )
{
    if $(path)
    {
        local command = [ GLOB $(path) : cl.exe ] ;

        if $(command)
        {
            if $(.debug-configuration)
            {
                ECHO "notice: msvc-$(version) detected, command: '$(command)'" ;
            }

            $(.versions).register $(version) ;
            $(.versions).set $(version) : options : <command>$(command) ;
        }
    }
}

if [ os.name ] in NT CYGWIN
{
    # Get installation paths from the registry

    for local i in $(.known-versions)
    {
        if $(.version-$(i)-reg)
        {
            local vc-path = [ W32_GETREG
                "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\VisualStudio\\$(i)\\Setup\\"$(.version-$(i)-reg)
                : "ProductDir" ] ;
            
            if $(vc-path)
            {
                vc-path = [ path.native [ path.join [ path.make-NT $(vc-path) ] "bin" ] ] ;
                register-configuration $(i) : $(vc-path) ;
            }
        }
    }
}


# Check environment and default installation paths

for local i in $(.known-versions)
{
    if ! $(i) in [ $(.versions).all ]
    {
        register-configuration $(i) : [ default-path $(i) ] ;
    }
}

