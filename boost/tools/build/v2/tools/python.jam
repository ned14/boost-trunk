# Copyright 2004 Vladimir Prus.
# Distributed under the Boost Software License, Version 1.0. (See
# accompanying file LICENSE_1_0.txt or copy at
# http://www.boost.org/LICENSE_1_0.txt)

# Support for Python and the the Boost.Python library.
#
# This module defines
#
# - a project 'python' with a target 'python' in it, that corresponds
#   to the python library
#
# - a main target rule 'python-extension' which can be used
#   to build a python extension.
#
# Extensions that use Boost.Python must explicitly link to it.

# Known problems: 
# - the directory where extension is generated is different from V2
# - the ext + py -> pyd_run_output generator is declared to take 
#   SHARED_LIB, not PYTHON_EXTENSION. That's because we reuse 
#   'lib-target-class', which creates SHARED_LIB explicitly.

import type ;
import testing ;
import generators ;
import project ;
import errors ;
import targets ;
import "class" : new ;
import os ;
import common ;
import toolset : flags ;
import regex ;
import numbers ;
import string ;
import property ;
import sequence ;
import path ;

# Make this module a project
project.initialize $(__name__) ;
project python ;

# Save the project so that if 'init' is called several
# times we define new targets in the python project,
# not in whatever project we were called by.
.project = [ project.current ] ;

.alias-defined = ;

# Dynamic linker lib. Necessary to specify it explicitly 
# on some platforms.
lib dl ;  
# This contains 'openpty' function need by python. Again, on
# some system need to pass this to linker explicitly.
lib util ;
# Python uses pthread symbols.
lib pthread ;
# Extra library needed by phtread on some platforms.
lib rt ;


# Initializes the Python toolset.
# - version -- the version of Python to use. Should be in Major.Minor format,
#   for example 2.3
# - 'root' -- the install root for Python
# - 'includes' -- the include path to Python headers. If empty, will be
#        guessed from 'root'
# - 'libraries' -- the path to Python libraries. If empty, will be guessed
#        from 'root'
# - 'specifics' -- if specified, should be a set of properties which
#   are present when we're building with cygwin gcc. 
#   This argument is not used yet.
#
# Example usage:
#
#   using python 2.3 ;  # Use default root
#   using python 2.3 : /usr/local ; # Root specified, include and lib paths
#                                   # will be guessed
#    
rule init ( version ? : root ? : includes ? : libraries ? 
    : specifics * )
{
    .configured = true ;
    
    project.push-current $(.project) ;
         
    debug-message Configuring python... ;
    for local v in version root includes libraries specifics
    {
        if $($(v))
        {
            debug-message "  user-specified "$(v): \"$($(v))\" ;
        }
    }
    
    if [ os.name ] = MACOSX
    {
        init-mac $(version) : $(root) : $(includes) : $(libraries) ;
    } 
    else
    {
        init-unix-nt $(version) : $(root) : $(includes) : $(libraries) : $(specifics) ;
    }
    
    project.pop-current ;
}

# Retrieves the Python interpreter
rule get-python-interpreter ( )
{
  return $(PYTHON) ;
}

# Retrieves the Python version number
rule get-python-version ( )
{
  return [ python-version [ get-python-interpreter ] ] ;
}

# A simpler version of SHELL that grabs stderr as well as stdout, but
# returns nothing if there's an error.
local rule shell-cmd ( cmd )
{
    # debug-message running command '$(cmd)' ;
    x = [ SHELL $(cmd)" 2>&1" : exit-status ] ;
    if $(x[2]) = 0
    {
        return $(x[1]) ;
    }
    else
    {
        return ;
    }
}

# Invoke the given python interpreter command, import everything from
# sys, and return the result of printing the given python expression
# in that context.
local rule python-print ( interpreter-cmd : expression )
{
    local nl = "

" ;
    local full-cmd = $(interpreter-cmd)" -c \"from sys import *; print "$(expression)\" ;
    return [ MATCH ^([^$(nl)]+).* : [ shell-cmd $(full-cmd) ] : 1 ] ;
}

# Try to identify Cygwin symlinks.  Invoking such a file directly as
# an NT executable from a native Windows build of bjam would be fatal
# to the bjam process.  One /can/ invoke them through sh.exe or
# bash.exe, if you can prove that those aren't also symlinks ;-)
#
# Note: 1. only works on NT  2. path is a native path.
local rule is-cygwin-symlink ( path )
{
    local is-symlink = ;
    
    # Look for a file with the given path having the S attribute set,
    # as cygwin symlinks do.  /-C means "do not use thousands
    # separators in file sizes."
    local dir-listing = [ shell-cmd "dir /-C /A:S "$(path) ] ;

    if $(dir-listing)
    {
        # escape any special regex characters in the base part of the path
        local base-pat = [ regex.escape $(path:D=) : ].[()*+?|\\$^ : \\ ] ;
        
        # extract the file's size from the directory listing
        local size-of-system-file = [ MATCH "([0-9]+) "$(base-pat) : $(dir-listing) : 1 ] ;
        
        # if the file has a reasonably small size, look for the
        # special symlink identification text
        if $(size-of-system-file) && [ numbers.less $(size-of-system-file) 1000 ]
        {
            local link = [ SHELL "FIND /OFF \"!<symlink>\" \""$(path)"\" 2>&1" ] ;
            if $(link[2]) != 0
            {
                local nl = "

" ;
                is-symlink = [ *nix-path [ MATCH ".*!<symlink>([^"$(nl)"]*)" : $(link[1]) : 1 ] ] ;
            }
        }
    }
    return $(is-symlink) ;
}

# Append ext to each member of names that does not contain '.'
local rule default-extension ( names * : ext * )
{
    local result ;
    for local n in $(names)
    {
        switch $(n)
        {
            case *.* : result += $(n) ;
            case * : result += $(n)$(ext) ;
        }
    }
    return $(result) ;
}

# Find the path to the python executable invoked by the given command
#
# Tries to determine whether invoking "cmd" would actually attempt to
# launch a cygwin symlink.
#
# Note: only works on NT
local rule invokes-cygwin-symlink ( cmd )
{
    local dirs = $(cmd:D) ;
    if ! $(dirs)
    {
        dirs = . [ os.executable-path ] ;
    }
    local base = [ default-extension $(cmd:D=) : .exe .bat ] ;
    local paths = [ GLOB $(dirs) : $(base) ] ;
    if $(paths)
    {
        # Make sure we didn't find a Cygwin symlink.  Invoking such a
        # file as an NT executable will be fatal to the bjam process.
        return [ is-cygwin-symlink $(paths[1]) ] ;
    }
}

local rule unix-python-root ( cmd )
{
    return [ MATCH (.*)/bin/[^/]* : [ python-path $(cmd) ] : 1 ] ;
}


local rule debug-message ( message * )
{
    if --debug-configuration in [ modules.peek : ARGV ]
    {
        ECHO notice: [python-cfg] $(message) ;
    }
}

# Convert an NT path to native
local rule nt-path ( path )
{
    if [ os.name ] = NT
    {
        return $(path) ;
    }
    else
    {
        path = $(path:T) ;
        parts = [ MATCH ^([A-Za-z]):/(.*) : $(path) : 1 2 ] ;
        if $(parts)
        {
            path = /cygdrive/$(parts[1])/$(parts[2]) ;
        }
    }
}

# Like W32_GETREG, except prepend HKEY_CURRENT_USER and
# HKEY_LOCAL_MACHINE to the argument, returning the first result
# found.
local rule registry-value ( path : data ? )
{
    local result ;
    for local root in HKEY_CURRENT_USER HKEY_LOCAL_MACHINE
    {
        if ! $(result)
        {
            result = [ W32_GETREG $(root)"\\"$(path) : $(data) ] ;
        }
    }
    return $(result) ;
}

# Convert a *nix path to native.  
local rule *nix-path ( path )
{
    if [ os.name ] = NT
    {
        path = $(path:R="") ; # strip any trailing slash
        
        local parts = [ MATCH ^/cygdrive/([[a-zA-Z])/(.*) : $(path) : 1 2 ] ;
        if $(parts)
        {
            path = $(parts[1]):/$(parts[2]) ;
        }
        else if $(path:R=/x) = $(path) # already rooted?
        {
            # Look for a cygwin mount that includes each head sequence in $(path).
            local head = $(path) ;
            local tail = "" ;

            while $(head)
            {
                local root = [ 
                  registry-value "SOFTWARE\\Cygnus Solutions\\Cygwin\\mounts v2\\"$(head) 
                  : native 
                ] ;
                
                if $(root)
                {
                    path = $(tail:R=$(root)) ;
                    head = ;
                }
                tail = $(tail:R=$(head:D=)) ;
                
                if $(head) = /
                {
                    head = ;
                }
                else
                {
                    head = $(head:D) ;
                }
            }
        }
        path = [ regex.replace $(path:R="") / \\ ] ;
    }
    return $(path) ;
}
  
# Validate the version string and extract the major/minor part we care
# about
local rule split-version ( version ? )
{
    local major-minor = [ MATCH ^([0-9]+)\.([0-9]+)(.*)$ : $(version) : 1 2 3 ] ;
    if ! $(major-minor[2]) || $(major-minor[3])
    {
        ECHO "Warning: \"using python\" expects a two part (major, minor) version number; got" $(version) instead ;
        
        # Add a zero to account for the missing digit if necessary.
        major-minor += 0 ;
    }
    
    return $(major-minor[1]) $(major-minor[2]) ;
}

local rule win32-python-commands ( bin-directories * )
{
    # Logic:
    #
    # Specified: 
    #    version    root    search-order
    #    no         no      %PATH%, registry from highest to lowest
    #    no         yes     $(root) $(root)/PCBuild
    #    yes        no      %PATH%, registry for given version
    #    yes        yes     $(root) $(root)/PCBuild
    
    # Look for the specific version given, or else versions from
    # highest to lowest.  Once the legendary Python 3.0 comes out,
    # this file will be out-of-date.  To date we're at python 2.5
    local looking-for-versions = $(major-minor:J="") ;
    if ! $(looking-for-versions)
    {
        looking-for-versions = [ sequence.reverse [ numbers.range 15 29 ] ] ;
    }
    
    # Start by looking for Python relative to the specific root
    # directory given, or in the PATH
    local cmds = $(:E=python:R=$(bin-directories:E="")) ;
    
    # Then add any installation locations given in the registry
    # for the versions we're interested in.
    for local v in $(looking-for-versions)
    {
        local vv = [ string.chars $(v) ] ;
        for local x64elt in "" "Wow6432node\\"
        {
            local install-path = [ 
              registry-value "SOFTWARE\\"$(x64elt)"Python\\PythonCore\\"$(vv[1]).$(vv[2])"\\InstallPath" ] ;
            
            if $(install-path)
            {
                debug-message Found installed Python at \"$(install-path)\" ;
            }
            
            cmds += $(:E=python:R=$(install-path)) ;
        }
    }
    return $(cmds) ;
}

# Assume "cmd" invokes a python interpreter and invoke it to extract
# the interpreter version.  If cmd does not invoke a python
# interpreter, returns void.
rule interpreter-version ( cmd )
{
    # Avoid invoking a Cygwin symlink on NT
    local skip-symlink ;
    if [ os.name ] = NT
    {
        skip-symlink = [ invokes-cygwin-symlink $(cmd) ] ;
    }
    
    if $(skip-symlink)
    {
        debug-message -------------------------------------------------------------------- ;
        debug-message \"$(cmd)\" would attempt to invoke a Cygwin symlink, ;
        debug-message causing an NT build of bjam to hang. ;
        debug-message ;
        debug-message If you intend to target a Cygwin build of Python, please ;
        debug-message replace the path to the link with the path to a real executable ;
        debug-message (guessing: \"$(skip-symlink)\") "in" your 'using python' line ;
        debug-message "in" user-config.jam or site-config.jam. ;
        debug-message -------------------------------------------------------------------- ;
    }
    else
    {
        return [ 
          python-print $(interpreter-cmd) : "'%d.%d' % (version_info[0], version_info[1])" ] ;
    }
}

# condition is a list of properties for which this python initialization applies.
rule init-unix-nt ( version ? : root ? : includes ? : libraries ? : condition * )
{
    # compute the string Python's sys.platform needs to match.  If not targeting
    # windows or cygwin we'll assume only native builds can possibly run, so we
    # won't require a match and we leave sys.platform blank.
    local sys.platform ;
    local target-os = [ property.select target-os : $(condition) ] [ os.name ] ;
    target-os = $(target-os[1]:G="") ;
    
    switch $(target-os) 
    {
        case NT :
          sys.platform = win32 ;
        case CYGWIN :
          sys.platform = cygwin ;
    }
    if $(sys.platform)
    {
          debug-message seeking sys.platform: $(sys.platform) ;
    }
    
    #
    # Autoconfiguration sequence
    #
    
    local major-minor ;
    if $(version) 
    {
        major-minor = [ split-version $(version) ] ;
        debug-message Looking for python version $(major-minor:J=.)... ;
    }
    else
    {
        debug-message Looking for any python version...  ;
    }

    #
    # Construct the list of subdirectories of an explicitly-specified
    # root in which to look for the Python binary.
    #
    local bin ;
    if $(sys.platform) = win32
    {
        # on Windows, look in the root directory itself and, to work
        # with the result of a build-from-source, the PCBuild directory
        bin = PCBuild8 PCBuild ""  ; 
    }
    else
    {
        # if root is explicitly specified, look in its bin subdirectory
        local bin = bin ;
    }
    
    bin = $(bin:R=$(root)) ; # will null out $(bin) if $(root) is empty.
    if $(bin)
    {
        debug-message searching for python binaries in: $(bin) ;
    }
    
    local cmds ;
    if $(sys.platform) = win32
    {
        cmds = [ win32-python-commands $(bin) ] ;
    }
    else
    {
        # First look for python with the explicit version number, then without it
        cmds = $(:E=python:R=$(bin:E=""))$(major-minor:J=.:E="") $(:E=python:R=$(bin:E="")) ;
    }
    
    # Look through the list of cmds for an interpreter with an
    # appropriate version number.
    local interpreter-cmd ;
    while $(cmds)
    {
        # pop a command
        interpreter-cmd = $(cmds[0]) ; cmds = $(cmds[2-]) ;
        debug-message Trying Python interpreter command \"$(interpreter-cmd)\"... ;
          
        # Check to see what version that command actually runs, if any
        local found-version = [ interpreter-version $(interpreter-cmd) ] ;
        
        if ! $(found-version)
        {
            debug-message \"$(interpreter-cmd)\" does not invoke a working Python interpreter ;
            interpreter-cmd = ;
        }
        else
        {
            debug-message \"$(interpreter-cmd)\" invokes actual Python (major,minor) version $(found-version) ;
            
            # if no version was specified, assume the version found is OK
            version ?= $(found-version) ;
            
            # ditto for platform
            local found-platform = [ python-print $(interpreter-cmd) : platform ] ;
            sys.platform ?= $(found-platform) ;
            
            # if the version is a match and it targets the right platform, stop searching
            if $(version) = $(found-version) && $(sys.platform) = $(found-platform)
            {
                # compute default library and include search paths
                if $(sys.platform) = win32
                {
                    # The exec-prefix is where you're supposed to look
                    # for machine-specific libraries.
                    local exec-prefix = [ nt-path [ python-print $(interpreter-cmd) :  exec_prefix ] ] ;
                    local default-library-path = $(:E=libs:R=$(exec-prefix)) ;
                    local default-include-path = $(:E=Include:R=$(exec-prefix)) ;
                    
                    # If the interpreter was found in a directory
                    # called "PCBuild" or "PCBuild8," assume we're
                    # looking at a Python built from the source
                    # distro, and go up one additional level to the
                    # default root.  Otherwise, the default root is
                    # the directory where the interpreter was found.
                    
                    # We ask Python itself what the executable path is
                    # in case of intermediate symlinks or shell
                    # scripts.
                    local executable-path = [ nt-path [ python-print $(interpreter-cmd) :  executable ] ] ;
                    local executable-dir = $(executable-path:D) ;
                    
                    
                    if [ MATCH ^(PCBuild) : $(executable-dir:D=) : 1 ]
                    {
                        debug-message "This Python appears to reside in a source distribution;" ;
                        debug-message "adding \""$(executable-dir)"\" to default library search path" ;
                        
                        default-library-path = $(executable-dir) $(default-library-path) ;
                        default-include-path = $(:E=PC:R=$(executable-dir:D)) $(default-include-path) ;
                        debug-message "and \""$(default-include-path[1])"\" to default #include path" ;
                    }
                    libraries ?= $(default-library-path) ;
                    includes ?= $(default-include-path) ;
                }
                else
                {
                    local prefix = [ python-print $(interpreter-cmd) :  prefix ] ;
                    includes ?= [ *nix-path $(prefix)/include/python$(version) ] ;
                    
                    local exec-prefix = [ python-print $(interpreter-cmd) : exec_prefix ] ;
                    libraries ?= [ *nix-path $(exec-prefix)/lib/python$(version)/config ]
                      [ *nix-path $(exec-prefix)/lib ] ;
                }
                cmds = ; # break
            }
            else
            {
                interpreter-cmd = ;
            }
        }
    }
    
    if $(interpreter-cmd)
    {
        debug-message "Python interpreter command is" \"$(interpreter-cmd)\" ;
        debug-message "Python include path is" \"$(includes)\" ;
        debug-message "Python library path is" \"$(libraries)\" ;
    }
    else
    {
        debug-message "*** No suitable Python interpreter found ***" ;
    }
    
    #
    # End autoconfiguration sequence
    #
    
    
    # Set up the PYTHON variable to point at the interpreter.
    # If no specific condition is specified, set global value
    # If condition is specified, set PYTHON on target. It will
    # override the global value.
    if ! $(condition)
    {
        PYTHON = $(interpreter-cmd) ;
    }
    else
    {              
        flags python.capture-output PYTHON $(condition:J=/) : $(interpreter-cmd) ;
    }   

    # Provide system library dependencies for targets linking with
    # static Python libraries.
    #
    # On many systems, Python uses libraries such as pthreads or
    # libdl.  Since static libraries carry no library dependency
    # information of their own that the linker can extract, these
    # extra dependencies have to be given explicitly on the link line
    # of the client.  The information about these dependencies is
    # packaged into the "python" target below.

    # Even where Python itself uses pthreads, it never allows
    # extension modules to be entered concurrently (unless they
    # explicitly give up the interpreter lock).  Therefore, extension
    # modules don't need the efficiency overhead of threadsafe code as
    # produced by <threading>multi, and we handle libpthread along
    # with other libraries here.  Note: this optimization is based on
    # an assumption that the compiler generates link-compatible code
    # in both the single- and multi-threaded cases, and that system
    # libraries don't change their ABIs either.  

    # Most libraries are added to 'extra-libs'. Those that depend on
    # the toolset are added to 'extra-libs-conditional', which will be
    # used to form more specific target alternatives.
    
    local extra-libs extra-libs-conditional ;
    local lib-version = $(version) ;
    
    switch $(target-os)
    {
        case SOLARIS :
        {
            extra-libs = pthread dl ;
            
            # Add a librt dependency for the gcc toolset on SunOS (the
            # sun toolset adds -lrt unconditionally). While this
            # appears to duplicate the logic already in gcc.jam, it
            # doesn't as long as we're not forcing <threading>multi.
            extra-libs-conditional = <toolset>gcc:<source>rt ;
        }
        
        case OSF :     
        {
            extra-libs = pthread ;
            extra-libs-conditional = <toolset>gcc:<source>rt ;
        }
        
        case QNX* :    
          
        case NT :
        {
            extra-libs =                 ;
            major-minor = [ split-version $(version) ] ;
            lib-version = $(major-minor:J="") ;
        }
        
        case HPUX :
        {
            extra-libs = pthread rt ;
        }
        
        case * :       extra-libs = pthread dl util ;
    }
    
    local libpython-name = python $(version) $(sys.platform) ;
    libpython-name = $(libpython-name:J=-) ;
    lib $(libpython-name) : : <name>python$(lib-version) ;
    
    debug-message lib-version= $(lib-version) ;
    
    # This should really be called python_for_embedding
    alias python
                 : $(extra-libs) 
                 : $(condition) $(extra-libs-conditional)
                 :
                 : <include>$(includes) 
                   <library-path>$(libraries)
                   <library>$(libpython-name)
                 ;

    # On *nix, we don't want to link either Boost.Python or Python
    # extensions to libpython, because the Python interpreter itself
    # provides all those symbols. If we linked to libpython, we'd get
    # duplicate symbols. So declare two targets -- one for building
    # extensions and another for embedding
    if [ os.on-windows ]
    {
        alias python_for_extensions : python : $(condition) ;
    }
    else
    {
        alias python_for_extensions
                     :  
                     : $(condition)
                     :
                     : <include>$(includes) 
                     ;
    }
}

rule init-mac ( version : root ? : includes ? : libraries ? )
{
    if ! $(root)
    {
        if [ GLOB /System/Library/Frameworks : Python.framework ]
        {
            root = /System/Library/Frameworks/Python.framework/Versions/$(version) ;
        }
        else
        {
            root = /Library/Frameworks/Python.framework/Versions/$(version) ;
        }
    }   

    # includes ?= $(PYTHON_ROOT)/include/python$(PYTHON_VERSION) ;
    includes ?= $(root)/include/python$(version) ;
    libraries ?= $(root)/lib/python$(version)/config ;

    # Find the 'python' binary, which is used for testing.
    # Look first in $(root)/bin, then in PATH.
    local interpreter = [ common.get-invocation-command 
        python : python : : $(root)/bin : path-last ] ;
    
    # debug support
    if --debug-configuration in [ modules.peek : ARGV ]
    {
        ECHO "notice: Python include path is" $(includes) ;
        ECHO "notice: Python library path is" $(libraries) ;
        ECHO "notice: Python interpreter is" $(interpreter) ;        
    }
    
    PYTHON = $(interpreter) ;
    flags python.capture-output PYTHON : $(interpreter) ;
    
    PYTHON_FRAMEWORK ?= $(root) ;
    while $(PYTHON_FRAMEWORK:D=) && $(PYTHON_FRAMEWORK:D=) != Python.framework
    {
        PYTHON_FRAMEWORK = $(PYTHON_FRAMEWORK:D) ;
    }
    PYTHON_FRAMEWORK = $(PYTHON_FRAMEWORK:D)/Python ;

    alias python
      :
      : <os>MACOSX <toolset>darwin
      :
      : <include>$(includes) <framework>$(PYTHON_FRAMEWORK)
      ;  

    # Unlike most *nix systems, Mac OS X's linker does not permit undefined
    # symbols when linking a shared library. So, we still need to link
    # against the Python framework, even when building extensions. 
    # Note that framework builds of Python always use shared libraries,
    # so we do not need to worry about duplicate Python symbols.
    alias python_for_extensions : python ;
}

rule configured ( ) 
{
     return $(.configured) ;
}
        
type.register PYTHON_EXTENSION : : SHARED_LIB ;

# We can't give "dll" suffix to PYTHON_EXTENSION, because
# we would not know what "a.dll" is: python extenstion or
# ordinary library. Therefore, we specify only suffixes
# used for generation of targets.
type.set-generated-target-suffix PYTHON_EXTENSION : : so ;
type.set-generated-target-suffix PYTHON_EXTENSION : <target-os>windows : pyd ;
type.set-generated-target-suffix PYTHON_EXTENSION : <target-os>cygwin : dll ;

# Unset 'lib' prefix for PYTHON_EXTENSION
type.set-generated-target-prefix PYTHON_EXTENSION : : "" ;

rule python-extension ( name : sources * : requirements * : default-build * : 
                        usage-requirements * )
{
    requirements += <use>/python//python_for_extensions ;
                    
    local project = [ project.current ] ;

    
    targets.main-target-alternative
      [ new typed-target $(name) : $(project) : PYTHON_EXTENSION
        : [ targets.main-target-sources $(sources) : $(name) ]
        : [ targets.main-target-requirements $(requirements) : $(project) ] 
        : [ targets.main-target-default-build $(default-build) : $(project) ] 
      ] ;
}                            

IMPORT python : python-extension : : python-extension ;

# Support for testing
type.register PY : py ;
type.register RUN_PYD_OUTPUT ;
#type.set-generated-target-suffix RUN_PYD : : run ;
type.register RUN_PYD : : TEST ;

class python-test-generator : generator
{
    import set ;
    
    rule __init__ ( * : * )
    {
        generator.__init__ $(1) : $(2) : $(3) : $(4) : $(5) : $(6) : $(7) : $(8) : $(9) ;
        self.composing = true ;
    }
        
    rule run ( project name ? : property-set : sources * : multiple ? )
    {       
        local python ;
        local other-pythons ;
        for local s in $(sources)
        {
            if [ $(s).type ] = PY
            {
                if ! $(python)
                {
                    # First Python source ends up on command line.
                    python = $(s) ;
                }
                else
                {
                    # Other Python sources become dependencies.
                    other-pythons += $(s) ;
                }                
            }
        }
        
        local extensions ;
        for local s in $(sources)
        {
            if [ $(s).type ] = PYTHON_EXTENSION
            {
                extensions += $(s) ;
            }
        }
                
        local libs ;
        for local s in $(sources)
        {
            if [ type.is-derived [ $(s).type ] LIB ] 
              && ! $(s) in $(extensions)
            {
                libs += $(s) ;
            }
        }
        
        local new-sources ;
        for local s in $(sources)
        {
            if [ type.is-derived [ $(s).type ] CPP ] 
            {
                local name = [ utility.basename [ $(s).name ] ] ;
                if $(name) = [ utility.basename [ $(python).name ] ]
                {
                    name = $(name)_ext ;
                }          
                local extension = [ generators.construct $(project) $(name) :
                  PYTHON_EXTENSION : $(property-set) : $(s) $(libs) ] ;

                # The important part of usage requirements returned from
                # PYTHON_EXTENSION genrator are xdll-path properties that
                # will allow to find python extension at runtime.
                property-set = [ $(property-set).add $(extension[1]) ] ;
                # Ignore usage requirements. We're top-level generator and
                # nobody is going to use us.
                new-sources += $(extension[2-]) ;
            }
        }

        property-set = [ $(property-set).add-raw <dependency>$(other-pythons) ] ;
        
        result = [ construct-result $(python) $(extensions) $(new-sources) 
          : $(project) $(name) : $(property-set) ] ;        
    }    
}

generators.register 
  [ new python-test-generator python.capture-output : : RUN_PYD_OUTPUT ] ;

generators.register-standard testing.expect-success 
  : RUN_PYD_OUTPUT : RUN_PYD ;


# The flag settings on testing.capture-output do not
# apply to python.capture output at the moment.
# Redo this explicitly.
toolset.flags python.capture-output ARGS <testing.arg> ;
rule capture-output ( target : sources * : properties * )
{
    # Setup up proper DLL search path.
    # Here, $(sources[1]) is python module and $(sources[2]) is
    # DLL. Only $(sources[1]) is passed to testing.capture-output,
    # so RUN_PATH variable on $(sources[2]) is not consulted. Move it
    # over explicitly.
    RUN_PATH on $(sources[1]) = [ on $(sources[2]) return $(RUN_PATH) ] ;
    PYTHONPATH = [ on $(sources[2]) return $(LOCATE) ] ;
    # After test is run, we remove the Python module, but not the Python
    # script.
    testing.capture-output $(target) : $(sources[1]) : $(properties) 
      : $(sources[2]) ;
    local c = [ common.prepend-path-variable-command PYTHONPATH : $(PYTHONPATH) ] ;
    LAUNCHER on $(target) = $(c) [ on $(target) return $(PYTHON) ] ;
}

rule bpl-test ( name : sources * : requirements * )
{        
    sources ?= $(name).py $(name).cpp ;
    return [ testing.make-test 
        run-pyd : $(sources) /boost/python//boost_python
          : $(requirements) : $(name) ] ;
}

IMPORT $(__name__) : bpl-test : : bpl-test ;
  
  
