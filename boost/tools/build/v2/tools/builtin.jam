#  Copyright (C) Vladimir Prus 2002. Permission to copy, use, modify, sell and
#  distribute this software is granted provided this copyright notice appears in
#  all copies. This software is provided "as is" without express or implied
#  warranty, and with no claim as to its suitability for any purpose.

#  Defines standard features and rules.

import class : class new ;

import feature : feature compose ;
import type ;
import scanner ;
import generators ;
import regex ;
import virtual-target ;

feature toolset : gcc : implicit propagated ;
feature shared : false true : propagated ;
feature optimization : off on : propagated ;
feature threading : single multi : link-incompatible propagated ;
feature rtti : on off : link-incompatible propagated ;
feature debug-symbols : on off : propagated ;
feature define : : free ;
feature "include" : : free ;

feature variant : debug release : implicit composite propagated ;
compose <variant>debug : <optimization>off <rtti>on <debug-symbols>on ;
compose <variant>release : <optimization>on <rtti>on <debug-symbols>off ;

type.register EXE : : : main ;
type.register LIB : : : main ;
type.register STATIC-LIB : a : LIB : main ;
type.register SHARED-LIB : so : LIB : main ;

type.register CPP : cpp cxx ;

rule c-scanner ( includes * )
{
    scanner.__init__ ;
    self.includes = $(includes) ;

    rule pattern ( )
    {
        return "#include[ ]*(<(.*)>|\"(.*)\")" ;
    }

    rule process ( target : matches * )
    {
        ECHO "c-scanner: processing target" $(target) with $(matches) ;
    }        
}

class c-scanner : scanner ;
scanner.register c-scanner : include ;

type.set-scanner CPP : c-scanner ;


type.register H : h ;
type.register C : c ;
type.register OBJ : o ;

rule lib-generator ( ) 
{
    composing-generator.__init__ lib-generator : unknown-source-type : LIB ;
    
    rule run ( project name ? : properties * : sources + )
    {
        local actual-type ;
        if <shared>true in $(properties)
        {
            actual-type = SHARED-LIB ;
        }
        else 
        {
            actual-type = STATIC-LIB ;
        }
        return [ generators.construct-dbg $(project) $(name) : $(actual-type) : $(properties)
          : $(sources) : allow-composing-generators ] ;
    }
}

class lib-generator : composing-generator ;

generators.register [ new lib-generator ] ;

rule compile-action ( targets + : sources * : action-name : properties * )
{
    action.__init__ $(targets) : $(sources) : $(action-name) : $(properties) ;
    
    rule adjust-properties ( properties * )
    {
        local dg = [ $(self.targets[1]).dg ] ;
        local target-paths = [ $(dg).all-target-directories ] ;    
        # Note that target-paths here are already relative to invocation
        # directory, and can be used as-is.
        
        return $(properties) $(target-paths:G=include) ;
    }    
}

class compile-action : action ;

rule C-compiling-generator ( id : source-types + : target-types + :
                             requirements * )
{
    generator.__init__ $(id) : $(source-types) : $(target-types) :
                       $(requirements) ;

    rule action-class ( )
    {
        return compile-action ;
    }
}

class C-compiling-generator : generator ;


rule register-c-compiler ( id : source-types + : target-types + :
                            requirements * )
{
    local g = [ new C-compiling-generator $(id) : $(source-types) 
                : $(target-types) : $(requirements) ] ;
    generators.register $(g) ;
}

# FIXME: this is ugly, should find a better way (we'd want client code to
# register all generators as "generator.some-rule", not with "some-module.some-rule".)
IMPORT $(__name__) : register-c-compiler : : generators.register-c-compiler ;






