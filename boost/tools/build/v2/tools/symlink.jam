#  Copyright (C) 2002, Rene Rivera. Permission to copy, use, modify, sell and
#  distribute this software is granted provided this copyright notice appears in
#  all copies. This software is provided "as is" without express or implied
#  warranty, and with no claim as to its suitability for any purpose.

# Defines the "symlink" special target. 'symlink' targets make symbolic links
# to the sources.

import numbers ;
import targets ;
import virtual-target ;
import class ;
import property ;
import modules ;
import os ;

count = 0 ;

# The class representing "symlink" targets.
#
rule symlink-targets (
    project
    : targets *
    : sources *
    )
{
    # Generate a fake name for now. Need unnamed targets eventually.
    local c = [ modules.peek symlink : count ] ;
    modules.poke symlink : count : [ numbers.increment $(c) ] ;
    local fake-name = symlink#$(c) ;
    
    basic-target.__init__ $(fake-name) : $(project) : $(sources) ;
    
    # Remember the targets to map the sources onto. Pad or truncate
    # to fit the sources given.
    self.targets = ;
    for local source in $(sources)
    {
        if $(targets)
        {
            self.targets += $(targets[1]) ;
            targets = $(targets[2-]) ;
        }
        else
        {
            self.targets += $(source) ;
        }
    }
    
    # The virtual targets corresponding to the given targets.
    self.virtual-targets = ;
    
    rule construct ( source-targets * : properties * )
    {
        local i = 1 ;
        for local t in $(source-targets)
        {
            local s = $(self.targets[$(i)]) ;
            local vt = [ class.new file-target $(s:D=) : [ $(t).type ] : $(self.project) ] ;
            $(vt).action [ class.new action $(vt) : $(t) : symlink.ln ] ;
                      
            # Place the symlink in the directory relative to the project
            # location, instead of placing it in the build directory.
            $(vt).set-path [ project.path-relative-to-project-location 
                $(s:D) $(self.project) ] ;
                        
            self.virtual-targets += $(vt) ;
            i = [ numbers.increment $(i) ] ;
        }
        return $(self.virtual-targets) ;
    }
}
class.class symlink-targets : basic-target ;

# Creates a symbolic link from a set of targets to a set of sources.
# The targets and sources map one to one. The symlinks generated are
# limited to be the ones given as the sources. That is, the targets
# are either padded or trimmed to equate to the sources. The padding
# is done with the name of the corresponding source. For example::
#
#     symlink : one two ;
#
# Is equal to::
#
#     symlink one two : one two ;
#
# Names for symlink are relative to the project location. They cannot
# include ".." path components.
rule symlink (
    targets *
    : sources *
    )
{
    local project = [ CALLER_MODULE ] ;
    
    return [ targets.main-target-alternative
        [ class.new symlink-targets $(project) : $(targets) : $(sources) ] ] ;
}

rule ln
{
    local os ;
    if [ modules.peek : UNIX ] { os = UNIX ; }
    else { os ?= [ os.name ] ; }
    # Remember the path from directory where symlink will create back
    # to current dir, so that we can translate paths of the targets
    # we're symlinking to   
    # Peek on LOCATE to find the directory for link
    local target-directory = [ on $(<) return $(LOCATE) ] ;
    PATH_TO_TOP on $(<) = [ path.native [ path.reverse [ path.make $(target-directory) ] ] ] ;  
    ln-$(os) $(<) : $(>) ;
}

actions ln-UNIX
{
    ln -s '$(PATH_TO_TOP)/$(>)' '$(<)'
}

IMPORT $(__name__) : symlink : : symlink ;
