<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN"
  "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">

  <chapter id="bbv2.advanced">
    <title>User documentation</title>

  <para>This section will provide the information necessary to create your own
  projects using Boost.Build. The information provided here is relatively
  high-level, and <link linkend="bbv2.reference">detailed reference</link> as
  well as the on-line help system must be used to obtain
  low-level documentation (see the <link linkend=
  "bbv2.reference.init.options.help">help option</link>).</para>

  <para>The Boost.Build actually consists of two parts - Boost.Jam, which is a
  build engine with its own interpreted language, and Boost.Build itself,
  implemented in Boost.Jam's language. The chain of event which happen when
  you type "bjam" on the command is:
      <orderedlist>
        <listitem>
          <para>Boost.Jam tries to find Boost.Build and loads the top-level
          module. The exact process is described in the <link
          linkend="bbv2.reference.init">section on
          initialization</link></para>
        </listitem>
        <listitem>
          <para>Boost.Build top-level module loads user-defined configuration
          files, "user-config.jam" and "site-config.jam", which define
          available toolsets.</para>
        </listitem>
        <listitem>
          <para>The Jamfile in the current directory is read. That in turn
          might cause reading of further Jamfiles. As a result, a tree of
          projects is created, with targets inside projects.</para>
        </listitem>
        <listitem>
          <para>Finally, using build request specified on the command line,
          Boost.Build decides which targets should be built, and how. That
          information is passed back to Boost.Jam, which takes care of
          actually running commands.</para>
        </listitem>        
      </orderedlist>
    </para>

    <para>So, to be able to successfully use Boost.Build, you'd need to know only
      three things:
      <itemizedlist>
        <listitem>
          <para><link linkend="bbv2.advanced.configuration">
              How to configure Boost.Build</link></para>
        </listitem>
        <listitem>
          <para><link linkend="bbv2.advanced.jamfiles">
              How to write Jamfiles</link></para>
        </listitem>
        <listitem>
          <para><link linkend="bbv2.advanced.build_process">
              How the build process works</link></para>
        </listitem>
      </itemizedlist>
    </para>
    

  <section id="bbv2.advanced.configuration">
    <title>Configuration</title>

    <para>The Boost.Build configuration is specified in the file
    "user-config.jam". You can edit the one which comes with Boost.Build, or
    create a copy in your home directory and edit that. (See the <link
    linkend="bbv2.reference.init.config">reference</link> for the exact search
    paths.) The primary function of that file is to declarate which compilers
    and other tools are available. The simplest syntax to configure a tool is:
<programlisting>
using &lt;tool-name&gt; ;        
</programlisting>
      The "using" rule is given a name of tool, and will make that tool
      available to Boost.Build. For example, "using gcc ;" will make available
      the gcc compiler.      
    </para>

    <para>
      Since nothing but tool name is specified, Boost.Build will pick some
      default settings -- for example will use gcc found in path, or look in
      some known installation locations. For ordinary users, this is quite
      fine. In case you have several version of a compiler, or it's located in
      some unusual location, or you need to tweak the configuration, you'd
      need to pass additional parameters to the "using" rule. Generally, 
      for every tool module, the parameters differ, and you can obtain the documentaiton
      by running
<programlisting>
bjam --help &lt;tool-name&gt;.init         
</programlisting>
      on the command line. However, for all compilers the meaning of the first
      three parameters is the same: version, invocation command and options.
    </para>

    <para>The "version" parameter identifies the compiler, in case you have
    several. It can have any form you like, but it's recommended that you use
    a numeric identifier, like &quot;7.1&quot;. The "invocation command"
    parameter is the command which must be executed to run the compiler. This
    might be just compiler name, or a name with a path in it. Here are some
    examples. 
    </para>
      
    <para>To configure a compiler installed in non-standard location and not
    present in path, you can do the following:
<programlisting>
using msvc : : Z:/Programs/Microsoft Visual Studio/vc98/bin/cl.exe ;
</programlisting>
    </para>

    <para>To configure several versions of a compiler, the following can be used.
<programlisting>
using gcc : 3.3 ;
using gcc : 3.4 : g++-3.4 ;
using gcc : 3.2 : g++-3.2 ;
</programlisting>
        Note that in the first call to "using", the compiler found in path
      will be used, and there's no need to explicitly specify the command.
    </para>

    <para>As shown above, both "version" and "invocation command" parameters
      are optional, but there's an important restriction: if you configure the
      same compiler more then once, you must pass the "version" parameter
      every time. For example, the following is not allowed:
<programlisting>
using gcc ;
using gcc : 3.4 : g++-3.4 ;
</programlisting>
      because the first "using" does not specify the version. 
    </para>

    <para>The <code>options</code> parameter is used to fine-tune the
      configuration. All compilers allow to pass four option, intentionally
      similiar in spelling to builtin features: <code>cflags</code>,
      <code>cxxflags</code>, <code>compileflags</code> and
      <code>linkflags</code>. They specify additional options which will be
      always passed to the corresponding tools. The <code>cflags</code> option
      applies only to the C compiler, the <code>cxxflags</code> option applies
      only to the C++ compiler and the <code>compileflags</code> options
      applies to both. For example, to use 64 bit mode with gcc you can use:
<programlisting>
using gcc : 3.4 : : &lt;compileflags&gt;-m64 &lt;linkflags&gt;-m64 ;
</programlisting>
    </para>
                
    </section>

  <section id="bbv2.advanced.jamfiles">
    <title>Writing Jamfiles</title>

    <section id="bbv2.advanced.overview">
      <title>Overview</title>

      <para>Jamfiles are the thing which is most important to the user,
      bacause they declare the targets which should be build. Jamfiles are
      also used for organizing targets -- each Jamfile is a separate project,
      which can be build independently from the other projects.</para>

      <para>Jamfile mostly contain calls to Boost.Build functions, which do
        all the work, specifically:
        <itemizedlist>
          <listitem>
            <para><link linkend="bbv2.advanced.targets">declare main
                targets</link></para>
          </listitem>
          <listitem>
            <para><link
            linkend="bbv2.advanced.projects">define
            project properties</link></para>
          </listitem>
          <listitem>
            <para><link linkend="bbv2.advanced.other-rules">do various other
            things</link></para>            
          </listitem>
        </itemizedlist>
      </para>

      <para>In addition to Jamfiles, Boost.Build has another user-editable
        file, project-root.jam, which is mostly useful to declare constants
        global to all the projects. It is described in more detail <link
        linkend="bbv2.advanced.project-root">below</link>.
      </para>

<!--
      <para>The most fundemental entity in Boost.Build is <emphasis>main
          target</emphasis>. This is object that user want to construct from
        sources and keep up to date with regard to those sources. Typical
        examples of main targets are executable files and libraries.</para>
      
      <para>Main targets are grouped in <emphasis>projects</emphasis>. Their main
        purpose is organization: related targets placed in one project,
        can then be built together, or share some definitions.</para>
      
      <para>Main targets and projects are created as the result of reading
        one or several Jamfiles. Each Jamfile is a file written in
        Boost.Jam interpreted language, and typically contains calls to
        functions provided by Boost.Build, which create main targets of
        needed type, declare project attributes and access other
        projects. The full list of functions provided by Boost.Build is
        described <link linkend="bbv2.advanced.builtins">below</link>.
        Of course, user can create his own functions, or it can directly
        access Boost.Build internals from Jamfile, if builtin facilities are
        not sufficient.</para>

  <para>Each main target, or project can be built in a number of ways,
  say with optimization or without. We'll call such entities
  "metatargets". To make Boost.Build produce any real targets, user
  issues <link linkend="bbv2.reference.buildreq">build request</link>,
  which specifies metatargets to be built, and properties to be
  used.</para>

  <para>The <emphasis>properties</emphasis> are just (name,value) pairs that
  describe various aspects of constructed objects, for example:</para>
  <programlisting>
&lt;optimization&gt;full &lt;inlining&gt;off
</programlisting>

  <para>Given the built request, Boost.Build figures out the targets
  needed for requested metatargets with requested properties, how
  they can be created, and whether exising files can be reused. It
  finally issues command to create needed files, automatically
  converting properties into appropricate command line options.</para>
-->
    </section>

<!--
    <section id="bbv2.advanced.roadmap">
      <title>Your first project and roadmap</title>


  <para>Creating your first project requires three steps:</para>

  <orderedlist>
    <listitem><simpara>Create an empty file called "Jamfile"</simpara></listitem>

    <listitem>
      <simpara>
        Create an empty file called "project-root.jam"
      </simpara>
    </listitem>

    <listitem>
      <para>Either set your <envar>BOOST_BUILD_PATH</envar> environment
    variant to Boost.Build root, or create a "boost-build.jam" file
    with the following content:

<programlisting>
boost-build /path/to/boost.build ;
</programlisting>

      </para>
    </listitem>
  </orderedlist>

  <para>After that, you can run the "bjam" command in the directory
  where you've created the files. Surely, it won't do anything, but
  it will run without error, at least. Your next steps might
  be:</para>

  <orderedlist>
    <listitem>
      <simpara>
        Adding new main targets to the "Jamfile" file. The basic
    syntax for declaring a main target is described <link linkend=
    "bbv2.advanced.targets">below</link>, and all builtin functions for
    declaring main targets are <link linkend=
    "bbv2.advanced.builtins.targets">listed</link>.
      </simpara>
    </listitem>

    <listitem>
      <simpara>
        Creating subprojects. Create a directory, put new Jamfile
    there, and move some main targets to that Jamfile, or declare
    new ones. The <link linkend="bbv2.advanced.projects">projects
    reference</link> will help with this part.
      </simpara>
    </listitem>

    <listitem>
      <simpara>
        Customizing Boost.Build for your needs. You might have
    additional tools you want to run, or just want different
    extension for some file. The <link linkend="bbv2.extending">extender manual</ulink> is waiting for
    you.
      </simpara>
    </listitem>
  </orderedlist>

    </section>
-->
    <section id="bbv2.advanced.targets">
      <title>Main targets</title>

      <para id="bbv2.advanced.targets.main">
        <emphasis>Main target</emphasis> is a user-defined named
        entity which can be build, for example a named executable file.
        Declaring a main target is usually done using one of <link linkend=
          "bbv2.advanced.builtins.targets">main target functions</link>.  The
        user can also declare <link linkend="bbv2.extending.rules"> custom
        main target function</link>.</para>
      
      <para>Most main targets rules in Boost.Build use similiar
        syntax:</para>

<anchor id="bbv2.main-target-rule-syntax"/>
<programlisting>
function-name main-target-name 
    : sources 
    : requirements 
    : default-build 
    : usage-requirements 
    ;
</programlisting>

      <itemizedlist>
        <listitem>
          <simpara>
            "main-target-name" is the name used to request the target
            on command line and to use it from other main targets. Main
            target name may contain alphanumeric characters and symbols '-'
            and '_';
          </simpara>
        </listitem>
        
        <listitem>
          <simpara>
            "sources" is the list of source files and other main
            targets that must be combined. 
          </simpara>
        </listitem>
        
        <listitem>
          <simpara>
            "requirements" is the list of properties that must always
            be present when this main target is built.
          </simpara>
        </listitem>
        
        <listitem>
          <simpara>
            "default-build" is the list of properties that will be used
            unless some other value of the same feature is already
            specified.
          </simpara>
        </listitem>
        
        <listitem>
          <simpara>
            "usage-requirements" is the list of properties that will be
            propagated to all main targets that use this one, i.e. to all
            dependents.
          </simpara>
        </listitem>
      </itemizedlist>

      <para>Note that the actual requirements, default-build and
        usage-requirements attributes for a target are obtained by combining
        the explicitly specified one with those specified for the project
        where a target is declared.
      </para>
      <para>          
        Some main target rules have shorter list of parameters, and
        you should consult their documentation for details.
      </para>
      
      <para>The list of sources specifies what should be processed to get
        the resulting targets. Most of the time, it's just a list of
        files. Sometimes, you'd want to use all files with the same
        extension as sources, in which case you can use the "glob"
        rule. Here are two examples:
<programlisting>
exe a : a.cpp ;
exe b : [ glob *.cpp ] ;
</programlisting>
        Unless you specify a files with absolute path, the name is
        considered relative to the source directory -- which is typically
        the same as directory when Jamfile is located, but can be changed as
        described <link linkend=
          "bbv2.advanced.projects.attributes.projectrule">here</link>
      </para>
      
      <para>
        The list of sources can also reference other main targets. The
        targets in the same project can be referred by using the name, and
        targets in other project need to specify directory or a symbolic
        name of the other project. For example:
<programlisting>
lib helper : helper.cpp ;
exe a : a.cpp helper ;
exe b : b.cpp ..//utils ;
exe c : c.cpp /boost/program_options//program_opions ;
</programlisting>
        The first exe uses the library defined in the same project. The
        second one uses some target (most likely library) defined by Jamfile
        one level higher. Finally, the third target uses some <ulink
          url="http://boost.org">C++ Boost</ulink> library, using the
        symbolic name to refer to it. More information about it can be found
        in <link linkend="bbv2.tutorial.libs">tutorial</link> and in 
        <link linkend="bbv2.reference.ids">target id reference</link>.          
      </para>

<!--
      <section id="bbv2.advanced.targets.requirements">        
        <title>Requirements and usage-requirements</title>
        
        <para>The requirements argument specify what properties are absolutely
        necessary for this main target. 
      </section>
-->
      <para>Requirements are the properties that should always be present when
        building a target. Typically, they are includes and defines:
<programlisting>
exe hello : hello.cpp : &lt;include&gt;/opt/boost &lt;define&gt;MY_DEBUG ;
</programlisting>
        In special circumstances, other properties can be used, for example if
        a library does not work if it's shared, or a file can't be compiled
        with optimization due to a compiler bug, one can use
<programlisting>
lib util : util.cpp : &lt;link&gt;static ;
obj main : main.cpp : &lt;optimization&gt;off ;
</programlisting>                
      </para>

      <para>Sometimes, requirements are necessary only for a specific
        compiler, or build variant. The 
        <link linkend="bbv2.reference.variants.propcond">conditional
        properties</link> can be used in that case:
<programlisting>
lib util : util.cpp : &lt;toolset&gt;msvc:&lt;link&gt;static ;
</programlisting>
        In means when whenever <code>&lt;toolset&gt;msvc</code> property is
        in build properties, the <code>&lt;link&gt;static</code> property will
        be included as well. The conditional requirements can be "chained":
<programlisting>
lib util : util.cpp : &lt;toolset&gt;msvc:&lt;link&gt;static 
                      &lt;link&gt;static:&lt;define&gt;STATIC_LINK ;
</programlisting>
        will set of static link and the <code>STATIC_LINK</code> define on the
        <code>msvc</code> toolset.
      </para>

      <para>The default-build attribute is
        a set of properties which should be used if build request does not
        specify a value. For example:
<programlisting>
exe hello : hello.cpp : : &lt;threading&gt;multi ;
</programlisting>
        would build the target in multi-threaded mode, unless the user
        explicitly requests single-threaded version. The difference between
        requirements and default-build is that requirements cannot be
        overriden in any way.
      </para>

      <para>A target of the same name can be declared several times. In that
        case is declaration is called an
        <firstterm>alternative</firstterm>. When the target is build, one of
        the alternatives will be selected and use. Alternatives need not be
        defined by the same main target rule. The following is OK:
<programlisting>
lib helpers : helpers.hpp ;
alias helpers : helpers.lib : &lt;toolset&gt;msvc ;
</programlisting>
      </para>

      <para>Building of the same main target can differ greatly from
        platform to platform. For example, you might have different list
        of sources for different compilers, or different options for those
        compilers. Two approaches to this are explained in the 
        <link linkend="bbv2.tutorial.conditions">tutorial</link>.
      </para>

      <para>Sometimes a main target is really needed only by some other main
        target. For example, a rule that declares a test-suite uses a main
        target that represent test, but those main targets are rarely needed
        by themself.</para>

      <para>It is possible to declare target inline, i.e. the "sources"
        parameter may include call to other main rules. For example:</para>

<programlisting>
exe hello : hello.cpp 
    [ obj helpers : helpers.cpp : &lt;optimization&gt;off ] ;
</programlisting>

      <para>
        Will cause "helpers.cpp" to be always compiled without
        optimization. It's possible to request main targets declared
        inline, but since they are considered local, they are renamed to
        "parent-main-target_name..main-target-name". In the example above,
        to build only helpers, one should run "bjam hello..helpers".
      </para>

    </section>

    <section id="bbv2.advanced.projects">
      <title>Projects</title>

      <para>As mentioned before, targets are grouped into project, and each
        Jamfile is a separate project. Projects are useful because it allows
        to group related targets together, define properties common to all
        those targets, and assign a symbolic name to the project, allowing to
        easily refer to the targets in the project. Two last goals are
        accompished with the "project" rule.
      </para>

      <para>The rule has this syntax
<programlisting>
project id : &lt;attributes&gt; ;
</programlisting>
        Here, attributes is a sequence of (attribute-name,
        attribute-value) pairs. The list of attribute names along with its
        handling is also shown in the table below. For example, it is
        possible to write:
<programlisting>
project tennis 
    : requirements &lt;threading&gt;multi 
    : default-build release
    ;
</programlisting>   
      </para>

      <para>The possible attributes are listed below.</para>

      <para><emphasis>Project id</emphasis> is a short way to denote a project, as
        opposed to the Jamfile's pathname. It is a hierarchical path,
        unrelated to filesystem, such as "boost/thread". <link linkend=
          "bbv2.reference.ids">Target references</link> make use of project ids to
        specify a target.</para>

      <para><emphasis>Source location</emphasis> specifies the directory where sources
        for the project are located.</para>

      <para><emphasis>Project requirements</emphasis> are requirements that apply to
        all the targets in the projects as well as all subprojects.</para>

      <para><emphasis>Default build</emphasis> is the build request that should be
        used when no build request is specified explicitly.</para>

      <para id="bbv2.advanced.projects.attributes.projectrule">
        The default values for those attributes are
        given in the table below.

        <table>
          <title/>
          <tgroup cols="4">
            <thead>
              <row>
                <entry>Attribute</entry>
                
                <entry>Name for the 'project' rule</entry>
                
                <entry>Default value</entry>
                
                <entry>Handling by the 'project' rule</entry>
              </row>
            </thead>
            
            <tbody>
              
              <row>
                <entry>Project id</entry>
                
                <entry>none</entry>
                
                <entry>none</entry>
                
                <entry>Assigned from the first parameter of the 'project' rule.
                  It is assumed to denote absolute project id.</entry>
              </row>
              
              <row>
                <entry>Source location</entry>
                
                <entry><literal>source-location</literal></entry>
                
                <entry>The location of jamfile for the project</entry>
                
                <entry>Sets to the passed value</entry>
              </row>
              
              <row>
                <entry>Requirements</entry>
                
                <entry><literal>requirements</literal></entry>
                
                <entry>The parent's requirements</entry>
                
                <entry>The parent's requirements are refined with the passed
                  requirement and the result is used as the project
                  requirements.</entry>
              </row>
              
              <row>
                <entry>Default build</entry>
                
                <entry><literal>default-build</literal></entry>
                
                <entry>none</entry>
                
                <entry>Sets to the passed value</entry>
              </row>
              
              <row>
                <entry>Build directory</entry>
                
                <entry><literal>build-dir</literal></entry>
                
                <entry>If parent has a build dir set, the value of it, joined
                  with the relative path from parent to the current project.
                  Otherwise, empty</entry>
                
                <entry>Sets to the passed value, interpreted as relative to the
                  project's location.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        </para>
      </section>

    <section id="bbv2.advanced.other-rules">
      <title>Additional Jamfile rules</title>

      <para>There's a number of other helper rules which can be used in
      Jamfile, described in the following table.</para>

      <table>
        <title/>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Rule</entry>
              
              <entry>Semantic</entry>
            </row>
          </thead>
          
          <tbody>
            <row>
              <entry><link linkend=
                  "bbv2.advanced.projects.attributes.projectrule">project</link>
              </entry>
              
              <entry>Define project attributes.</entry>
            </row>
            
            <row>
              <entry><link linkend=
                  "bbv2.advanced.projects.relationships.useprojectrule">use-project</link></entry>
              
              <entry>Make another project known.</entry>
            </row>
            
            <row>
              <entry><link linkend=
                  "bbv2.advanced.projects.relationships.buildprojectrule">build-project</link></entry>
              
              <entry>Build another project when this one is built.</entry>
            </row>
            
            <row>
              <entry><link linkend=
                  "bbv2.reference.buildprocess.explict">explicit</link></entry>
              
              <entry>States that the target should be built only by explicit
                request.</entry>
            </row>
            
            <row>
              <entry>glob</entry>
              
              <entry>Takes a list of wildcards, and returns the list of files
                which match any of the wildcards.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
      
    <section id="bbv2.advanced.project-root">
      <para>Each project is also associated with <emphasis>project root</emphasis>.
        That's a root for a tree of projects, which specifies some global
        properties.</para>
      
        <title>Project root</title>

        <para>
          Project root for a projects is the nearest parent directory
          which contains a file called
          <filename>project-root.jam</filename>. That file defines
          certain properties which apply to all projects under project
          root. It can:

        <itemizedlist>
          <listitem>
            <simpara>
              configure toolsets, via call to <literal>toolset.using</literal>
            </simpara>
          </listitem>
          
          <listitem>
            <simpara>
              refer to other projects, via the <literal>use-project</literal>
              rule
            </simpara>
          </listitem>
          
          <listitem>
            <simpara>
              declare constants, via the <literal>constant</literal> and
              <literal>path-constant</literal> rules.
            </simpara>
          </listitem>
        </itemizedlist>

      </para>

      <para>To facilitate declaration of simple projects, Jamfile and
        project-root can be merged together. To achieve this effect, the
        project root file should call the <literal>project</literal> rule. The
        semantic is precisely the same as if the call was made in
        Jamfile, except that project-root.jam will start to serve as
        Jamfile. The Jamfile in the directory of project-root.jam will be
        ignored, and project-root.jam will be able to declare main
        targets as usual.</para>
      
    </section>

<!--
      <section id="bbv2.advanced.projects.relationships">
        <title>Project relationship</title>

  <para>There are three kinds of project relationships.</para>

  <para>First is parent-child. This relationship is established
  implicitly: parent directories of a project are searched, and the
  first found Jamfile is assumed to define the parent project. The
  parent-child relationship affects only attribute values for the
  child project.</para>

  <para id="bbv2.advanced.projects.relationships.buildprojectrule">
  Second is build relationship. Some
  project may request to recursively build other projects. Those
  project need not be child projects. The <literal>build-project</literal>
  rule is used for that:</para>
  <programlisting>
    build-project src ;   
</programlisting>

  <para id="bbv2.advanced.projects.relationships.useprojectrule">
  The third kind is the 'use'
  relationship. In means that one project uses targets from
  another. It is possible to just refer to target in other projects
  using target id. However, if target id uses project id, it is
  required that the project id is known. The
  <literal>use-project</literal>
  rule is employed to guarantee that.
  </para>

<programlisting>
use-project ( id : location )
</programlisting>

        <para>
It loads the project at the specified location, which makes
its project id available in the project which invokes the rule. It
is required that the <literal>id</literal> parameter passed to the
<literal>use-project</literal> rule be equal to the id that the loaded
project declared. At this moment, the <literal>id</literal> paremeter
should be absolute project id.
        </para>
      </section>
    </section>

-->
       
  </section>
  
  <section id="bbv2.advanced.build_process">
    <title>Build process</title>

    <para>When you've described your targets, you want Boost.Build to run the
      right tools and create the needed targets. This section will describe
      two things: how you specify what to build, and how the main targets are
      actually constructed.
    </para>

    <para>The most important thing to note is that in Boost.Build, unlike
      other build tools, the targets you declare do not correspond to specific
      files. What you declare in Jamfiles is more like "metatarget". Depending
      on the properties that you specify on the command line, each
      "metatarget" will produce a set of real targets corresponding to the
      requested properties. It is quite possible that the same metatarget is
      build several times with different properties, and will, of course,
      produce different files.
    </para>
    <tip>
      <para>
        This means that for Boost.Build, you cannot directly obtain build
        variant from Jamfile. There could be several variants requested by the
        user, and each target can be build with different properties. 
      </para>
    </tip>

    <section>
      <title>Build request</title>

      <para>
        The command line specifies which targets to build and with what
        properties. For example:
<programlisting>
bjam app1 lib1//lib1 toolset=gcc variant=debug optimization=full
</programlisting>
        would build two targets, "app1" and "lib1//lib1" with the specified
        properties. You can refer to any targets, using 
        <link linkend="bbv2.reference.ids">target id</link> and specify arbitrary
        properties. Some of the properties are very common, and for them the name
        of the property can be omitted. For example, the above can be written as:
<programlisting>
bjam app1 lib1//lib1 gcc debug optimization=full
</programlisting>
        The complete syntax which has some additional shortcuts if described <link
          linkend="bbv2.reference.commandline">here</link>.
      </para>
    </section>

    <section><title>Building a main target</title>

      <para>When you request, directly or indirectly, a build of a main target
        with specific requirements, the following steps are made. Some brief
        explanation is provided, and more detailes are given in the <link
        linkend="bbv2.reference.buildprocess">reference</link>.
        <orderedlist>
          
          <listitem><para>Applying default build. If the default-build
          property of a target specifies a value of a feature which is not
          present in the build request, that value is added.</para></listitem>
          
          <listitem><para>Selecting the main target alternative to use. For
              each alternative we look how many properties are present both in
              alternative's requirements, and in build request. The
              alternative with large number of matching properties is selected.
            </para></listitem>
          
          <listitem><para>Determining "common" properties. The build request
              is <link linkend="bbv2.reference.variants.proprefine">refined</link>
              with target's requirements. The conditional properties in
              requirements are handled as well. Finally, default values of
              features are added.
            </para></listitem>
          
          <listitem><para>Building targets referred by the sources list and
              dependency properties. The list of sources and the properties
              can refer to other target using <link
              linkend="bbv2.reference.ids">target references</link>. For each
              reference, we take all <link
              linkend="bbv2.reference.features.attributes.propagated">propagated</link>
              properties, refine them by explicit properties specified in the
              target reference, and pass the resulting properties as build
              request to the other target.              
            </para></listitem>
          
          <listitem><para>Adding the usage requirements produces when building
              dependencies to the "common" properties. When dependencies are
              built in the previous step, they return both the set of created
              "real" targets, and usage requirements. The usage requirements
              are added to the common properties and the resulting property
              set will be used for building the current target.              
            </para></listitem>
          
          <listitem><para>Building the target using generators. To convert the
              sources to the desired type, Boost.Build uses "generators" ---
              objects which correspond to tools like compilers and
              linkers. Each generator declares what type of targets in can
              produce and what type of sources it requires. Using this
              information, Boost.Build determines which generators must be run
              to produce a specific target from specific sources. When
              generators are run, they return the "real" targets.
            </para></listitem>
          
          <listitem><para>Computing the usage requirements to be returned. The
          conditional properties in usage requirements are expanded and the
          result is returned.</para></listitem>
        </orderedlist>        
      </para>
    </section>

    <section><title>Building a project</title>

      <para>Often, user request a build of a complete project, not just one
        main target. In fact, invoking <command>bjam</command> without
        parameters builds the project defined in the current directory.</para>

      <para>When a project is build, the build request is passed without
        modification to all main targets in that project. It's is possible to
        prevent implicit building of a target in a project with the
        <code>explicit</code> rule:
<programlisting>
explicit hello_test ;
</programlisting>
        would cause the <code>hello_test</code> target to be built only if
        explicitly requested by the user or by some other target.
      </para>

      <para>The Jamfile for a project can include a number of
      <code>build-project</code> rule calls, that specify additional projects
      to be built.
      </para>

    </section>

  </section>

  <section id="bbv2.advanced.builtins.targets">
    <title>Builtin target types</title>

    <section>
      <title>Programs</title>

      <para>Programs are created using the <code>exe</code> rule, which
        follows the <link linkend="bbv2.main-target-rule-syntax">common
          syntax</link>. For example:
<programlisting>
exe hello : hello.cpp some_library.lib /some_project//library 
          : &lt;threading&gt;multi 
          ;
</programlisting>
        This will create an executable file from the sources -- in this case,
        one C++ file, one library file present in the same directory, and
        another library which is created by Boost.Build. Generally, sources
        can include C and C++ files, object files and libraries. Boost.Build
        will automatically try to convert targets of other types.
      </para>

      <tip>
        <para>         
          On Windows, if an application uses dynamic libraries, and both
          the application and the libraries are built by Boost.Build, its not
          possible to immediately run the application, because the
          <literal>PATH</literal> environment variable should include the path
          to the libraries. It means you have to either add the paths
          manually, or place the application and the libraries to the same
          directory, for example using the <link linkend="bbv2.builtins.stage">
            stage</link> rule.
      </para>
      </tip>
    </section>

    <section>
      <title>Libraries</title>

      <para>Libraries are created using the <code>lib</code> rule, which
        follows the <link linkend="bbv2.main-target-rule-syntax">common
          syntax</link>. For example:
<programlisting>
lib helpers : helpers.cpp : &lt;include&gt;boost : : &lt;include&gt;. ;
</programlisting>
      </para>

      <para>In the most common case, the <code>lib</code> creates a library
        from the specified sources. Depending on the value of
        &lt;link&gt; feature the library will be either static or
        shared. There are two other cases. First is when the library is
        installed somewhere in compiler's search paths, and should be
        searched by the compiler (typically, using the <option>-l</option>
        option). The second case is where the library is available as a 
        prebuilt file and the full path is known.          
        </para>
      
      <para>
        The syntax for these case is given below:
<programlisting>
lib z : : &lt;name&gt;z &lt;search&gt;/home/ghost ;            
lib compress : : &lt;file&gt;/opt/libs/compress.a ;
</programlisting>
        The <code>name</code> property specifies the name which should be
        passed to the <option>-l</option> option, and the <code>file</code>
        property specifies the file location. The <code>search</code> feature
        specifies paths where the library should be searched. That feature can
        be specified several time, or can be omitted -- in which case only
        default compiler paths will be searched.
      </para>

      <para>The difference between using the <code>file</code> feature as
        opposed to the <code>name</code> name feature together with the
        <code>search</code> feature is that <code>file</code> is more
        precise. A specific file will be used. On the other hand, the
        <code>search</code> feature only adds a library path, and the
        <code>name</code> feature gives the basic name of the library. The
        search rules are specific to the linker. For example, given these
        definition:
<programlisting>
lib a : : &lt;variant&gt;release &lt;file&gt;/pool/release/a.so ;
lib a : : &lt;variant&gt;debug &lt;file&gt;/pool/debug/a.so ;
lib b : : &lt;variant&gt;release &lt;file&gt;/pool/release/b.so ;
lib b : : &lt;variant&gt;debug &lt;file&gt;/pool/debug/b.so ;
</programlisting>
        It's possible to use release version of <code>a</code> and debug
        version of <code>b</code>. Had we used the <code>name</code> and
        <code>search</code> features, the linker would always pick either
        release or debug versions.
      </para>
      
      <para>
        For convenience, the following syntax is allowed:
<programlisting>
lib z ;
lib gui db aux ;
</programlisting>
          and is does exactly the same as:
<programlisting>
lib z : : &lt;name&gt;z ;            
lib giu : : &lt;name&gt;gui ;            
lib db : : &lt;name&gt;db ;            
lib aux : : &lt;name&gt;aux ;            
</programlisting>
      </para>
          
      <para>When a library uses another library you should put that another
        library in the list of sources. This will do the right thing in all
        cases. For portability, you should specify library dependencies even
        for searched and prebuilt libraries, othewise, static linking on
        Unix won't work. For example:
<programlisting>
lib z ;
lib png : z : &lt;name&gt;png ;
</programlisting>
        </para>

      <note>
        <para>When a library (say, <code>a</code>), which has another
          library, (say, <code>b</code>) is linked dynamically, the <code>b</code>
          library will be incorporated in <code>a</code>. (If <code>b</code>
          is dynamic library as well, then <code>a</code> will only refer to
          it, and not include any extra code.) When the <code>a</code>
          library is linked statically, Boost.Build will assure that all
          executables which link to <code>a</code> will also link to
          <code>b</code>.
        </para>
      </note>
         
      <para>One feature of Boost.Build which is very important for libraries
        is usage requirements. For example, if you write:
<programlisting>
lib helpers : helpers.cpp : : : &lt;include&gt;. ;
</programlisting>
        then compiler include path for all targets which use
        <code>helpers</code> will contain the directory where the target is
        defined.path to "helpers.cpp". So, the user need only to add
        <code>helpers</code> to the list of sources, and don't bother about
        other requirements. This allows to greatly simplify Jamfiles.
      </para>

      <note>
        <para>If you don't want shared libraries to include all libraries
          which are specified in sources (especially statically linked ones),
          you'd need to use the following:
<programlisting>
lib b : a.cpp ;
lib a : a.cpp : &lt;use&gt;b : : &lt;library&gt;b ;
</programlisting>
          This specifies that <code>a</code> uses <code>b</code>, and causes
          all executables which link to <code>a</code> also link to
          <code>b</code>. In this case, even for shared linking, the
          <code>a</code> library won't even refer to <code>b</code>.
        </para>
      </note>
          
    </section>

    <section id="bbv2.builtins.alias">
      <title>Alias</title>

      <para>The <code>alias</code> rule follows the <link
          linkend="bbv2.main-target-rule-syntax">common syntax</link>. For
        example:
<programlisting>
alias core : im reader writer ;
</programlisting>
        will build the sources and return the generated source targets
        without modification. 
      </para>

      <para>
        The <code>alias</code> rule is a convenience tool. If you often build
        the same group of targets at the same time, you can define the alias
        to save typing.        
      </para>

      <para>
        Another use of the <code>alias</code> rule is to change build
        properties. For example, if you always want static linking for a
        specific C++ Boost library, you can write the following:
<programlisting>
alias boost_thread : /boost/thread//boost_thread : &lt;link&gt;static ;
</programlisting>
        and use only the <code>boost_thread</code> alias in your Jamfiles.
      </para>              

      <para>
        It is also allowed to specify usage requirements for the
        <code>alias</code> target. If you write the following:
<programlisting>
alias header_only_library : : : :  &lt;include&gt;/usr/include/header_only_library ; 
</programlisting>
        then using <code>header_only_library</code> in sources will only add an
        include path. Also note that when there are some sources, their usage
        requirements are propagated, too. For example:
<programlisting>
lib lib : lib.cpp : : : &lt;include&gt;. ;
alias lib_alias ;
exe main : main.cpp lib_alias ;
</programlisting>
        will compile <filename>main.cpp</filename> with the additional include.
      </para>
 
    </section>

    <section id="bbv2.builtins.stage">
      <title>Installing</title>

      <para>For installing the built target you should use the
        <code>stage</code> rule follows the <link
          linkend="bbv2.main-target-rule-syntax">common syntax</link>. For
        example:
<programlisting>
stage dist : hello helpers ;
</programlisting>
        will cause the targets <code>hello</code> and <code>helpers</code> to
        be moved to the <filename>dist</filename> directory. The directory can
        be changed with the <code>location</code> property:
<programlisting>
stage dist : hello helpers : &lt;location&gt;/usr/bin ;
</programlisting>
      </para>

      <para>
        Specifying the names of all libraries to install can be boring. The
        <code>stage</code> allows to specify only the top-level executable
        targets to install, and automatically install all dependencies:
<programlisting>
stage dist : hello 
           : &lt;traverse-dependencies&gt;on &lt;include-type&gt;EXE
             &lt;include-type&gt;LIB
           ;
</programlisting>
        will find all targets that <code>hello</code> depends on, and install
        all of the which are either executables or libraries.
      </para>
        
    </section>

    <section id="bbv2.builtins.testing">

      <title>Testing</title>

      <para>Boost.Build has convenient support for running unit tests. The
        simplest way is the <code>unit-test</code> rule, which follows the
        <link linkend="bbv2.main-target-rule-syntax">common syntax</link>. For
        example:
<programlisting>
unit-test helpers_test : helpers_test.cpp helpers ;
</programlisting>
      </para>

      <para>The <code>unit-test</code> rule behaves like the
        <code>exe</code> rule, but after the executable is created it is
        run. If the executable returns error, the build system will also
        return error and will try running the executable on the next
        invocation until it runs successfully. This behaviour ensures that you
        can't miss a unit test failure.
      </para>

      <para>There are rules for more elaborate testing: <code>compile</code>,
        <code>compile-fail</code>, <code>run</code> and
        <code>run-fail</code>. They are more suitable for automated testing, and
        are not covered here yet.
      </para>        
    </section>
    
  </section>
  
  <section id="bbv2.advanced.builtins.features">
    <title>Builtin features</title> 
        
    <variablelist>
      <varlistentry><term><literal>variant</literal></term>
        
        <listitem>
          <simpara>
            The feature which combines several low-level features in
            order to make building most common variants simple.
          </simpara>
          
          <para><emphasis role="bold">Allowed values:</emphasis> <literal>debug</literal>, <literal>release</literal>,
            <literal>profile</literal></para>
          
          <para>The value <literal>debug</literal> expands to</para>
          
          <programlisting>
            &lt;optimization&gt;off &lt;debug-symbols&gt;on &lt;inlining&gt;off &lt;runtime-debugging&gt;on
          </programlisting>
          
          <para>The value <literal>release</literal> expands to</para>
          
          <programlisting>
            &lt;optimization&gt;speed &lt;debug-symbols&gt;off &lt;inlining&gt;full &lt;runtime-debugging&gt;off
          </programlisting>
          
          <para>The value <literal>profile</literal> expands to the same as
            <literal>release</literal>, plus:</para>
          
          <programlisting>
            &lt;profiling&gt;on &lt;debug-symbols&gt;on
          </programlisting>
          
          <para><emphasis role="bold">Rationale:</emphasis> Runtime debugging is on in debug build
            to suit expectations of people used various IDEs. It's
            assumed other folks don't have any specific expectation in
            this point.</para>
        </listitem></varlistentry>
      
      <varlistentry id="bbv2.advanced.builtins.features.link">
        <term><literal>link</literal></term>
        
        <listitem>
          <simpara>
            Feature which controls how libraries are built.
          </simpara>
          
          <para><emphasis role="bold">Allowed values:</emphasis> <literal>shared</literal>,
            <literal>static</literal></para>
        </listitem></varlistentry>
      
      <varlistentry><term><literal>source</literal></term>
        
        <listitem>
          <simpara>
            Tthe &lt;source&gt;X feature has the same effect on building a target
            as putting X in the list of sources. The feature
            is sometimes more convenient: you can put &lt;source&gt;X in
            the requirements for a project and it will be linked to all
            executables.
          </simpara>
        </listitem>
      </varlistentry>
      
      <varlistentry><term><literal>library</literal></term>
        
        <listitem>
          <simpara>
            This feature is equivalent to the &lt;source&gt; feature, and exists
            for backward compatibility reasons.
          </simpara>
        </listitem>
      </varlistentry>
      
      
      <varlistentry><term><literal>use</literal></term>
        
        <listitem>
          <simpara>
            Causes the target referenced by the value of this feature
            to be constructed and adds it's usage requirements to build
            properties. The constructed targets are not used in any other
            way. The primary use case is when you use some library and want
            it's usage requirements (such as include paths) to be applied,
            but don't want to link to the library.
          </simpara>
        </listitem>
      </varlistentry>
      
      <varlistentry><term><literal>dll-path</literal></term>
        
        <listitem>
          <simpara>
            Specify an additional path where shared libraries should be
            searched where the executable or shared library is run. This
            feature only affect Unix compilers. Plase see the <link
            linkend="bbv2.faq.dll-path">FAQ entry</link> for details.
          </simpara>
        </listitem></varlistentry>
      
      <varlistentry><term><literal>hardcode-dll-paths</literal></term>
        
        <listitem>
          <simpara>
            Controls automatic generation of dll-path properties.
          </simpara>
          
          <para><emphasis role="bold">Allowed values:</emphasis>
            <literal>true</literal>, <literal>false</literal>.  This property
            is specific to Unix systems. If an executable is build with
            <code>&lt;hardcode-dll-paths&gt;true</code>, the generated binary
            will contain the list of all the paths to the used shared
            libraries. As the result, the executable can be run without
            changing system paths to shared libraries, or installing the
            libraries to system paths. This is very convenient during
            development. Plase see the <link
            linkend="bbv2.faq.dll-path">FAQ entry</link> for details.
          </para>
        </listitem></varlistentry>
    </variablelist>
  </section>

  <section id="bbv2.advanced.differences_to_v1">
    <title>Differences to Boost.Build V1</title>

    <para>While Boost.Build V2 is based on the same ideas as Boost.Build V1,
    some of the syntax was changed, and some new important features were
    added. This chapter describes most of the changes.</para>

    <section id="bbv2.advanced.differences_to_v1.configuration">
      <title>Configuration</title>
      
      <para>In V1, there were two methods to configure a toolset. One is to
      set some environment variable, or use "-s" command line option to set
      variable inside BJam. Another method was creating new toolset module,
      which would set the variables and then invoke basic toolset. Neither
      method is necessary now, the "using" rule provides a consistent way to
      initialize toolset, including several versions. See <link
      linkend="bbv2.advanced.configuration">section on configuraton</link> for
      details.
      </para>
      
    </section>

    <section id="bbv2.advanced.differences_to_v1.jamfiles">
      <title>Writing Jamfiles</title>

      <para>Probably one of the most important differences in V2 Jamfiles is
      the project requirements. In V1, if several targets have the same
      requirements (for example, common include path), it was necessary to
      manually write that requirements, or use a helper rule. In V2, the
      common properties can be specified with the "requirements" project
      attribute, as documented <link linkend="bbv2.advanced.projects">here</link>.
      </para>

      <para>The <link linkend="bbv2.tutorial.libs">usage requirements</link>
      is also important mechanism to simplify Jamfile. If a library requires
      all clients to use specific includes, or macros when compiling the
      code which depends on the library, this information can be cleanly
      represented.</para>

      <para>The difference between "lib" and "dll" targets in V1 is completely
      eliminated in V2. There's only one target -- "lib", which can create
      either static or shared library depending on the value of the 
        <link linkend="bbv2.advanced.builtins.features.link">&lt;link&gt;
      feature</link>. If your target should be only build in one variant, you
      can add &lt;link&gt;shared or &lt;link&gt;static to requirements.
      </para>

      <para>The syntax for referring to other targets was changed a bit. While
      in V1 one would use:
<programlisting>
exe a : a.cpp &lt;lib&gt;../foo/bar ;
</programlisting> 
        the V2 syntax is:
<programlisting>
exe a : a.cpp ../foo//bar ;
</programlisting>
        Note that you don't need to specify the type of other target, but the
        last element should be separated to double slash, to indicate that
        you're referring to target "bar" in project "../foo", and not to
        project "../foo/bar".
        </para>
      
                  
    </section>

    <section id="bbv2.advanced.differences_to_v1.build_process">
      <title>Build process</title>

      <para>The command line syntax in V2 is completely different. For example
<programlisting>
bjam -sTOOLS=msvc -sBUILD=release some_target
</programlisting>
        now becomes:
<programlisting>
bjam toolset=msvc variant=release some_target
</programlisting>
        or, using shortcuts, just:
<programlisting>
bjam msvc release some_target
</programlisting>
      See <link linkend="bbv2.reference.commandline">the reference</link> for
      complete description of the syntax.
      </para>

            
    </section>

  </section>
    

  </chapter>

<!--
     Local Variables:
     mode: xml
     sgml-indent-data: t     
     sgml-parent-document: ("userman.xml" "chapter")
     sgml-set-face: t
     End:
-->
