##############################################################
# Rules and actions that test Jam by invoking it recursively #
##############################################################

# Jam string : optional-expected-output
#
# Creates a fake target, always built, which succeeds in building if
# Invoking a Jamfile containing the given string succeeds. If optional-expected-output is
# supplied, creates another fake target which succeeds in building if
# optional-expected-output is in the Jam output.
#
# RETURNS: the target name of the Jam command.
#
rule Jam
{
    local jam-cmd = "$(<:G=jam_command)" ;
    
    NOTFILE "$(jam-cmd)" ;
    ALWAYS "$(jam-cmd)" ;
    DEPENDS all : "$(jam-cmd)" ;

    if ($NT)
    {
        redirect on $(jam-cmd) = "nul" ;
    }
    else if $(UNIX)
    {
        redirect on $(jam-cmd) = "/dev/null" ;
    }

    invoke-Jam "$(jam-cmd)" ;
    
    if $(>)
    {
        redirect on $(jam-cmd) = "scratch-output.txt" ;
        local output-target = "$(>:G=$(<))" ;
        NOTFILE "$(output-target)" ;
        ALWAYS "$(output-target)" ;
        DEPENDS all : "$(output-target)" ;
        Expect-in-output "$(output-target)" ;
    }
    return $(jam-cmd) ;
}

# Jam-fail string
rule Jam-fail
{
    FAIL_EXPECTED [ Jam $(<) : $(>) ] ;
}


# The temporary jamfile we write is called "temp.jam". If the user has set
# BOOST_BUILD_ROOT, it will be built there.
gBOOST_TEST_JAMFILE = temp.jam ;
LOCATE on gBOOST_TEST_JAMFILE ?= $(BOOST_BUILD_ROOT) ;

# invoke-Jam
#
# Will run Jam on a temporary Jamfile which contains the string in $(<:G=) and
# redirect the results into a temporary files called scratch-output.txt.
rule invoke-Jam
{
    PREFIX on $(<) = "actions unbuilt { } unbuilt all ;" ;
    if $(NT)
    {
        REMOVE on $(<) = $(SystemRoot)\System32\find ;
    }
    REMOVE on $(<) ?= rm ;
}
actions invoke-Jam
{
    echo $(PREFIX) $(<:G=) > $(gBOOST_TEST_JAMFILE)
    jam -f../Jambase -sJAMFILE=$(gBOOST_TEST_JAMFILE) >$(redirect)
    $(REMOVE) $(gBOOST_TEST_JAMFILE)
}

# These actions expect to find the ungristed part of $(<) in scratch-output.txt
# and return a nonzero exit code otherwise
if $(NT)
{
    # Explicitly get the NT find command in case someone has another find in their path.
    actions quietly Expect-in-output
    {
        $(SystemRoot)\System32\find /C "$(<:G=)" scratch-output.txt >nul
    }
}
else
{
    # Not really the right actions for Unix; the argument will be interpreted as
    # a regular expression. Is there a simpler find?
    actions quietly Expect-in-output
    {
        grep "$(<:G=)" scratch-output.txt
    }
}

