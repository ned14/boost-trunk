#  Copyright (C) Vladimir Prus 2002. Permission to copy, use, modify, sell and
#  distribute this software is granted provided this copyright notice appears in
#  all copies. This software is provided "as is" without express or implied
#  warranty, and with no claim as to its suitability for any purpose.

#  There are three kinds of targets:
#  - "abstract" -- given by user in jamfiles, and project targets,
#  - "virtual" -- part of possible transformation sequence, with defined
#     properties,
#  - actual -- the targets in Jam sense.
#  The first two kinds are handled by this module.

#  Each target is an instance of some class derived from 'target' class.

import sequence ;
import class : class ;
import regex ;
import property ;

#  Base target class.
rule target ( )
{
    self.dependencies = ;

    # Adds new depencies for this target
    rule depends ( d + )
    {
        d = [ sequence.insertion-sort $(d) ] ;
        self.dependencies = [ sequence.merge $(self.dependencies) : $(d) ] ;
    }

    # Retrives the list of dependencies
    rule dependencies ( )
    {
        return $(self.dependencies) ;
    }

    # Generates build instruction for the target and the specified build
    # request. If 'build-request' is omitted, default build is performed,
    # if appropriate
    rule generate ( build-request * )
    {
        for local d in [ dependencies ] {
            $(d).generate $(build-request) ;
        }
    }
}
class target ;

#  Project target class (derived from 'target')
rule project-target ( requirements * : default-build * )
{
    self.requirements = $(requirements) ;
    self.default-build = $(default-build) ;

    target.__init__ ;
}
class project-target : target ;

#  Concrete target (derived from 'target')
rule typed-target ( name : type : sources * : requirements * : default-build * )
{
    self.name = $(name) ;
    self.type = $(type) ;
    self.sources = $(sources) ;
    self.requirements = $(requirements) ;
    self.default-build = $(default-build) ;

    target.__init__ ;

    rule generate ( build-request * )
    {
        ECHO "Generating typed target $(__name__)" ;
        # How one can call derived rule?
        # class@target.generate $(build-request) ;
    }
}

class typed-target : target ;

#
#  Returns the target instance for the specified jamfile-location and target
#  pair. If 'jamfile-location' is not yet known, loads Jamfile there.
#
rule abstract-target-name ( jamfile-location : target-in-jamfile ? )
{
    if $(target-in-jamfile)
    {
        return target@$(jamfile-location)@$(target-in-jamfile) ;
    }
    else
    {
        return target@$(jamfile-location) ;
    }
}

#
#   Creates project target at the specified location
#
rule create-abstract-project-target ( jamfile-location )
{
    local target = [ abstract-target-name $(jamfile-location) ] ;
    class.instance $(target) : project-target ;
}


# Class which represents a virtual target
rule virtual-target ( name : subvariant : project )
{
    self.name = $(name) ;
    self.subvariant = $(subvariant) ;
    self.project = $(project) ;

    self.includes  = ;
    self.dependencies = ;
    self.action = ;

    self.actual-name  = 0 ;


    # Name of the target
    rule name ( ) { return $(self.name) ; }
    
    # Property set that distinguished different variants of a target.
    # May be a subset of the property set that is used for building.
    # Determines the location of target, in an unspecified way.
    rule subvariant ( ) { return $(self.subvariant) ; }
    
    # Project where this target was declared
    rule project ( ) { return $(self.project) ; }

    rule includes ( ) { return $(self.includes) ; }
    rule add_includes ( i + )
    {
        self.includes = [ sequence.merge $(self.includes)
                            : [ sequence.insertion-sort $(i) ] ] ;
    }

    rule dependencies ( ) { return $(self.dependencies) ; }
    rule depends ( d + )
    {
        self.dependencies = [ sequence.merge $(self.dependencies)
                               : [ sequence.insertion-sort $(d) ] ] ;
    }

    # If 'a' is supplied, sets action to 'a'.
    # Returns the action currently set.
    rule action ( a ? )
    {
        if $(a) {
            self.action = $(a) ;
        }
        return $(self.action) ;
    }

    # Generates all the actual targets and build instructions needed to build
    # this target. Returns the actual target name. Can be called several times.
    # Does no processing for other targets that 'action' will generate.
    # Rationale: we might need only one file from the set created by an
    # action, and there's no need to run the action if the file is up-to-date,
    # only because some other file in set is out-of-date.
    rule actualize ( )
    {
        ECHO "Actualizing target $(self.name)" ;
        if ! $(self.actual-name) {

            self.actual-name = [ actual-name ] ;
            for local i in $(dependencies) {
                DEPENDS $(name) : [ $(i).actualize ] ;
            }
            for local i in $(includes) {
                Includes $(name) : [ $(i).actualize ] ;
            }
            local a = [ action ] ;
            if $(a) {
                $(a).actualize ;
                local path = [ os.path.join [ $(self.project).location ] "bin" ] ;
                path = [ os.path.native $(path) ] ;
                MakeLocate $(self.actual-name) : $(path) ;

            } else {
                SEARCH on $(self.actual-name) =
                    [ os.path.native [ $(self.project).source-location ] ] ;
            }
        }
        return $(self.actual-name) ;
    }

# private:
    rule actual-name ( )
    {
        if ! $(self.actual-name)
        {
            local project-location = [ $(self.project).location ] ;
            local location-grist =
                [ sequence.join [ regex.split $(project-location) "/" ] : "!" ] ;
            local property-grist =
                [ property.path-representation $(self.subvariant) ] ;
            local grist = $(location-grist)/$(property-grist) ;
            self.actual-name = <$(grist)>$(self.name) ;
        }
        return $(self.actual-name) ;
    }
}
class virtual-target ;

# Class which represents an action.
# Both 'targets' and 'sources' should list instances of 'virtual-target'.
# Action name should name a rule with this prototype
#     rule action_name ( targets + : sources * : properties * )
# Targets and sources are passed as actual jam targets. The rule may
# not establish dependency relationship, but should do everything else.
rule action ( targets + : sources * : action_name : properties )
{
    self.targets = $(targets) ;
    self.sources = $(sources) ;
    self.action_name = $(action_name) ;
    self.properties = $(properties) ;

    rule targets ( )
    {
        return $(self.targets) ;
    }
    
    rule sources ( )
    {
        return $(self.sources) ;
    }
    
    rule action_name ( )
    {
        return $(self.action_name) ;
    }
    
    rule properties ( )
    {
        return $(self.properties) ;
    }

    # Generates actual build instructions.
    rule actualize ( )
    {
        local actual_targets ;
        for local i in [ targets ]
        {
            actual_targets += [ $(i).actualize ] ;
        }
        
        local actual_sources ;
        for local i in [ sources ]
        {
            actual_sources += [ $(i).actualize ] ;
        }
        
        DEPENDS $(actual_targets) : $(actual_sources) ;
        
        $(self.action_name)
            $(actual_targets) : $(actual_sources) : [ properties ] ;
    }
}
class action ;


