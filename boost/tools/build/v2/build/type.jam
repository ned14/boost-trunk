#  Copyright (C) Vladimir Prus 2002. Permission to copy, use, modify, sell and
#  distribute this software is granted provided this copyright notice appears in
#  all copies. This software is provided "as is" without express or implied
#  warranty, and with no claim as to its suitability for any purpose.

#  Deals with target type declaration and defines target class which supports
#  typed targets.

import feature ;
import generators : * ;
import class : class new ;
import errors ;

feature.feature target-type : : composite optional ;

# feature.feature base-target-type : : composite optional ;
feature.feature main-target-type : : optional incidental ;
feature.feature base-target-type : : composite optional free ;
# feature.feature main-target-type : : composite optional incidental ;

# Registers a target type, possible derived from a 'base-type'. 
# If 'suffixes' are provided, they given all the suffixes that mean a file is of 'type'.
# Also, the first element gives the suffix to be used when constructing and object of
# 'type'.
# If 'main' is given, a rule with the same name as the target type
# and signature
#     rule target-type ( name : sources * : requirements * : default-build )
# will be added to the global scope.
rule register ( type : suffixes * : base-type ? : main ? ) 
{
    # Type names cannot contain hyphens, because when used as
    # feature-values they will be interpreted as composite features
    # which need to be decomposed.
    switch $(type)
    {
        case *-* : errors.error "type name \"$(type)\" contains a hyphen" ;
    }
    
    if $(type) in $(.types)
    {
        errors.error "Type $(type) is already registered." ;
    }
    else
    {
        .types += $(type) ;
        .bases.$(type) = $(base-type) ;
        .suffix.$(type) = $(suffixes[1]) ;
        .type.$(suffixes) = $(type) ;
        feature.extend target-type : $(type) ;
        
        feature.compose <target-type>$(type) : $(base-type:G=<base-target-type>) ; 
        feature.extend base-target-type : $(type) ;
#        feature.compose <target-type>$(type) : <base-target-type>$(type) ;
        feature.compose <base-target-type>$(type) : <base-target-type>$(base-type) ;
        
        if $(main)
        {
            # Convert the type name to lowercase and convert all
            # underscores to hyphens to get the main target rule name.
            import regex ;
            local n = [ regex.split $(type:L) "_" ] ;
            n = $(n:J=-) ;
            .main-target-type.$(n) = $(type) ;
            
            IMPORT $(__name__) : main-target-rule : : $(n) ;
#            feature.compose <main-target-type>$(type) : <base-target-type>$(type) ;
        }        
    }
}

# Returns true iff type has been registered.
rule registered ( type )
{
    if $(type) in $(.types)
    {
        return true ;
    }
}

# Sets a scanner class that will be used for this 'type'.
rule set-scanner ( type : scanner )
{
    if ! $(type) in $(.types)
    {
        error "Type" $(type) "is not declared" ;
    }    
    .scanner.$(type) = $(scanner) ;
}

# Returns a scanner instance appropriate to 'type' and 'properties'.
rule get-scanner ( type : properties * )
{
    if $(.scanner.$(type)) {
        return [ scanner.get $(.scanner.$(type)) : $(properties) ] ;
    }    
}

# returns  type and all of its bases in order of their distance from type.
rule all-bases ( type )
{
    local result = $(type) ;
    while $(type)
    {
        type = $(.bases.$(type)) ;
        result += $(type) ;
    }
    return $(result) ;
}

# Returns true if 'type' has 'base' as its direct or
# indirect base.
rule is-derived ( type base )
{
    if $(base) in [ all-bases $(type) ]
    {
        return true ;
    }
}

# Returns suffix that should be used when generating target of 'type'.
rule generated-target-suffix ( type )
{
    return $(.suffix.$(type)) ;
}

# Returns file type given its suffix. The 'suffix' parameter should include 
# the dot.
rule type ( suffix ) 
{
    return $(.type$(suffix)) ;        
}


rule main-target-rule ( name : sources * : requirements * : default-build * 
                        : use-requirements * )
{
    # First find required target type, which is equal to the name used
    # to invoke us.
    local bt = [ BACKTRACE 1 ] ;
    local rulename = $(bt[4]) ;
    
    # This rule may be only called from Jamfile, and therefore, 
    # CALLER_MODULE is Jamfile module, which is used to denote 
    # a project.
    local project = [ CALLER_MODULE ] ;
    
    targets.main-target-alternative
      [ new typed-target $(name) : $(project) : $(.main-target-type.$(rulename))
        : $(sources)
        : [ targets.main-target-requirements $(requirements) : $(project) ] 
        : [ targets.main-target-default-build $(default-build) : $(project) ]
        : [ targets.main-target-use-requirements $(use-requirements) : $(project) ]
      ] ;
}

