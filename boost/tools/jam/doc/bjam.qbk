[article Boost.Jam
    [quickbook 1.3]
    [version 3.1.12]
    [authors [Rivera, Rene], [Abrahams, David], [Prus, Vladimir]]
    [copyright 2003 2004 2005 Rene Rivera, David Abrahams, Vladimir Prus]
    [category tool-build]
    [id jam]
    [dirname jam]
    [purpose
        Jam is a make(1) replacement that makes building simple things simple 
        and building complicated things manageable.
    ]
    [license
        Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
    ]
]

[/ QuickBook Document version 1.3 ]

[/ Shortcuts ]

[def :version:              3.1.12]

[/ Images ]

[def :note:                 [$images/note.png]]
[def :alert:                [$images/caution.png]]
[def :detail:               [$images/note.png]]
[def :tip:                  [$images/tip.png]]

[/ Links ]

[def :Boost:                [@http://www.boost.org Boost]]
[def :Perforce_Jam:         [@http://www.perforce.com/jam/jam.html Perforce Jam]]

[section:intro Introduction]

Boost.Jam (BJam)  is a build tool based on FTJam, which in turn is based on :Perforce_Jam:. It contains significant improvements made to facilitate its use in the Boost Build System, but should be backward compatible with :Perforce_Jam:.

This is version :version: of BJam and is based on version 2.4 of Jam/MR:

[pre
/+\
+\  Copyright 1993-2002 Christopher Seiwald and Perforce Software, Inc.
\+/
This is Release 2.4 of Jam/MR, a make-like program.
License is hereby granted to use this software and distribute it
freely, as long as this copyright notice is retained and modifications
are clearly marked.
ALL WARRANTIES ARE HEREBY DISCLAIMED.
]

[section:features Features]

Jam is a make(1) replacement that makes building simple things simple and building complicated things manageable. 

Jam's language is expressive, making Jamfiles (c.f. Makefiles) compact.

Jam handles header file dependencies automatically and on-the-fly.

Jam is very portable: it runs on UNIX, VMS, Mac, and NT. Most Jamfiles themselves are portable.

Jam is unintrusive: it is small, it has negligible CPU overhead, and it doesn't create any of its own funny files (c.f. Odin, nmake, SunOS make).

Jam can build large projects spread across many directories in one pass, without recursing, tracking the relationships among all files. Jam can do this with multiple, concurrent processes.

Jam isn't under the blinkin GNU copyright, so you can incorporate it into commercial products.

[endsect]

[endsect]

[section:building Building BJam]
[endsect]

[section:usage Using BJam]

If /target/ is provided on the command line, =bjam=  builds /target/; otherwise =bjam= builds the target =all=.

[pre
bjam ( -option \[value\] | target ) *
]

[section:options Options]

Options are either singular or have an accompanying value. When a value is allowed, or required, it can be either given as an argument following the option argument, or it can be given immediately after the option as part of the option argument. The allowed options are:

[table

  []
  
  [ [[^-a]]
    [Build all targets anyway, even if they are up-to-date.] ]
  
  [ [[^-d'''&nbsp;'''/n/]]
    [
    Enable cummulative debugging levels from 1 to n. Values are:\n
    
    1 - Show the actions taken for building targets, as they are executed (the default).\n
    2 - Show "quiet" actions and display all action text, as they are executed.\n
    3 - Show dependency analysis, and target/source timestamps/paths.\n
    4 - Show arguments and timming of shell invocations.\n
    5 - Show rule invocations and variable expansions.\n
    6 - Show directory/header file/archive scans, and attempts at binding to targets.\n
    7 - Show variable settings.\n
    8 - Show variable fetches, variable expansions, and evaluation of '"if"' expressions.\n
    9 - Show variable manipulation, scanner tokens, and memory usage.\n
    10 - Show profile information for rules, both timing and memory.\n
    11 - Show parsing progress of Jamfiles.\n
    12 - Show graph of target dependencies.\n
    13 - Show change target status (fate).
    ] ]
  
  [ [[^-d'''&nbsp;'''+/n/]]
    [Enable debugging level /n/.] ]
  
  [ [[^-d'''&nbsp;'''0]]
    [Turn off all debugging levels. Only errors are reported.] ]
  
  [ [[^-f'''&nbsp;'''/Jambase/]]
    [Read /Jambase/ instead of using the built-in Jambase. Only one -f flag is permitted, but the /Jambase/ may explicitly include other files. A /Jambase/ name of "-" is allowed, in which case console input is read until it is closed. At which point the input is treated as the Jambase.] ]
  
  [ [[^-j'''&nbsp;'''/n/]]
    [Run up to /n/ shell commands concurrently (UNIX and NT only). The default is 1.] ]
  
  [ [[^-l'''&nbsp;'''/n/]]
    [Limit actions to running for /n/ number of seconds, after which they are stopped. Note: Windows only.] ]
  
  [ [[^-n]]
    [Don't actually execute the updating actions, but do everything else. This changes the debug level default to =-d 2=.] ]
  
  [ [[^-o'''&nbsp;'''/file/]]
    [Write the updating actions to the specified file instead of running them.] ]
  
  [ [[^-q]]
    [Quit quickly (as if an interrupt was received) as soon as *any* target fails.] ]
  
  [ [[^-s'''&nbsp;'''/var/=/value/]]
    [Set the variable /var/ to /value/, overriding both internal variables and variables imported from the environment.] ]
  
  [ [[^-t'''&nbsp;'''/target/]]
    [Rebuild /target/ and everything that depends on it, even if it is up-to-date.] ]
  
  [ [[^--'''&nbsp;'''/value/]]
    [The option and /value/ is ignored, but is available from the =$(ARGV)= variable. ]]
  
  [ [[^-v]]
    [Print the version of =bjam= and exit.] ]
]

[endsect]

[section:operation Operation]

BJam has four phases of operation: start-up, parsing, binding, and updating.

[section:startup Start-up]

Upon start-up, =bjam= imports environment variable settings into =bjam= variables. Environment variables are split at blanks with each word becoming an element in the variable's list of values. Environment variables whose names end in =PATH= are split at =$(SPLITPATH)= characters (e.g., =":"= for Unix).

To set a variable's value on the command line, overriding the variable's environment value, use the =-s= option. To see variable assignments made during bjam's execution, use the =-d+7= option.

[endsect]

[section:parsing Parsing]

In the parsing phase, =bjam= reads and parses the =Jambase= file, by default the built-in one. It is written in the [link jam.language jam language]. The last action of the =Jambase= is to read (via the "include" rule) a user-provided file called "=Jamfile=".

Collectively, the purpose of the =Jambase= and the =Jamfile= is to name built target and source files, construct the dependency graph among them, and associate build actions with targets. The =Jambase= defines boilerplate rules and variable assignments, and the =Jamfile= uses these to specify the actual relationship among the target and source files.

[endsect]

[section:binding Binding]

After parsing, =bjam= recursively descends the dependency graph and binds every file target with a location in the filesystem. If =bjam= detects a circular dependency in the graph, it issues a warning.

File target names are given as absolute or relative path names in the filesystem. If the path name is absolute, it is bound as is. If the path name is relative, it is normally bound as is, and thus relative to the current directory. This can be modified by the settings of the =$(SEARCH)= and =$(LOCATE)= variables, which enable jam to find and build targets spread across a directory tree. See [link jam.language.variables.builtins.search SEARCH and LOCATE Variables] below.

[section:fate Update Determination]

After binding each target, =bjam= determines whether the target needs updating, and if so marks the target for the updating phase. A target is normally so marked if it is missing, it is older than any of its sources, or any of its sources are marked for updating. This behavior can be modified by the application of special built-in rules, =ALWAYS=, =LEAVES=, =NOCARE=, =NOTFILE=, =NOUPDATE=, and =TEMPORARY=. See [link jam.language.rules.builtins.modifying_binding Modifying Binding] below.

[endsect]

[section:headerscan Header File Scanning]

During the binding phase, =bjam= also performs header file scanning, where it looks inside source files for the implicit dependencies on other files caused by C's #include syntax. This is controlled by the special variables $(HDRSCAN) and $(HDRRULE). The result of the scan is formed into a rule invocation, with the scanned file as the target and the found included file names as the sources. Note that this is the only case where rules are invoked outside the parsing phase. See [link jam.language.variables.builtins.hdrscan HDRSCAN and HDRRULE Variables] below.

[endsect]

[endsect]

[section:updating Updating]

After binding, =bjam= again recursively descends the dependency graph, this time executing the update actions for each target marked for update during the binding phase. If a target's updating actions fail, then all other targets which depend on that target are skipped.

The =-j= flag instructs =bjam= to build more than one target at a time. If there are multiple actions on a single target, they are run sequentially.

[endsect]

[endsect]

[endsect]

[section:language Language]

=BJam= has an interpreted, procedural language. Statements in =bjam= are rule (procedure) definitions, rule invocations, flow-of-control structures, variable assignments, and sundry language support.

[section:lexical Lexical Features]

=BJam= treats its input files as whitespace-separated tokens, with two exceptions: double quotes (") can enclose whitespace to embed it into a token, and everything between the matching curly braces ({}) in the definition of a rule action is treated as a single string. A backslash (\) can escape a double quote, or any single whitespace character.

=BJam= requires whitespace (blanks, tabs, or newlines) to surround all tokens, including the colon (:) and semicolon (;) tokens.

=BJam= keywords (an mentioned in this document) are reserved and generally must be quoted with double quotes (") to be used as arbitrary tokens, such as variable or target names. 

[endsect]

[section:target Targets]

The essential =bjam= data entity is a target. Built targets are files to be updated. Source targets are the files used in updating built targets. Built targets and source targets are collectively referred to as file targets, and frequently built targets are source targets for other built targets. Pseudotargets are symbols which represent dependencies on other targets, but which are not themselves associated with any real file.

A file target's identifier is generally the file's name, which can be absolutely rooted, relative to the directory of =bjam='s invocation, or simply local (no directory). Most often it is the last case, and the actual file path is bound using the =$(SEARCH)= and =$(LOCATE)= special variables. See [link jam.language.variables.builtins.search SEARCH and LOCATE Variables] below. A local filename is optionally qualified with grist, a string value used to assure uniqueness. A file target with an identifier of the form /file(member)/ is a library member (usually an =ar=(1) archive on Unix).

[endsect]

[section:rules Rules]

The basic =bjam= language entity is called a rule. A rule is defined in two parts: the procedure and the actions. The procedure is a body of jam statements to be run when the rule is invoked; the actions are the OS shell commands to execute when updating the built targets of the rule.

Rules can return values, which can be expanded into a list with "[ /rule/ /args/ ... ]". A rule's value is the value of its last statement, though only the following statements have values: 'if' (value of the leg chosen), 'switch' (value of the case chosen), set (value of the resulting variable), and 'return' (value of its arguments). Note that 'return' doesn't actually cause a return, i.e., is a no-op unless it is the last statement of the last block executed within rule body.

The =bjam= statements for defining and invoking rules are as follows:

Define a rule's procedure, replacing any previous definition.

[pre
rule /rulename/ { /statements/ }
]

Define a rule's updating actions, replacing any previous definition.

[pre
actions \[ /modifiers/ \] /rulename/ { /commands/ }
]

Invoke a rule.

[pre
rulename /field1/ : /field2/ : /.../ : /fieldN/ ;
]

Invoke a rule under the influence of target's specific variables..

[pre
on /target/ /rulename/ /field1/ : /field2/ : /.../ : /fieldN/ ;
]

Used as an argument, expands to the return value of the rule invoked.

[pre
\[ /rulename/ /field1/ : /field2/ : /.../ : /fieldN/ \]
\[ on /target/ /rulename/ /field1/ : /field2/ : /.../ : /fieldN/ \]
]

A rule is invoked with values in /field1/ through /fieldN/. They may be referenced in the procedure's statements as [^$(1)] through [^$(['N])] (9 max), and the first two only may be referenced in the action's /commands/ as [^$(1)] and [^$(2)]. [^$(<)] and [^$(>)] are synonymous with [^$(1)] and [^$(2)].

Rules fall into two categories: updating rules (with actions), and pure procedure rules (without actions). Updating rules treat arguments [^$(1)] and [^$(2)] as built targets and sources, respectively, while pure procedure rules can take arbitrary arguments.

When an updating rule is invoked, its updating actions are added to those associated with its built targets ([^$(1)]) before the rule's procedure is run. Later, to build the targets in the updating phase, /commands/ are passed to the OS command shell, with [^$(1)] and [^$(2)] replaced by bound versions of the target names. See Binding above.

Rule invokation may be indirected through a variable:

[pre
$(/var/) /field1/ : /field2/ : /.../ : /fieldN/ ;

on /target/ $(/var/) /field1/ : /field2/ : /.../ : /fieldN/ ;

\[ $(/var/) /field1/ : /field2/ : /.../ : /fieldN/ \]
\[ on /target/ $(/var/) /field1/ : /field2/ : /.../ : /fieldN/ \]
]

The variable's value names the rule (or rules) to be invoked. A rule is invoked for each element in the list of [^$(/var/)]'s values. The fields [^/field1/ : /field2/ : /.../] are passed as arguments for each invokation. For the [ ... ] forms, the return value is the concatenation of the return values for all of the invokations.

[section Action Modifiers]

The following action modifiers are understood:

[table

[]

[[[^actions bind /vars/]]
 [[^$(/vars/)] will be replaced with bound values.]]

[[[^actions existing]]
 [[^$(>)] includes only source targets currently existing.]]

[[[^actions ignore]]
 [The return status of the commands is ignored.]]

[[[^actions piecemeal]]
 [commands are repeatedly invoked with a subset of [^$(>)] small enough to fit in the command buffer on this OS.]]

[[[^actions quietly]]
 [The action is not echoed to the standard output.]]

[[[^actions together]]
 [The [^$(>)] from multiple invocations of the same action on the same built target are glommed together.]]

[[[^actions updated]]
 [[^$(>)] includes only source targets themselves marked for updating.]]

]

[endsect]

[section:builtins Built-in Rules]

=BJam= has a growing set of built-in rules, all of which are pure procedure rules without updating actions. They are in three groups: the first builds the dependency graph; the second modifies it; and the third are just utility rules.

[section Dependency Building]

[pre
DEPENDS /targets1/ : /targets2/ ;
]

Builds a direct dependency: makes each of /targets1/ depend on each of /targets2/. Generally, /targets1/ will be rebuilt if /targets2/ are themselves rebuilt are or are newer than /targets1/.

[pre
INCLUDES /targets1/ : /targets2/ ;
]

Builds a sibling dependency: makes any target that depends on any of /targets1/ also depend on each of /targets2/. This reflects the dependencies that arise when one source file includes another: the object built from the source file depends both on the original and included source file, but the two sources files don't depend on each other. For example:

[pre
DEPENDS foo.o : foo.c ;
INCLUDES foo.c : foo.h ;
]

"=foo.o=" depends on "=foo.c=" and "=foo.h=" in this example.

[endsect]

[section Modifying Binding]

The six rules =ALWAYS=, =LEAVES=, =NOCARE=, =NOTFILE=, =NOUPDATE=, and =TEMPORARY= modify the dependency graph so that =bjam= treats the targets differently during its target binding phase. See Binding above. Normally, =bjam= updates a target if it is missing, if its filesystem modification time is older than any of its dependencies (recursively), or if any of its dependencies are being updated. This basic behavior can be changed by invoking the following rules:

[pre
ALWAYS /targets/ ;
]

Causes /targets/ to be rebuilt regardless of whether they are up-to-date (they must still be in the dependency graph). This is used for the clean and uninstall targets, as they have no dependencies and would otherwise appear never to need building. It is best applied to targets that are also =NOTFILE= targets, but it can also be used to force a real file to be updated as well.

[pre
LEAVES /targets/ ;
]

Makes each of /targets/ depend only on its leaf sources, and not on any intermediate targets. This makes it immune to its dependencies being updated, as the "leaf" dependencies are those without their own dependencies and without updating actions. This allows a target to be updated only if original source files change.

[pre
NOCARE /targets/ ;
]

Causes =bjam= to ignore /targets/ that neither can be found nor have updating actions to build them. Normally for such targets =bjam= issues a warning and then skips other targets that depend on these missing targets. The =HdrRule= in =Jambase= uses =NOCARE= on the header file names found during header file scanning, to let =bjam= know that the included files may not exist. For example, if an `#include` is within an `#ifdef`, the included file may not actually be around.

[pre
NOTFILE /targets/ ;
]

Marks /targets/ as pseudotargets and not real files. No timestamp is checked, and so the actions on such a target are only executed if the target's dependencies are updated, or if the target is also marked with =ALWAYS=. The default =bjam= target "=all=" is a pseudotarget. In =Jambase=, =NOTFILE= is used to define several addition convenient pseudotargets.

[pre
NOUPDATE /targets/ ;
]

Causes the timestamps on /targets/ to be ignored. This has two effects: first, once the target has been created it will never be updated; second, manually updating target will not cause other targets to be updated. In =Jambase=, for example, this rule is applied to directories by the =MkDir= rule, because =MkDir= only cares that the target directory exists, not when it has last been updated.

[pre
TEMPORARY /targets/ ;
]

Marks /targets/ as temporary, allowing them to be removed after other targets that depend upon them have been updated. If a =TEMPORARY= target is missing, =bjam= uses the timestamp of the target's parent. =Jambase= uses =TEMPORARY= to mark object files that are archived in a library after they are built, so that they can be deleted after they are archived. 

[endsect]

[section Utility]

The two rules =ECHO= and =EXIT= are utility rules, used only in =bjam='s parsing phase.

[pre
ECHO /args/ ;
]

Blurts out the message /args/ to stdout.

[pre
EXIT /args/ ;
]

Blurts out the message args to stdout and then exits with a failure status.

"=Echo=", "=echo=", "=Exit=", and "=exit=" are accepted as aliases for =ECHO= and =EXIT=, since it is hard to tell that these are built-in rules and not part of the language, like "=include=". 

The =GLOB= rule does filename globbing.

[pre
GLOB /directories/ : /patterns/ : /downcase-opt/
]

Using the same wildcards as for the patterns in the switch statement. It is invoked by being used as an argument to a rule invocation inside of "=[ ]=". For example: "[^FILES = \[ GLOB dir1 dir2 : *.c *.h \]]" sets =FILES= to the list of C source and header files in =dir1= and =dir2=. The resulting filenames are the full pathnames, including the directory, but the pattern is applied only to the file name without the directory.

If /downcase-opt/ is supplied, filenames are converted to all-lowercase before matching against the pattern; you can use this to do case-insensitive matching using lowercase patterns. The paths returned will still have mixed case if the OS supplies them. On Windows NT and Cygwin, filenames are always downcased before matching. 

The =MATCH= rule does pattern matching.

[pre
MATCH /regexps/ : /list/
]

Matches the =egrep=(1) style regular expressions /regexps/ against the strings in /list/. The result is the concatenation of matching =()= subexpressions for each string in /list/, and for each regular expression in /regexps/. Only useful within the "=[ ]=" construct, to change the result into a list.

[endsect]

[endsect]

[endsect]

[section Flow-of-Control]

=BJam= has several simple flow-of-control statements:

[pre
for /var/ in /list/ { /statements/ }
]

Executes /statements/ for each element in /list/, setting the variable /var/ to the element value.

[pre
if /cond/ { /statements/ }
\[ else { /statements/ } \]
]

Does the obvious; the =else= clause is optional. /cond/ is built of:

[table

[]

[[[^['a']]]
 [true if any ['a] element is a non-zero-length string]]

[[[^['a] = ['b]]]
 [list ['a] matches list ['b] string-for-string]]

[[[^['a] != ['b]]]
 [list ['a] does not match list ['b]]]

[[[^['a] < ['b]]]
 [['a\[i\]] string is less than ['b\[i\]] string, where ['i] is first mismatched element in lists ['a] and ['b]]]

[[[^['a] <= ['b]]]
 [every ['a] string is less than or equal to its ['b] counterpart]]

[[[^['a] > ['b]]]
 [['a\[i\]] string is greater than ['b\[i\]] string, where ['i] is first mismatched element]]

[[[^['a] >= ['b]]]
 [every ['a] string is greater than or equal to its ['b] counterpart]]

[[[^['a] in ['b]]]
 [true if all elements of ['a] can be found in ['b], or if ['a] has no elements]]

[[[^! ['cond]]]
 [condition not true]]

[[[^['cond] && ['cond]]]
 [conjunction]]

[[[^['cond] || ['cond]]]
 [disjunction]]

[[[^( ['cond] )]]
 [precedence grouping]]

]

[pre
include /file/ ;
]

Causes =bjam= to read the named /file/. The /file/ is bound like a regular target (see Binding above) but unlike a regular target the include /file/ cannot be built.

The include /file/ is inserted into the input stream during the parsing phase. The primary input file and all the included file(s) are treated as a single file; that is, jam infers no scope boundaries from included files.

[pre
local /vars/ \[ = /values/ \] ;
]

Creates new /vars/ inside to the enclosing ={}= block, obscuring any previous values they might have. The previous values for vars are restored when the current block ends. Any rule called or file included will see the local and not the previous value (this is sometimes called Dynamic Scoping). The local statement may appear anywhere, even outside of a block (in which case the previous value is restored when the input ends). The /vars/ are initialized to /values/ if present, or left uninitialized otherwise.

[pre
return /values/ ;
]

Within a rule body, the return statement sets the return value for an invocation of the rule. It does *not* cause the rule to return; a rule's value is actually the value of the last statement executed, so a return should be the last statement executed before the rule "naturally" returns.

[pre
switch /value/
{
    case /pattern1/ : /statements/ ;
    case /pattern2/ : /statements/ ;
    ...
}
]

The switch statement executes zero or one of the enclosed /statements/, depending on which, if any, is the first case whose /pattern/ matches /value/. The /pattern/ values are not variable-expanded. The pattern values may include the following wildcards:

[table

[]

[[[^?]]
 [match any single character]]

[[[^*]]
 [match zero or more characters]]

[[[^\[/chars/\]]]
 [match any single character in /chars/]]

[[[^\[\^/chars/\]]]
 [match any single character not in /chars/]]

[[[^\\/x/]]
 [match /x/ (escapes the other wildcards)]]

]

[pre
while /cond/ { /statements/ }
]

Repeatedly execute /statements/ while /cond/ remains true upon entry. (See the description of /cond/ expression syntax under if, above). 

[endsect]

[section Variables]

=BJam= variables are lists of zero or more elements, with each element being a string value. An undefined variable is indistinguishable from a variable with an empty list, however, a defined variable may have one more elements which are null strings. All variables are referenced as [^$(/variable/)].

Variables are either global or target-specific. In the latter case, the variable takes on the given value only during the updating of the specific target.

A variable is defined with:

[pre
/variable/ = /elements/ ;
/variable/ += /elements ;
/variable/ on /targets/ = /elements/ ;
/variable/ on /targets/ += /elements/ ;
/variable/ default = /elements/ ;
/variable/ ?= /elements/ ;
]

The first two forms set /variable/ globally. The third and forth forms set a target-specific variable. The [^=] operator replaces any previous elements of /variable/ with /elements/; the [^+=] operation adds /elements/ to /variable/'s list of elements. The final two forms are synonymous: they set /variable/ globally, but only if it was previously unset.

Variables referenced in updating commands will be replaced with their values; target-specific values take precedence over global values. Variables passed as arguments (=$(1)= and =$(2)=) to actions are replaced with their bound values; the "=bind=" modifier can be used on actions to cause other variables to be replaced with bound values. See Action Modifiers above.

=BJam= variables are not re-exported to the environment of the shell that executes the updating actions, but the updating actions can reference =bjam= variables with [^$(/variable/)]. 

[section:expansion Variable Expansion]

During parsing, =bjam= performs variable expansion on each token that is not a keyword or rule name. Such tokens with embedded variable references are replaced with zero or more tokens. Variable references are of the form [^$(/v/)] or [^$(/vm/)], where ['v] is the variable name, and ['m] are optional modifiers.

Variable expansion in a rule's actions is similar to variable expansion in statements, except that the action string is tokenized at whitespace regardless of quoting.

The result of a token after variable expansion is the /product/ of the components of the token, where each component is a literal substring or a list substituting a variable reference. For example:

[pre
$(X) -> a b c
t$(X) -> ta tb tc
$(X)z -> az bz cz
$(X)-$(X) -> a-a a-b a-c b-a b-b b-c c-a c-b c-c
]

The variable name and modifiers can themselves contain a variable reference, and this partakes of the product as well:

[pre
$(X) -> a b c
$(Y) -> 1 2
$(Z) -> X Y
$($(Z)) -> a b c 1 2
]

Because of this product expansion, if any variable reference in a token is undefined, the result of the expansion is an empty list. If any variable element is a null string, the result propagates the non-null elements:

[pre
$(X) -> a ""
$(Y) -> "" 1
$(Z) ->
-$(X)$(Y)- -> -a- -a1- -- -1-
-$(X)$(Z)- ->
]

A variable element's string value can be parsed into grist and filename-related components. Modifiers to a variable are used to select elements, select components, and replace components. The modifiers are:

[table

[]

[[[^\[['n]\]]]
 [Select element number ['n] (starting at 1). If the variable contains fewer than ['n] elements, the result is a zero-element list.]]

[[[^\[['n]-['m]\]]]
 [Select elements number ['n] through ['m].]]

[[[^\[['n]-\]]]
 [Select elements number ['n] through the last.]]

[[[^:B]]
 [Select filename base.]]

[[[^:S]]
 [Select (last) filename suffix.]]

[[[^:M]]
 [Select archive member name.]]

[[[^:D]]
 [Select directory path.]]

[[[^:P]]
 [Select parent directory.]]

[[[^:G]]
 [Select grist.]]

[[[^:U]]
 [Replace lowercase characters with uppercase.]]

[[[^:L]]
 [Replace uppercase characters with lowercase.]]

[[[^:['chars]]]
 [Select the components listed in ['chars].]]

[[[^:G=['grist]]]
 [Replace grist with ['grist].]]

[[[^:D=['path]]]
 [Replace directory with ['path].]]

[[[^:B=['base]]]
 [Replace the base part of file name with ['base].]]

[[[^:S=['suf]]]
 [Replace the suffix of file name with ['suf].]]

[[[^:M=['mem]]]
 [Replace the archive member name with ['mem].]]

[[[^:R=['root]]]
 [Prepend ['root] to the whole file name, if not already rooted.]]

[[[^:E=['value]]]
 [Assign ['value] to the variable if it is unset.]]

[[[^:J=['joinval]]]
 [Concatentate list elements into single element, separated by ['joinval]'.]]

]

On VMS, [^$(var:P)] is the parent directory of [^$(var:D)].

[endsect]

[section:builtins Built-in Variables]

[section:search SEARCH and LOCATE]
[endsect]

[section:hdrscan HDRSCAN and HDRRULE]
[endsect]

[section Platform Identifier]
[endsect]

[section Jam Version]
[endsect]

[section JAMSHELL]
[endsect]

[endsect]

[endsect]

[endsect]
