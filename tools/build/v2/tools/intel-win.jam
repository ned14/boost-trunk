# Copyright Vladimir Prus 2004.
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE_1_0.txt
# or copy at http://www.boost.org/LICENSE_1_0.txt)

# Importing common is needed because the rules we inherit here depend on it.
# That is nasty.
import common ;
import errors ;
import feature ;
import intel ;
import msvc ;
import os ;
import toolset ;
import generators ;
import type ;

feature.extend-subfeature toolset intel : platform : win ;

toolset.inherit-generators intel-win <toolset>intel <toolset-intel:platform>win : msvc ;
toolset.inherit-flags intel-win : msvc ;
toolset.inherit-rules intel-win : msvc ;

# Override default do-nothing generators.
generators.override intel-win.compile.c.pch   : pch.default-c-pch-generator   ;
generators.override intel-win.compile.c++.pch : pch.default-cpp-pch-generator ;

toolset.flags intel-win.compile PCH_SOURCE <pch>on : <pch-source> ;

type.set-generated-target-suffix PCH : <toolset>intel <toolset-intel:platform>win : pchi ;

toolset.add-requirements <toolset>intel-win,<runtime-link>shared:<threading>multi ;

# Initializes the intel toolset for windows
rule init ( version ? :     # the compiler version
            command * :     # the command to invoke the compiler itself
            options *       # Additional option: <compatibility>
                            # either 'vc6', 'vc7', 'vc7.1'
                            # or 'native'(default).
          )
{
    local compatibility =
      [ feature.get-values <compatibility> : $(options) ] ;
    local condition = [  common.check-init-parameters intel-win
        : version $(version) : compatibility $(compatibility) ] ;

    command = [ common.get-invocation-command intel-win : icl.exe :
        $(command) ] ;

    common.handle-options intel-win : $(condition) : $(command) : $(options) ;

    local root ;
    if $(command)
    {
        root = [ common.get-absolute-tool-path $(command[-1]) ] ;
        root = $(root)/ ;
    }

    local setup ;
    setup = $(root)/iclvars.bat ;
    setup = "call \""$(setup)"\" > nul " ;

    if [ os.name ] = NT
    {
        setup = $(setup)"
" ;
    }
    else
    {
        setup = "cmd /S /C "$(setup)" \"&&\" " ;
    }

    toolset.flags intel-win.compile .CC $(condition) : $(setup)icl ;
    toolset.flags intel-win.link .LD $(condition) : $(setup)xilink ;
    toolset.flags intel-win.archive .LD $(condition) : $(setup)xilink /lib ;
    toolset.flags intel-win.link .MT $(condition) : mt -nologo ;

    local m = [ MATCH (.).* : $(version) ] ;
    local major = $(m[1]) ;

    local C++FLAGS ;

    C++FLAGS += /nologo ;

    # Reduce the number of spurious error messages
    C++FLAGS += /Qwn5 /Qwd985 ;

    # Enable ADL
    C++FLAGS += -Qoption,c,--arg_dep_lookup ; #"c" works for C++, too

    # Disable Microsoft "secure" overloads in Dinkumware libraries since they
    # cause compile errors with Intel versions 9 and 10.
    C++FLAGS += -D_SECURE_SCL=0 ;

    if $(major) > 5
    {
        C++FLAGS += /Zc:forScope ;  # Add support for correct for loop scoping.
    }

    # Add options recognized only by intel7 and above.
    if $(major) >= 7
    {
        C++FLAGS += /Qansi_alias ;
    }

    if $(compatibility) = vc6
    {
        C++FLAGS +=
          # Emulate VC6
          /Qvc6

          # No wchar_t support in vc6 dinkum library.  Furthermore, in vc6
          # compatibility-mode, wchar_t is not a distinct type from unsigned
          # short.
          -DBOOST_NO_INTRINSIC_WCHAR_T
          ;
    }
    else
    {
        if $(major) > 5
        {
            # Add support for wchar_t
            C++FLAGS += /Zc:wchar_t
              # Tell the dinkumware library about it.
              -D_NATIVE_WCHAR_T_DEFINED
              ;
        }
    }

    if $(compatibility) && $(compatibility) != native
    {
        C++FLAGS += /Q$(base-vc) ;
    }
    else
    {
        C++FLAGS +=
          -Qoption,cpp,--arg_dep_lookup
          # The following options were intended to disable the Intel compiler's
          # 'bug-emulation' mode, but were later reported to be causing ICE with
          # Intel-Win 9.0. It is not yet clear which options can be safely used.
          # -Qoption,cpp,--const_string_literals
          # -Qoption,cpp,--new_for_init
          # -Qoption,cpp,--no_implicit_typename
          # -Qoption,cpp,--no_friend_injection
          # -Qoption,cpp,--no_microsoft_bugs
          ;
    }

    toolset.flags intel-win CFLAGS $(condition) : $(C++FLAGS) ;

    if ! $(compatibility)
    {
        # If there's no backend version, assume 7.1.
        compatibility = vc7.1 ;
    }

    local extract-version = [ MATCH ^vc(.*) : $(compatibility) ] ;
    if ! $(extract-version)
    {
        errors.user-error "Invalid value for compatibility option:"
            $(compatibility) ;
    }

    # Depending on the settings, running of tests require some runtime DLLs.
    toolset.flags intel-win RUN_PATH $(condition) : $(root) ;

    msvc.configure-version-specific intel-win : $(extract-version[1]) : $(condition) ;
}

toolset.flags intel-win.link LIBRARY_OPTION <toolset>intel : "" ;

.escaped-double-quote = "\"" ;
# Unline msvc, intel-win does not support the -Yl option, so this is a version
# of msvc rules without -Yl
# Also note that intel compiler has totally broken handling of the -Fp option --
# it always adds 'i' to the provided extension. So, we have to copy the actual
# file produced to the one that Boost.Build expects so that dependency analysis
# works.
actions compile-c-c++-pch
{
    $(.CC) @"@($(<[1]:W).rsp:E="$(>[2]:W)" -Fo"$(<[2]:W)" -Yc"$(>[1]:D=)" -Fp"$(<[1]:W:S=pch)" $(CC_RSPLINE))" "@($(<[1]:W).cpp:E=#include $(.escaped-double-quote)$(>[1]:D=)$(.escaped-double-quote))" $(.CC.FILTER)
    copy "$(<[1]:W:S=pch)i" "$(<[1]:W:S=pch)"
}

actions compile-c-c++-pch-s
{
    $(.CC) @"@($(<[1]:W).rsp:E="$(>[2]:W)" -Fo"$(<[2]:W)" -Yc"$(>[1]:D=)" -Fp"$(<[1]:W:S=pch)" $(CC_RSPLINE))" $(.CC.FILTER)
    copy "$(<[1]:W:S=pch)i" "$(<[1]:W:S=pch)"
}

# The compile.c.pch rule that is actually called from the generator for PCH
# is imported by toolset.inherit-rules, but it's not localized, so it will
# use compile-c-c++-pch* defined in msvc. Re-import it localized.
IMPORT msvc : compile.c.pch : intel-win : intel-win.compile.c.pch : localized ;
IMPORT msvc : compile.c++.pch : intel-win : intel-win.compile.c++.pch : localized ;
# This one is used by compile.c++.pch. Of course, this is a mess, but Python port
# will clean this up.
IMPORT msvc : get-rspline : intel-win : get-rspline ;
