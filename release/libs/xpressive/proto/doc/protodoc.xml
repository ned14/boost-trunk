<?xml version="1.0" standalone="yes"?>
<library-reference><header name="boost/xpressive/proto/args.hpp"><para>Contains definition of args&lt;&gt; class template. </para><namespace name="boost"><namespace name="proto"><namespace name="argsns_"><struct name="args0"><template>
      <template-type-parameter name="Arg0"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>mpl::void_</type></typedef><typedef name="arg2"><type>mpl::void_</type></typedef><typedef name="arg3"><type>mpl::void_</type></typedef><typedef name="arg4"><type>mpl::void_</type></typedef><data-member name="size" specifiers="static"><type>const long</type></data-member></struct><struct name="args1"><template>
      <template-type-parameter name="Arg0"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>mpl::void_</type></typedef><typedef name="arg2"><type>mpl::void_</type></typedef><typedef name="arg3"><type>mpl::void_</type></typedef><typedef name="arg4"><type>mpl::void_</type></typedef><data-member name="size" specifiers="static"><type>const long</type></data-member></struct><struct name="args2"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>Arg1</type></typedef><typedef name="arg2"><type>mpl::void_</type></typedef><typedef name="arg3"><type>mpl::void_</type></typedef><typedef name="arg4"><type>mpl::void_</type></typedef><data-member name="size" specifiers="static"><type>const long</type></data-member></struct><struct name="args3"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
      <template-type-parameter name="Arg2"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>Arg1</type></typedef><typedef name="arg2"><type>Arg2</type></typedef><typedef name="arg3"><type>mpl::void_</type></typedef><typedef name="arg4"><type>mpl::void_</type></typedef><data-member name="size" specifiers="static"><type>const long</type></data-member></struct><struct name="args4"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
      <template-type-parameter name="Arg2"/>
      <template-type-parameter name="Arg3"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>Arg1</type></typedef><typedef name="arg2"><type>Arg2</type></typedef><typedef name="arg3"><type>Arg3</type></typedef><typedef name="arg4"><type>mpl::void_</type></typedef><data-member name="size" specifiers="static"><type>const long</type></data-member></struct><struct name="args5"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
      <template-type-parameter name="Arg2"/>
      <template-type-parameter name="Arg3"/>
      <template-type-parameter name="Arg4"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><typedef name="arg0"><type>Arg0</type></typedef><typedef name="arg1"><type>Arg1</type></typedef><typedef name="arg2"><type>Arg2</type></typedef><typedef name="arg3"><type>Arg3</type></typedef><typedef name="arg4"><type>Arg4</type></typedef><data-member name="size" specifiers="static"><type>const long</type></data-member></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/context.hpp"><para>Includes all the context classes in the context/ sub-directory. </para></header><header name="boost/xpressive/proto/context/callable.hpp"><para>Definintion of callable_context&lt;&gt;, an evaluation context for proto::eval() that explodes each node and calls the derived context type with the expressions constituents. If the derived context doesn't have an overload that handles this node, fall-back to the default_context. TODO: make the fall-back configurable! </para><namespace name="boost"><namespace name="proto"><namespace name="context"><struct name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
      <template-nontype-parameter name="Arity"><type>long</type></template-nontype-parameter>
    </template><description><para>callable_eval </para></description></struct><struct name="callable_context"><template>
      <template-type-parameter name="Context"/>
      <template-type-parameter name="DefaultCtx"/>
    </template><description><para>callable_context </para></description><struct name="eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="ThisContext"><default>Context</default></template-type-parameter>
    </template><description><para>callable_context::eval </para></description></struct></struct><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>0</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::proto_tag, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::proto_tag, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::proto_tag, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 1 &gt;::const_reference)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>3</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::proto_tag, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 1 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 2 &gt;::const_reference)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>4</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::proto_tag, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 1 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 2 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 3 &gt;::const_reference)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>5</template-arg></specialization><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::proto_tag, typename proto::result_of::arg_c&lt; Expr, 0 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 1 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 2 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 3 &gt;::const_reference, typename proto::result_of::arg_c&lt; Expr, 4 &gt;::const_reference)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization></namespace></namespace></namespace></header><header name="boost/xpressive/proto/context/default.hpp"><para>Definintion of default_context, a default evaluation context for proto::eval() that uses Boost.Typeof to deduce return types of the built-in operators. </para><namespace name="boost"><namespace name="proto"><namespace name="context"><struct name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
      <template-type-parameter name="Tag"/>
      <template-nontype-parameter name="Arity"><type>long</type></template-nontype-parameter>
    </template></struct><struct name="default_context"><description><para>default_context </para></description><struct name="eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="ThisContext"><default>default_context const</default></template-type-parameter>
    </template><inherit access="public">boost::proto::context::default_eval&lt; Expr, ThisContext &gt;</inherit><description><para>default_context::eval </para></description></struct></struct><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::posit</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::negate</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::dereference</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::complement</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::address_of</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::logical_not</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::pre_inc</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::pre_dec</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::shift_left</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::shift_right</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::multiplies</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::divides</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::modulus</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::plus</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::minus</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::less</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::greater</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::less_equal</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::greater_equal</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::equal_to</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::not_equal_to</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::logical_or</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::logical_and</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_and</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_or</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_xor</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::mem_ptr</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::shift_left_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::shift_right_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::multilpies_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::divides_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::modulus_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::plus_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::minus_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_and_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_or_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_xor_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::terminal</template-arg><template-arg>0</template-arg></specialization><typedef name="result_type"><type>mpl::if_&lt; is_const &lt; Expr &gt;, typename <classname>proto::result_of::arg</classname>&lt; Expr &gt;::const_reference, typename <classname>proto::result_of::arg</classname>&lt; Expr &gt;::reference &gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name=""><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::post_inc</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::post_dec</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::subscript</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::if_else_</template-arg><template-arg>3</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::comma</template-arg><template-arg>2</template-arg></specialization><typedef name="proto_arg0"><type><classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 0 &gt;::type, Context &gt;::type</type></typedef><typedef name="proto_arg1"><type><classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 1 &gt;::type, Context &gt;::type</type></typedef><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>1</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type()&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>2</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 1 &gt;::type, Context &gt;::type)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>3</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 1 &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 2 &gt;::type, Context &gt;::type)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>4</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 1 &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 2 &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 3 &gt;::type, Context &gt;::type)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>5</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 1 &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 2 &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 3 &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename proto::result_of::arg_c&lt; Expr, 4 &gt;::type, Context &gt;::type)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization></namespace></namespace></namespace></header><header name="boost/xpressive/proto/context/null.hpp"><para>Definintion of null_context&lt;&gt;, an evaluation context for proto::eval() that simply evaluates each child expression, doesn't combine the results at all, and returns void. </para><namespace name="boost"><namespace name="proto"><namespace name="context"><struct name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
      <template-nontype-parameter name="Arity"><type>long</type></template-nontype-parameter>
    </template></struct><struct-specialization name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>0</template-arg></specialization><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><parameter name=""><paramtype>Expr &amp;</paramtype></parameter><parameter name=""><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>3</template-arg></specialization><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>4</template-arg></specialization><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>5</template-arg></specialization><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct name="null_context"><description><para>null_context </para></description><struct name="eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="ThisContext"><default>null_context const</default></template-type-parameter>
    </template><inherit access="public">boost::proto::context::null_eval&lt; Expr, ThisContext &gt;</inherit><description><para>null_context::eval </para></description></struct></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/debug.hpp"><para>Utilities for debugging proto expression trees </para><namespace name="boost"><namespace name="proto"><namespace name="functional"><struct name="display_expr"><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>expr&lt; <classname>tag::terminal</classname>, Args, 0 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>expr&lt; Tag, Args, 1 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>expr&lt; Tag, Args, 0 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></method></method-group><constructor><parameter name="depth"><paramtype>int</paramtype><default>0</default></parameter><parameter name="sout"><paramtype>std::ostream &amp;</paramtype><default>std::cout</default></parameter></constructor></struct></namespace><namespace name="tag"><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::posit</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::negate</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::dereference</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::complement</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::address_of</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::logical_not</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::pre_inc</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::pre_dec</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::post_inc</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::post_dec</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::shift_left</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::shift_right</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::multiplies</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::divides</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::modulus</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::plus</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::minus</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::less</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::greater</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::less_equal</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::greater_equal</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::equal_to</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::not_equal_to</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::logical_or</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::logical_and</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_and</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_or</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_xor</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::comma</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::mem_ptr</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::shift_left_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::shift_right_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::multilpies_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::divides_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::modulus_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::plus_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::minus_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_and_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_or_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_xor_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::subscript</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::if_else_</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::function</classname></paramtype></parameter></function><data-member name="proto_tag_name"><type><classname>hidden_detail_::printable_tag</classname>&lt; Tag &gt;::type</type></data-member></namespace><function name="display_expr"><type>void</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></function><function name="display_expr"><type>void</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="sout"><paramtype>std::ostream &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/xpressive/proto/deep_copy.hpp"><para>Replace all nodes stored by reference by nodes stored by value. </para><namespace name="boost"><namespace name="proto"><namespace name="functional"><struct name="deep_copy"><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::deep_copy</classname>&lt; Expr &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct></namespace><namespace name="result_of"><struct name="deep_copy"><template>
      <template-type-parameter name="Expr"/>
    </template></struct></namespace><data-member name="deep_copy"><type><classname>functional::deep_copy</classname> const</type></data-member></namespace></namespace></header><header name="boost/xpressive/proto/domain.hpp"><para>Contains definition of domain&lt;&gt; class template, for defining domains with a grammar for controlling operator overloading. </para><namespace name="boost"><namespace name="proto"><namespace name="domainns_"><struct name="domain"><template>
      <template-type-parameter name="Generator"/>
      <template-type-parameter name="Grammar"/>
    </template><inherit access="public">Generator</inherit><typedef name="grammar"><type>Grammar</type></typedef></struct><struct name="default_domain"><inherit access="public">boost::proto::domainns_::domain&lt;  &gt;</inherit></struct><struct name="deduce_domain"/></namespace><namespace name="result_of"><struct name="is_domain"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="EnableIf"/>
    </template></struct><struct name="domain_of"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="EnableIf"/>
    </template><typedef name="type"><type><classname>default_domain</classname></type></typedef></struct><struct-specialization name="is_domain"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>typename T::proto_is_domain_</template-arg></specialization></struct-specialization><struct-specialization name="domain_of"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>typename T::proto_is_expr_</template-arg></specialization><typedef name="type"><type>T::proto_domain</type></typedef></struct-specialization></namespace></namespace></namespace></header><header name="boost/xpressive/proto/eval.hpp"><para>Contains the eval() expression evaluator. </para><namespace name="boost"><namespace name="proto"><namespace name="functional"><struct name="eval"><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>Context)</template-arg></specialization><inherit access="public">boost::proto::result_of::eval&lt; remove_reference&lt; Expr &gt;::type, remove_reference&lt; Context &gt;::type &gt;</inherit></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>proto::result_of::eval</classname>&lt; Expr, Context &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="Context"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>proto::result_of::eval</classname>&lt; Expr, Context &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="Context"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context const &amp;</paramtype></parameter></method></method-group></struct></namespace><namespace name="result_of"><struct name="eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><typedef name="type"><type>Context::template <classname>eval</classname>&lt; Expr &gt;::result_type</type></typedef></struct></namespace><data-member name="eval"><type><classname>functional::eval</classname> const</type></data-member></namespace></namespace></header><header name="boost/xpressive/proto/expr.hpp"><para>Contains definition of expr&lt;&gt; class template. </para><namespace name="boost"><namespace name="proto"><namespace name="exprns_"><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>0</template-arg></specialization><purpose>Representation of a node in an expression tree. </purpose><description><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a node in an expression template tree. It is a container for its children sub-trees. It also serves as the terminal nodes of the tree.</para><para><computeroutput>Tag</computeroutput> is type that represents the operation encoded by this expression. It is typically one of the structs in the <computeroutput>boost::proto::tag</computeroutput> namespace, but it doesn't have to be. If the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput> then this <computeroutput>expr&lt;&gt;</computeroutput> type represents a leaf in the expression tree.</para><para><computeroutput>Args</computeroutput> is a type list representing the type of the children of this expression. It is an instantiation of one of <computeroutput>proto::args1&lt;&gt;</computeroutput>, <computeroutput>proto::args2&lt;&gt;</computeroutput>, etc. The children types must all themselves be either <computeroutput>expr&lt;&gt;</computeroutput> or <computeroutput>proto::ref_&lt;proto::expr&lt;&gt;&gt;</computeroutput>, unless the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput>, in which case <computeroutput>Args</computeroutput> must be <computeroutput>proto::args1&lt;T&gt;</computeroutput>, where <computeroutput>T</computeroutput> can be any type. </para></description><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr &gt;::type</type></typedef></struct><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arity"><type>mpl::long_&lt; 0 &gt;</type></typedef><typedef name="proto_base_expr"><type>expr</type></typedef><typedef name="proto_args"><type>Args</type></typedef><typedef name="proto_domain"><type><classname>default_domain</classname></type></typedef><typedef name="fusion_tag"><type>tag::proto_expr</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>expr</type></typedef><typedef name="proto_arg0"><type>Args::arg0</type></typedef><typedef name="proto_arg1"><type>void</type></typedef><typedef name="proto_arg2"><type>void</type></typedef><typedef name="proto_arg3"><type>void</type></typedef><typedef name="proto_arg4"><type>void</type></typedef><method-group name="public member functions"><method name="proto_base" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="proto_base" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv=""><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv=""><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv=""><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref_</classname>&lt; expr &gt; &gt; &gt; const</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><data-member name="arg0"><type>proto_arg0</type></data-member><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-nontype-parameter name="N"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-nontype-parameter name="N"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>1</template-arg></specialization><purpose>Representation of a node in an expression tree. </purpose><description><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a node in an expression template tree. It is a container for its children sub-trees. It also serves as the terminal nodes of the tree.</para><para><computeroutput>Tag</computeroutput> is type that represents the operation encoded by this expression. It is typically one of the structs in the <computeroutput>boost::proto::tag</computeroutput> namespace, but it doesn't have to be. If the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput> then this <computeroutput>expr&lt;&gt;</computeroutput> type represents a leaf in the expression tree.</para><para><computeroutput>Args</computeroutput> is a type list representing the type of the children of this expression. It is an instantiation of one of <computeroutput>proto::args1&lt;&gt;</computeroutput>, <computeroutput>proto::args2&lt;&gt;</computeroutput>, etc. The children types must all themselves be either <computeroutput>expr&lt;&gt;</computeroutput> or <computeroutput>proto::ref_&lt;proto::expr&lt;&gt;&gt;</computeroutput>, unless the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput>, in which case <computeroutput>Args</computeroutput> must be <computeroutput>proto::args1&lt;T&gt;</computeroutput>, where <computeroutput>T</computeroutput> can be any type. </para></description><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr &gt;::type</type></typedef></struct><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arity"><type>mpl::long_&lt; 1 &gt;</type></typedef><typedef name="proto_base_expr"><type>expr</type></typedef><typedef name="proto_args"><type>Args</type></typedef><typedef name="proto_domain"><type><classname>default_domain</classname></type></typedef><typedef name="fusion_tag"><type>tag::proto_expr</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>expr</type></typedef><typedef name="proto_arg0"><type>Args::arg0</type></typedef><typedef name="proto_arg1"><type>void</type></typedef><typedef name="proto_arg2"><type>void</type></typedef><typedef name="proto_arg3"><type>void</type></typedef><typedef name="proto_arg4"><type>void</type></typedef><typedef name="address_of_hack_type_"><description><para>If <computeroutput>Tag</computeroutput> is <computeroutput>boost::proto::tag::address_of</computeroutput> and <computeroutput>proto_arg0</computeroutput> is <computeroutput>proto::ref_&lt;T&gt;</computeroutput>, then <computeroutput>address_of_hack_type_</computeroutput> is <computeroutput>T*</computeroutput>. Otherwise, it is some undefined type. </para></description><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="proto_base" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="proto_base" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="conversion-operator" cv="const"><type>address_of_hack_type_</type><description><para>

</para></description><returns><para>The address of <computeroutput>this-&gt;arg0</computeroutput> if <computeroutput>Tag</computeroutput> is <computeroutput>boost::proto::tag::address_of</computeroutput>. Otherwise, this function will fail to compile.</para></returns><notes><para>Proto overloads <computeroutput>operator&amp;</computeroutput>, which means that proto-ified objects cannot have their addresses taken, unless we use the following hack to make <computeroutput>&amp;x</computeroutput> implicitly convertible to <computeroutput>X*</computeroutput>. </para></notes></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><data-member name="arg0"><type>proto_arg0</type></data-member><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>2</template-arg></specialization><purpose>Representation of a node in an expression tree. </purpose><description><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a node in an expression template tree. It is a container for its children sub-trees. It also serves as the terminal nodes of the tree.</para><para><computeroutput>Tag</computeroutput> is type that represents the operation encoded by this expression. It is typically one of the structs in the <computeroutput>boost::proto::tag</computeroutput> namespace, but it doesn't have to be. If the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput> then this <computeroutput>expr&lt;&gt;</computeroutput> type represents a leaf in the expression tree.</para><para><computeroutput>Args</computeroutput> is a type list representing the type of the children of this expression. It is an instantiation of one of <computeroutput>proto::args1&lt;&gt;</computeroutput>, <computeroutput>proto::args2&lt;&gt;</computeroutput>, etc. The children types must all themselves be either <computeroutput>expr&lt;&gt;</computeroutput> or <computeroutput>proto::ref_&lt;proto::expr&lt;&gt;&gt;</computeroutput>, unless the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput>, in which case <computeroutput>Args</computeroutput> must be <computeroutput>proto::args1&lt;T&gt;</computeroutput>, where <computeroutput>T</computeroutput> can be any type. </para></description><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr &gt;::type</type></typedef></struct><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arity"><type>mpl::long_&lt; 2 &gt;</type></typedef><typedef name="proto_base_expr"><type>expr</type></typedef><typedef name="proto_args"><type>Args</type></typedef><typedef name="proto_domain"><type><classname>default_domain</classname></type></typedef><typedef name="fusion_tag"><type>tag::proto_expr</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>expr</type></typedef><typedef name="proto_arg0"><type>Args::arg0</type></typedef><typedef name="proto_arg1"><type>Args::arg1</type></typedef><typedef name="proto_arg2"><type>void</type></typedef><typedef name="proto_arg3"><type>void</type></typedef><typedef name="proto_arg4"><type>void</type></typedef><method-group name="public member functions"><method name="proto_base" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="proto_base" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><data-member name="arg0"><type>proto_arg0</type></data-member><data-member name="arg1"><type>proto_arg1</type></data-member><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>3</template-arg></specialization><purpose>Representation of a node in an expression tree. </purpose><description><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a node in an expression template tree. It is a container for its children sub-trees. It also serves as the terminal nodes of the tree.</para><para><computeroutput>Tag</computeroutput> is type that represents the operation encoded by this expression. It is typically one of the structs in the <computeroutput>boost::proto::tag</computeroutput> namespace, but it doesn't have to be. If the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput> then this <computeroutput>expr&lt;&gt;</computeroutput> type represents a leaf in the expression tree.</para><para><computeroutput>Args</computeroutput> is a type list representing the type of the children of this expression. It is an instantiation of one of <computeroutput>proto::args1&lt;&gt;</computeroutput>, <computeroutput>proto::args2&lt;&gt;</computeroutput>, etc. The children types must all themselves be either <computeroutput>expr&lt;&gt;</computeroutput> or <computeroutput>proto::ref_&lt;proto::expr&lt;&gt;&gt;</computeroutput>, unless the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput>, in which case <computeroutput>Args</computeroutput> must be <computeroutput>proto::args1&lt;T&gt;</computeroutput>, where <computeroutput>T</computeroutput> can be any type. </para></description><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr &gt;::type</type></typedef></struct><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arity"><type>mpl::long_&lt; 3 &gt;</type></typedef><typedef name="proto_base_expr"><type>expr</type></typedef><typedef name="proto_args"><type>Args</type></typedef><typedef name="proto_domain"><type><classname>default_domain</classname></type></typedef><typedef name="fusion_tag"><type>tag::proto_expr</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>expr</type></typedef><typedef name="proto_arg0"><type>Args::arg0</type></typedef><typedef name="proto_arg1"><type>Args::arg1</type></typedef><typedef name="proto_arg2"><type>Args::arg2</type></typedef><typedef name="proto_arg3"><type>void</type></typedef><typedef name="proto_arg4"><type>void</type></typedef><method-group name="public member functions"><method name="proto_base" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="proto_base" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><data-member name="arg0"><type>proto_arg0</type></data-member><data-member name="arg1"><type>proto_arg1</type></data-member><data-member name="arg2"><type>proto_arg2</type></data-member><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>4</template-arg></specialization><purpose>Representation of a node in an expression tree. </purpose><description><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a node in an expression template tree. It is a container for its children sub-trees. It also serves as the terminal nodes of the tree.</para><para><computeroutput>Tag</computeroutput> is type that represents the operation encoded by this expression. It is typically one of the structs in the <computeroutput>boost::proto::tag</computeroutput> namespace, but it doesn't have to be. If the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput> then this <computeroutput>expr&lt;&gt;</computeroutput> type represents a leaf in the expression tree.</para><para><computeroutput>Args</computeroutput> is a type list representing the type of the children of this expression. It is an instantiation of one of <computeroutput>proto::args1&lt;&gt;</computeroutput>, <computeroutput>proto::args2&lt;&gt;</computeroutput>, etc. The children types must all themselves be either <computeroutput>expr&lt;&gt;</computeroutput> or <computeroutput>proto::ref_&lt;proto::expr&lt;&gt;&gt;</computeroutput>, unless the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput>, in which case <computeroutput>Args</computeroutput> must be <computeroutput>proto::args1&lt;T&gt;</computeroutput>, where <computeroutput>T</computeroutput> can be any type. </para></description><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr &gt;::type</type></typedef></struct><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arity"><type>mpl::long_&lt; 4 &gt;</type></typedef><typedef name="proto_base_expr"><type>expr</type></typedef><typedef name="proto_args"><type>Args</type></typedef><typedef name="proto_domain"><type><classname>default_domain</classname></type></typedef><typedef name="fusion_tag"><type>tag::proto_expr</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>expr</type></typedef><typedef name="proto_arg0"><type>Args::arg0</type></typedef><typedef name="proto_arg1"><type>Args::arg1</type></typedef><typedef name="proto_arg2"><type>Args::arg2</type></typedef><typedef name="proto_arg3"><type>Args::arg3</type></typedef><typedef name="proto_arg4"><type>void</type></typedef><method-group name="public member functions"><method name="proto_base" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="proto_base" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><data-member name="arg0"><type>proto_arg0</type></data-member><data-member name="arg1"><type>proto_arg1</type></data-member><data-member name="arg2"><type>proto_arg2</type></data-member><data-member name="arg3"><type>proto_arg3</type></data-member><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>5</template-arg></specialization><purpose>Representation of a node in an expression tree. </purpose><description><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a node in an expression template tree. It is a container for its children sub-trees. It also serves as the terminal nodes of the tree.</para><para><computeroutput>Tag</computeroutput> is type that represents the operation encoded by this expression. It is typically one of the structs in the <computeroutput>boost::proto::tag</computeroutput> namespace, but it doesn't have to be. If the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput> then this <computeroutput>expr&lt;&gt;</computeroutput> type represents a leaf in the expression tree.</para><para><computeroutput>Args</computeroutput> is a type list representing the type of the children of this expression. It is an instantiation of one of <computeroutput>proto::args1&lt;&gt;</computeroutput>, <computeroutput>proto::args2&lt;&gt;</computeroutput>, etc. The children types must all themselves be either <computeroutput>expr&lt;&gt;</computeroutput> or <computeroutput>proto::ref_&lt;proto::expr&lt;&gt;&gt;</computeroutput>, unless the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput>, in which case <computeroutput>Args</computeroutput> must be <computeroutput>proto::args1&lt;T&gt;</computeroutput>, where <computeroutput>T</computeroutput> can be any type. </para></description><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr &gt;::type</type></typedef></struct><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arity"><type>mpl::long_&lt; 5 &gt;</type></typedef><typedef name="proto_base_expr"><type>expr</type></typedef><typedef name="proto_args"><type>Args</type></typedef><typedef name="proto_domain"><type><classname>default_domain</classname></type></typedef><typedef name="fusion_tag"><type>tag::proto_expr</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>expr</type></typedef><typedef name="proto_arg0"><type>Args::arg0</type></typedef><typedef name="proto_arg1"><type>Args::arg1</type></typedef><typedef name="proto_arg2"><type>Args::arg2</type></typedef><typedef name="proto_arg3"><type>Args::arg3</type></typedef><typedef name="proto_arg4"><type>Args::arg4</type></typedef><method-group name="public member functions"><method name="proto_base" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="proto_base" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>expr&lt; <classname>tag::subscript</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt;, typename <classname>result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref_</classname>&lt; expr const  &gt; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const , const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const , const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const , const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const , const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><data-member name="arg0"><type>proto_arg0</type></data-member><data-member name="arg1"><type>proto_arg1</type></data-member><data-member name="arg2"><type>proto_arg2</type></data-member><data-member name="arg3"><type>proto_arg3</type></data-member><data-member name="arg4"><type>proto_arg4</type></data-member><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
          <template-type-parameter name="A4"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><parameter name="a4"><paramtype>A4 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group></struct-specialization></namespace><namespace name="result_of"><struct name="funop0"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>expr&lt; <classname>tag::function</classname>, <classname>args1</classname>&lt; <classname>ref_</classname>&lt; Expr &gt;&gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr()</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop0&lt; This &gt;</inherit></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr const ()</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop0&lt; This const  &gt;</inherit></struct-specialization><struct name="funop1"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
    </template><typedef name="type"><type>expr&lt; <classname>tag::function</classname>, <classname>args2</classname>&lt; <classname>ref_</classname>&lt; Expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A0 &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr(A0)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop1&lt; This, remove_reference&lt; A0 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr const (A0)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop1&lt; This const , remove_reference&lt; A0 &gt;::type &gt;</inherit></struct-specialization><struct name="funop2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><typedef name="type"><type>expr&lt; <classname>tag::function</classname>, <classname>args3</classname>&lt; <classname>ref_</classname>&lt; Expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A0 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A1 &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr(A0</template-arg><template-arg>A1)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop2&lt; This, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr const (A0</template-arg><template-arg>A1)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop2&lt; This const , remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type &gt;</inherit></struct-specialization><struct name="funop3"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><typedef name="type"><type>expr&lt; <classname>tag::function</classname>, <classname>args4</classname>&lt; <classname>ref_</classname>&lt; Expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A0 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A1 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A2 &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop3&lt; This, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr const (A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop3&lt; This const , remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type &gt;</inherit></struct-specialization><struct name="funop4"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><typedef name="type"><type>expr&lt; <classname>tag::function</classname>, <classname>args5</classname>&lt; <classname>ref_</classname>&lt; Expr &gt;, typename <classname>result_of::as_arg</classname>&lt; A0 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A1 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A2 &gt;::type, typename <classname>result_of::as_arg</classname>&lt; A3 &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop4&lt; This, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type, remove_reference&lt; A3 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="This"/>
    </template><specialization><template-arg>Expr const (A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg><template-arg>This</template-arg></specialization><inherit access="public">boost::proto::result_of::funop4&lt; This const , remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type, remove_reference&lt; A3 &gt;::type &gt;</inherit></struct-specialization></namespace></namespace></namespace></header><header name="boost/xpressive/proto/extends.hpp"><para>Macros and a base class for defining end-user expression types </para><namespace name="boost"><namespace name="proto"><namespace name="exprns_"><struct name="is_proto_expr"><purpose>Empty type to be used as a dummy template parameter of POD expression wrappers. It allows argument-dependent lookup to find Proto's operator overloads. </purpose><description><para><computeroutput>proto::is_proto_expr</computeroutput> allows argument-dependent lookup to find Proto's operator overloads. For example:</para><para><programlisting>












/// 
</programlisting></para><para>Without the second <computeroutput>Dummy</computeroutput> template parameter, Proto's operator overloads would not be considered by name lookup. </para></description></struct><struct name="extends"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Derived"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="Tag"/>
    </template><purpose>extends&lt;&gt; class template for adding behaviors to a proto expression template </purpose><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><typedef name="type"><type>boost::mpl::apply_wrap1&lt; Domain, typename boost::proto::result_of::funop&lt; Sig, Derived &gt;::type &gt;::type</type></typedef></struct><typedef name="proto_base_expr"><type>Expr</type></typedef><typedef name="proto_domain"><type>Domain</type></typedef><typedef name="proto_derived_expr"><type>Derived</type></typedef><typedef name="proto_tag"><type>Expr::proto_tag</type></typedef><typedef name="proto_args"><type>Expr::proto_args</type></typedef><typedef name="proto_arity"><type>Expr::proto_arity</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="fusion_tag"><type>boost::proto::tag::proto_expr</type></typedef><typedef name="proto_arg0"><type>Expr::proto_arg0</type></typedef><typedef name="proto_arg1"><type>Expr::proto_arg1</type></typedef><typedef name="proto_arg2"><type>Expr::proto_arg2</type></typedef><typedef name="proto_arg3"><type>Expr::proto_arg3</type></typedef><typedef name="proto_arg4"><type>Expr::proto_arg4</type></typedef><method-group name="public member functions"><method name="proto_base" cv=""><type>Expr &amp;</type></method><method name="proto_base" cv="const"><type>Expr const &amp;</type></method><method name="operator[]" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; boost::proto::ref_&lt; Derived const  &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; boost::proto::ref_&lt; Derived const  &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop0</classname>&lt; Derived const  &gt;::type &gt;::type const</type></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop1</classname>&lt; Derived const , const A0 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop2</classname>&lt; Derived const , const A0, const A1 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop3</classname>&lt; Derived const , const A0, const A1, const A2 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop4</classname>&lt; Derived const , const A0, const A1, const A2, const A3 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter></method></method-group><constructor/><constructor><parameter name="that"><paramtype><classname>extends</classname> const &amp;</paramtype></parameter></constructor><constructor><parameter name="expr_"><paramtype>Expr const &amp;</paramtype></parameter></constructor><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment><data-member name="expr"><type>Expr</type></data-member><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static Derived const</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="extends"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Derived"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Derived</template-arg><template-arg>Domain</template-arg><template-arg>tag::terminal</template-arg></specialization><purpose>extends&lt;&gt; class template for adding behaviors to a proto expression template </purpose><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><typedef name="type"><type>boost::mpl::apply_wrap1&lt; Domain, typename boost::proto::result_of::funop&lt; Sig, Derived &gt;::type &gt;::type</type></typedef></struct><typedef name="proto_base_expr"><type>Expr</type></typedef><typedef name="proto_domain"><type>Domain</type></typedef><typedef name="proto_derived_expr"><type>Derived</type></typedef><typedef name="proto_tag"><type>Expr::proto_tag</type></typedef><typedef name="proto_args"><type>Expr::proto_args</type></typedef><typedef name="proto_arity"><type>Expr::proto_arity</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="fusion_tag"><type>boost::proto::tag::proto_expr</type></typedef><typedef name="proto_arg0"><type>Expr::proto_arg0</type></typedef><typedef name="proto_arg1"><type>Expr::proto_arg1</type></typedef><typedef name="proto_arg2"><type>Expr::proto_arg2</type></typedef><typedef name="proto_arg3"><type>Expr::proto_arg3</type></typedef><typedef name="proto_arg4"><type>Expr::proto_arg4</type></typedef><method-group name="public member functions"><method name="extends" cv=""><type/></method><method name="extends" cv=""><type/><parameter name="that"><paramtype><classname>extends</classname> const &amp;</paramtype></parameter></method><method name="extends" cv=""><type/><parameter name="expr_"><paramtype>Expr const &amp;</paramtype></parameter></method><method name="proto_base" cv=""><type>Expr &amp;</type></method><method name="proto_base" cv="const"><type>Expr const &amp;</type></method><method name="operator[]" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; boost::proto::ref_&lt; Derived const  &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; boost::proto::ref_&lt; Derived const  &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator[]" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; boost::proto::ref_&lt; Derived &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator[]" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, boost::proto::expr&lt; <classname>boost::proto::tag::subscript</classname>, <classname>boost::proto::args2</classname>&lt; boost::proto::ref_&lt; Derived &gt;, typename <classname>boost::proto::result_of::as_arg</classname>&lt; A const  &gt;::type &gt; &gt; &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop0</classname>&lt; Derived const  &gt;::type &gt;::type const</type></method><method name="operator()" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop0</classname>&lt; Derived &gt;::type &gt;::type const</type></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop1</classname>&lt; Derived const , const A0 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></method><method name="operator()" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop1</classname>&lt; Derived, const A0 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop2</classname>&lt; Derived const , const A0, const A1 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter></method><method name="operator()" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop2</classname>&lt; Derived, const A0, const A1 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop3</classname>&lt; Derived const , const A0, const A1, const A2 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter></method><method name="operator()" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop3</classname>&lt; Derived, const A0, const A1, const A2 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop4</classname>&lt; Derived const , const A0, const A1, const A2, const A3 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter></method><method name="operator()" cv=""><type>boost::mpl::apply_wrap1&lt; Domain, typename <classname>boost::proto::result_of::funop4</classname>&lt; Derived, const A0, const A1, const A2, const A3 &gt;::type &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></copy-assignment><data-member name="expr"><type>Expr</type></data-member><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method><method name="make" cv=""><type>static Derived const</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization></namespace></namespace></namespace></header><header name="boost/xpressive/proto/fusion.hpp"><para>Make any Proto parse tree a valid Fusion sequence </para><namespace name="boost"><namespace name="fusion"><namespace name="extension"><struct name="as_element"><template>
      <template-type-parameter name="Tag"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization></struct-specialization></struct><struct-specialization name="is_view_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_ref</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Iterator"/>
    </template></struct></struct-specialization><struct-specialization name="is_view_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_expr</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Iterator"/>
    </template></struct></struct-specialization><struct-specialization name="value_of_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_ref_iterator</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Iterator"/>
    </template><inherit access="public">boost::proto::result_of::arg&lt; Iterator::expr_type, Iterator::index &gt;</inherit></struct></struct-specialization><struct-specialization name="deref_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_ref_iterator</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Iterator"/>
    </template><typedef name="type"><type><classname>proto::result_of::arg</classname>&lt; typename Iterator::expr_type, typename Iterator::index &gt;::type const &amp;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type</type><parameter name="iter"><paramtype>Iterator const &amp;</paramtype></parameter></method></method-group></struct></struct-specialization><struct-specialization name="advance_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_ref_iterator</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Iterator"/>
      <template-type-parameter name="N"/>
    </template><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>type</classname></type><parameter name="iter"><paramtype>Iterator const &amp;</paramtype></parameter></method></method-group></struct></struct-specialization><struct-specialization name="distance_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_ref_iterator</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="IteratorFrom"/>
      <template-type-parameter name="IteratorTo"/>
    </template></struct></struct-specialization><struct-specialization name="next_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_ref_iterator</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Iterator"/>
    </template></struct></struct-specialization><struct-specialization name="prior_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_ref_iterator</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Iterator"/>
    </template></struct></struct-specialization><struct-specialization name="category_of_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_ref</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
    </template><typedef name="type"><type>random_access_traversal_tag</type></typedef></struct></struct-specialization><struct-specialization name="size_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_ref</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
    </template></struct></struct-specialization><struct-specialization name="begin_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_ref</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
    </template><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>type</classname></type><parameter name="seq"><paramtype>Sequence &amp;</paramtype></parameter></method></method-group></struct></struct-specialization><struct-specialization name="end_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_ref</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
    </template><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>type</classname></type><parameter name="seq"><paramtype>Sequence &amp;</paramtype></parameter></method></method-group></struct></struct-specialization><struct-specialization name="value_at_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_ref</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
      <template-type-parameter name="N"/>
    </template><typedef name="type"><type><classname>proto::result_of::arg</classname>&lt; Sequence, N &gt;::type</type></typedef></struct></struct-specialization><struct-specialization name="at_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_ref</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
      <template-type-parameter name="N"/>
    </template><typedef name="type"><type><classname>proto::result_of::arg</classname>&lt; Sequence, N &gt;::type const &amp;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type</type><parameter name="seq"><paramtype>Sequence &amp;</paramtype></parameter></method></method-group></struct></struct-specialization><struct-specialization name="is_segmented_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_expr</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Iterator"/>
    </template></struct></struct-specialization><struct-specialization name="segments_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_expr</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
    </template><typedef name="proto_tag"><type>Sequence::proto_tag</type></typedef><typedef name="type"><type>fusion::transform_view&lt; proto::ref_&lt; Sequence &gt;, <classname>as_element</classname>&lt; proto_tag &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type</type><parameter name="sequence"><paramtype>Sequence &amp;</paramtype></parameter></method></method-group></struct></struct-specialization><struct-specialization name="category_of_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_expr</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
    </template><typedef name="type"><type>forward_traversal_tag</type></typedef></struct></struct-specialization><struct-specialization name="begin_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_expr</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
    </template></struct></struct-specialization><struct-specialization name="end_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_expr</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
    </template></struct></struct-specialization><struct-specialization name="size_impl"><template>
    </template><specialization><template-arg>proto::tag::proto_expr</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Sequence"/>
    </template></struct></struct-specialization></namespace></namespace><namespace name="proto"><struct name="children"><template>
      <template-type-parameter name="Expr"/>
    </template><method-group name="public member functions"/><constructor><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></constructor></struct><struct name="eval_fun"><template>
      <template-type-parameter name="Context"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><typedef name="type"><type>Context::template eval&lt; typename remove_reference&lt; Expr &gt;::type &gt;::result_type</type></typedef></struct-specialization><method-group name="public member functions"/><constructor><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></constructor></struct><function name="children_of"><type><classname>children</classname>&lt; Expr &gt;</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></function></namespace></namespace></header><header name="boost/xpressive/proto/generate.hpp"><para>Contains definition of generate&lt;&gt; class template, which end users can specialize for generating domain-specific expression wrappers. </para><namespace name="boost"><namespace name="proto"><namespace name="generatorns_"><struct name="default_generator"><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>Expr</type></typedef></struct><method-group name="public static functions"><method name="make" cv=""><type>static Expr const &amp;</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="generator"><template>
      <template-nontype-parameter name="Extends"><type>template&lt; typename &gt; class</type></template-nontype-parameter>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>Extends&lt; Expr &gt;</type></typedef></struct><method-group name="public static functions"><method name="make" cv=""><type>static Extends&lt; Expr &gt;</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="pod_generator"><template>
      <template-nontype-parameter name="Extends"><type>template&lt; typename &gt; class</type></template-nontype-parameter>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>Extends&lt; Expr &gt;</type></typedef></struct><method-group name="public static functions"><method name="make" cv=""><type>static Extends&lt; Expr &gt;</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/literal.hpp"><para>The literal&lt;&gt; terminal wrapper, and the proto::lit() function for creating literal&lt;&gt; wrappers. </para><namespace name="boost"><namespace name="proto"><namespace name="utility"><struct name="literal"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"/>
    </template><inherit access="public">boost::proto::exprns_::extends&lt; Expr, Derived, Domain, Tag &gt;</inherit><typedef name="terminal_type"><type><classname>terminal</classname>&lt; T &gt;::type</type></typedef><typedef name="base_type"><type><classname>extends</classname>&lt; terminal_type, <classname>literal</classname>&lt; T, Domain &gt;, Domain &gt;</type></typedef><method-group name="public member functions"/><constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype>U &amp;</paramtype></parameter></constructor><constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype>U const &amp;</paramtype></parameter></constructor><constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype><classname>literal</classname>&lt; U, Domain &gt; const &amp;</paramtype></parameter></constructor></struct></namespace><overloaded-function name="lit"><signature><type><classname>literal</classname>&lt; T &amp; &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></signature><signature><type><classname>literal</classname>&lt; T const &amp; &gt;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></signature><description><para>lit </para></description></overloaded-function></namespace></namespace></header><header name="boost/xpressive/proto/make_expr.hpp"><para>Given a Fusion sequence of arguments and the type of a proto Expression, unpacks the sequence into the Expression. </para><namespace name="boost"><namespace name="fusion"/><namespace name="proto"><namespace name="functional"><struct name="make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>This(A0)</template-arg></specialization><inherit access="public">boost::proto::result_of::make_expr&lt; Tag, Domain, remove_reference&lt; A0 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>This(A0</template-arg><template-arg>A1)</template-arg></specialization><inherit access="public">boost::proto::result_of::make_expr&lt; Tag, Domain, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg></specialization><inherit access="public">boost::proto::result_of::make_expr&lt; Tag, Domain, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg></specialization><inherit access="public">boost::proto::result_of::make_expr&lt; Tag, Domain, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type, remove_reference&lt; A3 &gt;::type &gt;</inherit></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4)</template-arg></specialization><inherit access="public">boost::proto::result_of::make_expr&lt; Tag, Domain, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type, remove_reference&lt; A3 &gt;::type, remove_reference&lt; A4 &gt;::type &gt;</inherit></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, A &gt;::type const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>const A3 &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const A0, const A1, const A2, const A3, const A4 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
          <template-type-parameter name="A4"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>const A3 &amp;</paramtype></parameter><parameter name="a4"><paramtype>const A4 &amp;</paramtype></parameter></method></method-group></struct><struct name="unpack_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>This(Sequence)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::unpack_expr</classname>&lt; Tag, Domain, Sequence &gt;::type</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="sequence"><paramtype>Sequence const &amp;</paramtype></parameter></method></method-group></struct><struct name="unfused_expr_fun"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Sequence"/>
    </template><inherit access="public">boost::proto::result_of::unpack_expr&lt; Tag, Domain, Sequence &gt;</inherit></struct><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>proto::result_of::unpack_expr</classname>&lt; Tag, Domain, Sequence &gt;::type</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="sequence"><paramtype>Sequence const &amp;</paramtype></parameter></method></method-group></struct><struct name="unfused_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"/>
    </template></struct><struct-specialization name="make_expr"><template>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>tag::terminal</template-arg><template-arg>Domain</template-arg></specialization><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A"/>
    </template><specialization><template-arg>This(A)</template-arg></specialization><inherit access="public">boost::proto::result_of::make_expr&lt; tag::terminal, Domain, A &gt;</inherit></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; <classname>tag::terminal</classname>, Domain, A &gt;::type</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; <classname>tag::terminal</classname>, Domain, A const  &gt;::type</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter></method></method-group></struct-specialization></namespace><namespace name="result_of"><struct name="unpack_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Sequence"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template></struct><struct name="make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template></struct><struct-specialization name="make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>deduce_domain</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4</template-arg><template-arg>void</template-arg></specialization></struct-specialization><struct-specialization name="unpack_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Domain</template-arg><template-arg>Sequence</template-arg><template-arg>typename Domain::proto_is_domain_</template-arg></specialization></struct-specialization><struct-specialization name="make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Domain</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4</template-arg><template-arg>typename Domain::proto_is_domain_</template-arg></specialization></struct-specialization></namespace><overloaded-function name="unpack_expr"><signature><type>lazy_disable_if&lt; <classname>is_domain</classname>&lt; Sequence &gt;, <classname>result_of::unpack_expr</classname>&lt; Tag, Sequence &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="sequence"><paramtype>Sequence const &amp;</paramtype></parameter></signature><signature><type><classname>result_of::unpack_expr</classname>&lt; Tag, Domain, Sequence2 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="Sequence2"/>
        </template><parameter name="sequence2"><paramtype>Sequence2 const &amp;</paramtype></parameter></signature><description><para>unpack_expr </para></description></overloaded-function><overloaded-function name="make_expr"><signature><type>lazy_disable_if&lt; <classname>is_domain</classname>&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, A0 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, B0 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
        </template><parameter name="b0"><paramtype>B0 &amp;</paramtype></parameter></signature><signature><type>lazy_disable_if&lt; <classname>is_domain</classname>&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, const A0 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const B0 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
        </template><parameter name="b0"><paramtype>const B0 &amp;</paramtype></parameter></signature><signature><type>lazy_disable_if&lt; <classname>is_domain</classname>&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, const A0, const A1 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const B0, const B1 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
          <template-type-parameter name="B1"/>
        </template><parameter name="b0"><paramtype>const B0 &amp;</paramtype></parameter><parameter name="b1"><paramtype>const B1 &amp;</paramtype></parameter></signature><signature><type>lazy_disable_if&lt; <classname>is_domain</classname>&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, const A0, const A1, const A2 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const B0, const B1, const B2 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
          <template-type-parameter name="B1"/>
          <template-type-parameter name="B2"/>
        </template><parameter name="b0"><paramtype>const B0 &amp;</paramtype></parameter><parameter name="b1"><paramtype>const B1 &amp;</paramtype></parameter><parameter name="b2"><paramtype>const B2 &amp;</paramtype></parameter></signature><signature><type>lazy_disable_if&lt; <classname>is_domain</classname>&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, const A0, const A1, const A2, const A3 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>const A3 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const B0, const B1, const B2, const B3 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
          <template-type-parameter name="B1"/>
          <template-type-parameter name="B2"/>
          <template-type-parameter name="B3"/>
        </template><parameter name="b0"><paramtype>const B0 &amp;</paramtype></parameter><parameter name="b1"><paramtype>const B1 &amp;</paramtype></parameter><parameter name="b2"><paramtype>const B2 &amp;</paramtype></parameter><parameter name="b3"><paramtype>const B3 &amp;</paramtype></parameter></signature><signature><type>lazy_disable_if&lt; <classname>is_domain</classname>&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, const A0, const A1, const A2, const A3, const A4 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
          <template-type-parameter name="A4"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>const A3 &amp;</paramtype></parameter><parameter name="a4"><paramtype>const A4 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const B0, const B1, const B2, const B3, const B4 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
          <template-type-parameter name="B1"/>
          <template-type-parameter name="B2"/>
          <template-type-parameter name="B3"/>
          <template-type-parameter name="B4"/>
        </template><parameter name="b0"><paramtype>const B0 &amp;</paramtype></parameter><parameter name="b1"><paramtype>const B1 &amp;</paramtype></parameter><parameter name="b2"><paramtype>const B2 &amp;</paramtype></parameter><parameter name="b3"><paramtype>const B3 &amp;</paramtype></parameter><parameter name="b4"><paramtype>const B4 &amp;</paramtype></parameter></signature><description><para>make_expr </para></description></overloaded-function></namespace></namespace></header><header name="boost/xpressive/proto/matches.hpp"><para>Contains definition of matches&lt;&gt; metafunction for determining if a given expression matches a given pattern. </para><namespace name="boost"><namespace name="proto"><namespace name="control"><struct name="not_"><template>
      <template-type-parameter name="Grammar"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_identity_transform</inherit><typedef name="proto_base_expr"><type><classname>not_</classname></type></typedef></struct><struct name="if_"><template>
      <template-type-parameter name="Condition"/>
      <template-type-parameter name="Then"/>
      <template-type-parameter name="Else"/>
    </template><inherit access="public">boost::proto::control::or_&lt; and_&lt; if_&lt; Condition &gt;, Then &gt;, and_&lt; not_&lt; if_&lt; Condition &gt; &gt;, Else &gt; &gt;</inherit></struct><struct-specialization name="if_"><template>
      <template-type-parameter name="Condition"/>
      <template-type-parameter name="Then"/>
    </template><specialization><template-arg>Condition</template-arg><template-arg>Then</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::control::and_&lt; if_&lt; Condition &gt;, Then &gt;</inherit></struct-specialization><struct-specialization name="if_"><template>
      <template-type-parameter name="Condition"/>
    </template><specialization><template-arg>Condition</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_transformns_::has_identity_transform</inherit><typedef name="proto_base_expr"><type><classname>if_</classname></type></typedef></struct-specialization><struct name="or_"><template>
      <template-type-parameter name="G0"/>
      <template-type-parameter name="G1"/>
      <template-type-parameter name="G2"/>
      <template-type-parameter name="G3"/>
      <template-type-parameter name="G4"/>
      <template-type-parameter name="G5"/>
      <template-type-parameter name="G6"/>
      <template-type-parameter name="G7"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><typedef name="which"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="type"><type>which::template <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type></typedef></struct><typedef name="proto_base_expr"><type><classname>or_</classname></type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="and_"><template>
      <template-type-parameter name="G0"/>
      <template-type-parameter name="G1"/>
      <template-type-parameter name="G2"/>
      <template-type-parameter name="G3"/>
      <template-type-parameter name="G4"/>
      <template-type-parameter name="G5"/>
      <template-type-parameter name="G6"/>
      <template-type-parameter name="G7"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><typedef name="which"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="type"><type>which::template <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type></typedef></struct><typedef name="proto_base_expr"><type><classname>and_</classname></type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="switch_"><template>
      <template-type-parameter name="Cases"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><typedef name="proto_base_expr"><type><classname>switch_</classname></type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="exact"><template>
      <template-type-parameter name="T"/>
    </template></struct><struct name="convertible_to"><template>
      <template-type-parameter name="T"/>
    </template></struct><struct name="vararg"><template>
      <template-type-parameter name="Grammar"/>
    </template><typedef name="proto_is_vararg_"><type>void</type></typedef></struct></namespace><namespace name="result_of"><struct name="matches"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Grammar"/>
    </template></struct></namespace><namespace name="wildcardns_"><struct name="_"><inherit access="public">boost::proto::has_transformns_::has_identity_transform</inherit><typedef name="proto_base_expr"><type><classname>_</classname></type></typedef><typedef name="proto_is_wildcard_"><type>void</type></typedef></struct><function name="is_wildcard_expression_fun"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="T"/>
        </template><parameter name=""><paramtype>T const *</paramtype></parameter></function></namespace></namespace></namespace></header><header name="boost/xpressive/proto/operators.hpp"><para>Contains all the overloaded operators that make it possible to build expression templates using proto components </para><namespace name="boost"><namespace name="proto"><struct name="is_extension"><template>
      <template-type-parameter name="T"/>
    </template></struct><namespace name="exprns_"><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator~"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator~"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator!"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator!"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="if_else"><type><classname>boost::proto::result_of::make_expr</classname>&lt; <classname>tag::if_else_</classname>, <classname>deduce_domain</classname>, const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter><description><para>if_else </para></description></function></namespace></namespace></namespace></header><header name="boost/xpressive/proto/proto.hpp"><para>The proto expression template compiler and supporting utilities. </para></header><header name="boost/xpressive/proto/proto_fwd.hpp"><para>Forward declarations of all of proto's public types and functions. </para><namespace name="boost"><namespace name="proto"><namespace name="context"/><namespace name="control"><data-member name="N"><type>int const</type></data-member></namespace><namespace name="domainns_"/><namespace name="exops"/><namespace name="exprns_"/><namespace name="functional"/><namespace name="generatorns_"/><namespace name="has_transformns_"><struct name="has_identity_transform"><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method></method-group></struct></namespace><namespace name="op"/><namespace name="refns_"/><namespace name="result_of"/><namespace name="tag"/><namespace name="transform"/><namespace name="utility"/><namespace name="wildcardns_"/></namespace></namespace></header><header name="boost/xpressive/proto/ref.hpp"><para>Utility for storing a sub-expr by reference </para><namespace name="boost"><namespace name="proto"><namespace name="functional"><struct name="unref"><struct name="result"><template>
      <template-type-parameter name="T"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>T &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>T const &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>T &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype><classname>ref_</classname>&lt; T &gt; &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>T &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype><classname>ref_</classname>&lt; T &gt; const &amp;</paramtype></parameter></method></method-group></struct></namespace><namespace name="refns_"><struct name="ref_"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="proto_base_expr"><type>Expr::proto_base_expr</type></typedef><typedef name="proto_tag"><type>Expr::proto_tag</type></typedef><typedef name="proto_args"><type>Expr::proto_args</type></typedef><typedef name="proto_arity"><type>Expr::proto_arity</type></typedef><typedef name="proto_domain"><type>Expr::proto_domain</type></typedef><typedef name="fusion_tag"><type>tag::proto_ref</type></typedef><typedef name="proto_is_ref_"><type>void</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>Expr</type></typedef><typedef name="proto_arg0"><type>Expr::proto_arg0</type></typedef><typedef name="proto_arg1"><type>Expr::proto_arg1</type></typedef><typedef name="proto_arg2"><type>Expr::proto_arg2</type></typedef><typedef name="proto_arg3"><type>Expr::proto_arg3</type></typedef><typedef name="proto_arg4"><type>Expr::proto_arg4</type></typedef><method-group name="public member functions"><method name="proto_base" cv="const"><type>mpl::if_&lt; is_const &lt; Expr &gt;, proto_base_expr const &amp;, proto_base_expr &amp; &gt;::type</type></method></method-group><data-member name="expr"><type>Expr &amp;</type></data-member><method-group name="public static functions"><method name="make" cv=""><type>static <classname>ref_</classname>&lt; Expr &gt;</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="ref_"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>ref_&lt; Expr &gt;</template-arg></specialization></struct-specialization></namespace><namespace name="result_of"><struct name="unref"><template>
      <template-type-parameter name="T"/>
    </template><typedef name="type"><type>T</type></typedef><typedef name="reference"><type>T &amp;</type></typedef><typedef name="const_reference"><type>T const &amp;</type></typedef></struct><struct-specialization name="unref"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>ref_&lt; T &gt;</template-arg></specialization><typedef name="type"><type>T::proto_derived_expr</type></typedef><typedef name="reference"><type>T &amp;</type></typedef><typedef name="const_reference"><type>T &amp;</type></typedef></struct-specialization><struct-specialization name="unref"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T &amp;</template-arg></specialization><typedef name="type"><type>T</type></typedef><typedef name="reference"><type>T &amp;</type></typedef><typedef name="const_reference"><type>T &amp;</type></typedef></struct-specialization><struct-specialization name="unref"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T const &amp;</template-arg></specialization><typedef name="type"><type>T</type></typedef><typedef name="reference"><type>T const &amp;</type></typedef><typedef name="const_reference"><type>T const &amp;</type></typedef></struct-specialization></namespace><data-member name="unref"><type><classname>functional::unref</classname> const</type></data-member></namespace></namespace></header><header name="boost/xpressive/proto/tags.hpp"><para>Contains the tags for all the overloadable operators in C++ </para><namespace name="boost"><namespace name="proto"><namespace name="tag"><struct name="terminal"><purpose>Tag type for terminals; aka, leaves in the expression tree. </purpose></struct><struct name="posit"><purpose>Tag type for the unary + operator. </purpose></struct><struct name="negate"><purpose>Tag type for the unary - operator. </purpose></struct><struct name="dereference"><purpose>Tag type for the unary * operator. </purpose></struct><struct name="complement"><purpose>Tag type for the unary ~ operator. </purpose></struct><struct name="address_of"><purpose>Tag type for the unary &amp; operator. </purpose></struct><struct name="logical_not"><purpose>Tag type for the unary ! operator. </purpose></struct><struct name="pre_inc"><purpose>Tag type for the unary prefix ++ operator. </purpose></struct><struct name="pre_dec"><purpose>Tag type for the unary prefix -- operator. </purpose></struct><struct name="post_inc"><purpose>Tag type for the unary postfix ++ operator. </purpose></struct><struct name="post_dec"><purpose>Tag type for the unary postfix -- operator. </purpose></struct><struct name="shift_left"><purpose>Tag type for the binary &lt;&lt; operator. </purpose></struct><struct name="shift_right"><purpose>Tag type for the binary &gt;&gt; operator. </purpose></struct><struct name="multiplies"><purpose>Tag type for the binary * operator. </purpose></struct><struct name="divides"><purpose>Tag type for the binary / operator. </purpose></struct><struct name="modulus"><purpose>Tag type for the binary % operator. </purpose></struct><struct name="plus"><purpose>Tag type for the binary + operator. </purpose></struct><struct name="minus"><purpose>Tag type for the binary - operator. </purpose></struct><struct name="less"><purpose>Tag type for the binary &lt; operator. </purpose></struct><struct name="greater"><purpose>Tag type for the binary &gt; operator. </purpose></struct><struct name="less_equal"><purpose>Tag type for the binary &lt;= operator. </purpose></struct><struct name="greater_equal"><purpose>Tag type for the binary &gt;= operator. </purpose></struct><struct name="equal_to"><purpose>Tag type for the binary == operator. </purpose></struct><struct name="not_equal_to"><purpose>Tag type for the binary != operator. </purpose></struct><struct name="logical_or"><purpose>Tag type for the binary || operator. </purpose></struct><struct name="logical_and"><purpose>Tag type for the binary &amp;&amp; operator. </purpose></struct><struct name="bitwise_and"><purpose>Tag type for the binary &amp; operator. </purpose></struct><struct name="bitwise_or"><purpose>Tag type for the binary | operator. </purpose></struct><struct name="bitwise_xor"><purpose>Tag type for the binary ^ operator. </purpose></struct><struct name="comma"><purpose>Tag type for the binary , operator. </purpose></struct><struct name="mem_ptr"><purpose>Tag type for the binary -&gt;* operator. </purpose></struct><struct name="assign"><purpose>Tag type for the binary = operator. </purpose></struct><struct name="shift_left_assign"><purpose>Tag type for the binary &lt;&lt;= operator. </purpose></struct><struct name="shift_right_assign"><purpose>Tag type for the binary &gt;&gt;= operator. </purpose></struct><struct name="multilpies_assign"><purpose>Tag type for the binary *= operator. </purpose></struct><struct name="divides_assign"><purpose>Tag type for the binary /= operator. </purpose></struct><struct name="modulus_assign"><purpose>Tag type for the binary = operator. </purpose></struct><struct name="plus_assign"><purpose>Tag type for the binary += operator. </purpose></struct><struct name="minus_assign"><purpose>Tag type for the binary -= operator. </purpose></struct><struct name="bitwise_and_assign"><purpose>Tag type for the binary &amp;= operator. </purpose></struct><struct name="bitwise_or_assign"><purpose>Tag type for the binary |= operator. </purpose></struct><struct name="bitwise_xor_assign"><purpose>Tag type for the binary ^= operator. </purpose></struct><struct name="subscript"><purpose>Tag type for the binary subscript operator. </purpose></struct><struct name="if_else_"><purpose>Tag type for the ternary ?: conditional operator. </purpose></struct><struct name="function"><purpose>Tag type for the nary function call operator. </purpose></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/traits.hpp"><para>Contains definitions for arg&lt;&gt;, arg_c&lt;&gt;, left&lt;&gt;, right&lt;&gt;, tag&lt;&gt;, and the helper functions arg(), arg_c(), left() and right(). </para><namespace name="boost"><namespace name="proto"><namespace name="functional"><struct name="as_expr"><template>
      <template-type-parameter name="Domain"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T)</template-arg></specialization><inherit access="public">boost::proto::result_of::as_expr&lt; remove_reference&lt; T &gt;::type, Domain &gt;</inherit></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::as_expr</classname>&lt; T, Domain &gt;::result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::as_expr</classname>&lt; T const, Domain &gt;::result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></method></method-group></struct><struct name="as_arg"><template>
      <template-type-parameter name="Domain"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T)</template-arg></specialization><inherit access="public">boost::proto::result_of::as_arg&lt; remove_reference&lt; T &gt;::type, Domain &gt;</inherit></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::as_arg</classname>&lt; T, Domain &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::as_arg</classname>&lt; T const, Domain &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></method></method-group></struct><struct name="arg_c"><template>
      <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
    </template><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result_of::arg_c&lt; Expr, N &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>result_of::arg_c&lt; Expr, N &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="arg"><template>
      <template-type-parameter name="N"/>
    </template><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::arg</classname>&lt; Expr, N &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::arg</classname>&lt; Expr, N &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="left"><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::left</classname>&lt; Expr &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::left</classname>&lt; Expr &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="right"><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::right</classname>&lt; Expr &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><classname>result_of::right</classname>&lt; Expr &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct></namespace><namespace name="op"><struct name="terminal"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_identity_transform</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::terminal</classname>, <classname>args0</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::terminal</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="if_else_"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
      <template-type-parameter name="V"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::if_else_</classname>, <classname>args3</classname>&lt; T, U, V &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::if_else_</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><typedef name="proto_arg2"><type>V</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="unary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arg0"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="binary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="posit"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::posit</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::posit</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="negate"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::negate</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::negate</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="dereference"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::dereference</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::dereference</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="complement"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::complement</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::complement</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="address_of"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::address_of</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::address_of</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="logical_not"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::logical_not</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::logical_not</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="pre_inc"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::pre_inc</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::pre_inc</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="pre_dec"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::pre_dec</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::pre_dec</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="post_inc"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::post_inc</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::post_inc</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="post_dec"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::post_dec</classname>, <classname>args1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::post_dec</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="shift_left"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::shift_left</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::shift_left</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="shift_right"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::shift_right</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::shift_right</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="multiplies"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::multiplies</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::multiplies</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="divides"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::divides</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::divides</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="modulus"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::modulus</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::modulus</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="plus"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::plus</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::plus</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="minus"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::minus</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::minus</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="less"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::less</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::less</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="greater"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::greater</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::greater</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="less_equal"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::less_equal</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::less_equal</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="greater_equal"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::greater_equal</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::greater_equal</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="equal_to"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::equal_to</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::equal_to</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="not_equal_to"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::not_equal_to</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::not_equal_to</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="logical_or"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::logical_or</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::logical_or</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="logical_and"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::logical_and</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::logical_and</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="bitwise_and"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::bitwise_and</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::bitwise_and</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="bitwise_or"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::bitwise_or</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::bitwise_or</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="bitwise_xor"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::bitwise_xor</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::bitwise_xor</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="comma"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::comma</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::comma</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="mem_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::mem_ptr</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::mem_ptr</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="shift_left_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::shift_left_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::shift_left_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="shift_right_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::shift_right_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::shift_right_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="multilpies_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::multilpies_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::multilpies_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="divides_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::divides_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::divides_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="modulus_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::modulus_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::modulus_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="plus_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::plus_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::plus_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="minus_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::minus_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::minus_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="bitwise_and_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::bitwise_and_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::bitwise_and_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="bitwise_or_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::bitwise_or_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::bitwise_or_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="bitwise_xor_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::bitwise_xor_assign</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::bitwise_xor_assign</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct name="subscript"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::subscript</classname>, <classname>args2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::subscript</classname></type></typedef><typedef name="proto_arg0"><type>T</type></typedef><typedef name="proto_arg1"><type>U</type></typedef><method-group name="public member functions"/><constructor/></struct><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::function</classname>, <classname>args1</classname>&lt; A0 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::function</classname></type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg2"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg3"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args1</classname>&lt; A0 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg2"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg3"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::function</classname>, <classname>args2</classname>&lt; A0, A1 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::function</classname></type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type>A1</type></typedef><typedef name="proto_arg2"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg3"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args2</classname>&lt; A0, A1 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type>A1</type></typedef><typedef name="proto_arg2"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg3"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::function</classname>, <classname>args3</classname>&lt; A0, A1, A2 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::function</classname></type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type>A1</type></typedef><typedef name="proto_arg2"><type>A2</type></typedef><typedef name="proto_arg3"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args3</classname>&lt; A0, A1, A2 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type>A1</type></typedef><typedef name="proto_arg2"><type>A2</type></typedef><typedef name="proto_arg3"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_arg4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::function</classname>, <classname>args4</classname>&lt; A0, A1, A2, A3 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::function</classname></type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type>A1</type></typedef><typedef name="proto_arg2"><type>A2</type></typedef><typedef name="proto_arg3"><type>A3</type></typedef><typedef name="proto_arg4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args4</classname>&lt; A0, A1, A2, A3 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type>A1</type></typedef><typedef name="proto_arg2"><type>A2</type></typedef><typedef name="proto_arg3"><type>A3</type></typedef><typedef name="proto_arg4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; <classname>proto::tag::function</classname>, <classname>args5</classname>&lt; A0, A1, A2, A3, A4 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type><classname>proto::tag::function</classname></type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type>A1</type></typedef><typedef name="proto_arg2"><type>A2</type></typedef><typedef name="proto_arg3"><type>A3</type></typedef><typedef name="proto_arg4"><type>A4</type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4</template-arg><template-arg>void</template-arg></specialization><inherit access="public">boost::proto::has_transformns_::has_pass_through_transform&lt; Grammar &gt;</inherit><typedef name="type"><type>expr&lt; Tag, <classname>args5</classname>&lt; A0, A1, A2, A3, A4 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arg0"><type>A0</type></typedef><typedef name="proto_arg1"><type>A1</type></typedef><typedef name="proto_arg2"><type>A2</type></typedef><typedef name="proto_arg3"><type>A3</type></typedef><typedef name="proto_arg4"><type>A4</type></typedef></struct-specialization></namespace><namespace name="result_of"><struct name="is_ref"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="EnableIf"/>
    </template></struct><struct name="is_expr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="EnableIf"/>
    </template></struct><struct name="tag_of"><template>
      <template-type-parameter name="Expr"/>
    </template><typedef name="type"><type>Expr::proto_tag</type></typedef></struct><struct name="id"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::result_of::deep_copy&lt; Expr &gt;</inherit></struct><struct name="as_expr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="EnableIf"/>
    </template><typedef name="proto_arg0"><type>mpl::eval_if&lt; mpl::or_&lt; boost::is_array&lt; T &gt;, is_function&lt; T &gt; &gt;, add_reference&lt; T &gt;, remove_cv&lt; T &gt;&gt;::type</type></typedef><typedef name="expr_type"><type>expr&lt; <classname>proto::tag::terminal</classname>, <classname>args0</classname>&lt; proto_arg0 &gt; &gt;</type></typedef><typedef name="type"><type>Domain::template apply&lt; expr_type &gt;::type</type></typedef><typedef name="result_type"><type>type const</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static result_type</type><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="t"><paramtype>T2 &amp;</paramtype></parameter></method></method-group></struct><struct name="as_arg"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="EnableIf"/>
    </template><typedef name="expr_type"><type>expr&lt; <classname>proto::tag::terminal</classname>, <classname>args0</classname>&lt; T &amp; &gt; &gt;</type></typedef><typedef name="type"><type>Domain::template apply&lt; expr_type &gt;::type</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type</type><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="t"><paramtype>T2 &amp;</paramtype></parameter></method></method-group></struct><struct name="arg"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="N"/>
    </template></struct><struct name="left"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::result_of::unref&lt; Expr::proto_arg0 &gt;</inherit></struct><struct name="right"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::result_of::unref&lt; Expr::proto_arg1 &gt;</inherit></struct><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>0</template-arg></specialization><inherit access="public">boost::proto::result_of::unref&lt; Expr::proto_arg0 &gt;</inherit><method-group name="public static functions"><method name="call" cv=""><type>static <classname>arg_c</classname>&lt; Expr, 0 &gt;::reference</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="call" cv=""><type>static <classname>arg_c</classname>&lt; Expr, 0 &gt;::const_reference</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>0</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 0 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>1</template-arg></specialization><inherit access="public">boost::proto::result_of::unref&lt; Expr::proto_arg1 &gt;</inherit><method-group name="public static functions"><method name="call" cv=""><type>static <classname>arg_c</classname>&lt; Expr, 1 &gt;::reference</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="call" cv=""><type>static <classname>arg_c</classname>&lt; Expr, 1 &gt;::const_reference</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>1</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 1 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>2</template-arg></specialization><inherit access="public">boost::proto::result_of::unref&lt; Expr::proto_arg2 &gt;</inherit><method-group name="public static functions"><method name="call" cv=""><type>static <classname>arg_c</classname>&lt; Expr, 2 &gt;::reference</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="call" cv=""><type>static <classname>arg_c</classname>&lt; Expr, 2 &gt;::const_reference</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>2</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 2 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>3</template-arg></specialization><inherit access="public">boost::proto::result_of::unref&lt; Expr::proto_arg3 &gt;</inherit><method-group name="public static functions"><method name="call" cv=""><type>static <classname>arg_c</classname>&lt; Expr, 3 &gt;::reference</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="call" cv=""><type>static <classname>arg_c</classname>&lt; Expr, 3 &gt;::const_reference</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>3</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 3 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>4</template-arg></specialization><inherit access="public">boost::proto::result_of::unref&lt; Expr::proto_arg4 &gt;</inherit><method-group name="public static functions"><method name="call" cv=""><type>static <classname>arg_c</classname>&lt; Expr, 4 &gt;::reference</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="call" cv=""><type>static <classname>arg_c</classname>&lt; Expr, 4 &gt;::const_reference</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>4</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 4 &gt;</inherit></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>5</template-arg></specialization><inherit access="public">boost::proto::result_of::unref&lt; Expr::proto_arg5 &gt;</inherit><method-group name="public static functions"><method name="call" cv=""><type>static <classname>arg_c</classname>&lt; Expr, 5 &gt;::reference</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method><method name="call" cv=""><type>static <classname>arg_c</classname>&lt; Expr, 5 &gt;::const_reference</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="arg_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const</template-arg><template-arg>5</template-arg></specialization><inherit access="public">boost::proto::result_of::arg_c&lt; Expr, 5 &gt;</inherit></struct-specialization><struct-specialization name="is_ref"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>typename T::proto_is_ref_</template-arg></specialization></struct-specialization><struct-specialization name="is_expr"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>typename T::proto_is_expr_</template-arg></specialization></struct-specialization><struct-specialization name="as_expr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>T</template-arg><template-arg>Domain</template-arg><template-arg>typename T::proto_is_expr_</template-arg></specialization><typedef name="type"><type>T::proto_derived_expr</type></typedef><typedef name="result_type"><type>T &amp;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static result_type</type><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="t"><paramtype>T2 &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="as_arg"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>T</template-arg><template-arg>Domain</template-arg><template-arg>typename T::proto_is_expr_</template-arg></specialization><typedef name="type"><type><classname>ref_</classname>&lt; T &gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static <classname>type</classname></type><template>
          <template-type-parameter name="T2"/>
        </template><parameter name="t"><paramtype>T2 &amp;</paramtype></parameter></method></method-group></struct-specialization></namespace><function name="implicit_expr"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter></function><function name="implicit_expr"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter></function><function name="implicit_expr"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 &amp;</paramtype></parameter></function><function name="implicit_expr"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 &amp;</paramtype></parameter></function><function name="implicit_expr"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
          <template-type-parameter name="A4"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 &amp;</paramtype></parameter><parameter name="a4"><paramtype>A4 &amp;</paramtype></parameter></function><overloaded-function name="as_expr"><signature><type><classname>result_of::as_expr</classname>&lt; T &gt;::result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></signature><signature><type><classname>result_of::as_expr</classname>&lt; T const  &gt;::result_type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></signature><description><para>as_expr </para></description></overloaded-function><overloaded-function name="as_arg"><signature><type><classname>result_of::as_arg</classname>&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype></parameter></signature><signature><type><classname>result_of::as_arg</classname>&lt; T const  &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></signature><description><para>as_arg </para></description></overloaded-function><overloaded-function name="arg"><signature><type><classname>result_of::unref</classname>&lt; typename Expr::proto_base_expr::proto_arg0 &gt;::reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></signature><signature><type><classname>result_of::unref</classname>&lt; typename Expr::proto_base_expr::proto_arg0 &gt;::const_reference</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></signature><description><para>arg </para></description></overloaded-function><overloaded-function name="arg_c"><signature><type>result_of::arg_c&lt; Expr, N &gt;::reference</type><template>
          <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></signature><signature><type>result_of::arg_c&lt; Expr, N &gt;::const_reference</type><template>
          <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></signature><description><para>arg_c </para></description></overloaded-function><data-member name="left"><type><classname>functional::left</classname> const</type></data-member><data-member name="right"><type><classname>functional::right</classname> const</type></data-member></namespace></namespace></header><header name="boost/xpressive/proto/transform.hpp"><para>Includes all the transforms in the transform/ sub-directory. </para></header><header name="boost/xpressive/proto/transform/apply.hpp"><para>Proto transforms for applying MPL placeholder expressions. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="always"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Always"/>
      <template-type-parameter name="Factory"/>
    </template><struct name="apply"><template>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Always</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static Always</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name=""><paramtype>Expr const &amp;</paramtype></parameter><parameter name=""><paramtype>State const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="apply1"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Lambda"/>
      <template-type-parameter name="Factory"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="apply2"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Lambda"/>
      <template-type-parameter name="Factory"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="apply3"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Lambda"/>
      <template-type-parameter name="Factory"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/arg.hpp"><para>Proto transforms for extracting arguments from expressions. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="arg"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="N"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><inherit access="public">boost::proto::result_of::arg&lt; Grammar::template apply&lt; Expr, State, Visitor &gt;::type, N &gt;</inherit></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="arg_c"><template>
      <template-type-parameter name="Grammar"/>
      <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="left"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><inherit access="public">boost::proto::result_of::left&lt; Grammar::template apply&lt; Expr, State, Visitor &gt;::type &gt;</inherit></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="right"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><inherit access="public">boost::proto::result_of::right&lt; Grammar::template apply&lt; Expr, State, Visitor &gt;::type &gt;</inherit></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="identity"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr_"/>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>Expr_</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static Expr_ const &amp;</type><template>
          <template-type-parameter name="Expr_"/>
          <template-type-parameter name="State_"/>
          <template-type-parameter name="Visitor_"/>
        </template><parameter name="expr_"><paramtype>Expr_ const &amp;</paramtype></parameter><parameter name=""><paramtype>State_ const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor_ &amp;</paramtype></parameter></method></method-group></struct><struct name="state"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name=""/>
      <template-type-parameter name="State"/>
      <template-type-parameter name=""/>
    </template><typedef name="type"><type>State</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static State const &amp;</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name=""><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state_"><paramtype>State const &amp;</paramtype></parameter><parameter name=""><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="visitor"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name=""/>
      <template-type-parameter name=""/>
      <template-type-parameter name="Visitor"/>
    </template><typedef name="type"><type>Visitor</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static Visitor &amp;</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name=""><paramtype>Expr const &amp;</paramtype></parameter><parameter name=""><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor_"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/branch.hpp"><para>A special-purpose proto transform for transforming one branch of the expression tree separately from the rest. Given an expression and a new state, it transforms the expression using the new state. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="branch"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="BranchState"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name=""><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/compose.hpp"><para>A special-purpose proto transform for composing two transfomations. Given two Grammars, expressions that match the first grammar are transformed according to that grammar, and the result is forwarded to the second for further transformation. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="compose"><template>
      <template-type-parameter name="Grammar1"/>
      <template-type-parameter name="Grammar2"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><typedef name="type"><type>Grammar2::template <classname>apply</classname>&lt; typename Grammar1::template <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type, State, Visitor &gt;::type</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/construct.hpp"><para>For constructing an arbitrary type from a bunch of transforms. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct-specialization name="construct"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Result"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>Result()</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public static functions"><method name="call" cv=""><type>static apply&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group><method-group name="private static functions"/></struct-specialization><struct-specialization name="construct"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Result"/>
      <template-type-parameter name="Arg0"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>Result(Arg0)</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public static functions"><method name="call" cv=""><type>static apply&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group><method-group name="private static functions"/></struct-specialization><struct-specialization name="construct"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Result"/>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>Result(Arg0</template-arg><template-arg>Arg1)</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public static functions"><method name="call" cv=""><type>static apply&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group><method-group name="private static functions"/></struct-specialization><struct-specialization name="construct"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Result"/>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
      <template-type-parameter name="Arg2"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>Result(Arg0</template-arg><template-arg>Arg1</template-arg><template-arg>Arg2)</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public static functions"><method name="call" cv=""><type>static apply&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group><method-group name="private static functions"/></struct-specialization><struct-specialization name="construct"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Result"/>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
      <template-type-parameter name="Arg2"/>
      <template-type-parameter name="Arg3"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>Result(Arg0</template-arg><template-arg>Arg1</template-arg><template-arg>Arg2</template-arg><template-arg>Arg3)</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public static functions"><method name="call" cv=""><type>static apply&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group><method-group name="private static functions"/></struct-specialization><struct-specialization name="construct"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Result"/>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
      <template-type-parameter name="Arg2"/>
      <template-type-parameter name="Arg3"/>
      <template-type-parameter name="Arg4"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>Result(Arg0</template-arg><template-arg>Arg1</template-arg><template-arg>Arg2</template-arg><template-arg>Arg3</template-arg><template-arg>Arg4)</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public static functions"><method name="call" cv=""><type>static apply&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group><method-group name="private static functions"/></struct-specialization></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/fold.hpp"><para>A special-purpose proto transform for merging sequences of binary operations. It transforms the right operand and passes the result as state while transforming the left. Or, it might do the left first, if you choose. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct-specialization name="fold"><template>
      <template-type-parameter name="Grammar"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>void</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"><method name="fold" cv=""><type/></method></method-group><method-group name="public static functions"><method name="call" cv=""><type>static apply&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="reverse_fold"><template>
      <template-type-parameter name="Grammar"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>void</template-arg></specialization><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"><method name="reverse_fold" cv=""><type/></method></method-group><method-group name="public static functions"><method name="call" cv=""><type>static apply&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct-specialization></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/fold_tree.hpp"><para>A higher-level transform that uses the fold, and branch transforms to recursively fold a tree. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="fold_tree"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="State"/>
    </template><description><para>fold_tree </para></description></struct><struct name="reverse_fold_tree"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="State"/>
    </template><description><para>reverse_fold_tree </para></description></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/function.hpp"><para>Proto transforms for applying a function object. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="function1"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Function1"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="function2"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Function2"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="function3"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Function3"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/list.hpp"><para>A special-purpose proto transform for putting things into a fusion::cons&lt;&gt; list. </para><namespace name="boost"><namespace name="proto"><namespace name="transform"><struct name="list"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><typedef name="type"><type>fusion::cons&lt; typename Grammar::template <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type, State &gt;</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct><struct name="tail"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template><typedef name="type"><type>Grammar::template <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type::cdr_type</type></typedef></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header><header name="boost/xpressive/proto/transform/pass_through.hpp"><para>TODO </para><namespace name="boost"><namespace name="proto"><namespace name="has_transformns_"><struct name="has_pass_through_transform"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace><namespace name="transform"><struct name="pass_through"><template>
      <template-type-parameter name="Grammar"/>
    </template><struct name="apply"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Visitor"/>
    </template></struct><method-group name="public member functions"/><constructor/><method-group name="public static functions"><method name="call" cv=""><type>static <classname>apply</classname>&lt; Expr, State, Visitor &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="State"/>
          <template-type-parameter name="Visitor"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><parameter name="state"><paramtype>State const &amp;</paramtype></parameter><parameter name="visitor"><paramtype>Visitor &amp;</paramtype></parameter></method></method-group></struct></namespace></namespace></namespace></header></library-reference>
