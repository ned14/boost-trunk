#!/usr/bin/python
#
#  copyright (C) 2008  troy d. straszheim  <troy@resophonic.com>
#  
#  Distributed under the Boost Software License, Version 1.0.
#  See accompanying file LICENSE_1_0.txt or copy at
#  http://www.boost.org/LICENSE_1_0.txt
#
#
#  Compiler driver.  Takes a few arguments describing what is to be done
#  (used to mark up the output) and executes compiler in a subshell, checking
#  for errors and marshalling output to disk.
#
import sys
sys.path.append("@BOOST_BUILD_SLAVE_PYTHONPATH@")
from boost_build_slave import *

import datetime, time, signal
from subprocess import Popen, PIPE
from kill_subprocess import kill_subprocess

log = os.path.join(sys.argv[1], "Log.marshal")
op = sys.argv[2]
target = sys.argv[3]
argv = sys.argv[4:]
expect_fail = op.endswith("fail")

# print "***\n*** Executing op:" + op + "\n*** " + str(argv) + "\n*** log=" + log + "\n***"

#
#  execute subprocess, watch for timeout
#
subproc = None
returncode = None
ex = None
try:
    starttime = datetime.datetime.now()
    subproc = Popen(argv, stdout=PIPE, stderr=PIPE)
    returncode = subproc.poll()
    while returncode is None:
        time.sleep(1)
        now = datetime.datetime.now()
        if (now - starttime).seconds > timeout_seconds:
            kill_subprocess(subproc.pid)
            e = OSError()
            e.errno = 666
            e.message = e.strerror = "TIMEOUT AFTER %d SECONDS" % timeout_seconds
            e.filename = argv[0]
            raise e
        returncode = subproc.poll()

except EnvironmentError, e:
    ex = e

duration = datetime.datetime.now() - starttime

#
#  Collect and store subprocess info
#
result = { 'expect_fail' : expect_fail,
           'wallclock_duration' : duration.seconds + duration.microseconds * 10**-6 }

if not ex:
    
    result['returncode'] = returncode
    result['stdout'] = subproc.stdout.read()
    result['stderr'] = subproc.stderr.read()

    if returncode != 0 and not expect_fail:
        print "*** stdout:" + result['stdout']
        print "*** stderr:" + result['stderr']
        
else:

    result['errno'] = ex.errno
    result['filename'] = ex.filename
    result['message'] = ex.message
    result['strerror'] = ex.strerror
    print "Errno:" + str(ex.errno) + ": " + ex.strerror

result.update({'op' : op,
               'target' : target,
               'cmdline' : argv })

f = open(log, "a")
marshal.dump(result, f)

if ex:
    sys.exit(ex.errno)
else:
    if expect_fail:
        if returncode != 0:
            sys.exit(0)
        else: 
            print "UNEXPECTED SUCCESS"
            sys.exit(1)  # we need an exit status for 'unexpected success'
    else:
        sys.exit(returncode)

    

