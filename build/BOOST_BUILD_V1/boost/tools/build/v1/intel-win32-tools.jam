# Intel Compiler (on Windows, using the Microsoft Standard Library)

# (C) Copyright David Abrahams 2001.
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE_1_0.txt or http://www.boost.org/LICENSE_1_0.txt)

# The following #// line will be used by the regression test table generation
# program as the column heading for HTML tables. Must not include version number.
#//<a href="http://developer.intel.com/software/products/compilers/">Intel<br>C++</a>

# singleton variables...
set-as-singleton INTELC ;

# compute INTEL tool path. You can either use the environment variable
# setup that comes with the Intel compiler, or you can set the
# INTEL_PATH or INTELC (in order to respect FTJam setup) environment
# variables to point at the intel-win32 installation directory
INTEL_PATH ?= $(INTELC) ;
INTEL_TOOL_PATH ?= "$(INTEL_PATH)"\\bin\\ ;

# if you have vc6 and vc7 installed, you may want your intel compiler
# to use the VC7 libraries. In that case, you might set
#       INTEL_BASE_MSVC_TOOLSET = vc7
# instead.

INTEL_BASE_MSVC_TOOLSET ?= msvc ;

extends-toolset $(INTEL_BASE_MSVC_TOOLSET) ;

VC_TOOL_PATH = $(INTEL_TOOL_PATH) ;
VC_STDLIB_PATH = "$(INTEL_PATH)"\\bin ;
VC_COMPILER = icl ;
VC_LINKER = xilink ;

# Extract the compiler version from its installation path
local version = $(INTEL_VERSION) ;
# Syntax < 9
version ?= [ MATCH .*[\\/][Cc][Oo][Mm][Pp][Ii][Ll][Ee][Rr]([0-9])[0-9][\\/].* : $(INTEL_TOOL_PATH) ] ;
# Syntax >= 9.0
version ?= [ MATCH .*[\\/][Cc][\+][\+][\\/]([0-9])\.[0-9][\\/].* : $(INTEL_TOOL_PATH) ] ;

# Reduce the number of spurious error messages
C++FLAGS += /Qwn5 /Qwd985 ;

# Detect illegal conversions in this program:
#
# # include <vector>
# # include <algorithm>
# int main()
# {
# char* a[20];
# std::vector<int> v(20);
# std::copy(v.begin(), v.end(), a);
# return 0;
# }
C++FLAGS += /Qwe556 ;

# Enable ADL
C++FLAGS += -Qoption,c,--arg_dep_lookup ; #"c" works for C++, too

if $(version) <= 5
{
    # remove options unrecognized by Intel5
    C++FLAGS = [ difference $(C++FLAGS) : /Zc:wchar_t,forScope ] ;
}
else
{
    C++FLAGS += /Zc:forScope ;  # Add support for correct for loop scoping
}

# Add options recognized only by intel7
if $(version) >= 7
{
    C++FLAGS += /Qansi_alias ;
}

# tell the compiler about the base toolset.
if [ MATCH (vc-7_1).* : $(INTEL_BASE_MSVC_TOOLSET) ]
{
    C++FLAGS += /Qvc7.1 ;
}
else if [ MATCH (vc7).* : $(INTEL_BASE_MSVC_TOOLSET) ]
{
    C++FLAGS += /Qvc7 ;
}
else if [ MATCH (msvc).* : $(INTEL_BASE_MSVC_TOOLSET) ]
{
    C++FLAGS += /Qvc6 ;
}

if $(INTEL_BASE_MSVC_TOOLSET) = msvc
{
    # no wchar_t support in vc6 dinkum library.  Furthermore, in vc6
    # compatibility-mode, wchar_t is not a distinct type from unsigned
    # short
    C++FLAGS += -DBOOST_NO_INTRINSIC_WCHAR_T ; 
}
else if $(version) > 5
{
    # Add support for wchar_t
    C++FLAGS += /Zc:wchar_t
        # Tell the dinkumware library about it.
        -D_NATIVE_WCHAR_T_DEFINED
        ;
}

# remove any duplicates caused by the additions above
C++FLAGS = [ unique $(C++FLAGS) ] ;

if $(VC_SETUP)
{
    if $(version) <= 7
    {
        VC_SETUP = "CALL \"$(INTEL_TOOL_PATH)ICCVARS.BAT\" > nul" ;
    }
    else
    {
        VC_SETUP = "CALL \"$(INTEL_TOOL_PATH)ICLVARS.BAT\" > nul" ;
    }
}
