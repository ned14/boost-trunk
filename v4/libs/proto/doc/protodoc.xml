<?xml version="1.0" standalone="yes"?>
<library-reference><header name="boost/proto/args.hpp"><para>Contains definition of args&lt;&gt; class template. </para><namespace name="boost"><namespace name="proto"><struct-specialization name="term_ref"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T const &amp;</template-arg></specialization><typedef name="type"><type>T</type></typedef></struct-specialization><struct name="term"><template>
      <template-type-parameter name="Arg0"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="arity" specifiers="static"><type>const long</type></data-member><typedef name="child0"><type>Arg0</type></typedef><typedef name="child_ref0"><type><classname>term_ref</classname>&lt; Arg0 &gt;</type></typedef></struct><struct name="list1"><template>
      <template-type-parameter name="Arg0"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="arity" specifiers="static"><type>const long</type></data-member><typedef name="child0"><type>Arg0</type></typedef><typedef name="child_ref0"><type><classname>expr_ref</classname>&lt; Arg0 &gt;</type></typedef></struct><struct name="list2"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="arity" specifiers="static"><type>const long</type></data-member><typedef name="child0"><type>Arg0</type></typedef><typedef name="child_ref0"><type><classname>expr_ref</classname>&lt; Arg0 &gt;</type></typedef><typedef name="child1"><type>Arg1</type></typedef><typedef name="child_ref1"><type><classname>expr_ref</classname>&lt; Arg1 &gt;</type></typedef></struct><struct name="list3"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
      <template-type-parameter name="Arg2"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="arity" specifiers="static"><type>const long</type></data-member><typedef name="child0"><type>Arg0</type></typedef><typedef name="child_ref0"><type><classname>expr_ref</classname>&lt; Arg0 &gt;</type></typedef><typedef name="child1"><type>Arg1</type></typedef><typedef name="child_ref1"><type><classname>expr_ref</classname>&lt; Arg1 &gt;</type></typedef><typedef name="child2"><type>Arg2</type></typedef><typedef name="child_ref2"><type><classname>expr_ref</classname>&lt; Arg2 &gt;</type></typedef></struct><struct name="list4"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
      <template-type-parameter name="Arg2"/>
      <template-type-parameter name="Arg3"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="arity" specifiers="static"><type>const long</type></data-member><typedef name="child0"><type>Arg0</type></typedef><typedef name="child_ref0"><type><classname>expr_ref</classname>&lt; Arg0 &gt;</type></typedef><typedef name="child1"><type>Arg1</type></typedef><typedef name="child_ref1"><type><classname>expr_ref</classname>&lt; Arg1 &gt;</type></typedef><typedef name="child2"><type>Arg2</type></typedef><typedef name="child_ref2"><type><classname>expr_ref</classname>&lt; Arg2 &gt;</type></typedef><typedef name="child3"><type>Arg3</type></typedef><typedef name="child_ref3"><type><classname>expr_ref</classname>&lt; Arg3 &gt;</type></typedef></struct><struct name="list5"><template>
      <template-type-parameter name="Arg0"/>
      <template-type-parameter name="Arg1"/>
      <template-type-parameter name="Arg2"/>
      <template-type-parameter name="Arg3"/>
      <template-type-parameter name="Arg4"/>
    </template><purpose>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. </purpose><description><para>A type sequence, for use as the 2nd parameter to the <computeroutput>expr&lt;&gt;</computeroutput> class template. The types in the sequence correspond to the children of a node in an expression tree. </para></description><data-member name="arity" specifiers="static"><type>const long</type></data-member><typedef name="child0"><type>Arg0</type></typedef><typedef name="child_ref0"><type><classname>expr_ref</classname>&lt; Arg0 &gt;</type></typedef><typedef name="child1"><type>Arg1</type></typedef><typedef name="child_ref1"><type><classname>expr_ref</classname>&lt; Arg1 &gt;</type></typedef><typedef name="child2"><type>Arg2</type></typedef><typedef name="child_ref2"><type><classname>expr_ref</classname>&lt; Arg2 &gt;</type></typedef><typedef name="child3"><type>Arg3</type></typedef><typedef name="child_ref3"><type><classname>expr_ref</classname>&lt; Arg3 &gt;</type></typedef><typedef name="child4"><type>Arg4</type></typedef><typedef name="child_ref4"><type><classname>expr_ref</classname>&lt; Arg4 &gt;</type></typedef></struct></namespace></namespace></header><header name="boost/proto/context.hpp"><para>Includes all the context classes in the context/ sub-directory. </para></header><header name="boost/proto/context/callable.hpp"><para>Definintion of callable_context&lt;&gt;, an evaluation context for proto::eval() that explodes each node and calls the derived context type with the expressions constituents. If the derived context doesn't have an overload that handles this node, fall back to some other context. </para><namespace name="boost"><namespace name="proto"><namespace name="context"><struct name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
      <template-nontype-parameter name="Arity"><type>long</type><default>Expr::proto_arity::value</default></template-nontype-parameter>
    </template><purpose>A BinaryFunction that accepts a Proto expression and a callable context and calls the context with the expression tag and children as arguments, effectively fanning the expression out. </purpose><description><para><computeroutput>callable_eval&lt;&gt;</computeroutput> requires that <computeroutput>Context</computeroutput> is a PolymorphicFunctionObject that can be invoked with <computeroutput>Expr's</computeroutput> tag and children as expressions, as follows:</para><para><programlisting> context(Expr::proto_tag(), child_c&lt;0&gt;(expr), child_c&lt;1&gt;(expr), ...)
</programlisting> </para></description></struct><struct name="callable_context"><template>
      <template-type-parameter name="Context"/>
      <template-type-parameter name="DefaultCtx"><default>default_context</default></template-type-parameter>
    </template><purpose>An evaluation context adaptor that makes authoring a context a simple matter of writing function overloads, rather then writing template specializations. </purpose><description><para><computeroutput>callable_context&lt;&gt;</computeroutput> is a base class that implements the context protocol by passing fanned-out expression nodes to the derived context, making it easy to customize the handling of expression types by writing function overloads. Only those expression types needing special handling require explicit handling. All others are dispatched to a user-specified default context, <computeroutput>DefaultCtx</computeroutput>.</para><para><computeroutput>callable_context&lt;&gt;</computeroutput> is defined simply as:</para><para><programlisting> template&lt;typename Context, typename DefaultCtx = default_context&gt;
 struct callable_context
 {
    template&lt;typename Expr, typename ThisContext = Context&gt;
     struct eval
       : mpl::if_&lt;
             is_expr_handled_&lt;Expr, Context&gt; // For exposition
           , callable_eval&lt;Expr, ThisContext&gt;
           , typename DefaultCtx::template eval&lt;Expr, Context&gt;
         &gt;::type
     {};
 };
</programlisting></para><para>The Boolean metafunction <computeroutput>is_expr_handled_&lt;&gt;</computeroutput> uses metaprogramming tricks to determine whether <computeroutput>Context</computeroutput> has an overloaded function call operator that accepts the fanned-out constituents of an expression of type <computeroutput>Expr</computeroutput>. If so, the handling of the expression is dispatched to <computeroutput>callable_eval&lt;&gt;</computeroutput>. If not, it is dispatched to the user-specified <computeroutput>DefaultCtx</computeroutput>.</para><para>Below is an example of how to use <computeroutput>callable_context&lt;&gt;</computeroutput>:</para><para><programlisting> // An evaluation context that increments all
 // integer terminals in-place.
 struct increment_ints
  : callable_context&lt;
         increment_ints const    // derived context
       , null_context const      // fall-back context
     &gt;
 {
     typedef void result_type;

     // Handle int terminals here:
     void operator()(proto::tag::terminal, int &amp;i) const
     {
        ++i;
     }
 };
</programlisting></para><para>With <computeroutput>increment_ints</computeroutput>, we can do the following:</para><para><programlisting> literal&lt;int&gt; i = 0, j = 10;
 proto::eval( i - j * 3.14, increment_ints() );

 assert( i.get() == 1 &amp;&amp; j.get() == 11 );
</programlisting> </para></description><struct name="eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="ThisContext"><default>Context</default></template-type-parameter>
    </template><description><para>A BinaryFunction that accepts an <computeroutput>Expr</computeroutput> and a <computeroutput>Context</computeroutput>, and either fans out the expression and passes it to the context, or else hands off the expression to <computeroutput>DefaultCtx</computeroutput>.</para><para>If <computeroutput>Context</computeroutput> is a PolymorphicFunctionObject such that it can be invoked with the tag and children of <computeroutput>Expr</computeroutput>, as <computeroutput>ctx(Expr::proto_tag(), child_c&lt;0&gt;(expr), child_c&lt;1&gt;(expr)...)</computeroutput>, then <computeroutput>eval&lt;Expr, ThisContext&gt;</computeroutput> inherits from <computeroutput>callable_eval&lt;Expr, ThisContext&gt;</computeroutput>. Otherwise, <computeroutput>eval&lt;Expr, ThisContext&gt;</computeroutput> inherits from <computeroutput>DefaultCtx::eval&lt;Expr, Context&gt;</computeroutput>. </para></description></struct></struct><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>0</template-arg></specialization><purpose>A BinaryFunction that accepts a Proto expression and a callable context and calls the context with the expression tag and children as arguments, effectively fanning the expression out. </purpose><description><para><computeroutput>callable_eval&lt;&gt;</computeroutput> requires that <computeroutput>Context</computeroutput> is a PolymorphicFunctionObject that can be invoked with <computeroutput>Expr's</computeroutput> tag and children as expressions, as follows:</para><para><programlisting> context(Expr::proto_tag(), child_c\&lt;0\&gt;(expr), child_c\&lt;1\&gt;(expr), ...)
</programlisting> </para></description><typedef name="child0"><type>proto::result_of::child_c&lt; Expr const &amp;, 0 &gt;::type</type></typedef><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::proto_tag, child0)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype><description><para>The current expression </para></description></parameter><parameter name="context"><paramtype>Context &amp;</paramtype><description><para>The callable evaluation context </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>context(Expr::proto_tag(), child_c&lt;0&gt;(expr), child_c&lt;1&gt;(expr), ...)</computeroutput> </para></returns></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>1</template-arg></specialization><purpose>A BinaryFunction that accepts a Proto expression and a callable context and calls the context with the expression tag and children as arguments, effectively fanning the expression out. </purpose><description><para><computeroutput>callable_eval&lt;&gt;</computeroutput> requires that <computeroutput>Context</computeroutput> is a PolymorphicFunctionObject that can be invoked with <computeroutput>Expr's</computeroutput> tag and children as expressions, as follows:</para><para><programlisting> context(Expr::proto_tag(), child_c\&lt;0\&gt;(expr), child_c\&lt;1\&gt;(expr), ...)
</programlisting> </para></description><typedef name="child0"><type>proto::result_of::child_c&lt; Expr const &amp;, 0 &gt;::type</type></typedef><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::proto_tag, child0)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype><description><para>The current expression </para></description></parameter><parameter name="context"><paramtype>Context &amp;</paramtype><description><para>The callable evaluation context </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>context(Expr::proto_tag(), child_c&lt;0&gt;(expr), child_c&lt;1&gt;(expr), ...)</computeroutput> </para></returns></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>2</template-arg></specialization><purpose>A BinaryFunction that accepts a Proto expression and a callable context and calls the context with the expression tag and children as arguments, effectively fanning the expression out. </purpose><description><para><computeroutput>callable_eval&lt;&gt;</computeroutput> requires that <computeroutput>Context</computeroutput> is a PolymorphicFunctionObject that can be invoked with <computeroutput>Expr's</computeroutput> tag and children as expressions, as follows:</para><para><programlisting> context(Expr::proto_tag(), child_c\&lt;0\&gt;(expr), child_c\&lt;1\&gt;(expr), ...)
</programlisting> </para></description><typedef name="child0"><type>proto::result_of::child_c&lt; Expr const &amp;, 0 &gt;::type</type></typedef><typedef name="child1"><type>proto::result_of::child_c&lt; Expr const &amp;, 1 &gt;::type</type></typedef><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::proto_tag, child0, child1)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype><description><para>The current expression </para></description></parameter><parameter name="context"><paramtype>Context &amp;</paramtype><description><para>The callable evaluation context </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>context(Expr::proto_tag(), child_c&lt;0&gt;(expr), child_c&lt;1&gt;(expr), ...)</computeroutput> </para></returns></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>3</template-arg></specialization><purpose>A BinaryFunction that accepts a Proto expression and a callable context and calls the context with the expression tag and children as arguments, effectively fanning the expression out. </purpose><description><para><computeroutput>callable_eval&lt;&gt;</computeroutput> requires that <computeroutput>Context</computeroutput> is a PolymorphicFunctionObject that can be invoked with <computeroutput>Expr's</computeroutput> tag and children as expressions, as follows:</para><para><programlisting> context(Expr::proto_tag(), child_c\&lt;0\&gt;(expr), child_c\&lt;1\&gt;(expr), ...)
</programlisting> </para></description><typedef name="child0"><type>proto::result_of::child_c&lt; Expr const &amp;, 0 &gt;::type</type></typedef><typedef name="child1"><type>proto::result_of::child_c&lt; Expr const &amp;, 1 &gt;::type</type></typedef><typedef name="child2"><type>proto::result_of::child_c&lt; Expr const &amp;, 2 &gt;::type</type></typedef><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::proto_tag, child0, child1, child2)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype><description><para>The current expression </para></description></parameter><parameter name="context"><paramtype>Context &amp;</paramtype><description><para>The callable evaluation context </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>context(Expr::proto_tag(), child_c&lt;0&gt;(expr), child_c&lt;1&gt;(expr), ...)</computeroutput> </para></returns></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>4</template-arg></specialization><purpose>A BinaryFunction that accepts a Proto expression and a callable context and calls the context with the expression tag and children as arguments, effectively fanning the expression out. </purpose><description><para><computeroutput>callable_eval&lt;&gt;</computeroutput> requires that <computeroutput>Context</computeroutput> is a PolymorphicFunctionObject that can be invoked with <computeroutput>Expr's</computeroutput> tag and children as expressions, as follows:</para><para><programlisting> context(Expr::proto_tag(), child_c\&lt;0\&gt;(expr), child_c\&lt;1\&gt;(expr), ...)
</programlisting> </para></description><typedef name="child0"><type>proto::result_of::child_c&lt; Expr const &amp;, 0 &gt;::type</type></typedef><typedef name="child1"><type>proto::result_of::child_c&lt; Expr const &amp;, 1 &gt;::type</type></typedef><typedef name="child2"><type>proto::result_of::child_c&lt; Expr const &amp;, 2 &gt;::type</type></typedef><typedef name="child3"><type>proto::result_of::child_c&lt; Expr const &amp;, 3 &gt;::type</type></typedef><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::proto_tag, child0, child1, child2, child3)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype><description><para>The current expression </para></description></parameter><parameter name="context"><paramtype>Context &amp;</paramtype><description><para>The callable evaluation context </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>context(Expr::proto_tag(), child_c&lt;0&gt;(expr), child_c&lt;1&gt;(expr), ...)</computeroutput> </para></returns></method></method-group></struct-specialization><struct-specialization name="callable_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>5</template-arg></specialization><purpose>A BinaryFunction that accepts a Proto expression and a callable context and calls the context with the expression tag and children as arguments, effectively fanning the expression out. </purpose><description><para><computeroutput>callable_eval&lt;&gt;</computeroutput> requires that <computeroutput>Context</computeroutput> is a PolymorphicFunctionObject that can be invoked with <computeroutput>Expr's</computeroutput> tag and children as expressions, as follows:</para><para><programlisting> context(Expr::proto_tag(), child_c\&lt;0\&gt;(expr), child_c\&lt;1\&gt;(expr), ...)
</programlisting> </para></description><typedef name="child0"><type>proto::result_of::child_c&lt; Expr const &amp;, 0 &gt;::type</type></typedef><typedef name="child1"><type>proto::result_of::child_c&lt; Expr const &amp;, 1 &gt;::type</type></typedef><typedef name="child2"><type>proto::result_of::child_c&lt; Expr const &amp;, 2 &gt;::type</type></typedef><typedef name="child3"><type>proto::result_of::child_c&lt; Expr const &amp;, 3 &gt;::type</type></typedef><typedef name="child4"><type>proto::result_of::child_c&lt; Expr const &amp;, 4 &gt;::type</type></typedef><typedef name="result_type"><type>boost::result_of&lt; Context(typename Expr::proto_tag, child0, child1, child2, child3, child4)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype><description><para>The current expression </para></description></parameter><parameter name="context"><paramtype>Context &amp;</paramtype><description><para>The callable evaluation context </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>context(Expr::proto_tag(), child_c&lt;0&gt;(expr), child_c&lt;1&gt;(expr), ...)</computeroutput> </para></returns></method></method-group></struct-specialization></namespace></namespace></namespace></header><header name="boost/proto/context/default.hpp"><namespace name="boost"><namespace name="proto"><struct name="_default"><template>
      <template-type-parameter name="Grammar"/>
    </template><inherit access="public">transform&lt; boost::proto::_default&lt; Grammar &gt; &gt;</inherit><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::address_of</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::bitwise_and</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::bitwise_and_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::bitwise_or</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::bitwise_or_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::bitwise_xor</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::bitwise_xor_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::complement</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::dereference</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::divides</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::divides_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::equal_to</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::function</template-arg><template-arg>1</template-arg></specialization><typedef name="e0"><type>result_of::child_c&lt; Expr, 0 &gt;::type</type></typedef><typedef name="r0"><type>Grammar::template <classname>impl</classname>&lt; e0, State, Data &gt;::result_type</type></typedef><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type()&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::function</template-arg><template-arg>2</template-arg></specialization><typedef name="e0"><type>result_of::child_c&lt; Expr, 0 &gt;::type</type></typedef><typedef name="r0"><type>Grammar::template <classname>impl</classname>&lt; e0, State, Data &gt;::result_type</type></typedef><typedef name="e1"><type>result_of::child_c&lt; Expr, 1 &gt;::type</type></typedef><typedef name="r1"><type>Grammar::template <classname>impl</classname>&lt; e1, State, Data &gt;::result_type</type></typedef><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(e1)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::function</template-arg><template-arg>3</template-arg></specialization><typedef name="e0"><type>result_of::child_c&lt; Expr, 0 &gt;::type</type></typedef><typedef name="r0"><type>Grammar::template <classname>impl</classname>&lt; e0, State, Data &gt;::result_type</type></typedef><typedef name="e1"><type>result_of::child_c&lt; Expr, 1 &gt;::type</type></typedef><typedef name="r1"><type>Grammar::template <classname>impl</classname>&lt; e1, State, Data &gt;::result_type</type></typedef><typedef name="e2"><type>result_of::child_c&lt; Expr, 2 &gt;::type</type></typedef><typedef name="r2"><type>Grammar::template <classname>impl</classname>&lt; e2, State, Data &gt;::result_type</type></typedef><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(e1, e2)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::function</template-arg><template-arg>4</template-arg></specialization><typedef name="e0"><type>result_of::child_c&lt; Expr, 0 &gt;::type</type></typedef><typedef name="r0"><type>Grammar::template <classname>impl</classname>&lt; e0, State, Data &gt;::result_type</type></typedef><typedef name="e1"><type>result_of::child_c&lt; Expr, 1 &gt;::type</type></typedef><typedef name="r1"><type>Grammar::template <classname>impl</classname>&lt; e1, State, Data &gt;::result_type</type></typedef><typedef name="e2"><type>result_of::child_c&lt; Expr, 2 &gt;::type</type></typedef><typedef name="r2"><type>Grammar::template <classname>impl</classname>&lt; e2, State, Data &gt;::result_type</type></typedef><typedef name="e3"><type>result_of::child_c&lt; Expr, 3 &gt;::type</type></typedef><typedef name="r3"><type>Grammar::template <classname>impl</classname>&lt; e3, State, Data &gt;::result_type</type></typedef><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(e1, e2, e3)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::function</template-arg><template-arg>5</template-arg></specialization><typedef name="e0"><type>result_of::child_c&lt; Expr, 0 &gt;::type</type></typedef><typedef name="r0"><type>Grammar::template <classname>impl</classname>&lt; e0, State, Data &gt;::result_type</type></typedef><typedef name="e1"><type>result_of::child_c&lt; Expr, 1 &gt;::type</type></typedef><typedef name="r1"><type>Grammar::template <classname>impl</classname>&lt; e1, State, Data &gt;::result_type</type></typedef><typedef name="e2"><type>result_of::child_c&lt; Expr, 2 &gt;::type</type></typedef><typedef name="r2"><type>Grammar::template <classname>impl</classname>&lt; e2, State, Data &gt;::result_type</type></typedef><typedef name="e3"><type>result_of::child_c&lt; Expr, 3 &gt;::type</type></typedef><typedef name="r3"><type>Grammar::template <classname>impl</classname>&lt; e3, State, Data &gt;::result_type</type></typedef><typedef name="e4"><type>result_of::child_c&lt; Expr, 4 &gt;::type</type></typedef><typedef name="r4"><type>Grammar::template <classname>impl</classname>&lt; e4, State, Data &gt;::result_type</type></typedef><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(e1, e2, e3, e4)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::greater</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::greater_equal</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::if_else_</template-arg><template-arg>3</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::less</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::less_equal</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::logical_and</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::logical_not</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::logical_or</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::mem_ptr</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::minus</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::minus_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::modulus</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::modulus_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::multiplies</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::multiplies_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::negate</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::not_equal_to</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::plus</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::plus_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::post_dec</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::post_inc</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::pre_dec</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::pre_inc</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::shift_left</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::shift_left_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::shift_right</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::shift_right_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::subscript</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::terminal</template-arg><template-arg>0</template-arg></specialization><inherit access="public">boost::proto::_child_c&lt; I &gt;::impl&lt; Expr, State, Data &gt;</inherit></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::unary_plus</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization></struct><struct-specialization name="is_callable"><template>
      <template-type-parameter name="Grammar"/>
    </template><specialization><template-arg>_default&lt; Grammar &gt;</template-arg></specialization><inherit access="public">boost::mpl::true_</inherit></struct-specialization><namespace name="context"><struct name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
      <template-type-parameter name="Tag"><default>typename Expr::proto_tag</default></template-type-parameter>
      <template-nontype-parameter name="Arity"><type>long</type><default>Expr::proto_arity::value</default></template-nontype-parameter>
    </template></struct><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::unary_plus</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::negate</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::dereference</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::complement</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::address_of</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::logical_not</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::pre_inc</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::pre_dec</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::shift_left</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::shift_right</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::multiplies</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::divides</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::modulus</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::plus</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::minus</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::less</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::greater</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::less_equal</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::greater_equal</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::equal_to</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::not_equal_to</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::logical_or</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::logical_and</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_and</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_or</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_xor</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::mem_ptr</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::shift_left_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::shift_right_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::multiplies_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::divides_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::modulus_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::plus_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::minus_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_and_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_or_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::bitwise_xor_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::terminal</template-arg><template-arg>0</template-arg></specialization><typedef name="result_type"><type><classname>proto::result_of::value</classname>&lt; Expr &amp; &gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name=""><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::post_inc</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::post_dec</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::subscript</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::if_else_</template-arg><template-arg>3</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::comma</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>1</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type()&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>2</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::child_c&lt; Expr, 1 &gt;::type &gt;::type, Context &gt;::type)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>3</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::child_c&lt; Expr, 1 &gt;::type &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::child_c&lt; Expr, 2 &gt;::type &gt;::type, Context &gt;::type)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>4</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::child_c&lt; Expr, 1 &gt;::type &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::child_c&lt; Expr, 2 &gt;::type &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::child_c&lt; Expr, 3 &gt;::type &gt;::type, Context &gt;::type)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="default_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>proto::tag::function</template-arg><template-arg>5</template-arg></specialization><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::child_c&lt; Expr, 1 &gt;::type &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::child_c&lt; Expr, 2 &gt;::type &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::child_c&lt; Expr, 3 &gt;::type &gt;::type, Context &gt;::type, typename <classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; typename proto::result_of::child_c&lt; Expr, 4 &gt;::type &gt;::type, Context &gt;::type)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct name="default_context"><description><para>default_context </para></description><struct name="eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="ThisContext"><default>default_context const</default></template-type-parameter>
    </template><inherit access="public">boost::proto::context::default_eval&lt; Expr, ThisContext &gt;</inherit><description><para>default_context::eval </para></description></struct></struct></namespace></namespace></namespace></header><header name="boost/proto/transform/default.hpp"><namespace name="boost"><namespace name="proto"><struct name="_default"><template>
      <template-type-parameter name="Grammar"/>
    </template><inherit access="public">transform&lt; boost::proto::_default&lt; Grammar &gt; &gt;</inherit><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::address_of</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::bitwise_and</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::bitwise_and_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::bitwise_or</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::bitwise_or_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::bitwise_xor</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::bitwise_xor_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::complement</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::dereference</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::divides</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::divides_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::equal_to</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::function</template-arg><template-arg>1</template-arg></specialization><typedef name="e0"><type>result_of::child_c&lt; Expr, 0 &gt;::type</type></typedef><typedef name="r0"><type>Grammar::template <classname>impl</classname>&lt; e0, State, Data &gt;::result_type</type></typedef><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type()&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::function</template-arg><template-arg>2</template-arg></specialization><typedef name="e0"><type>result_of::child_c&lt; Expr, 0 &gt;::type</type></typedef><typedef name="r0"><type>Grammar::template <classname>impl</classname>&lt; e0, State, Data &gt;::result_type</type></typedef><typedef name="e1"><type>result_of::child_c&lt; Expr, 1 &gt;::type</type></typedef><typedef name="r1"><type>Grammar::template <classname>impl</classname>&lt; e1, State, Data &gt;::result_type</type></typedef><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(e1)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::function</template-arg><template-arg>3</template-arg></specialization><typedef name="e0"><type>result_of::child_c&lt; Expr, 0 &gt;::type</type></typedef><typedef name="r0"><type>Grammar::template <classname>impl</classname>&lt; e0, State, Data &gt;::result_type</type></typedef><typedef name="e1"><type>result_of::child_c&lt; Expr, 1 &gt;::type</type></typedef><typedef name="r1"><type>Grammar::template <classname>impl</classname>&lt; e1, State, Data &gt;::result_type</type></typedef><typedef name="e2"><type>result_of::child_c&lt; Expr, 2 &gt;::type</type></typedef><typedef name="r2"><type>Grammar::template <classname>impl</classname>&lt; e2, State, Data &gt;::result_type</type></typedef><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(e1, e2)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::function</template-arg><template-arg>4</template-arg></specialization><typedef name="e0"><type>result_of::child_c&lt; Expr, 0 &gt;::type</type></typedef><typedef name="r0"><type>Grammar::template <classname>impl</classname>&lt; e0, State, Data &gt;::result_type</type></typedef><typedef name="e1"><type>result_of::child_c&lt; Expr, 1 &gt;::type</type></typedef><typedef name="r1"><type>Grammar::template <classname>impl</classname>&lt; e1, State, Data &gt;::result_type</type></typedef><typedef name="e2"><type>result_of::child_c&lt; Expr, 2 &gt;::type</type></typedef><typedef name="r2"><type>Grammar::template <classname>impl</classname>&lt; e2, State, Data &gt;::result_type</type></typedef><typedef name="e3"><type>result_of::child_c&lt; Expr, 3 &gt;::type</type></typedef><typedef name="r3"><type>Grammar::template <classname>impl</classname>&lt; e3, State, Data &gt;::result_type</type></typedef><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(e1, e2, e3)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::function</template-arg><template-arg>5</template-arg></specialization><typedef name="e0"><type>result_of::child_c&lt; Expr, 0 &gt;::type</type></typedef><typedef name="r0"><type>Grammar::template <classname>impl</classname>&lt; e0, State, Data &gt;::result_type</type></typedef><typedef name="e1"><type>result_of::child_c&lt; Expr, 1 &gt;::type</type></typedef><typedef name="r1"><type>Grammar::template <classname>impl</classname>&lt; e1, State, Data &gt;::result_type</type></typedef><typedef name="e2"><type>result_of::child_c&lt; Expr, 2 &gt;::type</type></typedef><typedef name="r2"><type>Grammar::template <classname>impl</classname>&lt; e2, State, Data &gt;::result_type</type></typedef><typedef name="e3"><type>result_of::child_c&lt; Expr, 3 &gt;::type</type></typedef><typedef name="r3"><type>Grammar::template <classname>impl</classname>&lt; e3, State, Data &gt;::result_type</type></typedef><typedef name="e4"><type>result_of::child_c&lt; Expr, 4 &gt;::type</type></typedef><typedef name="r4"><type>Grammar::template <classname>impl</classname>&lt; e4, State, Data &gt;::result_type</type></typedef><typedef name="function_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>boost::result_of&lt; function_type(e1, e2, e3, e4)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::greater</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::greater_equal</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::if_else_</template-arg><template-arg>3</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::less</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::less_equal</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::logical_and</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::logical_not</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::logical_or</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::mem_ptr</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::minus</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::minus_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::modulus</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::modulus_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::multiplies</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::multiplies_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::negate</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::not_equal_to</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::plus</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::plus_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::post_dec</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::post_inc</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::pre_dec</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::pre_inc</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::shift_left</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::shift_left_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::shift_right</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::shift_right_assign</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::subscript</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::terminal</template-arg><template-arg>0</template-arg></specialization><inherit access="public">boost::proto::_child_c&lt; I &gt;::impl&lt; Expr, State, Data &gt;</inherit></struct-specialization><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>tag::unary_plus</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization></struct><struct-specialization name="is_callable"><template>
      <template-type-parameter name="Grammar"/>
    </template><specialization><template-arg>_default&lt; Grammar &gt;</template-arg></specialization><inherit access="public">boost::mpl::true_</inherit></struct-specialization></namespace></namespace></header><header name="boost/proto/context/null.hpp"><para>Definintion of null_context&lt;&gt;, an evaluation context for proto::eval() that simply evaluates each child expression, doesn't combine the results at all, and returns void. </para><namespace name="boost"><namespace name="proto"><namespace name="context"><struct name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
      <template-nontype-parameter name="Arity"><type>long</type><default>Expr::proto_arity::value</default></template-nontype-parameter>
    </template></struct><struct-specialization name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>0</template-arg></specialization><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><parameter name=""><paramtype>Expr &amp;</paramtype></parameter><parameter name=""><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>1</template-arg></specialization><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>2</template-arg></specialization><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>3</template-arg></specialization><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>4</template-arg></specialization><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct-specialization name="null_eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Context</template-arg><template-arg>5</template-arg></specialization><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="ctx"><paramtype>Context &amp;</paramtype></parameter></method></method-group></struct-specialization><struct name="null_context"><description><para>null_context </para></description><struct name="eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="ThisContext"><default>null_context const</default></template-type-parameter>
    </template><inherit access="public">boost::proto::context::null_eval&lt; Expr, ThisContext &gt;</inherit><description><para>null_context::eval </para></description></struct></struct></namespace></namespace></namespace></header><header name="boost/proto/core.hpp"><para>Includes the core of Proto. Not included are the contexts, transforms and debugging utilities. </para></header><header name="boost/proto/debug.hpp"><para>Utilities for debugging Proto expression trees </para><namespace name="boost"><namespace name="proto"><namespace name="functional"><struct name="display_expr"><purpose>Pretty-print a Proto expression tree. </purpose><description><para>A PolymorphicFunctionObject which accepts a Proto expression tree and pretty-prints it to an <computeroutput>ostream</computeroutput> for debugging purposes. </para></description><typedef name="result_type"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>proto::expr&lt; <classname>tag::terminal</classname>, Args, 0 &gt; const &amp;</paramtype></parameter><purpose>Pretty-print the current node in a Proto expression tree. </purpose></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>proto::expr&lt; Tag, Args, 1 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>proto::expr&lt; Tag, Args, 2 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>proto::expr&lt; Tag, Args, 3 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>proto::expr&lt; Tag, Args, 4 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Args"/>
        </template><parameter name="expr"><paramtype>proto::expr&lt; Tag, Args, 5 &gt; const &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><constructor><parameter name="sout"><paramtype>std::ostream &amp;</paramtype><default>std::cout</default><description><para>The <computeroutput>ostream</computeroutput> to which the expression tree will be written. </para></description></parameter><parameter name="depth"><paramtype>int</paramtype><default>0</default><description><para>The starting indentation depth for this node. Children nodes will be displayed at a starting depth of <computeroutput>depth+4</computeroutput>. </para></description></parameter><description><para>
</para></description></constructor><method-group name="private member functions"/><copy-assignment><parameter name=""><paramtype><classname>display_expr</classname> const &amp;</paramtype></parameter></copy-assignment></struct></namespace><namespace name="tag"><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::unary_plus</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::negate</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::dereference</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::complement</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::address_of</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::logical_not</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::pre_inc</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::pre_dec</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::post_inc</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::post_dec</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::shift_left</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::shift_right</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::multiplies</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::divides</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::modulus</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::plus</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::minus</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::less</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::greater</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::less_equal</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::greater_equal</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::equal_to</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::not_equal_to</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::logical_or</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::logical_and</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_and</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_or</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_xor</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::comma</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::mem_ptr</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::shift_left_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::shift_right_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::multiplies_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::divides_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::modulus_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::plus_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::minus_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_and_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_or_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::bitwise_xor_assign</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::subscript</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::if_else_</classname></paramtype></parameter></function><function name="proto_tag_name"><type>char const *</type><parameter name=""><paramtype><classname>tag::function</classname></paramtype></parameter></function></namespace><overloaded-function name="display_expr"><signature><type>void</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The Proto expression tree to pretty-print </para></description></parameter><parameter name="sout"><paramtype>std::ostream &amp;</paramtype><description><para>The <computeroutput>ostream</computeroutput> to which the output should be written. If not specified, defaults to <computeroutput>std::cout</computeroutput>. </para></description></parameter></signature><signature><type>void</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></signature><purpose>Pretty-print a Proto expression tree. </purpose><description><para>

</para></description><notes><para>Equivalent to <computeroutput>functional::display_expr(0, sout)(expr)</computeroutput> </para></notes></overloaded-function></namespace></namespace></header><header name="boost/proto/deep_copy.hpp"><para>Replace all nodes stored by reference by nodes stored by value. </para><namespace name="boost"><namespace name="proto"><namespace name="functional"><struct name="deep_copy"><purpose>A PolymorphicFunctionObject type for deep-copying Proto expression trees. </purpose><description><para>A PolymorphicFunctionObject type for deep-copying Proto expression trees. When a tree is deep-copied, all internal nodes and most terminals held by reference are instead held by value.</para><para>
</para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><typedef name="type"><type><classname>result_of::deep_copy</classname>&lt; Expr &gt;::type</type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::deep_copy</classname>&lt; Expr &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><purpose>Deep-copies a Proto expression tree, turning all nodes and terminals held by reference into ones held by value. </purpose></method></method-group></struct></namespace><namespace name="result_of"><struct name="deep_copy"><template>
      <template-type-parameter name="Expr"/>
    </template><purpose>A metafunction for calculating the return type of <computeroutput>proto::deep_copy()</computeroutput>. </purpose><description><para>A metafunction for calculating the return type of <computeroutput>proto::deep_copy()</computeroutput>. The type parameter <computeroutput>Expr</computeroutput> should be the type of a Proto expression tree. It should not be a reference type, nor should it be cv-qualified. </para></description><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct></namespace><function name="deep_copy"><type><classname>proto::result_of::deep_copy</classname>&lt; Expr &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><purpose>A function for deep-copying Proto expression trees. </purpose><description><para>A function for deep-copying Proto expression trees. When a tree is deep-copied, all internal nodes and most terminals held by reference are instead held by value.</para><para>
<para>proto::functional::deep_copy. </para>
</para></description><notes><para>Terminals of reference-to-array type and of reference-to-function type are left unchanged.</para></notes></function></namespace></namespace></header><header name="boost/proto/domain.hpp"><para>Contains definition of domain&lt;&gt; class template and helpers for defining domains with a generator and a grammar for controlling operator overloading. </para><namespace name="boost"><namespace name="proto"><struct name="domain"><template>
      <template-type-parameter name="Generator"><default>default_generator</default></template-type-parameter>
      <template-type-parameter name="Grammar"><default>proto::_</default></template-type-parameter>
    </template><purpose>For use in defining domain tags to be used with <computeroutput>proto::extends&lt;&gt;</computeroutput>. A Domain associates an expression type with a Generator, and optionally a Grammar. </purpose><description><para>The Generator determines how new expressions in the domain are constructed. Typically, a generator wraps all new expressions in a wrapper that imparts domain-specific behaviors to expressions within its domain. (See <computeroutput>proto::extends&lt;&gt;</computeroutput>.)</para><para>The Grammar determines whether a given expression is valid within the domain, and automatically disables any operator overloads which would cause an invalid expression to be created. By default, the Grammar parameter defaults to the wildcard, <computeroutput>proto::_</computeroutput>, which makes all expressions valid within the domain.</para><para>Example: <programlisting> template&lt;typename Expr&gt;
 struct MyExpr;

 struct MyGrammar
   : or_&lt; terminal&lt;_&gt;, plus&lt;MyGrammar, MyGrammar&gt; &gt;
 {};

 // Define MyDomain, in which all expressions are
 // wrapped in MyExpr&lt;&gt; and only expressions that
 // conform to MyGrammar are allowed.
 struct MyDomain
   : domain&lt;generator&lt;MyExpr&gt;, MyGrammar&gt;
 {};

 // Use MyDomain to define MyExpr
 template&lt;typename Expr&gt;
 struct MyExpr
   : extends&lt;Expr, MyExpr&lt;Expr&gt;, MyDomain&gt;
 {
     // ...
 };
</programlisting> </para></description><typedef name="proto_grammar"><type>Grammar</type></typedef><typedef name="proto_is_domain_"><type>void</type></typedef></struct><struct name="default_domain"><inherit access="public">boost::proto::domain&lt; Generator, Grammar &gt;</inherit><purpose>The domain expressions have by default, if <computeroutput>proto::extends&lt;&gt;</computeroutput> has not been used to associate a domain with an expression. </purpose></struct><struct name="deduce_domain"><inherit access="public">boost::proto::domain&lt; Generator, Grammar &gt;</inherit><purpose>A pseudo-domain for use in functions and metafunctions that require a domain parameter. It indicates that the domain of the parent node should be inferred from the domains of the child nodes. </purpose><description><para>
</para></description></struct><namespace name="result_of"><struct name="is_domain"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Void"><default>void</default></template-type-parameter>
    </template><inherit access="public">boost::mpl::false_</inherit><description><para>A metafunction that returns <computeroutput>mpl::true_</computeroutput> if the type <computeroutput>T</computeroutput> is the type of a Proto domain; <computeroutput>mpl::false_</computeroutput> otherwise. If <computeroutput>T</computeroutput> inherits from <computeroutput>proto::domain&lt;&gt;</computeroutput>, <computeroutput>is_domain&lt;T&gt;</computeroutput> is <computeroutput>mpl::true_</computeroutput>. </para></description></struct><struct name="domain_of"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Void"><default>void</default></template-type-parameter>
    </template><description><para>A metafunction that returns the domain of a given type. If <computeroutput>T</computeroutput> is a Proto expression type, it returns that expression's associated domain. If not, it returns <computeroutput>proto::default_domain</computeroutput>. </para></description><typedef name="type"><type><classname>default_domain</classname></type></typedef></struct></namespace></namespace></namespace></header><header name="boost/proto/eval.hpp"><para>Contains the eval() expression evaluator. </para><namespace name="boost"><namespace name="proto"><namespace name="functional"><struct name="eval"><purpose>A PolymorphicFunctionObject type for evaluating a given Proto expression with a given context. </purpose><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><specialization><template-arg>This(Expr</template-arg><template-arg>Context)</template-arg></specialization><typedef name="type"><type><classname>proto::result_of::eval</classname>&lt; typename remove_reference&lt; Expr &gt;::type, typename remove_reference&lt; Context &gt;::type &gt;::type</type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>proto::result_of::eval</classname>&lt; Expr, Context &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="Context"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype><description><para>The Proto expression to evaluate </para></description></parameter><parameter name="context"><paramtype>Context &amp;</paramtype><description><para>The context in which the expression should be evaluated. </para></description></parameter><purpose>Evaluate a given Proto expression with a given context. </purpose><description><para>

</para></description><returns><para><computeroutput>typename Context::template eval&lt;Expr&gt;()(expr, context)</computeroutput> </para></returns></method><method name="operator()" cv="const"><type><classname>proto::result_of::eval</classname>&lt; Expr, Context &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="Context"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group></struct></namespace><namespace name="result_of"><struct name="eval"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Context"/>
    </template><purpose>A metafunction for calculating the return type of <computeroutput>proto::eval()</computeroutput> given a certain <computeroutput>Expr</computeroutput> and <computeroutput>Context</computeroutput> types. </purpose><description><para>
</para></description><typedef name="type"><type>Context::template <classname>eval</classname>&lt; Expr &gt;::result_type</type></typedef></struct></namespace><overloaded-function name="eval"><signature><type><classname>proto::result_of::eval</classname>&lt; Expr, Context &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="Context"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype><description><para>The Proto expression to evaluate </para></description></parameter><parameter name="context"><paramtype>Context &amp;</paramtype><description><para>The context in which the expression should be evaluated. </para></description></parameter></signature><signature><type><classname>proto::result_of::eval</classname>&lt; Expr, Context &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
          <template-type-parameter name="Context"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="context"><paramtype>Context const &amp;</paramtype></parameter></signature><purpose>Evaluate a given Proto expression with a given context. </purpose><description><para>

</para></description><returns><para><computeroutput>typename Context::template eval&lt;Expr&gt;()(expr, context)</computeroutput> </para></returns></overloaded-function></namespace></namespace></header><header name="boost/proto/expr.hpp"><para>Contains definition of expr&lt;&gt; class template. </para><namespace name="boost"><namespace name="proto"><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>0</template-arg></specialization><purpose>Representation of a node in an expression tree. </purpose><description><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a node in an expression template tree. It is a container for its child sub-trees. It also serves as the terminal nodes of the tree.</para><para><computeroutput>Tag</computeroutput> is type that represents the operation encoded by this expression. It is typically one of the structs in the <computeroutput>boost::proto::tag</computeroutput> namespace, but it doesn't have to be. If the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput> then this <computeroutput>expr&lt;&gt;</computeroutput> type represents a leaf in the expression tree.</para><para><computeroutput>Args</computeroutput> is a type list representing the type of the children of this expression. It is an instantiation of one of <computeroutput>proto::list1&lt;&gt;</computeroutput>, <computeroutput>proto::list2&lt;&gt;</computeroutput>, etc. The child types must all themselves be either <computeroutput>expr&lt;&gt;</computeroutput> or <computeroutput>proto::expr&lt;&gt;&amp;</computeroutput>, unless the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput>, in which case <computeroutput>Args</computeroutput> must be <computeroutput>proto::term&lt;T&gt;</computeroutput>, where <computeroutput>T</computeroutput> can be any type.</para><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a valid Fusion random-access sequence, where the elements of the sequence are the child expressions. </para></description><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr, <classname>default_domain</classname> &gt;::type</type></typedef></struct><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arity"><type>mpl::long_&lt; 0 &gt;</type></typedef><typedef name="proto_base_expr"><type>expr</type></typedef><typedef name="proto_args"><type>Args</type></typedef><typedef name="proto_domain"><type><classname>default_domain</classname></type></typedef><typedef name="fusion_tag"><type>proto::tag::proto_expr</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>expr</type></typedef><typedef name="proto_child0"><type>Args::child0</type></typedef><typedef name="proto_child_ref0"><type>Args::child_ref0</type></typedef><typedef name="proto_child1"><type>void</type></typedef><typedef name="proto_child_ref1"><type>void</type></typedef><typedef name="proto_child2"><type>void</type></typedef><typedef name="proto_child_ref2"><type>void</type></typedef><typedef name="proto_child3"><type>void</type></typedef><typedef name="proto_child_ref3"><type>void</type></typedef><typedef name="proto_child4"><type>void</type></typedef><typedef name="proto_child_ref4"><type>void</type></typedef><data-member name="child0"><type>proto_child0</type></data-member><method-group name="public member functions"><method name="proto_base" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="proto_base" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>list2</classname>&lt; expr const &amp;, typename <classname>result_of::as_child</classname>&lt; A &gt;::type &gt;&gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>list2</classname>&lt; expr const &amp;, typename <classname>result_of::as_child</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv=""><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>list2</classname>&lt; expr &amp;, typename <classname>result_of::as_child</classname>&lt; A &gt;::type &gt;&gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv=""><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>list2</classname>&lt; expr &amp;, typename <classname>result_of::as_child</classname>&lt; A const  &gt;::type &gt;&gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>list1</classname>&lt; expr const &amp; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv=""><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>list1</classname>&lt; expr &amp; &gt; &gt; const</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const, <classname>default_domain</classname>, const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const, <classname>default_domain</classname>, const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const, <classname>default_domain</classname>, const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const, <classname>default_domain</classname>, const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><method-group name="public static functions"><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-nontype-parameter name="N"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-nontype-parameter name="N"><type>std::size_t</type></template-nontype-parameter>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name=""><paramtype><emphasis>unspecified</emphasis></paramtype><default>0</default></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>1</template-arg></specialization><purpose>Representation of a node in an expression tree. </purpose><description><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a node in an expression template tree. It is a container for its child sub-trees. It also serves as the terminal nodes of the tree.</para><para><computeroutput>Tag</computeroutput> is type that represents the operation encoded by this expression. It is typically one of the structs in the <computeroutput>boost::proto::tag</computeroutput> namespace, but it doesn't have to be. If the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput> then this <computeroutput>expr&lt;&gt;</computeroutput> type represents a leaf in the expression tree.</para><para><computeroutput>Args</computeroutput> is a type list representing the type of the children of this expression. It is an instantiation of one of <computeroutput>proto::list1&lt;&gt;</computeroutput>, <computeroutput>proto::list2&lt;&gt;</computeroutput>, etc. The child types must all themselves be either <computeroutput>expr&lt;&gt;</computeroutput> or <computeroutput>proto::expr&lt;&gt;&amp;</computeroutput>, unless the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput>, in which case <computeroutput>Args</computeroutput> must be <computeroutput>proto::term&lt;T&gt;</computeroutput>, where <computeroutput>T</computeroutput> can be any type.</para><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a valid Fusion random-access sequence, where the elements of the sequence are the child expressions. </para></description><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr, <classname>default_domain</classname> &gt;::type</type></typedef></struct><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arity"><type>mpl::long_&lt; 1 &gt;</type></typedef><typedef name="proto_base_expr"><type>expr</type></typedef><typedef name="proto_args"><type>Args</type></typedef><typedef name="proto_domain"><type><classname>default_domain</classname></type></typedef><typedef name="fusion_tag"><type>proto::tag::proto_expr</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>expr</type></typedef><typedef name="proto_child0"><type>Args::child0</type></typedef><typedef name="proto_child_ref0"><type>Args::child_ref0</type></typedef><typedef name="proto_child1"><type>void</type></typedef><typedef name="proto_child_ref1"><type>void</type></typedef><typedef name="proto_child2"><type>void</type></typedef><typedef name="proto_child_ref2"><type>void</type></typedef><typedef name="proto_child3"><type>void</type></typedef><typedef name="proto_child_ref3"><type>void</type></typedef><typedef name="proto_child4"><type>void</type></typedef><typedef name="proto_child_ref4"><type>void</type></typedef><typedef name="address_of_hack_type_"><description><para>If <computeroutput>Tag</computeroutput> is <computeroutput>boost::proto::tag::address_of</computeroutput> and <computeroutput>proto_child0</computeroutput> is <computeroutput>T&amp;</computeroutput>, then <computeroutput>address_of_hack_type_</computeroutput> is <computeroutput>T*</computeroutput>. Otherwise, it is some undefined type. </para></description><type><emphasis>unspecified</emphasis></type></typedef><data-member name="child0"><type>proto_child0</type></data-member><method-group name="public member functions"><method name="proto_base" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="proto_base" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="conversion-operator" cv="const"><type>address_of_hack_type_</type><description><para>

</para></description><returns><para>The address of <computeroutput>this-&gt;child0</computeroutput> if <computeroutput>Tag</computeroutput> is <computeroutput>boost::proto::tag::address_of</computeroutput>. Otherwise, this function will fail to compile.</para></returns><notes><para>Proto overloads <computeroutput>operator&amp;</computeroutput>, which means that proto-ified objects cannot have their addresses taken, unless we use the following hack to make <computeroutput>&amp;x</computeroutput> implicitly convertible to <computeroutput>X*</computeroutput>. </para></notes></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>list2</classname>&lt; expr const &amp;, typename <classname>result_of::as_child</classname>&lt; A &gt;::type &gt;&gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>list2</classname>&lt; expr const &amp;, typename <classname>result_of::as_child</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>list1</classname>&lt; expr const &amp; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const, <classname>default_domain</classname>, const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const, <classname>default_domain</classname>, const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const, <classname>default_domain</classname>, const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const, <classname>default_domain</classname>, const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><method-group name="public static functions"><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>2</template-arg></specialization><purpose>Representation of a node in an expression tree. </purpose><description><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a node in an expression template tree. It is a container for its child sub-trees. It also serves as the terminal nodes of the tree.</para><para><computeroutput>Tag</computeroutput> is type that represents the operation encoded by this expression. It is typically one of the structs in the <computeroutput>boost::proto::tag</computeroutput> namespace, but it doesn't have to be. If the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput> then this <computeroutput>expr&lt;&gt;</computeroutput> type represents a leaf in the expression tree.</para><para><computeroutput>Args</computeroutput> is a type list representing the type of the children of this expression. It is an instantiation of one of <computeroutput>proto::list1&lt;&gt;</computeroutput>, <computeroutput>proto::list2&lt;&gt;</computeroutput>, etc. The child types must all themselves be either <computeroutput>expr&lt;&gt;</computeroutput> or <computeroutput>proto::expr&lt;&gt;&amp;</computeroutput>, unless the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput>, in which case <computeroutput>Args</computeroutput> must be <computeroutput>proto::term&lt;T&gt;</computeroutput>, where <computeroutput>T</computeroutput> can be any type.</para><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a valid Fusion random-access sequence, where the elements of the sequence are the child expressions. </para></description><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr, <classname>default_domain</classname> &gt;::type</type></typedef></struct><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arity"><type>mpl::long_&lt; 2 &gt;</type></typedef><typedef name="proto_base_expr"><type>expr</type></typedef><typedef name="proto_args"><type>Args</type></typedef><typedef name="proto_domain"><type><classname>default_domain</classname></type></typedef><typedef name="fusion_tag"><type>proto::tag::proto_expr</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>expr</type></typedef><typedef name="proto_child0"><type>Args::child0</type></typedef><typedef name="proto_child_ref0"><type>Args::child_ref0</type></typedef><typedef name="proto_child1"><type>Args::child1</type></typedef><typedef name="proto_child_ref1"><type>Args::child_ref1</type></typedef><typedef name="proto_child2"><type>void</type></typedef><typedef name="proto_child_ref2"><type>void</type></typedef><typedef name="proto_child3"><type>void</type></typedef><typedef name="proto_child_ref3"><type>void</type></typedef><typedef name="proto_child4"><type>void</type></typedef><typedef name="proto_child_ref4"><type>void</type></typedef><data-member name="child0"><type>proto_child0</type></data-member><data-member name="child1"><type>proto_child1</type></data-member><method-group name="public member functions"><method name="proto_base" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="proto_base" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>list2</classname>&lt; expr const &amp;, typename <classname>result_of::as_child</classname>&lt; A &gt;::type &gt;&gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>list2</classname>&lt; expr const &amp;, typename <classname>result_of::as_child</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>list1</classname>&lt; expr const &amp; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const, <classname>default_domain</classname>, const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const, <classname>default_domain</classname>, const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const, <classname>default_domain</classname>, const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const, <classname>default_domain</classname>, const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><method-group name="public static functions"><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>3</template-arg></specialization><purpose>Representation of a node in an expression tree. </purpose><description><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a node in an expression template tree. It is a container for its child sub-trees. It also serves as the terminal nodes of the tree.</para><para><computeroutput>Tag</computeroutput> is type that represents the operation encoded by this expression. It is typically one of the structs in the <computeroutput>boost::proto::tag</computeroutput> namespace, but it doesn't have to be. If the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput> then this <computeroutput>expr&lt;&gt;</computeroutput> type represents a leaf in the expression tree.</para><para><computeroutput>Args</computeroutput> is a type list representing the type of the children of this expression. It is an instantiation of one of <computeroutput>proto::list1&lt;&gt;</computeroutput>, <computeroutput>proto::list2&lt;&gt;</computeroutput>, etc. The child types must all themselves be either <computeroutput>expr&lt;&gt;</computeroutput> or <computeroutput>proto::expr&lt;&gt;&amp;</computeroutput>, unless the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput>, in which case <computeroutput>Args</computeroutput> must be <computeroutput>proto::term&lt;T&gt;</computeroutput>, where <computeroutput>T</computeroutput> can be any type.</para><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a valid Fusion random-access sequence, where the elements of the sequence are the child expressions. </para></description><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr, <classname>default_domain</classname> &gt;::type</type></typedef></struct><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arity"><type>mpl::long_&lt; 3 &gt;</type></typedef><typedef name="proto_base_expr"><type>expr</type></typedef><typedef name="proto_args"><type>Args</type></typedef><typedef name="proto_domain"><type><classname>default_domain</classname></type></typedef><typedef name="fusion_tag"><type>proto::tag::proto_expr</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>expr</type></typedef><typedef name="proto_child0"><type>Args::child0</type></typedef><typedef name="proto_child_ref0"><type>Args::child_ref0</type></typedef><typedef name="proto_child1"><type>Args::child1</type></typedef><typedef name="proto_child_ref1"><type>Args::child_ref1</type></typedef><typedef name="proto_child2"><type>Args::child2</type></typedef><typedef name="proto_child_ref2"><type>Args::child_ref2</type></typedef><typedef name="proto_child3"><type>void</type></typedef><typedef name="proto_child_ref3"><type>void</type></typedef><typedef name="proto_child4"><type>void</type></typedef><typedef name="proto_child_ref4"><type>void</type></typedef><data-member name="child0"><type>proto_child0</type></data-member><data-member name="child1"><type>proto_child1</type></data-member><data-member name="child2"><type>proto_child2</type></data-member><method-group name="public member functions"><method name="proto_base" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="proto_base" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>list2</classname>&lt; expr const &amp;, typename <classname>result_of::as_child</classname>&lt; A &gt;::type &gt;&gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>list2</classname>&lt; expr const &amp;, typename <classname>result_of::as_child</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>list1</classname>&lt; expr const &amp; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const, <classname>default_domain</classname>, const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const, <classname>default_domain</classname>, const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const, <classname>default_domain</classname>, const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const, <classname>default_domain</classname>, const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><method-group name="public static functions"><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>4</template-arg></specialization><purpose>Representation of a node in an expression tree. </purpose><description><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a node in an expression template tree. It is a container for its child sub-trees. It also serves as the terminal nodes of the tree.</para><para><computeroutput>Tag</computeroutput> is type that represents the operation encoded by this expression. It is typically one of the structs in the <computeroutput>boost::proto::tag</computeroutput> namespace, but it doesn't have to be. If the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput> then this <computeroutput>expr&lt;&gt;</computeroutput> type represents a leaf in the expression tree.</para><para><computeroutput>Args</computeroutput> is a type list representing the type of the children of this expression. It is an instantiation of one of <computeroutput>proto::list1&lt;&gt;</computeroutput>, <computeroutput>proto::list2&lt;&gt;</computeroutput>, etc. The child types must all themselves be either <computeroutput>expr&lt;&gt;</computeroutput> or <computeroutput>proto::expr&lt;&gt;&amp;</computeroutput>, unless the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput>, in which case <computeroutput>Args</computeroutput> must be <computeroutput>proto::term&lt;T&gt;</computeroutput>, where <computeroutput>T</computeroutput> can be any type.</para><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a valid Fusion random-access sequence, where the elements of the sequence are the child expressions. </para></description><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr, <classname>default_domain</classname> &gt;::type</type></typedef></struct><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arity"><type>mpl::long_&lt; 4 &gt;</type></typedef><typedef name="proto_base_expr"><type>expr</type></typedef><typedef name="proto_args"><type>Args</type></typedef><typedef name="proto_domain"><type><classname>default_domain</classname></type></typedef><typedef name="fusion_tag"><type>proto::tag::proto_expr</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>expr</type></typedef><typedef name="proto_child0"><type>Args::child0</type></typedef><typedef name="proto_child_ref0"><type>Args::child_ref0</type></typedef><typedef name="proto_child1"><type>Args::child1</type></typedef><typedef name="proto_child_ref1"><type>Args::child_ref1</type></typedef><typedef name="proto_child2"><type>Args::child2</type></typedef><typedef name="proto_child_ref2"><type>Args::child_ref2</type></typedef><typedef name="proto_child3"><type>Args::child3</type></typedef><typedef name="proto_child_ref3"><type>Args::child_ref3</type></typedef><typedef name="proto_child4"><type>void</type></typedef><typedef name="proto_child_ref4"><type>void</type></typedef><data-member name="child0"><type>proto_child0</type></data-member><data-member name="child1"><type>proto_child1</type></data-member><data-member name="child2"><type>proto_child2</type></data-member><data-member name="child3"><type>proto_child3</type></data-member><method-group name="public member functions"><method name="proto_base" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="proto_base" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>list2</classname>&lt; expr const &amp;, typename <classname>result_of::as_child</classname>&lt; A &gt;::type &gt;&gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>list2</classname>&lt; expr const &amp;, typename <classname>result_of::as_child</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>list1</classname>&lt; expr const &amp; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const, <classname>default_domain</classname>, const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const, <classname>default_domain</classname>, const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const, <classname>default_domain</classname>, const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const, <classname>default_domain</classname>, const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><method-group name="public static functions"><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group></struct-specialization><struct-specialization name="expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Args</template-arg><template-arg>5</template-arg></specialization><purpose>Representation of a node in an expression tree. </purpose><description><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a node in an expression template tree. It is a container for its child sub-trees. It also serves as the terminal nodes of the tree.</para><para><computeroutput>Tag</computeroutput> is type that represents the operation encoded by this expression. It is typically one of the structs in the <computeroutput>boost::proto::tag</computeroutput> namespace, but it doesn't have to be. If the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput> then this <computeroutput>expr&lt;&gt;</computeroutput> type represents a leaf in the expression tree.</para><para><computeroutput>Args</computeroutput> is a type list representing the type of the children of this expression. It is an instantiation of one of <computeroutput>proto::list1&lt;&gt;</computeroutput>, <computeroutput>proto::list2&lt;&gt;</computeroutput>, etc. The child types must all themselves be either <computeroutput>expr&lt;&gt;</computeroutput> or <computeroutput>proto::expr&lt;&gt;&amp;</computeroutput>, unless the <computeroutput>Tag</computeroutput> type is <computeroutput>boost::proto::tag::terminal</computeroutput>, in which case <computeroutput>Args</computeroutput> must be <computeroutput>proto::term&lt;T&gt;</computeroutput>, where <computeroutput>T</computeroutput> can be any type.</para><para><computeroutput>proto::expr&lt;&gt;</computeroutput> is a valid Fusion random-access sequence, where the elements of the sequence are the child expressions. </para></description><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><description><para>Encodes the return type of <computeroutput>expr&lt;&gt;operator()</computeroutput>, for use with <computeroutput>boost::result_of&lt;&gt;</computeroutput> </para></description><typedef name="type"><type>result_of::funop&lt; Sig, expr, <classname>default_domain</classname> &gt;::type</type></typedef></struct><typedef name="proto_tag"><type>Tag</type></typedef><typedef name="proto_arity"><type>mpl::long_&lt; 5 &gt;</type></typedef><typedef name="proto_base_expr"><type>expr</type></typedef><typedef name="proto_args"><type>Args</type></typedef><typedef name="proto_domain"><type><classname>default_domain</classname></type></typedef><typedef name="fusion_tag"><type>proto::tag::proto_expr</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="proto_derived_expr"><type>expr</type></typedef><typedef name="proto_child0"><type>Args::child0</type></typedef><typedef name="proto_child_ref0"><type>Args::child_ref0</type></typedef><typedef name="proto_child1"><type>Args::child1</type></typedef><typedef name="proto_child_ref1"><type>Args::child_ref1</type></typedef><typedef name="proto_child2"><type>Args::child2</type></typedef><typedef name="proto_child_ref2"><type>Args::child_ref2</type></typedef><typedef name="proto_child3"><type>Args::child3</type></typedef><typedef name="proto_child_ref3"><type>Args::child_ref3</type></typedef><typedef name="proto_child4"><type>Args::child4</type></typedef><typedef name="proto_child_ref4"><type>Args::child_ref4</type></typedef><data-member name="child0"><type>proto_child0</type></data-member><data-member name="child1"><type>proto_child1</type></data-member><data-member name="child2"><type>proto_child2</type></data-member><data-member name="child3"><type>proto_child3</type></data-member><data-member name="child4"><type>proto_child4</type></data-member><method-group name="public member functions"><method name="proto_base" cv="const"><type>expr const &amp;</type><description><para>
</para></description><returns><para>*this </para></returns></method><method name="proto_base" cv=""><type>expr &amp;</type><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>list2</classname>&lt; expr const &amp;, typename <classname>result_of::as_child</classname>&lt; A &gt;::type &gt;&gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Subscript</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing <computeroutput>*this</computeroutput> subscripted with <computeroutput>a</computeroutput>. </para></returns></method><method name="operator[]" cv="const"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>list2</classname>&lt; expr const &amp;, typename <classname>result_of::as_child</classname>&lt; A const  &gt;::type &gt; &gt; const</type><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>list1</classname>&lt; expr const &amp; &gt; &gt; const</type><description><para>Function call</para><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing the function invocation of <computeroutput/>(*this)(). </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::funop1</classname>&lt; expr const, <classname>default_domain</classname>, const A0 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop2</classname>&lt; expr const, <classname>default_domain</classname>, const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop3</classname>&lt; expr const, <classname>default_domain</classname>, const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::funop4</classname>&lt; expr const, <classname>default_domain</classname>, const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A &amp;</paramtype><description><para>The rhs. </para></description></parameter><description><para>Assignment</para><para>

</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> node representing an assignment of <computeroutput>a</computeroutput> to <computeroutput>*this</computeroutput>. </para></returns></copy-assignment><copy-assignment><template>
          <template-type-parameter name="A"/>
        </template><parameter name="a"><paramtype>A const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></copy-assignment><method-group name="public static functions"><method name="make" cv=""><type>static expr</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
          <template-type-parameter name="A4"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 const &amp;</paramtype></parameter><parameter name="a4"><paramtype>A4 const &amp;</paramtype></parameter><description><para>
</para></description><returns><para>A new <computeroutput>expr&lt;&gt;</computeroutput> object initialized with the specified arguments. </para></returns></method></method-group></struct-specialization><namespace name="result_of"><struct name="funop0"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Domain"/>
    </template><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose><typedef name="type"><type>proto::expr&lt; <classname>tag::function</classname>, <classname>list1</classname>&lt; Expr &amp; &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>Expr()</template-arg><template-arg>This</template-arg><template-arg>Domain</template-arg></specialization><inherit access="public">boost::proto::result_of::funop0&lt; This, Domain &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>Expr const ()</template-arg><template-arg>This</template-arg><template-arg>Domain</template-arg></specialization><inherit access="public">boost::proto::result_of::funop0&lt; Expr, Domain &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization><struct name="funop1"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="A0"/>
    </template><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose><typedef name="type"><type>proto::expr&lt; <classname>tag::function</classname>, <classname>list2</classname>&lt; Expr &amp;, typename <classname>proto::result_of::as_child</classname>&lt; A0, Domain &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>Expr(A0)</template-arg><template-arg>This</template-arg><template-arg>Domain</template-arg></specialization><inherit access="public">boost::proto::result_of::funop1&lt; This, Domain, remove_reference&lt; A0 &gt;::type &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>Expr const (A0)</template-arg><template-arg>This</template-arg><template-arg>Domain</template-arg></specialization><inherit access="public">boost::proto::result_of::funop1&lt; Expr, Domain, A0 &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization><struct name="funop2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose><typedef name="type"><type>proto::expr&lt; <classname>tag::function</classname>, <classname>list3</classname>&lt; Expr &amp;, typename <classname>proto::result_of::as_child</classname>&lt; A0, Domain &gt;::type, typename <classname>proto::result_of::as_child</classname>&lt; A1, Domain &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>Expr(A0</template-arg><template-arg>A1)</template-arg><template-arg>This</template-arg><template-arg>Domain</template-arg></specialization><inherit access="public">boost::proto::result_of::funop2&lt; This, Domain, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>Expr const (A0</template-arg><template-arg>A1)</template-arg><template-arg>This</template-arg><template-arg>Domain</template-arg></specialization><inherit access="public">boost::proto::result_of::funop2&lt; Expr, Domain, A0, A1 &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization><struct name="funop3"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose><typedef name="type"><type>proto::expr&lt; <classname>tag::function</classname>, <classname>list4</classname>&lt; Expr &amp;, typename <classname>proto::result_of::as_child</classname>&lt; A0, Domain &gt;::type, typename <classname>proto::result_of::as_child</classname>&lt; A1, Domain &gt;::type, typename <classname>proto::result_of::as_child</classname>&lt; A2, Domain &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>Expr(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg><template-arg>This</template-arg><template-arg>Domain</template-arg></specialization><inherit access="public">boost::proto::result_of::funop3&lt; This, Domain, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>Expr const (A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg><template-arg>This</template-arg><template-arg>Domain</template-arg></specialization><inherit access="public">boost::proto::result_of::funop3&lt; Expr, Domain, A0, A1, A2 &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization><struct name="funop4"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose><typedef name="type"><type>proto::expr&lt; <classname>tag::function</classname>, <classname>list5</classname>&lt; Expr &amp;, typename <classname>proto::result_of::as_child</classname>&lt; A0, Domain &gt;::type, typename <classname>proto::result_of::as_child</classname>&lt; A1, Domain &gt;::type, typename <classname>proto::result_of::as_child</classname>&lt; A2, Domain &gt;::type, typename <classname>proto::result_of::as_child</classname>&lt; A3, Domain &gt;::type &gt;&gt;</type></typedef><method-group name="public static functions"><method name="call" cv=""><type>static type const</type><parameter name="expr"><paramtype>Expr &amp;</paramtype></parameter><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>Expr(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg><template-arg>This</template-arg><template-arg>Domain</template-arg></specialization><inherit access="public">boost::proto::result_of::funop4&lt; This, Domain, remove_reference&lt; A0 &gt;::type, remove_reference&lt; A1 &gt;::type, remove_reference&lt; A2 &gt;::type, remove_reference&lt; A3 &gt;::type &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization><struct-specialization name="funop"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>Expr const (A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg><template-arg>This</template-arg><template-arg>Domain</template-arg></specialization><inherit access="public">boost::proto::result_of::funop4&lt; Expr, Domain, A0, A1, A2, A3 &gt;</inherit><purpose>A helper metafunction for computing the return type of <computeroutput>proto::expr&lt;&gt;operator()</computeroutput>. </purpose></struct-specialization></namespace></namespace></namespace></header><header name="boost/proto/extends.hpp"><para>Macros and a base class for defining end-user expression types </para><namespace name="boost"><namespace name="proto"><struct name="is_proto_expr"><purpose>Empty type to be used as a dummy template parameter of POD expression wrappers. It allows argument-dependent lookup to find Proto's operator overloads. </purpose><description><para><computeroutput>proto::is_proto_expr</computeroutput> allows argument-dependent lookup to find Proto's operator overloads. For example:</para><para><programlisting> template&lt;typename T, typename Dummy = proto::is_proto_expr&gt;
 struct my_terminal
 {
     BOOST_PROTO_BASIC_EXTENDS(
         typename proto::terminal&lt;T&gt;::type
       , my_terminal&lt;T&gt;
       , default_domain
     )
 };

 // ...
 my_terminal&lt;int&gt; _1, _2;
 _1 + _2; // OK, uses proto::operator+
</programlisting></para><para>Without the second <computeroutput>Dummy</computeroutput> template parameter, Proto's operator overloads would not be considered by name lookup. </para></description></struct><struct name="extends"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Derived"/>
      <template-type-parameter name="Domain"><default>default_domain</default></template-type-parameter>
      <template-type-parameter name="Tag"><default>typename Expr::proto_tag</default></template-type-parameter>
    </template><purpose>extends&lt;&gt; class template for adding behaviors to a Proto expression template </purpose><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><typedef name="type"><type>boost::result_of&lt; proto_domain(typename boost::proto::result_of::funop&lt; Sig, proto_derived_expr, proto_domain &gt;::type) &gt;::type</type></typedef></struct><data-member name="expr"><type>Expr</type></data-member><typedef name="proto_base_expr"><type>Expr::proto_base_expr</type></typedef><typedef name="proto_domain"><type>Domain</type></typedef><typedef name="proto_derived_expr"><type>Derived</type></typedef><typedef name="proto_tag"><type>proto_base_expr::proto_tag</type></typedef><typedef name="proto_args"><type>proto_base_expr::proto_args</type></typedef><typedef name="proto_arity"><type>proto_base_expr::proto_arity</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="fusion_tag"><type>boost::proto::tag::proto_expr</type></typedef><typedef name="proto_child0"><type>proto_base_expr::proto_child0</type></typedef><typedef name="proto_child1"><type>proto_base_expr::proto_child1</type></typedef><typedef name="proto_child2"><type>proto_base_expr::proto_child2</type></typedef><typedef name="proto_child3"><type>proto_base_expr::proto_child3</type></typedef><typedef name="proto_child4"><type>proto_base_expr::proto_child4</type></typedef><method-group name="public member functions"><method name="proto_base" cv=""><type>proto_base_expr &amp;</type></method><method name="proto_base" cv="const"><type>proto_base_expr const &amp;</type></method></method-group><constructor/><constructor><parameter name="that"><paramtype><classname>extends</classname> const &amp;</paramtype></parameter></constructor><constructor><parameter name="expr_"><paramtype>Expr const &amp;</paramtype></parameter></constructor><method-group name="public static functions"><method name="make" cv=""><type>static proto_derived_expr const</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct-specialization name="extends"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Derived"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>Derived</template-arg><template-arg>Domain</template-arg><template-arg>tag::terminal</template-arg></specialization><purpose>extends&lt;&gt; class template for adding behaviors to a Proto expression template </purpose><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template><typedef name="type"><type>boost::result_of&lt; proto_domain(typename boost::proto::result_of::funop&lt; Sig, proto_derived_expr, proto_domain &gt;::type) &gt;::type</type></typedef></struct><data-member name="expr"><type>Expr</type></data-member><typedef name="proto_base_expr"><type>Expr::proto_base_expr</type></typedef><typedef name="proto_domain"><type>Domain</type></typedef><typedef name="proto_derived_expr"><type>Derived</type></typedef><typedef name="proto_tag"><type>proto_base_expr::proto_tag</type></typedef><typedef name="proto_args"><type>proto_base_expr::proto_args</type></typedef><typedef name="proto_arity"><type>proto_base_expr::proto_arity</type></typedef><typedef name="proto_is_expr_"><type>void</type></typedef><typedef name="fusion_tag"><type>boost::proto::tag::proto_expr</type></typedef><typedef name="proto_child0"><type>proto_base_expr::proto_child0</type></typedef><typedef name="proto_child1"><type>proto_base_expr::proto_child1</type></typedef><typedef name="proto_child2"><type>proto_base_expr::proto_child2</type></typedef><typedef name="proto_child3"><type>proto_base_expr::proto_child3</type></typedef><typedef name="proto_child4"><type>proto_base_expr::proto_child4</type></typedef><method-group name="public member functions"><method name="extends" cv=""><type/></method><method name="extends" cv=""><type/><parameter name="that"><paramtype><classname>extends</classname> const &amp;</paramtype></parameter></method><method name="extends" cv=""><type/><parameter name="expr_"><paramtype>Expr const &amp;</paramtype></parameter></method><method name="proto_base" cv=""><type>proto_base_expr &amp;</type></method><method name="proto_base" cv="const"><type>proto_base_expr const &amp;</type></method></method-group><method-group name="public static functions"><method name="make" cv=""><type>static proto_derived_expr const</type><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct-specialization></namespace></namespace></header><header name="boost/proto/fusion.hpp"><para>Make any Proto expression a valid Fusion sequence </para><namespace name="boost"><namespace name="proto"><namespace name="functional"><struct name="flatten"><purpose>A PolymorphicFunctionObject type that returns a "flattened" view of a Proto expression tree. </purpose><description><para>A PolymorphicFunctionObject type that returns a "flattened" view of a Proto expression tree. For a tree with a top-most node tag of type <computeroutput>T</computeroutput>, the elements of the flattened sequence are determined by recursing into each child node with the same tag type and returning those nodes of different type. So for instance, the Proto expression tree corresponding to the expression <computeroutput>a | b | c</computeroutput> has a flattened view with elements [a, b, c], even though the tree is grouped as <computeroutput>((a | b) | c)</computeroutput>. </para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="pop_front"><purpose>A PolymorphicFunctionObject type that invokes the <computeroutput>fusion::pop_front()</computeroutput> algorithm on its argument. </purpose><description><para>A PolymorphicFunctionObject type that invokes the <computeroutput>fusion::pop_front()</computeroutput> algorithm on its argument. This is useful for defining a CallableTransform like <computeroutput>pop_front(_)</computeroutput> which removes the first child from a Proto expression node. Such a transform might be used as the first argument to the <computeroutput>proto::fold&lt;&gt;</computeroutput> transform; that is, fold all but the first child. </para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><typedef name="type"><type>fusion::result_of::pop_front&lt; typename boost::remove_reference&lt; Expr &gt;::type const  &gt;::type</type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>fusion::result_of::pop_front&lt; Expr const  &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct><struct name="reverse"><purpose>A PolymorphicFunctionObject type that invokes the <computeroutput>fusion::reverse()</computeroutput> algorithm on its argument. </purpose><description><para>A PolymorphicFunctionObject type that invokes the <computeroutput>fusion::reverse()</computeroutput> algorithm on its argument. This is useful for defining a CallableTransform like <computeroutput>reverse(_)</computeroutput> which reverses the order of the children of a Proto expression node. </para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><typedef name="type"><type>fusion::result_of::reverse&lt; typename boost::remove_reference&lt; Expr &gt;::type const  &gt;::type</type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>fusion::result_of::reverse&lt; Expr const  &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct></namespace><function name="flatten"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><purpose>A function that returns a "flattened" view of a Proto expression tree. </purpose><description><para>For a tree with a top-most node tag of type <computeroutput>T</computeroutput>, the elements of the flattened sequence are determined by recursing into each child node with the same tag type and returning those nodes of different type. So for instance, the Proto expression tree corresponding to the expression <computeroutput>a | b | c</computeroutput> has a flattened view with elements [a, b, c], even though the tree is grouped as <computeroutput>((a | b) | c)</computeroutput>. </para></description></function></namespace></namespace></header><header name="boost/proto/generate.hpp"><para>Contains definition of generate&lt;&gt; class template, which end users can specialize for generating domain-specific expression wrappers. </para><namespace name="boost"><namespace name="proto"><struct name="default_generator"><purpose>A simple generator that passes an expression through unchanged. </purpose><description><para>Generators are intended for use as the first template parameter to the <computeroutput>domain&lt;&gt;</computeroutput> class template and control if and how expressions within that domain are to be customized. The <computeroutput>default_generator</computeroutput> makes no modifications to the expressions passed to it. </para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><typedef name="type"><type>Expr</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>Expr const &amp;</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>A Proto expression </para></description></parameter><description><para>

</para></description><returns><para>expr </para></returns></method></method-group></struct><struct name="generator"><template>
      <template-nontype-parameter name="Extends"><type>template&lt; typename &gt; class</type></template-nontype-parameter>
    </template><purpose>A generator that wraps expressions passed to it in the specified extension wrapper. </purpose><description><para>Generators are intended for use as the first template parameter to the <computeroutput>domain&lt;&gt;</computeroutput> class template and control if and how expressions within that domain are to be customized. <computeroutput>generator&lt;&gt;</computeroutput> wraps each expression passed to it in the <computeroutput>Extends&lt;&gt;</computeroutput> wrapper. </para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><typedef name="type"><type>Extends&lt; Expr &gt;</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>Extends&lt; Expr &gt;</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>A Proto expression </para></description></parameter><description><para>

</para></description><returns><para>Extends&lt;Expr&gt;(expr) </para></returns></method></method-group></struct><struct name="pod_generator"><template>
      <template-nontype-parameter name="Extends"><type>template&lt; typename &gt; class</type></template-nontype-parameter>
    </template><purpose>A generator that wraps expressions passed to it in the specified extension wrapper and uses aggregate initialization for the wrapper. </purpose><description><para>Generators are intended for use as the first template parameter to the <computeroutput>domain&lt;&gt;</computeroutput> class template and control if and how expressions within that domain are to be customized. <computeroutput>pod_generator&lt;&gt;</computeroutput> wraps each expression passed to it in the <computeroutput>Extends&lt;&gt;</computeroutput> wrapper, and uses aggregate initialzation for the wrapped object. </para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><typedef name="type"><type>Extends&lt; Expr &gt;</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>Extends&lt; Expr &gt;</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The expression to wrap </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>Extends&lt;Expr&gt; that = {expr}; return that;</computeroutput> </para></returns></method></method-group></struct><struct name="by_value_generator"><purpose>A generator that replaces child nodes held by reference with ones held by value. Use with <computeroutput>compose_generators</computeroutput> to forward that result to another generator. </purpose><description><para>Generators are intended for use as the first template parameter to the <computeroutput>domain&lt;&gt;</computeroutput> class template and control if and how expressions within that domain are to be customized. <computeroutput>by_value_generator</computeroutput> ensures all child nodes are held by value. This generator is typically composed with a second generator for further processing, as <computeroutput>compose_generators&lt;by_value_generator, MyGenerator&gt;</computeroutput>. </para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><typedef name="type"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr)&gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The expression to modify. </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>deep_copy(expr)</computeroutput> </para></returns></method></method-group></struct><struct name="compose_generators"><template>
      <template-type-parameter name="First"/>
      <template-type-parameter name="Second"/>
    </template><purpose>A composite generator that first applies one transform to an expression and then forwards the result on to another generator for further transformation. </purpose><description><para>Generators are intended for use as the first template parameter to the <computeroutput>domain&lt;&gt;</computeroutput> class template and control if and how expressions within that domain are to be customized. <computeroutput>compose_generators&lt;&gt;</computeroutput> is a composite generator that first applies one transform to an expression and then forwards the result on to another generator for further transformation. </para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><typedef name="type"><type>Second::template result&lt; typename First::template result&lt; void(Expr)&gt;::type &gt;::type</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>result&lt; void(Expr)&gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype><description><para>The expression to modify. </para></description></parameter><description><para>

</para></description><returns><para>Second()(First()(expr)) </para></returns></method></method-group></struct></namespace></namespace></header><header name="boost/proto/literal.hpp"><para>The literal&lt;&gt; terminal wrapper, and the proto::lit() function for creating literal&lt;&gt; wrappers. </para><namespace name="boost"><namespace name="proto"><namespace name="utility"><struct name="literal"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"><default>default_domain</default></template-type-parameter>
    </template><inherit access="public">boost::proto::extends&lt; Expr, Derived, Domain, Tag &gt;</inherit><purpose>A simple wrapper for a terminal, provided for ease of use. </purpose><description><para>A simple wrapper for a terminal, provided for ease of use. In all cases, <computeroutput>literal&lt;X&gt; l(x);</computeroutput> is equivalent to <computeroutput>terminal&lt;X&gt;::type l = {x};</computeroutput>.</para><para>The <computeroutput>Domain</computeroutput> template parameter defaults to <computeroutput>proto::default_domain</computeroutput>. </para></description><typedef name="value_type"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="reference"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="const_reference"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="get" cv=""><type>reference</type></method><method name="get" cv="const"><type>const_reference</type></method></method-group><constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype>U &amp;</paramtype></parameter></constructor><constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype>U const &amp;</paramtype></parameter></constructor><constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype><classname>literal</classname>&lt; U, Domain &gt; const &amp;</paramtype></parameter></constructor></struct></namespace><overloaded-function name="lit"><signature><type>literal&lt; T &amp; &gt; const</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype><description><para>The object to wrap. </para></description></parameter></signature><signature><type>literal&lt; T const &amp; &gt; const</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></signature><purpose>A helper function for creating a <computeroutput>literal&lt;&gt;</computeroutput> wrapper. </purpose><description><para>



</para></description><returns><para>literal&lt;T &amp;&gt;(t) </para></returns><throws><simpara>Will not throw.</simpara></throws><notes><para>The returned value holds the argument by reference. </para></notes></overloaded-function></namespace></namespace></header><header name="boost/proto/make_expr.hpp"><para>Definition of the <computeroutput>make_expr()</computeroutput> and <computeroutput>unpack_expr()</computeroutput> utilities for building Proto expression nodes from child nodes or from a Fusion sequence of child nodes, respectively. </para><namespace name="boost"><namespace name="proto"><struct name="_make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"><default>deduce_domain</default></template-type-parameter>
    </template><inherit access="public">boost::proto::callable</inherit><purpose>TODO document me. </purpose><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><method-group name="public member functions"><method name="operator()" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 &amp;</paramtype></parameter></method><method name="operator()" cv="const"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
          <template-type-parameter name="A4"/>
        </template><parameter name="a0"><paramtype>A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>A3 &amp;</paramtype></parameter><parameter name="a4"><paramtype>A4 &amp;</paramtype></parameter></method></method-group></struct><namespace name="functional"><struct name="make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"><default>deduce_domain</default></template-type-parameter>
    </template><purpose>A callable function object equivalent to the <computeroutput>proto::make_expr()</computeroutput> function. </purpose><description><para>In all cases, <computeroutput>functional::make_expr&lt;Tag, Domain&gt;()(a0, ... aN)</computeroutput> is equivalent to <computeroutput>proto::make_expr&lt;Tag, Domain&gt;(a0, ... aN)</computeroutput>.</para><para><computeroutput>functional::make_expr&lt;Tag&gt;()(a0, ... aN)</computeroutput> is equivalent to <computeroutput>proto::make_expr&lt;Tag&gt;(a0, ... aN)</computeroutput>. </para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>This(A0)</template-arg></specialization><typedef name="type"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, A0 &gt;::type</type></typedef></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>This(A0</template-arg><template-arg>A1)</template-arg></specialization><typedef name="type"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, A0, A1 &gt;::type</type></typedef></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg></specialization><typedef name="type"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, A0, A1, A2 &gt;::type</type></typedef></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg></specialization><typedef name="type"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, A0, A1, A2, A3 &gt;::type</type></typedef></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>This(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4)</template-arg></specialization><typedef name="type"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, A0, A1, A2, A3, A4 &gt;::type</type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, A0 const  &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><description><para>Construct an expression node with tag type <computeroutput>Tag</computeroutput> and in the domain <computeroutput>Domain</computeroutput>.</para><para>
</para></description><returns><para><computeroutput>proto::make_expr&lt;Tag, Domain&gt;(a0,...aN)</computeroutput> </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const A0, const A1 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const A0, const A1, const A2 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const A0, const A1, const A2, const A3 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>const A3 &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method><method name="operator()" cv="const"><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const A0, const A1, const A2, const A3, const A4 &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
          <template-type-parameter name="A4"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>const A3 &amp;</paramtype></parameter><parameter name="a4"><paramtype>const A4 &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group></struct><struct name="unpack_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"><default>deduce_domain</default></template-type-parameter>
    </template><purpose>A callable function object equivalent to the <computeroutput>proto::unpack_expr()</computeroutput> function. </purpose><description><para>In all cases, <computeroutput>functional::unpack_expr&lt;Tag, Domain&gt;()(seq)</computeroutput> is equivalent to <computeroutput>proto::unpack_expr&lt;Tag, Domain&gt;(seq)</computeroutput>.</para><para><computeroutput>functional::unpack_expr&lt;Tag&gt;()(seq)</computeroutput> is equivalent to <computeroutput>proto::unpack_expr&lt;Tag&gt;(seq)</computeroutput>. </para></description><struct name="result"><template>
      <template-type-parameter name="Sig"/>
    </template></struct><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>This(Sequence)</template-arg></specialization><typedef name="type"><type><classname>result_of::unpack_expr</classname>&lt; Tag, Domain, typename remove_reference&lt; Sequence &gt;::type &gt;::type</type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::unpack_expr</classname>&lt; Tag, Domain, Sequence const  &gt;::type const</type><template>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="sequence"><paramtype>Sequence const &amp;</paramtype><description><para>A Fusion Random Access Sequence </para></description></parameter><description><para>Construct an expression node with tag type <computeroutput>Tag</computeroutput> and in the domain <computeroutput>Domain</computeroutput>.</para><para>

</para></description><returns><para><computeroutput>proto::unpack_expr&lt;Tag, Domain&gt;(sequence)</computeroutput> </para></returns></method></method-group></struct></namespace><namespace name="result_of"><struct name="make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"><default>void</default></template-type-parameter>
      <template-type-parameter name="A2"><default>void</default></template-type-parameter>
      <template-type-parameter name="A3"><default>void</default></template-type-parameter>
      <template-type-parameter name="A4"><default>void</default></template-type-parameter>
      <template-type-parameter name="Void1"><default>void</default></template-type-parameter>
      <template-type-parameter name="Void2"><default>void</default></template-type-parameter>
    </template><purpose>Metafunction that computes the return type of the <computeroutput>make_expr()</computeroutput> function, with a domain deduced from the domains of the children. </purpose><description><para>Use the <computeroutput>result_of::make_expr&lt;&gt;</computeroutput> metafunction to compute the return type of the <computeroutput>make_expr()</computeroutput> function.</para><para>In this specialization, the domain is deduced from the domains of the child types. (If <computeroutput>is_domain&lt;A0&gt;::value</computeroutput> is <computeroutput>true</computeroutput>, then another specialization is selected.) </para></description><typedef name="type"><description><para>Same as <computeroutput>result_of::make_expr&lt;Tag, D, A0, ... AN&gt;::type</computeroutput> where <computeroutput>D</computeroutput> is the deduced domain, which is calculated as follows:</para><para>For each <computeroutput>x</computeroutput> in <computeroutput>[0,N)</computeroutput> (proceeding in order beginning with <computeroutput>x=0</computeroutput>), if <computeroutput>domain_of&lt;Ax&gt;::type</computeroutput> is not <computeroutput>default_domain</computeroutput>, then <computeroutput>D</computeroutput> is <computeroutput>domain_of&lt;Ax&gt;::type</computeroutput>. Otherwise, <computeroutput>D</computeroutput> is <computeroutput>default_domain</computeroutput>. </para></description><type><emphasis>unspecified</emphasis></type></typedef></struct><struct-specialization name="make_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Domain</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4</template-arg><template-arg>typename Domain::proto_is_domain_</template-arg></specialization><purpose>Metafunction that computes the return type of the <computeroutput>make_expr()</computeroutput> function, within the specified domain. </purpose><description><para>Use the <computeroutput>result_of::make_expr&lt;&gt;</computeroutput> metafunction to compute the return type of the <computeroutput>make_expr()</computeroutput> function. </para></description><typedef name="type"><description><para>If <computeroutput>Tag</computeroutput> is <computeroutput>tag::terminal</computeroutput>, then <computeroutput>type</computeroutput> is a typedef for <computeroutput>boost::result_of&lt;Domain(expr&lt;tag::terminal, term&lt;A0&gt; &gt;)&gt;::type</computeroutput>.</para><para>Otherwise, <computeroutput>type</computeroutput> is a typedef for <computeroutput>boost::result_of&lt;Domain(expr&lt;Tag, listN&lt; as_child&lt;A0&gt;::type, ... as_child&lt;AN&gt;::type&gt;) &gt;::type</computeroutput>, where <computeroutput>N</computeroutput> is the number of non-void template arguments, and <computeroutput>as_child&lt;A&gt;::type</computeroutput> is evaluated as follows:</para><para><itemizedlist>
<listitem><para>If <computeroutput>is_expr&lt;A&gt;::value</computeroutput> is <computeroutput>true</computeroutput>, then the child type is <computeroutput>A</computeroutput>. </para></listitem>
<listitem><para>If <computeroutput>A</computeroutput> is <computeroutput>B &amp;</computeroutput> or <computeroutput>cv boost::reference_wrapper&lt;B&gt;</computeroutput>, and <computeroutput>is_expr&lt;B&gt;::value</computeroutput> is <computeroutput>true</computeroutput>, then the child type is <computeroutput>B &amp;</computeroutput>. </para></listitem>
<listitem><para>If <computeroutput>is_expr&lt;A&gt;::value</computeroutput> is <computeroutput>false</computeroutput>, then the child type is <computeroutput>boost::result_of&lt;Domain(expr&lt;tag::terminal, term&lt;A&gt; &gt; )&gt;::type</computeroutput>. </para></listitem>
<listitem><para>If <computeroutput>A</computeroutput> is <computeroutput>B &amp;</computeroutput> or <computeroutput>cv boost::reference_wrapper&lt;B&gt;</computeroutput>, and <computeroutput>is_expr&lt;B&gt;::value</computeroutput> is <computeroutput>false</computeroutput>, then the child type is <computeroutput>boost::result_of&lt;Domain(expr&lt;tag::terminal, term&lt;B &amp;&gt; &gt; )&gt;::type</computeroutput>. </para></listitem>
</itemizedlist>
</para></description><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct name="unpack_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Sequence"/>
      <template-type-parameter name="Void1"><default>void</default></template-type-parameter>
      <template-type-parameter name="Void2"><default>void</default></template-type-parameter>
    </template><purpose>Metafunction that computes the return type of the <computeroutput>unpack_expr()</computeroutput> function, with a domain deduced from the domains of the children. </purpose><description><para>Use the <computeroutput>result_of::unpack_expr&lt;&gt;</computeroutput> metafunction to compute the return type of the <computeroutput>unpack_expr()</computeroutput> function.</para><para><computeroutput>Sequence</computeroutput> is a Fusion Random Access Sequence.</para><para>In this specialization, the domain is deduced from the domains of the child types. (If <computeroutput>is_domain&lt;Sequence&gt;::value</computeroutput> is <computeroutput>true</computeroutput>, then another specialization is selected.) </para></description><typedef name="type"><description><para>Same as <computeroutput>result_of::make_expr&lt;Tag, fusion::value_at&lt;Sequence, 0&gt;::type, ... fusion::value_at&lt;Sequence, N-1&gt;::type&gt;::type</computeroutput>, where <computeroutput>N</computeroutput> is the size of <computeroutput>Sequence</computeroutput>. </para></description><type><emphasis>unspecified</emphasis></type></typedef></struct><struct-specialization name="unpack_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Domain"/>
      <template-type-parameter name="Sequence"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>Domain</template-arg><template-arg>Sequence</template-arg><template-arg>typename Domain::proto_is_domain_</template-arg></specialization><purpose>Metafunction that computes the return type of the <computeroutput>unpack_expr()</computeroutput> function, within the specified domain. </purpose><description><para>Use the <computeroutput>result_of::make_expr&lt;&gt;</computeroutput> metafunction to compute the return type of the <computeroutput>make_expr()</computeroutput> function. </para></description><typedef name="type"><description><para>Same as <computeroutput>result_of::make_expr&lt;Tag, Domain, fusion::value_at&lt;Sequence, 0&gt;::type, ... fusion::value_at&lt;Sequence, N-1&gt;::type&gt;::type</computeroutput>, where <computeroutput>N</computeroutput> is the size of <computeroutput>Sequence</computeroutput>. </para></description><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization></namespace><overloaded-function name="make_expr"><signature><type>lazy_disable_if&lt; is_domain&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, A0 const  &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, B0 const  &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
        </template><parameter name="b0"><paramtype>B0 const &amp;</paramtype></parameter></signature><signature><type>lazy_disable_if&lt; is_domain&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, const A0, const A1 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const B0, const B1 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
          <template-type-parameter name="B1"/>
        </template><parameter name="b0"><paramtype>const B0 &amp;</paramtype></parameter><parameter name="b1"><paramtype>const B1 &amp;</paramtype></parameter></signature><signature><type>lazy_disable_if&lt; is_domain&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, const A0, const A1, const A2 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const B0, const B1, const B2 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
          <template-type-parameter name="B1"/>
          <template-type-parameter name="B2"/>
        </template><parameter name="b0"><paramtype>const B0 &amp;</paramtype></parameter><parameter name="b1"><paramtype>const B1 &amp;</paramtype></parameter><parameter name="b2"><paramtype>const B2 &amp;</paramtype></parameter></signature><signature><type>lazy_disable_if&lt; is_domain&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, const A0, const A1, const A2, const A3 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>const A3 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const B0, const B1, const B2, const B3 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
          <template-type-parameter name="B1"/>
          <template-type-parameter name="B2"/>
          <template-type-parameter name="B3"/>
        </template><parameter name="b0"><paramtype>const B0 &amp;</paramtype></parameter><parameter name="b1"><paramtype>const B1 &amp;</paramtype></parameter><parameter name="b2"><paramtype>const B2 &amp;</paramtype></parameter><parameter name="b3"><paramtype>const B3 &amp;</paramtype></parameter></signature><signature><type>lazy_disable_if&lt; is_domain&lt; A0 &gt;, <classname>result_of::make_expr</classname>&lt; Tag, const A0, const A1, const A2, const A3, const A4 &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
          <template-type-parameter name="A3"/>
          <template-type-parameter name="A4"/>
        </template><parameter name="a0"><paramtype>const A0 &amp;</paramtype></parameter><parameter name="a1"><paramtype>const A1 &amp;</paramtype></parameter><parameter name="a2"><paramtype>const A2 &amp;</paramtype></parameter><parameter name="a3"><paramtype>const A3 &amp;</paramtype></parameter><parameter name="a4"><paramtype>const A4 &amp;</paramtype></parameter></signature><signature><type><classname>result_of::make_expr</classname>&lt; Tag, Domain, const B0, const B1, const B2, const B3, const B4 &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="B0"/>
          <template-type-parameter name="B1"/>
          <template-type-parameter name="B2"/>
          <template-type-parameter name="B3"/>
          <template-type-parameter name="B4"/>
        </template><parameter name="b0"><paramtype>const B0 &amp;</paramtype></parameter><parameter name="b1"><paramtype>const B1 &amp;</paramtype></parameter><parameter name="b2"><paramtype>const B2 &amp;</paramtype></parameter><parameter name="b3"><paramtype>const B3 &amp;</paramtype></parameter><parameter name="b4"><paramtype>const B4 &amp;</paramtype></parameter></signature><purpose>Construct an expression of the requested tag type with a domain and with the specified arguments as children. </purpose><description><para>This function template may be invoked either with or without specifying a <computeroutput>Domain</computeroutput> argument. If no domain is specified, the domain is deduced by examining in order the domains of the given arguments and taking the first that is not <computeroutput>default_domain</computeroutput>, if any such domain exists, or <computeroutput>default_domain</computeroutput> otherwise.</para><para>Let <computeroutput>wrap_(x)</computeroutput> be defined such that: <itemizedlist>
<listitem><para>If <computeroutput>x</computeroutput> is a <computeroutput>boost::reference_wrapper&lt;&gt;</computeroutput>, <computeroutput>wrap_(x)</computeroutput> is equivalent to <computeroutput>as_child&lt;Domain&gt;(x.get())</computeroutput>. </para></listitem>
<listitem><para>Otherwise, <computeroutput>wrap_(x)</computeroutput> is equivalent to <computeroutput>as_expr&lt;Domain&gt;(x)</computeroutput>.</para></listitem>
</itemizedlist>
Let <computeroutput>make_&lt;Tag&gt;(b0,...bN)</computeroutput> be defined as <computeroutput>expr&lt;Tag, listN&lt;B0,...BN&gt; &gt;::make(b0,...bN)</computeroutput> where <computeroutput>Bx</computeroutput> is the type of <computeroutput>bx</computeroutput>.</para><para>
</para></description><returns><para><computeroutput>Domain()(make_&lt;Tag&gt;(wrap_(a0),...wrap_(aN)))</computeroutput>. </para></returns></overloaded-function><overloaded-function name="unpack_expr"><signature><type>lazy_disable_if&lt; is_domain&lt; Sequence &gt;, <classname>result_of::unpack_expr</classname>&lt; Tag, Sequence const  &gt;&gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Sequence"/>
        </template><parameter name="sequence"><paramtype>Sequence const &amp;</paramtype><description><para>a Fusion Random Access Sequence. </para></description></parameter></signature><signature><type><classname>result_of::unpack_expr</classname>&lt; Tag, Domain, Sequence2 const  &gt;::type const</type><template>
          <template-type-parameter name="Tag"/>
          <template-type-parameter name="Domain"/>
          <template-type-parameter name="Sequence2"/>
        </template><parameter name="sequence2"><paramtype>Sequence2 const &amp;</paramtype></parameter></signature><purpose>Construct an expression of the requested tag type with a domain and with childres from the specified Fusion Random Access Sequence. </purpose><description><para>This function template may be invoked either with or without specifying a <computeroutput>Domain</computeroutput> argument. If no domain is specified, the domain is deduced by examining in order the domains of the elements of <computeroutput>sequence</computeroutput> and taking the first that is not <computeroutput>default_domain</computeroutput>, if any such domain exists, or <computeroutput>default_domain</computeroutput> otherwise.</para><para>Let <computeroutput>wrap_&lt;N&gt;(s)</computeroutput>, where <computeroutput>s</computeroutput> has type <computeroutput>S</computeroutput>, be defined such that: <itemizedlist>
<listitem><para>If <computeroutput>fusion::value_at&lt;S,N&gt;::type</computeroutput> is a reference, <computeroutput>wrap_&lt;N&gt;(s)</computeroutput> is equivalent to <computeroutput>as_child&lt;Domain&gt;(fusion::at_c&lt;N&gt;(s))</computeroutput>. </para></listitem>
<listitem><para>Otherwise, <computeroutput>wrap_&lt;N&gt;(s)</computeroutput> is equivalent to <computeroutput>as_expr&lt;Domain&gt;(fusion::at_c&lt;N&gt;(s))</computeroutput>.</para></listitem>
</itemizedlist>
Let <computeroutput>make_&lt;Tag&gt;(b0,...bN)</computeroutput> be defined as <computeroutput>expr&lt;Tag, listN&lt;B0,...BN&gt; &gt;::make(b0,...bN)</computeroutput> where <computeroutput>Bx</computeroutput> is the type of <computeroutput>bx</computeroutput>.</para><para>

</para></description><returns><para><computeroutput>Domain()(make_&lt;Tag&gt;(wrap_&lt;0&gt;(s),...wrap_&lt;N-1&gt;(S)))</computeroutput>, where N is the size of <computeroutput>Sequence</computeroutput>. </para></returns></overloaded-function></namespace></namespace></header><header name="boost/proto/matches.hpp"><para>Contains definition of matches&lt;&gt; metafunction for determining if a given expression matches a given pattern. </para><namespace name="boost"><namespace name="proto"><namespace name="control"><struct name="not_"><template>
      <template-type-parameter name="Grammar"/>
    </template><inherit access="public">transform&lt; boost::proto::control::not_&lt; Grammar &gt; &gt;</inherit><purpose>Inverts the set of expressions matched by a grammar. When used as a transform, <computeroutput>not_&lt;&gt;</computeroutput> returns the current expression unchanged. </purpose><description><para>If an expression type <computeroutput>E</computeroutput> does not match a grammar <computeroutput>G</computeroutput>, then <computeroutput>E</computeroutput> does match <computeroutput>not_&lt;G&gt;</computeroutput>. For example, <computeroutput>not_&lt;terminal&lt;_&gt; &gt;</computeroutput> will match any non-terminal. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="result_type"><type>Expr</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>impl::expr_param</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>An expression </para></description></parameter><parameter name=""><paramtype>typename impl::state_param</paramtype></parameter><parameter name=""><paramtype>typename impl::data_param</paramtype></parameter><description><para>


</para></description><requires><para><computeroutput>matches&lt;Expr,not_&gt;::value</computeroutput> is <computeroutput>true</computeroutput>. </para></requires><returns><para><computeroutput>expr</computeroutput> </para></returns></method></method-group></struct><typedef name="proto_base_expr"><type><classname>not_</classname></type></typedef></struct><struct name="if_"><template>
      <template-type-parameter name="If"/>
      <template-type-parameter name="Then"><default>_</default></template-type-parameter>
      <template-type-parameter name="Else"><default>not_&lt;_&gt;</default></template-type-parameter>
    </template><inherit access="public">transform&lt; boost::proto::control::if_&lt; If, Then, Else &gt; &gt;</inherit><purpose>Used to select one grammar or another based on the result of a compile-time Boolean. When used as a transform, <computeroutput>if_&lt;&gt;</computeroutput> selects between two transforms based on a compile-time Boolean. </purpose><description><para>When <computeroutput>if_&lt;If,Then,Else&gt;</computeroutput> is used as a grammar, <computeroutput>If</computeroutput> must be a Proto transform and <computeroutput>Then</computeroutput> and <computeroutput>Else</computeroutput> must be grammars. An expression type <computeroutput>E</computeroutput> matches <computeroutput>if_&lt;If,Then,Else&gt;</computeroutput> if <computeroutput>when&lt;_,If&gt;::result&lt;void(E,int,int)&gt;::type::value</computeroutput> is <computeroutput>true</computeroutput> and <computeroutput>E</computeroutput> matches <computeroutput>U</computeroutput>; or, if <computeroutput>when&lt;_,If&gt;::result&lt;void(E,int,int)&gt;::type::value</computeroutput> is <computeroutput>false</computeroutput> and <computeroutput>E</computeroutput> matches <computeroutput>V</computeroutput>.</para><para>The template parameter <computeroutput>Then</computeroutput> defaults to <computeroutput>_</computeroutput> and <computeroutput>Else</computeroutput> defaults to <computeroutput>not&lt;_&gt;</computeroutput>, so an expression type <computeroutput>E</computeroutput> will match <computeroutput>if_&lt;If&gt;</computeroutput> if and only if <computeroutput>when&lt;_,If&gt;::result&lt;void(E,int,int)&gt;::type::value</computeroutput> is <computeroutput>true</computeroutput>.</para><para><programlisting> // A grammar that only matches integral terminals,
 // using is_integral&lt;&gt; from Boost.Type_traits.
 struct IsIntegral
   : and_&lt;
         terminal&lt;_&gt;
       , if_&lt; is_integral&lt;_value&gt;() &gt;
     &gt;
 {};
</programlisting></para><para>When <computeroutput>if_&lt;If,Then,Else&gt;</computeroutput> is used as a transform, <computeroutput>If</computeroutput>, <computeroutput>Then</computeroutput> and <computeroutput>Else</computeroutput> must be Proto transforms. When applying the transform to an expression <computeroutput>E</computeroutput>, state <computeroutput>S</computeroutput> and data <computeroutput>V</computeroutput>, if <computeroutput>when&lt;_,If&gt;::result&lt;void(E,S,V)&gt;::type::value</computeroutput> is <computeroutput>true</computeroutput> then the <computeroutput>Then</computeroutput> transform is applied; otherwise the <computeroutput>Else</computeroutput> transform is applied.</para><para><programlisting> // Match a terminal. If the terminal is integral, return
 // mpl::true_; otherwise, return mpl::false_.
 struct IsIntegral2
   : when&lt;
         terminal&lt;_&gt;
       , if_&lt;
             is_integral&lt;_value&gt;()
           , mpl::true_()
           , mpl::false_()
         &gt;
     &gt;
 {};
</programlisting> </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="condition"><type><classname>when</classname>&lt; _, If &gt;::template <classname>impl</classname>&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="which"><type>mpl::if_c&lt; remove_reference&lt; condition &gt;::type::value, <classname>when</classname>&lt; _, Then &gt;, <classname>when</classname>&lt; _, Else &gt;&gt;::type</type></typedef><typedef name="result_type"><type>which::template <classname>impl</classname>&lt; Expr, State, Data &gt;::result_type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>An expression </para></description></parameter><parameter name="state"><paramtype>typename impl::state_param</paramtype><description><para>The current state </para></description></parameter><parameter name="data"><paramtype>typename impl::data_param</paramtype><description><para>A data of arbitrary type </para></description></parameter><description><para>

</para></description><returns><para><computeroutput>which::impl&lt;Expr, State, Data&gt;()(expr, state, data)</computeroutput> </para></returns></method></method-group></struct><typedef name="proto_base_expr"><type><classname>if_</classname></type></typedef></struct><struct name="or_"><template>
      <template-type-parameter name="G0"/>
      <template-type-parameter name="G1"/>
      <template-type-parameter name="G2"/>
      <template-type-parameter name="G3"/>
      <template-type-parameter name="G4"/>
      <template-type-parameter name="G5"/>
      <template-type-parameter name="G6"/>
      <template-type-parameter name="G7"/>
    </template><inherit access="public">transform&lt; boost::proto::control::or_&lt; G0, G1, G2, G3, G4, G5, G6, G7 &gt; &gt;</inherit><purpose>For matching one of a set of alternate grammars. Alternates tried in order to avoid ambiguity. When used as a transform, <computeroutput>or_&lt;&gt;</computeroutput> applies the transform associated with the first grammar that matches the expression. </purpose><description><para>An expression type <computeroutput>E</computeroutput> matches <computeroutput>or_&lt;B0,B1,...Bn&gt;</computeroutput> if <computeroutput>E</computeroutput> matches any <computeroutput>Bx</computeroutput> for <computeroutput>x</computeroutput> in <computeroutput>[0,n)</computeroutput>.</para><para>When applying <computeroutput>or_&lt;B0,B1,...Bn&gt;</computeroutput> as a transform with an expression <computeroutput>e</computeroutput> of type <computeroutput>E</computeroutput>, state <computeroutput>s</computeroutput> and data <computeroutput>v</computeroutput>, it is equivalent to <computeroutput>Bx()(e, s, v)</computeroutput>, where <computeroutput>x</computeroutput> is the lowest number such that <computeroutput>matches&lt;E,Bx&gt;::value</computeroutput> is <computeroutput>true</computeroutput>. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><description><para>


</para></description></struct><struct-specialization name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr &amp;</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg></specialization></struct-specialization><typedef name="proto_base_expr"><type><classname>or_</classname></type></typedef></struct><struct name="and_"><template>
      <template-type-parameter name="G0"/>
      <template-type-parameter name="G1"/>
      <template-type-parameter name="G2"/>
      <template-type-parameter name="G3"/>
      <template-type-parameter name="G4"/>
      <template-type-parameter name="G5"/>
      <template-type-parameter name="G6"/>
      <template-type-parameter name="G7"/>
    </template><inherit access="public">transform&lt; boost::proto::control::and_&lt; G0, G1, G2, G3, G4, G5, G6, G7 &gt; &gt;</inherit><purpose>For matching all of a set of grammars. When used as a transform, <computeroutput>and_&lt;&gt;</computeroutput> applies the transform associated with the last grammar in the set. </purpose><description><para>An expression type <computeroutput>E</computeroutput> matches <computeroutput>and_&lt;B0,B1,...Bn&gt;</computeroutput> if <computeroutput>E</computeroutput> matches all <computeroutput>Bx</computeroutput> for <computeroutput>x</computeroutput> in <computeroutput>[0,n)</computeroutput>.</para><para>When applying <computeroutput>and_&lt;B0,B1,...Bn&gt;</computeroutput> as a transform with an expression <computeroutput>e</computeroutput>, state <computeroutput>s</computeroutput> and data <computeroutput>v</computeroutput>, it is equivalent to <computeroutput>Bn()(e, s, v)</computeroutput>. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="proto_base_expr"><type><classname>and_</classname></type></typedef></struct><struct name="switch_"><template>
      <template-type-parameter name="Cases"/>
    </template><inherit access="public">transform&lt; boost::proto::control::switch_&lt; Cases &gt; &gt;</inherit><purpose>For matching one of a set of alternate grammars, which are looked up based on an expression's tag type. When used as a transform, <computeroutput>switch_&lt;&gt;</computeroutput> applies the transform associated with the grammar that matches the expression. </purpose><description><para>
An expression type <computeroutput>E</computeroutput> matches <computeroutput>switch_&lt;C&gt;</computeroutput> if <computeroutput>E</computeroutput> matches <computeroutput>C::case_&lt;E::proto_tag&gt;</computeroutput>.</para><para>When applying <computeroutput>switch_&lt;C&gt;</computeroutput> as a transform with an expression <computeroutput>e</computeroutput> of type <computeroutput>E</computeroutput>, state <computeroutput>s</computeroutput> and data <computeroutput>v</computeroutput>, it is equivalent to <computeroutput>C::case_&lt;E::proto_tag&gt;()(e, s, v)</computeroutput>. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><description><para>


</para></description></struct><struct-specialization name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr &amp;</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg></specialization></struct-specialization><typedef name="proto_base_expr"><type><classname>switch_</classname></type></typedef></struct><struct name="exact"><template>
      <template-type-parameter name="T"/>
    </template><purpose>For forcing exact matches of terminal types. </purpose><description><para>By default, matching terminals ignores references and cv-qualifiers. For instance, a terminal expression of type <computeroutput>terminal&lt;int const &amp;&gt;::type</computeroutput> will match the grammar <computeroutput>terminal&lt;int&gt;</computeroutput>. If that is not desired, you can force an exact match with <computeroutput>terminal&lt;exact&lt;int&gt; &gt;</computeroutput>. This will only match integer terminals where the terminal is held by value. </para></description></struct><struct name="convertible_to"><template>
      <template-type-parameter name="T"/>
    </template><purpose>For matching terminals that are convertible to a type. </purpose><description><para>Use <computeroutput>convertible_to&lt;&gt;</computeroutput> to match a terminal that is convertible to some type. For example, the grammar <computeroutput>terminal&lt;convertible_to&lt;int&gt; &gt;</computeroutput> will match any terminal whose argument is convertible to an integer.</para><para>
</para></description></struct><struct name="vararg"><template>
      <template-type-parameter name="Grammar"/>
    </template><purpose>For matching a Grammar to a variable number of sub-expressions. </purpose><description><para>An expression type <computeroutput>expr&lt;AT, listN&lt;A0,...An,U0,...Um&gt; &gt;</computeroutput> matches a grammar <computeroutput>expr&lt;BT, listM&lt;B0,...Bn,vararg&lt;V&gt; &gt; &gt;</computeroutput> if <computeroutput>BT</computeroutput> is <computeroutput>_</computeroutput> or <computeroutput>AT</computeroutput>, and if <computeroutput>Ax</computeroutput> matches <computeroutput>Bx</computeroutput> for each <computeroutput>x</computeroutput> in <computeroutput>[0,n)</computeroutput> and if <computeroutput>Ux</computeroutput> matches <computeroutput>V</computeroutput> for each <computeroutput>x</computeroutput> in <computeroutput>[0,m)</computeroutput>.</para><para>For example:</para><para><programlisting> // Match any function call expression, irregardless
 // of the number of function arguments:
 struct Function
   : function&lt; vararg&lt;_&gt; &gt;
 {};
</programlisting></para><para>When used as a transform, <computeroutput>vararg&lt;G&gt;</computeroutput> applies <computeroutput>G</computeroutput>'s transform. </para></description><typedef name="proto_is_vararg_"><type>void</type></typedef></struct></namespace><namespace name="result_of"><struct name="matches"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Grammar"/>
    </template><purpose>A Boolean metafunction that evaluates whether a given expression type matches a grammar. </purpose><description><para><computeroutput>matches&lt;Expr,Grammar&gt;</computeroutput> inherits (indirectly) from <computeroutput>mpl::true_</computeroutput> if <computeroutput>Expr::proto_base_expr</computeroutput> matches <computeroutput>Grammar::proto_base_expr</computeroutput>, and from <computeroutput>mpl::false_</computeroutput> otherwise.</para><para>Non-terminal expressions are matched against a grammar according to the following rules:</para><para><itemizedlist>
<listitem><para>The wildcard pattern, <computeroutput>_</computeroutput>, matches any expression. </para></listitem>
<listitem><para>An expression <computeroutput>expr&lt;AT, listN&lt;A0,A1,...An&gt; &gt;</computeroutput> matches a grammar <computeroutput>expr&lt;BT, listN&lt;B0,B1,...Bn&gt; &gt;</computeroutput> if <computeroutput>BT</computeroutput> is <computeroutput>_</computeroutput> or <computeroutput>AT</computeroutput>, and if <computeroutput>Ax</computeroutput> matches <computeroutput>Bx</computeroutput> for each <computeroutput>x</computeroutput> in <computeroutput>[0,n)</computeroutput>. </para></listitem>
<listitem><para>An expression <computeroutput>expr&lt;AT, listN&lt;A0,...An,U0,...Um&gt; &gt;</computeroutput> matches a grammar <computeroutput>expr&lt;BT, listM&lt;B0,...Bn,vararg&lt;V&gt; &gt; &gt;</computeroutput> if <computeroutput>BT</computeroutput> is <computeroutput>_</computeroutput> or <computeroutput>AT</computeroutput>, and if <computeroutput>Ax</computeroutput> matches <computeroutput>Bx</computeroutput> for each <computeroutput>x</computeroutput> in <computeroutput>[0,n)</computeroutput> and if <computeroutput>Ux</computeroutput> matches <computeroutput>V</computeroutput> for each <computeroutput>x</computeroutput> in <computeroutput>[0,m)</computeroutput>. </para></listitem>
<listitem><para>An expression <computeroutput>E</computeroutput> matches <computeroutput>or_&lt;B0,B1,...Bn&gt;</computeroutput> if <computeroutput>E</computeroutput> matches some <computeroutput>Bx</computeroutput> for <computeroutput>x</computeroutput> in <computeroutput>[0,n)</computeroutput>. </para></listitem>
<listitem><para>An expression <computeroutput>E</computeroutput> matches <computeroutput>and_&lt;B0,B1,...Bn&gt;</computeroutput> if <computeroutput>E</computeroutput> matches all <computeroutput>Bx</computeroutput> for <computeroutput>x</computeroutput> in <computeroutput>[0,n)</computeroutput>. </para></listitem>
<listitem><para>An expression <computeroutput>E</computeroutput> matches <computeroutput>if_&lt;T,U,V&gt;</computeroutput> if <computeroutput>when&lt;_,T&gt;::result&lt;void(E,int,int)&gt;::type::value</computeroutput> is <computeroutput>true</computeroutput> and <computeroutput>E</computeroutput> matches <computeroutput>U</computeroutput>; or, if <computeroutput>when&lt;_,T&gt;::result&lt;void(E,int,int)&gt;::type::value</computeroutput> is <computeroutput>false</computeroutput> and <computeroutput>E</computeroutput> matches <computeroutput>V</computeroutput>. (Note: <computeroutput>U</computeroutput> defaults to <computeroutput>_</computeroutput> and <computeroutput>V</computeroutput> defaults to <computeroutput>not_&lt;_&gt;</computeroutput>.) </para></listitem>
<listitem><para>An expression <computeroutput>E</computeroutput> matches <computeroutput>not_&lt;T&gt;</computeroutput> if <computeroutput>E</computeroutput> does not match <computeroutput>T</computeroutput>. </para></listitem>
<listitem><para>An expression <computeroutput>E</computeroutput> matches <computeroutput>switch_&lt;C&gt;</computeroutput> if <computeroutput>E</computeroutput> matches <computeroutput>C::case_&lt;E::proto_tag&gt;</computeroutput>.</para></listitem>
</itemizedlist>
A terminal expression <computeroutput>expr&lt;tag::terminal,term&lt;A&gt; &gt;</computeroutput> matches a grammar <computeroutput>expr&lt;BT,term&lt;B&gt; &gt;</computeroutput> if <computeroutput>BT</computeroutput> is <computeroutput>_</computeroutput> or <computeroutput>tag::terminal</computeroutput> and one of the following is true:</para><para><itemizedlist>
<listitem><para><computeroutput>B</computeroutput> is the wildcard pattern, <computeroutput>_</computeroutput> </para></listitem>
<listitem><para><computeroutput>A</computeroutput> is <computeroutput>B</computeroutput> </para></listitem>
<listitem><para><computeroutput>A</computeroutput> is <computeroutput>B &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>A</computeroutput> is <computeroutput>B const &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>B</computeroutput> is <computeroutput>exact&lt;A&gt;</computeroutput> </para></listitem>
<listitem><para><computeroutput>B</computeroutput> is <computeroutput>convertible_to&lt;X&gt;</computeroutput> and <computeroutput>is_convertible&lt;A,X&gt;::value</computeroutput> is <computeroutput>true</computeroutput>. </para></listitem>
<listitem><para><computeroutput>A</computeroutput> is <computeroutput>X[M]</computeroutput> or <computeroutput>X(&amp;)[M]</computeroutput> and <computeroutput>B</computeroutput> is <computeroutput>X[proto::N]</computeroutput>. </para></listitem>
<listitem><para><computeroutput>A</computeroutput> is <computeroutput>X(&amp;)[M]</computeroutput> and <computeroutput>B</computeroutput> is <computeroutput>X(&amp;)[proto::N]</computeroutput>. </para></listitem>
<listitem><para><computeroutput>A</computeroutput> is <computeroutput>X[M]</computeroutput> or <computeroutput>X(&amp;)[M]</computeroutput> and <computeroutput>B</computeroutput> is <computeroutput>X*</computeroutput>. </para></listitem>
<listitem><para><computeroutput>B</computeroutput> lambda-matches <computeroutput>A</computeroutput> (see below).</para></listitem>
</itemizedlist>
A type <computeroutput>B</computeroutput> lambda-matches <computeroutput>A</computeroutput> if one of the following is true:</para><para><itemizedlist>
<listitem><para><computeroutput>B</computeroutput> is <computeroutput>A</computeroutput> </para></listitem>
<listitem><para><computeroutput>B</computeroutput> is the wildcard pattern, <computeroutput>_</computeroutput> </para></listitem>
<listitem><para><computeroutput>B</computeroutput> is <computeroutput>T&lt;B0,B1,...Bn&gt;</computeroutput> and <computeroutput>A</computeroutput> is <computeroutput>T&lt;A0,A1,...An&gt;</computeroutput> and for each <computeroutput>x</computeroutput> in <computeroutput>[0,n)</computeroutput>, <computeroutput>Ax</computeroutput> and <computeroutput>Bx</computeroutput> are types such that <computeroutput>Ax</computeroutput> lambda-matches <computeroutput>Bx</computeroutput> </para></listitem>
</itemizedlist>
</para></description></struct><struct-specialization name="matches"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="Grammar"/>
    </template><specialization><template-arg>Expr &amp;</template-arg><template-arg>Grammar</template-arg></specialization></struct-specialization></namespace><namespace name="wildcardns_"><struct name="_"><inherit access="public">transform&lt; boost::proto::wildcardns_::_ &gt;</inherit><purpose>A wildcard grammar element that matches any expression, and a transform that returns the current expression unchanged. </purpose><description><para>The wildcard type, <computeroutput>_</computeroutput>, is a grammar element such that <computeroutput>matches&lt;E,_&gt;::value</computeroutput> is <computeroutput>true</computeroutput> for any expression type <computeroutput>E</computeroutput>.</para><para>The wildcard can also be used as a stand-in for a template argument when matching terminals. For instance, the following is a grammar that will match any <computeroutput>std::complex&lt;&gt;</computeroutput> terminal:</para><para><programlisting> BOOST_MPL_ASSERT((
     matches&lt;
         terminal&lt;std::complex&lt;double&gt; &gt;::type
       , terminal&lt;std::complex&lt; _ &gt; &gt;
     &gt;
 ));
</programlisting></para><para>When used as a transform, <computeroutput>_</computeroutput> returns the current expression unchanged. For instance, in the following, <computeroutput>_</computeroutput> is used with the <computeroutput>fold&lt;&gt;</computeroutput> transform to fold the children of a node:</para><para><programlisting> struct CountChildren
   : or_&lt;
         // Terminals have no children
         when&lt;terminal&lt;_&gt;, mpl::int_&lt;0&gt;()&gt;
         // Use fold&lt;&gt; to count the children of non-terminals
       , otherwise&lt;
             fold&lt;
                 _ // &lt;-- fold the current expression
               , mpl::int_&lt;0&gt;()
               , mpl::plus&lt;_state, mpl::int_&lt;1&gt; &gt;()
             &gt;
         &gt;
     &gt;
 {};
</programlisting> </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="result_type"><type>Expr</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>impl::expr_param</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>An expression </para></description></parameter><parameter name=""><paramtype>typename impl::state_param</paramtype></parameter><parameter name=""><paramtype>typename impl::data_param</paramtype></parameter><description><para>

</para></description><returns><para><computeroutput>expr</computeroutput> </para></returns></method></method-group></struct><typedef name="proto_base_expr"><type><classname>_</classname></type></typedef></struct></namespace></namespace></namespace></header><header name="boost/proto/operators.hpp"><para>Contains all the overloaded operators that make it possible to build Proto expression trees. </para><namespace name="boost"><namespace name="proto"><struct name="is_extension"><template>
      <template-type-parameter name="T"/>
    </template><inherit access="public">boost::mpl::false_</inherit></struct><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator~"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator~"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator!"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator!"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function><function name="operator++"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function><function name="operator--"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Arg"/>
        </template><parameter name="arg"><paramtype>Arg const &amp;</paramtype></parameter><parameter name=""><paramtype>int</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator=="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator!="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator||"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator,"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-&gt;*"><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&lt;&lt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&gt;&gt;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator*="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator/="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator%="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator+="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator-="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator&amp;="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator|="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right &amp;</paramtype></parameter></function><function name="operator^="><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Left"/>
          <template-type-parameter name="Right"/>
        </template><parameter name="left"><paramtype>Left const &amp;</paramtype></parameter><parameter name="right"><paramtype>Right const &amp;</paramtype></parameter></function><function name="if_else"><type><classname>boost::proto::result_of::make_expr</classname>&lt; <classname>tag::if_else_</classname>, <classname>deduce_domain</classname>, A0 const &amp;, A1 const &amp;, A2 const &amp; &gt;::type const</type><template>
          <template-type-parameter name="A0"/>
          <template-type-parameter name="A1"/>
          <template-type-parameter name="A2"/>
        </template><parameter name="a0"><paramtype>A0 const &amp;</paramtype></parameter><parameter name="a1"><paramtype>A1 const &amp;</paramtype></parameter><parameter name="a2"><paramtype>A2 const &amp;</paramtype></parameter><description><para>if_else </para></description></function></namespace></namespace></header><header name="boost/proto/proto.hpp"><para>Includes all of Proto. </para></header><header name="boost/proto/proto_fwd.hpp"><para>Forward declarations of all of proto's public types and functions. </para><namespace name="boost"><namespace name="proto"><struct name="callable"><typedef name="proto_is_callable_"><type>void</type></typedef></struct><namespace name="context"/><namespace name="control"><data-member name="N"><type>int const</type></data-member></namespace><namespace name="exops"/><namespace name="functional"><typedef name="make_terminal"><type><classname>make_expr</classname>&lt; <classname>tag::terminal</classname> &gt;</type></typedef><typedef name="make_unary_plus"><type><classname>make_expr</classname>&lt; <classname>tag::unary_plus</classname> &gt;</type></typedef><typedef name="make_negate"><type><classname>make_expr</classname>&lt; <classname>tag::negate</classname> &gt;</type></typedef><typedef name="make_dereference"><type><classname>make_expr</classname>&lt; <classname>tag::dereference</classname> &gt;</type></typedef><typedef name="make_complement"><type><classname>make_expr</classname>&lt; <classname>tag::complement</classname> &gt;</type></typedef><typedef name="make_address_of"><type><classname>make_expr</classname>&lt; <classname>tag::address_of</classname> &gt;</type></typedef><typedef name="make_logical_not"><type><classname>make_expr</classname>&lt; <classname>tag::logical_not</classname> &gt;</type></typedef><typedef name="make_pre_inc"><type><classname>make_expr</classname>&lt; <classname>tag::pre_inc</classname> &gt;</type></typedef><typedef name="make_pre_dec"><type><classname>make_expr</classname>&lt; <classname>tag::pre_dec</classname> &gt;</type></typedef><typedef name="make_post_inc"><type><classname>make_expr</classname>&lt; <classname>tag::post_inc</classname> &gt;</type></typedef><typedef name="make_post_dec"><type><classname>make_expr</classname>&lt; <classname>tag::post_dec</classname> &gt;</type></typedef><typedef name="make_shift_left"><type><classname>make_expr</classname>&lt; <classname>tag::shift_left</classname> &gt;</type></typedef><typedef name="make_shift_right"><type><classname>make_expr</classname>&lt; <classname>tag::shift_right</classname> &gt;</type></typedef><typedef name="make_multiplies"><type><classname>make_expr</classname>&lt; <classname>tag::multiplies</classname> &gt;</type></typedef><typedef name="make_divides"><type><classname>make_expr</classname>&lt; <classname>tag::divides</classname> &gt;</type></typedef><typedef name="make_modulus"><type><classname>make_expr</classname>&lt; <classname>tag::modulus</classname> &gt;</type></typedef><typedef name="make_plus"><type><classname>make_expr</classname>&lt; <classname>tag::plus</classname> &gt;</type></typedef><typedef name="make_minus"><type><classname>make_expr</classname>&lt; <classname>tag::minus</classname> &gt;</type></typedef><typedef name="make_less"><type><classname>make_expr</classname>&lt; <classname>tag::less</classname> &gt;</type></typedef><typedef name="make_greater"><type><classname>make_expr</classname>&lt; <classname>tag::greater</classname> &gt;</type></typedef><typedef name="make_less_equal"><type><classname>make_expr</classname>&lt; <classname>tag::less_equal</classname> &gt;</type></typedef><typedef name="make_greater_equal"><type><classname>make_expr</classname>&lt; <classname>tag::greater_equal</classname> &gt;</type></typedef><typedef name="make_equal_to"><type><classname>make_expr</classname>&lt; <classname>tag::equal_to</classname> &gt;</type></typedef><typedef name="make_not_equal_to"><type><classname>make_expr</classname>&lt; <classname>tag::not_equal_to</classname> &gt;</type></typedef><typedef name="make_logical_or"><type><classname>make_expr</classname>&lt; <classname>tag::logical_or</classname> &gt;</type></typedef><typedef name="make_logical_and"><type><classname>make_expr</classname>&lt; <classname>tag::logical_and</classname> &gt;</type></typedef><typedef name="make_bitwise_and"><type><classname>make_expr</classname>&lt; <classname>tag::bitwise_and</classname> &gt;</type></typedef><typedef name="make_bitwise_or"><type><classname>make_expr</classname>&lt; <classname>tag::bitwise_or</classname> &gt;</type></typedef><typedef name="make_bitwise_xor"><type><classname>make_expr</classname>&lt; <classname>tag::bitwise_xor</classname> &gt;</type></typedef><typedef name="make_comma"><type><classname>make_expr</classname>&lt; <classname>tag::comma</classname> &gt;</type></typedef><typedef name="make_mem_ptr"><type><classname>make_expr</classname>&lt; <classname>tag::mem_ptr</classname> &gt;</type></typedef><typedef name="make_assign"><type><classname>make_expr</classname>&lt; <classname>tag::assign</classname> &gt;</type></typedef><typedef name="make_shift_left_assign"><type><classname>make_expr</classname>&lt; <classname>tag::shift_left_assign</classname> &gt;</type></typedef><typedef name="make_shift_right_assign"><type><classname>make_expr</classname>&lt; <classname>tag::shift_right_assign</classname> &gt;</type></typedef><typedef name="make_multiplies_assign"><type><classname>make_expr</classname>&lt; <classname>tag::multiplies_assign</classname> &gt;</type></typedef><typedef name="make_divides_assign"><type><classname>make_expr</classname>&lt; <classname>tag::divides_assign</classname> &gt;</type></typedef><typedef name="make_modulus_assign"><type><classname>make_expr</classname>&lt; <classname>tag::modulus_assign</classname> &gt;</type></typedef><typedef name="make_plus_assign"><type><classname>make_expr</classname>&lt; <classname>tag::plus_assign</classname> &gt;</type></typedef><typedef name="make_minus_assign"><type><classname>make_expr</classname>&lt; <classname>tag::minus_assign</classname> &gt;</type></typedef><typedef name="make_bitwise_and_assign"><type><classname>make_expr</classname>&lt; <classname>tag::bitwise_and_assign</classname> &gt;</type></typedef><typedef name="make_bitwise_or_assign"><type><classname>make_expr</classname>&lt; <classname>tag::bitwise_or_assign</classname> &gt;</type></typedef><typedef name="make_bitwise_xor_assign"><type><classname>make_expr</classname>&lt; <classname>tag::bitwise_xor_assign</classname> &gt;</type></typedef><typedef name="make_subscript"><type><classname>make_expr</classname>&lt; <classname>tag::subscript</classname> &gt;</type></typedef><typedef name="make_if_else"><type><classname>make_expr</classname>&lt; <classname>tag::if_else_</classname> &gt;</type></typedef><typedef name="make_function"><type><classname>make_expr</classname>&lt; <classname>tag::function</classname> &gt;</type></typedef></namespace><namespace name="op"/><namespace name="result_of"/><namespace name="tag"/><namespace name="utility"/><typedef name="ignore"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="_flatten"><type><classname>functional::flatten</classname></type></typedef><typedef name="_pop_front"><type><classname>functional::pop_front</classname></type></typedef><typedef name="_reverse"><type><classname>functional::reverse</classname></type></typedef><typedef name="_eval"><type><classname>functional::eval</classname></type></typedef><typedef name="_deep_copy"><type><classname>functional::deep_copy</classname></type></typedef><typedef name="_make_terminal"><type><classname>_make_expr</classname>&lt; <classname>tag::terminal</classname> &gt;</type></typedef><typedef name="_make_unary_plus"><type><classname>_make_expr</classname>&lt; <classname>tag::unary_plus</classname> &gt;</type></typedef><typedef name="_make_negate"><type><classname>_make_expr</classname>&lt; <classname>tag::negate</classname> &gt;</type></typedef><typedef name="_make_dereference"><type><classname>_make_expr</classname>&lt; <classname>tag::dereference</classname> &gt;</type></typedef><typedef name="_make_complement"><type><classname>_make_expr</classname>&lt; <classname>tag::complement</classname> &gt;</type></typedef><typedef name="_make_address_of"><type><classname>_make_expr</classname>&lt; <classname>tag::address_of</classname> &gt;</type></typedef><typedef name="_make_logical_not"><type><classname>_make_expr</classname>&lt; <classname>tag::logical_not</classname> &gt;</type></typedef><typedef name="_make_pre_inc"><type><classname>_make_expr</classname>&lt; <classname>tag::pre_inc</classname> &gt;</type></typedef><typedef name="_make_pre_dec"><type><classname>_make_expr</classname>&lt; <classname>tag::pre_dec</classname> &gt;</type></typedef><typedef name="_make_post_inc"><type><classname>_make_expr</classname>&lt; <classname>tag::post_inc</classname> &gt;</type></typedef><typedef name="_make_post_dec"><type><classname>_make_expr</classname>&lt; <classname>tag::post_dec</classname> &gt;</type></typedef><typedef name="_make_shift_left"><type><classname>_make_expr</classname>&lt; <classname>tag::shift_left</classname> &gt;</type></typedef><typedef name="_make_shift_right"><type><classname>_make_expr</classname>&lt; <classname>tag::shift_right</classname> &gt;</type></typedef><typedef name="_make_multiplies"><type><classname>_make_expr</classname>&lt; <classname>tag::multiplies</classname> &gt;</type></typedef><typedef name="_make_divides"><type><classname>_make_expr</classname>&lt; <classname>tag::divides</classname> &gt;</type></typedef><typedef name="_make_modulus"><type><classname>_make_expr</classname>&lt; <classname>tag::modulus</classname> &gt;</type></typedef><typedef name="_make_plus"><type><classname>_make_expr</classname>&lt; <classname>tag::plus</classname> &gt;</type></typedef><typedef name="_make_minus"><type><classname>_make_expr</classname>&lt; <classname>tag::minus</classname> &gt;</type></typedef><typedef name="_make_less"><type><classname>_make_expr</classname>&lt; <classname>tag::less</classname> &gt;</type></typedef><typedef name="_make_greater"><type><classname>_make_expr</classname>&lt; <classname>tag::greater</classname> &gt;</type></typedef><typedef name="_make_less_equal"><type><classname>_make_expr</classname>&lt; <classname>tag::less_equal</classname> &gt;</type></typedef><typedef name="_make_greater_equal"><type><classname>_make_expr</classname>&lt; <classname>tag::greater_equal</classname> &gt;</type></typedef><typedef name="_make_equal_to"><type><classname>_make_expr</classname>&lt; <classname>tag::equal_to</classname> &gt;</type></typedef><typedef name="_make_not_equal_to"><type><classname>_make_expr</classname>&lt; <classname>tag::not_equal_to</classname> &gt;</type></typedef><typedef name="_make_logical_or"><type><classname>_make_expr</classname>&lt; <classname>tag::logical_or</classname> &gt;</type></typedef><typedef name="_make_logical_and"><type><classname>_make_expr</classname>&lt; <classname>tag::logical_and</classname> &gt;</type></typedef><typedef name="_make_bitwise_and"><type><classname>_make_expr</classname>&lt; <classname>tag::bitwise_and</classname> &gt;</type></typedef><typedef name="_make_bitwise_or"><type><classname>_make_expr</classname>&lt; <classname>tag::bitwise_or</classname> &gt;</type></typedef><typedef name="_make_bitwise_xor"><type><classname>_make_expr</classname>&lt; <classname>tag::bitwise_xor</classname> &gt;</type></typedef><typedef name="_make_comma"><type><classname>_make_expr</classname>&lt; <classname>tag::comma</classname> &gt;</type></typedef><typedef name="_make_mem_ptr"><type><classname>_make_expr</classname>&lt; <classname>tag::mem_ptr</classname> &gt;</type></typedef><typedef name="_make_assign"><type><classname>_make_expr</classname>&lt; <classname>tag::assign</classname> &gt;</type></typedef><typedef name="_make_shift_left_assign"><type><classname>_make_expr</classname>&lt; <classname>tag::shift_left_assign</classname> &gt;</type></typedef><typedef name="_make_shift_right_assign"><type><classname>_make_expr</classname>&lt; <classname>tag::shift_right_assign</classname> &gt;</type></typedef><typedef name="_make_multiplies_assign"><type><classname>_make_expr</classname>&lt; <classname>tag::multiplies_assign</classname> &gt;</type></typedef><typedef name="_make_divides_assign"><type><classname>_make_expr</classname>&lt; <classname>tag::divides_assign</classname> &gt;</type></typedef><typedef name="_make_modulus_assign"><type><classname>_make_expr</classname>&lt; <classname>tag::modulus_assign</classname> &gt;</type></typedef><typedef name="_make_plus_assign"><type><classname>_make_expr</classname>&lt; <classname>tag::plus_assign</classname> &gt;</type></typedef><typedef name="_make_minus_assign"><type><classname>_make_expr</classname>&lt; <classname>tag::minus_assign</classname> &gt;</type></typedef><typedef name="_make_bitwise_and_assign"><type><classname>_make_expr</classname>&lt; <classname>tag::bitwise_and_assign</classname> &gt;</type></typedef><typedef name="_make_bitwise_or_assign"><type><classname>_make_expr</classname>&lt; <classname>tag::bitwise_or_assign</classname> &gt;</type></typedef><typedef name="_make_bitwise_xor_assign"><type><classname>_make_expr</classname>&lt; <classname>tag::bitwise_xor_assign</classname> &gt;</type></typedef><typedef name="_make_subscript"><type><classname>_make_expr</classname>&lt; <classname>tag::subscript</classname> &gt;</type></typedef><typedef name="_make_if_else"><type><classname>_make_expr</classname>&lt; <classname>tag::if_else_</classname> &gt;</type></typedef><typedef name="_make_function"><type><classname>_make_expr</classname>&lt; <classname>tag::function</classname> &gt;</type></typedef><typedef name="_child0"><type><classname>_child_c</classname>&lt; 0 &gt;</type></typedef><typedef name="_child1"><type><classname>_child_c</classname>&lt; 1 &gt;</type></typedef><typedef name="_child"><type><classname>_child0</classname></type></typedef><typedef name="_value"><type><classname>_child0</classname></type></typedef><typedef name="_left"><type><classname>_child0</classname></type></typedef><typedef name="_right"><type><classname>_child1</classname></type></typedef><typedef name="_child2"><type><classname>_child_c</classname>&lt; 2 &gt;</type></typedef><typedef name="_child3"><type><classname>_child_c</classname>&lt; 3 &gt;</type></typedef></namespace></namespace></header><header name="boost/proto/tags.hpp"><para>Contains the tags for all the overloadable operators in C++ </para><namespace name="boost"><namespace name="proto"><namespace name="tag"><struct name="terminal"><purpose>Tag type for terminals; aka, leaves in the expression tree. </purpose></struct><struct name="unary_plus"><purpose>Tag type for the unary + operator. </purpose></struct><struct name="negate"><purpose>Tag type for the unary - operator. </purpose></struct><struct name="dereference"><purpose>Tag type for the unary * operator. </purpose></struct><struct name="complement"><purpose>Tag type for the unary ~ operator. </purpose></struct><struct name="address_of"><purpose>Tag type for the unary &amp; operator. </purpose></struct><struct name="logical_not"><purpose>Tag type for the unary ! operator. </purpose></struct><struct name="pre_inc"><purpose>Tag type for the unary prefix ++ operator. </purpose></struct><struct name="pre_dec"><purpose>Tag type for the unary prefix -- operator. </purpose></struct><struct name="post_inc"><purpose>Tag type for the unary postfix ++ operator. </purpose></struct><struct name="post_dec"><purpose>Tag type for the unary postfix -- operator. </purpose></struct><struct name="shift_left"><purpose>Tag type for the binary &lt;&lt; operator. </purpose></struct><struct name="shift_right"><purpose>Tag type for the binary &gt;&gt; operator. </purpose></struct><struct name="multiplies"><purpose>Tag type for the binary * operator. </purpose></struct><struct name="divides"><purpose>Tag type for the binary / operator. </purpose></struct><struct name="modulus"><purpose>Tag type for the binary % operator. </purpose></struct><struct name="plus"><purpose>Tag type for the binary + operator. </purpose></struct><struct name="minus"><purpose>Tag type for the binary - operator. </purpose></struct><struct name="less"><purpose>Tag type for the binary &lt; operator. </purpose></struct><struct name="greater"><purpose>Tag type for the binary &gt; operator. </purpose></struct><struct name="less_equal"><purpose>Tag type for the binary &lt;= operator. </purpose></struct><struct name="greater_equal"><purpose>Tag type for the binary &gt;= operator. </purpose></struct><struct name="equal_to"><purpose>Tag type for the binary == operator. </purpose></struct><struct name="not_equal_to"><purpose>Tag type for the binary != operator. </purpose></struct><struct name="logical_or"><purpose>Tag type for the binary || operator. </purpose></struct><struct name="logical_and"><purpose>Tag type for the binary &amp;&amp; operator. </purpose></struct><struct name="bitwise_and"><purpose>Tag type for the binary &amp; operator. </purpose></struct><struct name="bitwise_or"><purpose>Tag type for the binary | operator. </purpose></struct><struct name="bitwise_xor"><purpose>Tag type for the binary ^ operator. </purpose></struct><struct name="comma"><purpose>Tag type for the binary , operator. </purpose></struct><struct name="mem_ptr"><purpose>Tag type for the binary -&gt;* operator. </purpose></struct><struct name="assign"><purpose>Tag type for the binary = operator. </purpose></struct><struct name="shift_left_assign"><purpose>Tag type for the binary &lt;&lt;= operator. </purpose></struct><struct name="shift_right_assign"><purpose>Tag type for the binary &gt;&gt;= operator. </purpose></struct><struct name="multiplies_assign"><purpose>Tag type for the binary *= operator. </purpose></struct><struct name="divides_assign"><purpose>Tag type for the binary /= operator. </purpose></struct><struct name="modulus_assign"><purpose>Tag type for the binary = operator. </purpose></struct><struct name="plus_assign"><purpose>Tag type for the binary += operator. </purpose></struct><struct name="minus_assign"><purpose>Tag type for the binary -= operator. </purpose></struct><struct name="bitwise_and_assign"><purpose>Tag type for the binary &amp;= operator. </purpose></struct><struct name="bitwise_or_assign"><purpose>Tag type for the binary |= operator. </purpose></struct><struct name="bitwise_xor_assign"><purpose>Tag type for the binary ^= operator. </purpose></struct><struct name="subscript"><purpose>Tag type for the binary subscript operator. </purpose></struct><struct name="if_else_"><purpose>Tag type for the ternary ?: conditional operator. </purpose></struct><struct name="function"><purpose>Tag type for the n-ary function call operator. </purpose></struct></namespace></namespace></namespace></header><header name="boost/proto/traits.hpp"><para>Contains definitions for child&lt;&gt;, child_c&lt;&gt;, left&lt;&gt;, right&lt;&gt;, tag_of&lt;&gt;, and the helper functions child(), child_c(), value(), left() and right(). </para><namespace name="boost"><namespace name="proto"><struct name="is_callable"><template>
      <template-type-parameter name="T"/>
    </template><purpose>Boolean metafunction which detects whether a type is a callable function object type or not. </purpose><description><para><computeroutput>is_callable&lt;&gt;</computeroutput> is used by the <computeroutput>when&lt;&gt;</computeroutput> transform to determine whether a function type <computeroutput>R(A1,A2,...AN)</computeroutput> is a callable transform or an object transform. (The former are evaluated using <computeroutput>call&lt;&gt;</computeroutput> and the later with <computeroutput>make&lt;&gt;</computeroutput>.) If <computeroutput>is_callable&lt;R&gt;::value</computeroutput> is <computeroutput>true</computeroutput>, the function type is a callable transform; otherwise, it is an object transform.</para><para>Unless specialized for a type <computeroutput>T</computeroutput>, <computeroutput>is_callable&lt;T&gt;::value</computeroutput> is computed as follows:</para><para><itemizedlist>
<listitem><para>If <computeroutput>T</computeroutput> is a template type <computeroutput>X&lt;Y0,Y1,...YN&gt;</computeroutput>, where all <computeroutput>Yx</computeroutput> are types for <computeroutput>x</computeroutput> in <computeroutput>[0,N]</computeroutput>, <computeroutput>is_callable&lt;T&gt;::value</computeroutput> is <computeroutput>is_same&lt;YN, proto::callable&gt;::value</computeroutput>. </para></listitem>
<listitem><para>If <computeroutput>T</computeroutput> has a nested type <computeroutput>proto_is_callable_</computeroutput> that is a typedef for <computeroutput>void</computeroutput>, <computeroutput>is_callable&lt;T&gt;::value</computeroutput> is <computeroutput>true</computeroutput>. (Note: this is the case for any type that derives from <computeroutput>proto::callable</computeroutput>.) </para></listitem>
<listitem><para>Otherwise, <computeroutput>is_callable&lt;T&gt;::value</computeroutput> is <computeroutput>false</computeroutput>. </para></listitem>
</itemizedlist>
</para></description></struct><struct name="is_aggregate"><template>
      <template-type-parameter name="T"/>
    </template><purpose>A Boolean metafunction that indicates whether a type requires aggregate initialization. </purpose><description><para><computeroutput>is_aggregate&lt;&gt;</computeroutput> is used by the <computeroutput>make&lt;&gt;</computeroutput> transform to determine how to construct an object of some type <computeroutput>T</computeroutput>, given some initialization arguments <computeroutput>a0,a1,...aN</computeroutput>. If <computeroutput>is_aggregate&lt;T&gt;::value</computeroutput> is <computeroutput>true</computeroutput>, then an object of type T will be initialized as <computeroutput>T t = {a0,a1,...aN};</computeroutput>. Otherwise, it will be initialized as <computeroutput>T t(a0,a1,...aN)</computeroutput>. </para></description></struct><struct-specialization name="is_aggregate"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="Args"/>
      <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
    </template><specialization><template-arg>proto::expr&lt; Tag</template-arg><template-arg>Args</template-arg><template-arg>N &gt;</template-arg></specialization><inherit access="public">boost::mpl::true_</inherit><purpose>Specialization of <computeroutput>is_aggregate&lt;&gt;</computeroutput> that indicates that objects of <computeroutput>expr&lt;&gt;</computeroutput> type require aggregate initialization. </purpose></struct-specialization><struct name="is_transform"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Void"><default>void</default></template-type-parameter>
    </template><inherit access="public">boost::mpl::false_</inherit><purpose>TODO document me! </purpose></struct><struct-specialization name="is_transform"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>typename T::proto_is_transform_</template-arg></specialization><inherit access="public">boost::mpl::true_</inherit></struct-specialization><namespace name="functional"><struct name="as_expr"><template>
      <template-type-parameter name="Domain"><default>default_domain</default></template-type-parameter>
    </template><purpose>A callable PolymorphicFunctionObject that is equivalent to the <computeroutput>as_expr()</computeroutput> function. </purpose><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T)</template-arg></specialization><typedef name="unref_type"><type>remove_reference&lt; T &gt;::type</type></typedef><typedef name="type"><type><classname>result_of::as_expr</classname>&lt; unref_type, Domain &gt;::type</type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::as_expr</classname>&lt; T, Domain &gt;::reference</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype><description><para>The object to wrap. </para></description></parameter><purpose>Wrap an object in a Proto terminal if it isn't a Proto expression already. </purpose><description><para>

</para></description><returns><para><computeroutput>proto::as_expr&lt;Domain&gt;(t)</computeroutput> </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::as_expr</classname>&lt; T const, Domain &gt;::reference</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group></struct><struct name="as_child"><template>
      <template-type-parameter name="Domain"><default>default_domain</default></template-type-parameter>
    </template><purpose>A callable PolymorphicFunctionObject that is equivalent to the <computeroutput>as_child()</computeroutput> function. </purpose><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T)</template-arg></specialization><typedef name="unref_type"><type>remove_reference&lt; T &gt;::type</type></typedef><typedef name="type"><type><classname>result_of::as_child</classname>&lt; unref_type, Domain &gt;::type</type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::as_child</classname>&lt; T, Domain &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype><description><para>The object to wrap. </para></description></parameter><purpose>Wrap an object in a Proto terminal if it isn't a Proto expression already. </purpose><description><para>

</para></description><returns><para><computeroutput>proto::as_child&lt;Domain&gt;(t)</computeroutput> </para></returns></method><method name="operator()" cv="const"><type><classname>result_of::as_child</classname>&lt; T const, Domain &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group></struct><struct name="child_c"><template>
      <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
    </template><purpose>A callable PolymorphicFunctionObject that is equivalent to the <computeroutput>child_c()</computeroutput> function. </purpose><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><typedef name="type"><type>result_of::child_c&lt; Expr, N &gt;::type</type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_of::child_c&lt; Expr &amp;, N &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype><description><para>The expression node. </para></description></parameter><purpose>Return the Nth child of the given expression. </purpose><description><para>



</para></description><requires><para><computeroutput>is_expr&lt;Expr&gt;::value</computeroutput> is <computeroutput>true</computeroutput> </para><para><computeroutput>N == 0 || N &lt; Expr::proto_arity::value</computeroutput> </para></requires><returns><para><computeroutput>proto::child_c&lt;N&gt;(expr)</computeroutput> </para></returns><throws><simpara>Will not throw.</simpara></throws></method><method name="operator()" cv="const"><type>result_of::child_c&lt; Expr const &amp;, N &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group></struct><struct name="child"><template>
      <template-type-parameter name="N"><default>mpl::long_&lt;0&gt;</default></template-type-parameter>
    </template><purpose>A callable PolymorphicFunctionObject that is equivalent to the <computeroutput>child()</computeroutput> function. </purpose><description><para>A callable PolymorphicFunctionObject that is equivalent to the <computeroutput>child()</computeroutput> function. <computeroutput>N</computeroutput> is required to be an MPL Integral Constant. </para></description><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><typedef name="type"><type><classname>result_of::child</classname>&lt; Expr, N &gt;::type</type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::child</classname>&lt; Expr &amp;, N &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype><description><para>The expression node. </para></description></parameter><purpose>Return the Nth child of the given expression. </purpose><description><para>



</para></description><requires><para><computeroutput>is_expr&lt;Expr&gt;::value</computeroutput> is <computeroutput>true</computeroutput> </para><para><computeroutput>N::value == 0 || N::value &lt; Expr::proto_arity::value</computeroutput> </para></requires><returns><para><computeroutput>proto::child&lt;N&gt;(expr)</computeroutput> </para></returns><throws><simpara>Will not throw.</simpara></throws></method><method name="operator()" cv="const"><type><classname>result_of::child</classname>&lt; Expr const &amp;, N &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group></struct><struct name="value"><purpose>A callable PolymorphicFunctionObject that is equivalent to the <computeroutput>value()</computeroutput> function. </purpose><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><typedef name="type"><type><classname>result_of::value</classname>&lt; Expr &gt;::type</type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::value</classname>&lt; Expr &amp; &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype><description><para>The terminal expression node. </para></description></parameter><purpose>Return the value of the given terminal expression. </purpose><description><para>



</para></description><requires><para><computeroutput>is_expr&lt;Expr&gt;::value</computeroutput> is <computeroutput>true</computeroutput> </para><para><computeroutput>0 == Expr::proto_arity::value</computeroutput> </para><para><computeroutput>Expr::proto_tag</computeroutput> is <computeroutput>tag::terminal</computeroutput> </para></requires><returns><para><computeroutput>proto::value(expr)</computeroutput> </para></returns><throws><simpara>Will not throw.</simpara></throws></method><method name="operator()" cv="const"><type><classname>result_of::value</classname>&lt; Expr const &amp; &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group></struct><struct name="left"><purpose>A callable PolymorphicFunctionObject that is equivalent to the <computeroutput>left()</computeroutput> function. </purpose><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><typedef name="type"><type><classname>result_of::left</classname>&lt; Expr &gt;::type</type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::left</classname>&lt; Expr &amp; &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype><description><para>The expression node. </para></description></parameter><purpose>Return the left child of the given binary expression. </purpose><description><para>



</para></description><requires><para><computeroutput>is_expr&lt;Expr&gt;::value</computeroutput> is <computeroutput>true</computeroutput> </para><para><computeroutput>2 == Expr::proto_arity::value</computeroutput> </para></requires><returns><para><computeroutput>proto::left(expr)</computeroutput> </para></returns><throws><simpara>Will not throw.</simpara></throws></method><method name="operator()" cv="const"><type><classname>result_of::left</classname>&lt; Expr const &amp; &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group></struct><struct name="right"><purpose>A callable PolymorphicFunctionObject that is equivalent to the <computeroutput>right()</computeroutput> function. </purpose><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>This(Expr)</template-arg></specialization><typedef name="type"><type><classname>result_of::right</classname>&lt; Expr &gt;::type</type></typedef></struct-specialization><typedef name="proto_is_callable_"><type>void</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type><classname>result_of::right</classname>&lt; Expr &amp; &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype><description><para>The expression node. </para></description></parameter><purpose>Return the right child of the given binary expression. </purpose><description><para>



</para></description><requires><para><computeroutput>is_expr&lt;Expr&gt;::value</computeroutput> is <computeroutput>true</computeroutput> </para><para><computeroutput>2 == Expr::proto_arity::value</computeroutput> </para></requires><returns><para><computeroutput>proto::right(expr)</computeroutput> </para></returns><throws><simpara>Will not throw.</simpara></throws></method><method name="operator()" cv="const"><type><classname>result_of::right</classname>&lt; Expr const &amp; &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></method></method-group></struct></namespace><namespace name="op"><struct name="terminal"><template>
      <template-type-parameter name="T"/>
    </template><purpose>A metafunction for generating terminal expression types, a grammar element for matching terminal expressions, and a PrimitiveTransform that returns the current expression unchanged. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="result_type"><type>Expr</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>impl::expr_param</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>The current expression </para></description></parameter><parameter name=""><paramtype>typename impl::state_param</paramtype></parameter><parameter name=""><paramtype>typename impl::data_param</paramtype></parameter><description><para>



</para></description><requires><para><computeroutput>matches&lt;Expr, terminal&lt;T&gt; &gt;::value</computeroutput> is <computeroutput>true</computeroutput>. </para></requires><returns><para><computeroutput>expr</computeroutput> </para></returns><throws><simpara>Will not throw.</simpara></throws></method></method-group></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::terminal</classname>, <classname>term</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="if_else_"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
      <template-type-parameter name="V"/>
    </template><purpose>A metafunction for generating ternary conditional expression types, a grammar element for matching ternary conditional expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::if_else_</classname>, <classname>list3</classname>&lt; T, U, V &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="unary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="T"/>
    </template><purpose>A metafunction for generating unary expression types with a specified tag type, a grammar element for matching unary expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><description><para>Use <computeroutput>unary_expr&lt;_, _&gt;</computeroutput> as a grammar element to match any unary expression. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; Tag, <classname>list1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="binary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating binary expression types with a specified tag type, a grammar element for matching binary expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><description><para>Use <computeroutput>binary_expr&lt;_, _, _&gt;</computeroutput> as a grammar element to match any binary expression. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; Tag, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="unary_plus"><template>
      <template-type-parameter name="T"/>
    </template><purpose>A metafunction for generating unary plus expression types, a grammar element for matching unary plus expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::unary_plus</classname>, <classname>list1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="negate"><template>
      <template-type-parameter name="T"/>
    </template><purpose>A metafunction for generating unary minus expression types, a grammar element for matching unary minus expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::negate</classname>, <classname>list1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="dereference"><template>
      <template-type-parameter name="T"/>
    </template><purpose>A metafunction for generating defereference expression types, a grammar element for matching dereference expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::dereference</classname>, <classname>list1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="complement"><template>
      <template-type-parameter name="T"/>
    </template><purpose>A metafunction for generating complement expression types, a grammar element for matching complement expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::complement</classname>, <classname>list1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="address_of"><template>
      <template-type-parameter name="T"/>
    </template><purpose>A metafunction for generating address_of expression types, a grammar element for matching address_of expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::address_of</classname>, <classname>list1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="logical_not"><template>
      <template-type-parameter name="T"/>
    </template><purpose>A metafunction for generating logical_not expression types, a grammar element for matching logical_not expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::logical_not</classname>, <classname>list1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="pre_inc"><template>
      <template-type-parameter name="T"/>
    </template><purpose>A metafunction for generating pre-increment expression types, a grammar element for matching pre-increment expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::pre_inc</classname>, <classname>list1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="pre_dec"><template>
      <template-type-parameter name="T"/>
    </template><purpose>A metafunction for generating pre-decrement expression types, a grammar element for matching pre-decrement expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::pre_dec</classname>, <classname>list1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="post_inc"><template>
      <template-type-parameter name="T"/>
    </template><purpose>A metafunction for generating post-increment expression types, a grammar element for matching post-increment expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::post_inc</classname>, <classname>list1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="post_dec"><template>
      <template-type-parameter name="T"/>
    </template><purpose>A metafunction for generating post-decrement expression types, a grammar element for matching post-decrement expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::post_dec</classname>, <classname>list1</classname>&lt; T &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="shift_left"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating left-shift expression types, a grammar element for matching left-shift expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::shift_left</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="shift_right"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating right-shift expression types, a grammar element for matching right-shift expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::shift_right</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="multiplies"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating multiplies expression types, a grammar element for matching multiplies expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::multiplies</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="divides"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating divides expression types, a grammar element for matching divides expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::divides</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="modulus"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating modulus expression types, a grammar element for matching modulus expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::modulus</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="plus"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating binary plus expression types, a grammar element for matching binary plus expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::plus</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="minus"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating binary minus expression types, a grammar element for matching binary minus expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::minus</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="less"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating less expression types, a grammar element for matching less expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::less</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="greater"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating greater expression types, a grammar element for matching greater expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::greater</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="less_equal"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating less-or-equal expression types, a grammar element for matching less-or-equal expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::less_equal</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="greater_equal"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating greater-or-equal expression types, a grammar element for matching greater-or-equal expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::greater_equal</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="equal_to"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating equal-to expression types, a grammar element for matching equal-to expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::equal_to</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="not_equal_to"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating not-equal-to expression types, a grammar element for matching not-equal-to expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::not_equal_to</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="logical_or"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating logical-or expression types, a grammar element for matching logical-or expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::logical_or</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="logical_and"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating logical-and expression types, a grammar element for matching logical-and expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::logical_and</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="bitwise_and"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating bitwise-and expression types, a grammar element for matching bitwise-and expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::bitwise_and</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="bitwise_or"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating bitwise-or expression types, a grammar element for matching bitwise-or expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::bitwise_or</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="bitwise_xor"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating bitwise-xor expression types, a grammar element for matching bitwise-xor expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::bitwise_xor</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="comma"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating comma expression types, a grammar element for matching comma expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::comma</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="mem_ptr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::mem_ptr</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating assignment expression types, a grammar element for matching assignment expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::assign</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="shift_left_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating left-shift-assign expression types, a grammar element for matching left-shift-assign expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::shift_left_assign</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="shift_right_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating right-shift-assign expression types, a grammar element for matching right-shift-assign expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::shift_right_assign</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="multiplies_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating multiplies-assign expression types, a grammar element for matching multiplies-assign expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::multiplies_assign</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="divides_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating divides-assign expression types, a grammar element for matching divides-assign expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::divides_assign</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="modulus_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating modulus-assign expression types, a grammar element for matching modulus-assign expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::modulus_assign</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="plus_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating plus-assign expression types, a grammar element for matching plus-assign expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::plus_assign</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="minus_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating minus-assign expression types, a grammar element for matching minus-assign expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::minus_assign</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="bitwise_and_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating bitwise-and-assign expression types, a grammar element for matching bitwise-and-assign expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::bitwise_and_assign</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="bitwise_or_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating bitwise-or-assign expression types, a grammar element for matching bitwise-or-assign expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::bitwise_or_assign</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="bitwise_xor_assign"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating bitwise-xor-assign expression types, a grammar element for matching bitwise-xor-assign expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::bitwise_xor_assign</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct name="subscript"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="U"/>
    </template><purpose>A metafunction for generating subscript expression types, a grammar element for matching subscript expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::subscript</classname>, <classname>list2</classname>&lt; T, U &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef></struct><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><purpose>A metafunction for generating function-call expression types, a grammar element for matching function-call expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>list1</classname>&lt; A0 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_child0"><type>A0</type></typedef><typedef name="proto_child1"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_child2"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_child3"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_child4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><purpose>A metafunction for generating n-ary expression types with a specified tag type, a grammar element for matching n-ary expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><description><para>Use <computeroutput>nary_expr&lt;_, vararg&lt;_&gt; &gt;</computeroutput> as a grammar element to match any n-ary expression; that is, any non-terminal. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; Tag, <classname>list1</classname>&lt; A0 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_child0"><type>A0</type></typedef><typedef name="proto_child1"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_child2"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_child3"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_child4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><purpose>A metafunction for generating function-call expression types, a grammar element for matching function-call expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>list2</classname>&lt; A0, A1 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_child0"><type>A0</type></typedef><typedef name="proto_child1"><type>A1</type></typedef><typedef name="proto_child2"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_child3"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_child4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><purpose>A metafunction for generating n-ary expression types with a specified tag type, a grammar element for matching n-ary expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><description><para>Use <computeroutput>nary_expr&lt;_, vararg&lt;_&gt; &gt;</computeroutput> as a grammar element to match any n-ary expression; that is, any non-terminal. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; Tag, <classname>list2</classname>&lt; A0, A1 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_child0"><type>A0</type></typedef><typedef name="proto_child1"><type>A1</type></typedef><typedef name="proto_child2"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_child3"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_child4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><purpose>A metafunction for generating function-call expression types, a grammar element for matching function-call expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>list3</classname>&lt; A0, A1, A2 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_child0"><type>A0</type></typedef><typedef name="proto_child1"><type>A1</type></typedef><typedef name="proto_child2"><type>A2</type></typedef><typedef name="proto_child3"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_child4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>void</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><purpose>A metafunction for generating n-ary expression types with a specified tag type, a grammar element for matching n-ary expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><description><para>Use <computeroutput>nary_expr&lt;_, vararg&lt;_&gt; &gt;</computeroutput> as a grammar element to match any n-ary expression; that is, any non-terminal. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; Tag, <classname>list3</classname>&lt; A0, A1, A2 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_child0"><type>A0</type></typedef><typedef name="proto_child1"><type>A1</type></typedef><typedef name="proto_child2"><type>A2</type></typedef><typedef name="proto_child3"><type><emphasis>unspecified</emphasis></type></typedef><typedef name="proto_child4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><purpose>A metafunction for generating function-call expression types, a grammar element for matching function-call expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>list4</classname>&lt; A0, A1, A2, A3 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_child0"><type>A0</type></typedef><typedef name="proto_child1"><type>A1</type></typedef><typedef name="proto_child2"><type>A2</type></typedef><typedef name="proto_child3"><type>A3</type></typedef><typedef name="proto_child4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>void</template-arg><template-arg>void</template-arg></specialization><purpose>A metafunction for generating n-ary expression types with a specified tag type, a grammar element for matching n-ary expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><description><para>Use <computeroutput>nary_expr&lt;_, vararg&lt;_&gt; &gt;</computeroutput> as a grammar element to match any n-ary expression; that is, any non-terminal. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; Tag, <classname>list4</classname>&lt; A0, A1, A2, A3 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_child0"><type>A0</type></typedef><typedef name="proto_child1"><type>A1</type></typedef><typedef name="proto_child2"><type>A2</type></typedef><typedef name="proto_child3"><type>A3</type></typedef><typedef name="proto_child4"><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="function"><template>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4</template-arg><template-arg>void</template-arg></specialization><purpose>A metafunction for generating function-call expression types, a grammar element for matching function-call expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; <classname>proto::tag::function</classname>, <classname>list5</classname>&lt; A0, A1, A2, A3, A4 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_child0"><type>A0</type></typedef><typedef name="proto_child1"><type>A1</type></typedef><typedef name="proto_child2"><type>A2</type></typedef><typedef name="proto_child3"><type>A3</type></typedef><typedef name="proto_child4"><type>A4</type></typedef></struct-specialization><struct-specialization name="nary_expr"><template>
      <template-type-parameter name="Tag"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Tag</template-arg><template-arg>A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4</template-arg><template-arg>void</template-arg></specialization><purpose>A metafunction for generating n-ary expression types with a specified tag type, a grammar element for matching n-ary expressions, and a PrimitiveTransform that dispatches to the <computeroutput>pass_through&lt;&gt;</computeroutput> transform. </purpose><description><para>Use <computeroutput>nary_expr&lt;_, vararg&lt;_&gt; &gt;</computeroutput> as a grammar element to match any n-ary expression; that is, any non-terminal. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct><typedef name="type"><type>proto::expr&lt; Tag, <classname>list5</classname>&lt; A0, A1, A2, A3, A4 &gt; &gt;</type></typedef><typedef name="proto_base_expr"><type>type</type></typedef><typedef name="proto_child0"><type>A0</type></typedef><typedef name="proto_child1"><type>A1</type></typedef><typedef name="proto_child2"><type>A2</type></typedef><typedef name="proto_child3"><type>A3</type></typedef><typedef name="proto_child4"><type>A4</type></typedef></struct-specialization></namespace><namespace name="result_of"><struct name="is_expr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Void"><default>void</default></template-type-parameter>
    </template><inherit access="public">boost::mpl::false_</inherit><purpose>A Boolean metafunction that indicates whether a given type <computeroutput>T</computeroutput> is a Proto expression type. </purpose><description><para>If <computeroutput>T</computeroutput> has a nested type <computeroutput>proto_is_expr_</computeroutput> that is a typedef for <computeroutput>void</computeroutput>, <computeroutput>is_expr&lt;T&gt;::value</computeroutput> is <computeroutput>true</computeroutput>. (Note, this is the case for <computeroutput>proto::expr&lt;&gt;</computeroutput>, any type that is derived from <computeroutput>proto::extends&lt;&gt;</computeroutput> or that uses the <computeroutput>BOOST_PROTO_BASIC_EXTENDS()</computeroutput> macro.) Otherwise, <computeroutput>is_expr&lt;T&gt;::value</computeroutput> is <computeroutput>false</computeroutput>. </para></description></struct><struct-specialization name="is_expr"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>typename T::proto_is_expr_</template-arg></specialization><inherit access="public">boost::mpl::true_</inherit><purpose>A Boolean metafunction that indicates whether a given type <computeroutput>T</computeroutput> is a Proto expression type. </purpose><description><para>If <computeroutput>T</computeroutput> has a nested type <computeroutput>proto_is_expr_</computeroutput> that is a typedef for <computeroutput>void</computeroutput>, <computeroutput>is_expr&lt;T&gt;::value</computeroutput> is <computeroutput>true</computeroutput>. (Note, this is the case for <computeroutput>proto::expr&lt;&gt;</computeroutput>, any type that is derived from <computeroutput>proto::extends&lt;&gt;</computeroutput> or that uses the <computeroutput>BOOST_PROTO_BASIC_EXTENDS()</computeroutput> macro.) Otherwise, <computeroutput>is_expr&lt;T&gt;::value</computeroutput> is <computeroutput>false</computeroutput>. </para></description></struct-specialization><struct name="tag_of"><template>
      <template-type-parameter name="Expr"/>
    </template><purpose>A metafunction that returns the tag type of a Proto expression. </purpose><typedef name="type"><type>Expr::proto_tag</type></typedef></struct><struct name="as_expr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"><default>default_domain</default></template-type-parameter>
      <template-type-parameter name="Void"><default>void</default></template-type-parameter>
    </template><purpose>A metafunction that computes the return type of the <computeroutput>as_expr()</computeroutput> function. </purpose><description><para>The <computeroutput>as_expr&lt;&gt;</computeroutput> metafunction turns types into Proto types, if they are not already, by making them Proto terminals held by value if possible. Types which are already Proto types are left alone.</para><para>This specialization is selected when the type is not yet a Proto type. The resulting terminal type is calculated as follows:</para><para>If <computeroutput>T</computeroutput> is a function type, let <computeroutput>A</computeroutput> be <computeroutput>T &amp;</computeroutput>. Otherwise, let <computeroutput>A</computeroutput> be the type <computeroutput>T</computeroutput> stripped of cv-qualifiers. Then, the result type <computeroutput>as_expr&lt;T, Domain&gt;::type</computeroutput> is <computeroutput>boost::result_of&lt;Domain(expr&lt; tag::terminal, term&lt;A&gt; &gt;)&gt;::type</computeroutput>. </para></description><typedef name="arg0_"><type>mpl::eval_if_c&lt; is_function&lt; T &gt;::<classname>value</classname>, add_reference&lt; T &gt;, remove_cv&lt; T &gt;&gt;::type</type></typedef><typedef name="expr_"><type>proto::expr&lt; <classname>proto::tag::terminal</classname>, <classname>term</classname>&lt; arg0_ &gt; &gt;</type></typedef><typedef name="type"><type>Domain::template result&lt; void(expr_)&gt;::type</type></typedef><typedef name="reference"><type>type const</type></typedef><method-group name="public static functions"/></struct><struct-specialization name="as_expr"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>T</template-arg><template-arg>Domain</template-arg><template-arg>typename T::proto_is_expr_</template-arg></specialization><purpose>A metafunction that computes the return type of the <computeroutput>as_expr()</computeroutput> function. </purpose><description><para>The <computeroutput>as_expr&lt;&gt;</computeroutput> metafunction turns types into Proto types, if they are not already, by making them Proto terminals held by value if possible. Types which are already Proto types are left alone.</para><para>This specialization is selected when the type is already a Proto type. The result type <computeroutput>as_expr&lt;T, Domain&gt;::type</computeroutput> is <computeroutput>T</computeroutput> stripped of cv-qualifiers. </para></description><typedef name="expr_"><type>T::proto_derived_expr</type></typedef><typedef name="type"><type>Domain::template result&lt; void(expr_)&gt;::type</type></typedef><typedef name="reference"><type>type const</type></typedef><method-group name="public static functions"/></struct-specialization><struct-specialization name="as_expr"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>typename T::proto_domain</template-arg><template-arg>typename T::proto_is_expr_</template-arg></specialization><typedef name="type"><type>T::proto_derived_expr</type></typedef><typedef name="reference"><type>T &amp;</type></typedef><method-group name="public static functions"/></struct-specialization><struct name="as_child"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"><default>default_domain</default></template-type-parameter>
      <template-type-parameter name="Void"><default>void</default></template-type-parameter>
    </template><purpose>A metafunction that computes the return type of the <computeroutput>as_child()</computeroutput> function. </purpose><description><para>The <computeroutput>as_child&lt;&gt;</computeroutput> metafunction turns types into Proto types, if they are not already, by making them Proto terminals held by reference. Types which are already Proto types are returned by reference.</para><para>This specialization is selected when the type is not yet a Proto type. The result type <computeroutput>as_child&lt;T, Domain&gt;::type</computeroutput> is <computeroutput>boost::result_of&lt;Domain(expr&lt; tag::terminal, term&lt;T &amp;&gt; &gt;)&gt;::type</computeroutput>. </para></description><typedef name="expr_"><type>proto::expr&lt; <classname>proto::tag::terminal</classname>, <classname>term</classname>&lt; T &amp; &gt; &gt;</type></typedef><typedef name="type"><type>Domain::template result&lt; void(expr_)&gt;::type</type></typedef><method-group name="public static functions"/></struct><struct-specialization name="as_child"><template>
      <template-type-parameter name="T"/>
      <template-type-parameter name="Domain"/>
    </template><specialization><template-arg>T</template-arg><template-arg>Domain</template-arg><template-arg>typename T::proto_is_expr_</template-arg></specialization><purpose>A metafunction that computes the return type of the <computeroutput>as_child()</computeroutput> function. </purpose><description><para>The <computeroutput>as_child&lt;&gt;</computeroutput> metafunction turns types into Proto types, if they are not already, by making them Proto terminals held by reference. Types which are already Proto types are returned by reference.</para><para>This specialization is selected when the type is already a Proto type. The result type <computeroutput>as_child&lt;T, Domain&gt;::type</computeroutput> is <computeroutput>T &amp;</computeroutput>. </para></description><typedef name="type"><type>Domain::template result&lt; void(T)&gt;::type</type></typedef><method-group name="public static functions"/></struct-specialization><struct-specialization name="as_child"><template>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>T</template-arg><template-arg>typename T::proto_domain</template-arg><template-arg>typename T::proto_is_expr_</template-arg></specialization><purpose>A metafunction that computes the return type of the <computeroutput>as_child()</computeroutput> function. </purpose><description><para>The <computeroutput>as_child&lt;&gt;</computeroutput> metafunction turns types into Proto types, if they are not already, by making them Proto terminals held by reference. Types which are already Proto types are returned by reference.</para><para>This specialization is selected when the type is already a Proto type. The result type <computeroutput>as_child&lt;T, Domain&gt;::type</computeroutput> is <computeroutput>T &amp;</computeroutput>. </para></description><typedef name="type"><type>T &amp;</type></typedef><method-group name="public static functions"/></struct-specialization><struct name="child"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="N"><default>mpl::long_&lt;0&gt;</default></template-type-parameter>
    </template><purpose>A metafunction that returns the type of the Nth child of a Proto expression, where N is an MPL Integral Constant. </purpose><description><para><computeroutput>result_of::child&lt;Expr, N&gt;</computeroutput> is equivalent to <computeroutput>result_of::child_c&lt;Expr, N::value&gt;</computeroutput>. </para></description></struct><struct name="value"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::result_of::child_c&lt; Expr, 0 &gt;</inherit><purpose>A metafunction that returns the type of the value of a terminal Proto expression. </purpose></struct><struct name="left"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::result_of::child_c&lt; Expr, 0 &gt;</inherit><purpose>A metafunction that returns the type of the left child of a binary Proto expression. </purpose><description><para><computeroutput>result_of::left&lt;Expr&gt;</computeroutput> is equivalent to <computeroutput>result_of::child_c&lt;Expr, 0&gt;</computeroutput>. </para></description></struct><struct name="right"><template>
      <template-type-parameter name="Expr"/>
    </template><inherit access="public">boost::proto::result_of::child_c&lt; Expr, 1 &gt;</inherit><purpose>A metafunction that returns the type of the right child of a binary Proto expression. </purpose><description><para><computeroutput>result_of::right&lt;Expr&gt;</computeroutput> is equivalent to <computeroutput>result_of::child_c&lt;Expr, 1&gt;</computeroutput>. </para></description></struct><struct-specialization name="child_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>0</template-arg></specialization><purpose>A metafunction that returns the type of the Nth child of a Proto expression. </purpose><description><para>A metafunction that returns the type of the Nth child of a Proto expression. <computeroutput>N</computeroutput> must be 0 or less than <computeroutput>Expr::proto_arity::value</computeroutput>. </para></description><typedef name="value_type"><description><para>The raw type of the Nth child as it is stored within <computeroutput>Expr</computeroutput>. This may be a value or a reference </para></description><type>Expr::proto_child0</type></typedef><typedef name="type"><description><para>The "value" type of the child, suitable for return by value, computed as follows: <itemizedlist>
<listitem><para><computeroutput>T const(&amp;)[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T(&amp;)[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>R(&amp;)(A0,...)</computeroutput> becomes <computeroutput>R(&amp;)(A0,...)</computeroutput> </para></listitem>
<listitem><para><computeroutput>T const &amp;</computeroutput> becomes <computeroutput>T</computeroutput> </para></listitem>
<listitem><para><computeroutput>T &amp;</computeroutput> becomes <computeroutput>T</computeroutput> </para></listitem>
<listitem><para><computeroutput>T</computeroutput> becomes <computeroutput>T</computeroutput> </para></listitem>
</itemizedlist>
</para></description><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="child_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr &amp;</template-arg><template-arg>0</template-arg></specialization><typedef name="value_type"><description><para>The raw type of the Nth child as it is stored within <computeroutput>Expr</computeroutput>. This may be a value or a reference </para></description><type>Expr::proto_child0</type></typedef><typedef name="type"><description><para>The "reference" type of the child, suitable for return by reference, computed as follows: <itemizedlist>
<listitem><para><computeroutput>T const(&amp;)[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T(&amp;)[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>R(&amp;)(A0,...)</computeroutput> becomes <computeroutput>R(&amp;)(A0,...)</computeroutput> </para></listitem>
<listitem><para><computeroutput>T const &amp;</computeroutput> becomes <computeroutput>T const &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T &amp;</computeroutput> becomes <computeroutput>T &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T</computeroutput> becomes <computeroutput>T &amp;</computeroutput> </para></listitem>
</itemizedlist>
</para></description><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"/></struct-specialization><struct-specialization name="child_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const &amp;</template-arg><template-arg>0</template-arg></specialization><typedef name="value_type"><description><para>The raw type of the Nth child as it is stored within <computeroutput>Expr</computeroutput>. This may be a value or a reference </para></description><type>Expr::proto_child0</type></typedef><typedef name="type"><description><para>The "const reference" type of the child, suitable for return by const reference, computed as follows: <itemizedlist>
<listitem><para><computeroutput>T const(&amp;)[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T(&amp;)[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>R(&amp;)(A0,...)</computeroutput> becomes <computeroutput>R(&amp;)(A0,...)</computeroutput> </para></listitem>
<listitem><para><computeroutput>T const &amp;</computeroutput> becomes <computeroutput>T const &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T &amp;</computeroutput> becomes <computeroutput>T &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T</computeroutput> becomes <computeroutput>T const &amp;</computeroutput> </para></listitem>
</itemizedlist>
</para></description><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"/></struct-specialization><struct-specialization name="child_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>1</template-arg></specialization><purpose>A metafunction that returns the type of the Nth child of a Proto expression. </purpose><description><para>A metafunction that returns the type of the Nth child of a Proto expression. <computeroutput>N</computeroutput> must be 0 or less than <computeroutput>Expr::proto_arity::value</computeroutput>. </para></description><typedef name="value_type"><description><para>The raw type of the Nth child as it is stored within <computeroutput>Expr</computeroutput>. This may be a value or a reference </para></description><type>Expr::proto_child1</type></typedef><typedef name="type"><description><para>The "value" type of the child, suitable for return by value, computed as follows: <itemizedlist>
<listitem><para><computeroutput>T const(&amp;)[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T(&amp;)[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>R(&amp;)(A0,...)</computeroutput> becomes <computeroutput>R(&amp;)(A0,...)</computeroutput> </para></listitem>
<listitem><para><computeroutput>T const &amp;</computeroutput> becomes <computeroutput>T</computeroutput> </para></listitem>
<listitem><para><computeroutput>T &amp;</computeroutput> becomes <computeroutput>T</computeroutput> </para></listitem>
<listitem><para><computeroutput>T</computeroutput> becomes <computeroutput>T</computeroutput> </para></listitem>
</itemizedlist>
</para></description><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="child_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr &amp;</template-arg><template-arg>1</template-arg></specialization><typedef name="value_type"><description><para>The raw type of the Nth child as it is stored within <computeroutput>Expr</computeroutput>. This may be a value or a reference </para></description><type>Expr::proto_child1</type></typedef><typedef name="type"><description><para>The "reference" type of the child, suitable for return by reference, computed as follows: <itemizedlist>
<listitem><para><computeroutput>T const(&amp;)[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T(&amp;)[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>R(&amp;)(A0,...)</computeroutput> becomes <computeroutput>R(&amp;)(A0,...)</computeroutput> </para></listitem>
<listitem><para><computeroutput>T const &amp;</computeroutput> becomes <computeroutput>T const &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T &amp;</computeroutput> becomes <computeroutput>T &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T</computeroutput> becomes <computeroutput>T &amp;</computeroutput> </para></listitem>
</itemizedlist>
</para></description><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"/></struct-specialization><struct-specialization name="child_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const &amp;</template-arg><template-arg>1</template-arg></specialization><typedef name="value_type"><description><para>The raw type of the Nth child as it is stored within <computeroutput>Expr</computeroutput>. This may be a value or a reference </para></description><type>Expr::proto_child1</type></typedef><typedef name="type"><description><para>The "const reference" type of the child, suitable for return by const reference, computed as follows: <itemizedlist>
<listitem><para><computeroutput>T const(&amp;)[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T(&amp;)[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>R(&amp;)(A0,...)</computeroutput> becomes <computeroutput>R(&amp;)(A0,...)</computeroutput> </para></listitem>
<listitem><para><computeroutput>T const &amp;</computeroutput> becomes <computeroutput>T const &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T &amp;</computeroutput> becomes <computeroutput>T &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T</computeroutput> becomes <computeroutput>T const &amp;</computeroutput> </para></listitem>
</itemizedlist>
</para></description><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"/></struct-specialization><struct-specialization name="child_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>2</template-arg></specialization><purpose>A metafunction that returns the type of the Nth child of a Proto expression. </purpose><description><para>A metafunction that returns the type of the Nth child of a Proto expression. <computeroutput>N</computeroutput> must be 0 or less than <computeroutput>Expr::proto_arity::value</computeroutput>. </para></description><typedef name="value_type"><description><para>The raw type of the Nth child as it is stored within <computeroutput>Expr</computeroutput>. This may be a value or a reference </para></description><type>Expr::proto_child2</type></typedef><typedef name="type"><description><para>The "value" type of the child, suitable for return by value, computed as follows: <itemizedlist>
<listitem><para><computeroutput>T const(&amp;)[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T(&amp;)[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>R(&amp;)(A0,...)</computeroutput> becomes <computeroutput>R(&amp;)(A0,...)</computeroutput> </para></listitem>
<listitem><para><computeroutput>T const &amp;</computeroutput> becomes <computeroutput>T</computeroutput> </para></listitem>
<listitem><para><computeroutput>T &amp;</computeroutput> becomes <computeroutput>T</computeroutput> </para></listitem>
<listitem><para><computeroutput>T</computeroutput> becomes <computeroutput>T</computeroutput> </para></listitem>
</itemizedlist>
</para></description><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="child_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr &amp;</template-arg><template-arg>2</template-arg></specialization><typedef name="value_type"><description><para>The raw type of the Nth child as it is stored within <computeroutput>Expr</computeroutput>. This may be a value or a reference </para></description><type>Expr::proto_child2</type></typedef><typedef name="type"><description><para>The "reference" type of the child, suitable for return by reference, computed as follows: <itemizedlist>
<listitem><para><computeroutput>T const(&amp;)[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T(&amp;)[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>R(&amp;)(A0,...)</computeroutput> becomes <computeroutput>R(&amp;)(A0,...)</computeroutput> </para></listitem>
<listitem><para><computeroutput>T const &amp;</computeroutput> becomes <computeroutput>T const &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T &amp;</computeroutput> becomes <computeroutput>T &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T</computeroutput> becomes <computeroutput>T &amp;</computeroutput> </para></listitem>
</itemizedlist>
</para></description><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"/></struct-specialization><struct-specialization name="child_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const &amp;</template-arg><template-arg>2</template-arg></specialization><typedef name="value_type"><description><para>The raw type of the Nth child as it is stored within <computeroutput>Expr</computeroutput>. This may be a value or a reference </para></description><type>Expr::proto_child2</type></typedef><typedef name="type"><description><para>The "const reference" type of the child, suitable for return by const reference, computed as follows: <itemizedlist>
<listitem><para><computeroutput>T const(&amp;)[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T(&amp;)[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>R(&amp;)(A0,...)</computeroutput> becomes <computeroutput>R(&amp;)(A0,...)</computeroutput> </para></listitem>
<listitem><para><computeroutput>T const &amp;</computeroutput> becomes <computeroutput>T const &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T &amp;</computeroutput> becomes <computeroutput>T &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T</computeroutput> becomes <computeroutput>T const &amp;</computeroutput> </para></listitem>
</itemizedlist>
</para></description><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"/></struct-specialization><struct-specialization name="child_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>3</template-arg></specialization><purpose>A metafunction that returns the type of the Nth child of a Proto expression. </purpose><description><para>A metafunction that returns the type of the Nth child of a Proto expression. <computeroutput>N</computeroutput> must be 0 or less than <computeroutput>Expr::proto_arity::value</computeroutput>. </para></description><typedef name="value_type"><description><para>The raw type of the Nth child as it is stored within <computeroutput>Expr</computeroutput>. This may be a value or a reference </para></description><type>Expr::proto_child3</type></typedef><typedef name="type"><description><para>The "value" type of the child, suitable for return by value, computed as follows: <itemizedlist>
<listitem><para><computeroutput>T const(&amp;)[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T(&amp;)[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>R(&amp;)(A0,...)</computeroutput> becomes <computeroutput>R(&amp;)(A0,...)</computeroutput> </para></listitem>
<listitem><para><computeroutput>T const &amp;</computeroutput> becomes <computeroutput>T</computeroutput> </para></listitem>
<listitem><para><computeroutput>T &amp;</computeroutput> becomes <computeroutput>T</computeroutput> </para></listitem>
<listitem><para><computeroutput>T</computeroutput> becomes <computeroutput>T</computeroutput> </para></listitem>
</itemizedlist>
</para></description><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="child_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr &amp;</template-arg><template-arg>3</template-arg></specialization><typedef name="value_type"><description><para>The raw type of the Nth child as it is stored within <computeroutput>Expr</computeroutput>. This may be a value or a reference </para></description><type>Expr::proto_child3</type></typedef><typedef name="type"><description><para>The "reference" type of the child, suitable for return by reference, computed as follows: <itemizedlist>
<listitem><para><computeroutput>T const(&amp;)[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T(&amp;)[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>R(&amp;)(A0,...)</computeroutput> becomes <computeroutput>R(&amp;)(A0,...)</computeroutput> </para></listitem>
<listitem><para><computeroutput>T const &amp;</computeroutput> becomes <computeroutput>T const &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T &amp;</computeroutput> becomes <computeroutput>T &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T</computeroutput> becomes <computeroutput>T &amp;</computeroutput> </para></listitem>
</itemizedlist>
</para></description><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"/></struct-specialization><struct-specialization name="child_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const &amp;</template-arg><template-arg>3</template-arg></specialization><typedef name="value_type"><description><para>The raw type of the Nth child as it is stored within <computeroutput>Expr</computeroutput>. This may be a value or a reference </para></description><type>Expr::proto_child3</type></typedef><typedef name="type"><description><para>The "const reference" type of the child, suitable for return by const reference, computed as follows: <itemizedlist>
<listitem><para><computeroutput>T const(&amp;)[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T(&amp;)[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>R(&amp;)(A0,...)</computeroutput> becomes <computeroutput>R(&amp;)(A0,...)</computeroutput> </para></listitem>
<listitem><para><computeroutput>T const &amp;</computeroutput> becomes <computeroutput>T const &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T &amp;</computeroutput> becomes <computeroutput>T &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T</computeroutput> becomes <computeroutput>T const &amp;</computeroutput> </para></listitem>
</itemizedlist>
</para></description><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"/></struct-specialization><struct-specialization name="child_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>4</template-arg></specialization><purpose>A metafunction that returns the type of the Nth child of a Proto expression. </purpose><description><para>A metafunction that returns the type of the Nth child of a Proto expression. <computeroutput>N</computeroutput> must be 0 or less than <computeroutput>Expr::proto_arity::value</computeroutput>. </para></description><typedef name="value_type"><description><para>The raw type of the Nth child as it is stored within <computeroutput>Expr</computeroutput>. This may be a value or a reference </para></description><type>Expr::proto_child4</type></typedef><typedef name="type"><description><para>The "value" type of the child, suitable for return by value, computed as follows: <itemizedlist>
<listitem><para><computeroutput>T const(&amp;)[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T(&amp;)[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>R(&amp;)(A0,...)</computeroutput> becomes <computeroutput>R(&amp;)(A0,...)</computeroutput> </para></listitem>
<listitem><para><computeroutput>T const &amp;</computeroutput> becomes <computeroutput>T</computeroutput> </para></listitem>
<listitem><para><computeroutput>T &amp;</computeroutput> becomes <computeroutput>T</computeroutput> </para></listitem>
<listitem><para><computeroutput>T</computeroutput> becomes <computeroutput>T</computeroutput> </para></listitem>
</itemizedlist>
</para></description><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="child_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr &amp;</template-arg><template-arg>4</template-arg></specialization><typedef name="value_type"><description><para>The raw type of the Nth child as it is stored within <computeroutput>Expr</computeroutput>. This may be a value or a reference </para></description><type>Expr::proto_child4</type></typedef><typedef name="type"><description><para>The "reference" type of the child, suitable for return by reference, computed as follows: <itemizedlist>
<listitem><para><computeroutput>T const(&amp;)[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T(&amp;)[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>R(&amp;)(A0,...)</computeroutput> becomes <computeroutput>R(&amp;)(A0,...)</computeroutput> </para></listitem>
<listitem><para><computeroutput>T const &amp;</computeroutput> becomes <computeroutput>T const &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T &amp;</computeroutput> becomes <computeroutput>T &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T</computeroutput> becomes <computeroutput>T &amp;</computeroutput> </para></listitem>
</itemizedlist>
</para></description><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"/></struct-specialization><struct-specialization name="child_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const &amp;</template-arg><template-arg>4</template-arg></specialization><typedef name="value_type"><description><para>The raw type of the Nth child as it is stored within <computeroutput>Expr</computeroutput>. This may be a value or a reference </para></description><type>Expr::proto_child4</type></typedef><typedef name="type"><description><para>The "const reference" type of the child, suitable for return by const reference, computed as follows: <itemizedlist>
<listitem><para><computeroutput>T const(&amp;)[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T(&amp;)[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>R(&amp;)(A0,...)</computeroutput> becomes <computeroutput>R(&amp;)(A0,...)</computeroutput> </para></listitem>
<listitem><para><computeroutput>T const &amp;</computeroutput> becomes <computeroutput>T const &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T &amp;</computeroutput> becomes <computeroutput>T &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T</computeroutput> becomes <computeroutput>T const &amp;</computeroutput> </para></listitem>
</itemizedlist>
</para></description><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"/></struct-specialization><struct-specialization name="child_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>5</template-arg></specialization><purpose>A metafunction that returns the type of the Nth child of a Proto expression. </purpose><description><para>A metafunction that returns the type of the Nth child of a Proto expression. <computeroutput>N</computeroutput> must be 0 or less than <computeroutput>Expr::proto_arity::value</computeroutput>. </para></description><typedef name="value_type"><description><para>The raw type of the Nth child as it is stored within <computeroutput>Expr</computeroutput>. This may be a value or a reference </para></description><type>Expr::proto_child5</type></typedef><typedef name="type"><description><para>The "value" type of the child, suitable for return by value, computed as follows: <itemizedlist>
<listitem><para><computeroutput>T const(&amp;)[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T(&amp;)[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>R(&amp;)(A0,...)</computeroutput> becomes <computeroutput>R(&amp;)(A0,...)</computeroutput> </para></listitem>
<listitem><para><computeroutput>T const &amp;</computeroutput> becomes <computeroutput>T</computeroutput> </para></listitem>
<listitem><para><computeroutput>T &amp;</computeroutput> becomes <computeroutput>T</computeroutput> </para></listitem>
<listitem><para><computeroutput>T</computeroutput> becomes <computeroutput>T</computeroutput> </para></listitem>
</itemizedlist>
</para></description><type><emphasis>unspecified</emphasis></type></typedef></struct-specialization><struct-specialization name="child_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr &amp;</template-arg><template-arg>5</template-arg></specialization><typedef name="value_type"><description><para>The raw type of the Nth child as it is stored within <computeroutput>Expr</computeroutput>. This may be a value or a reference </para></description><type>Expr::proto_child5</type></typedef><typedef name="type"><description><para>The "reference" type of the child, suitable for return by reference, computed as follows: <itemizedlist>
<listitem><para><computeroutput>T const(&amp;)[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T(&amp;)[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>R(&amp;)(A0,...)</computeroutput> becomes <computeroutput>R(&amp;)(A0,...)</computeroutput> </para></listitem>
<listitem><para><computeroutput>T const &amp;</computeroutput> becomes <computeroutput>T const &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T &amp;</computeroutput> becomes <computeroutput>T &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T</computeroutput> becomes <computeroutput>T &amp;</computeroutput> </para></listitem>
</itemizedlist>
</para></description><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"/></struct-specialization><struct-specialization name="child_c"><template>
      <template-type-parameter name="Expr"/>
    </template><specialization><template-arg>Expr const &amp;</template-arg><template-arg>5</template-arg></specialization><typedef name="value_type"><description><para>The raw type of the Nth child as it is stored within <computeroutput>Expr</computeroutput>. This may be a value or a reference </para></description><type>Expr::proto_child5</type></typedef><typedef name="type"><description><para>The "const reference" type of the child, suitable for return by const reference, computed as follows: <itemizedlist>
<listitem><para><computeroutput>T const(&amp;)[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T[N]</computeroutput> becomes <computeroutput>T const(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>T(&amp;)[N]</computeroutput> becomes <computeroutput>T(&amp;)[N]</computeroutput> </para></listitem>
<listitem><para><computeroutput>R(&amp;)(A0,...)</computeroutput> becomes <computeroutput>R(&amp;)(A0,...)</computeroutput> </para></listitem>
<listitem><para><computeroutput>T const &amp;</computeroutput> becomes <computeroutput>T const &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T &amp;</computeroutput> becomes <computeroutput>T &amp;</computeroutput> </para></listitem>
<listitem><para><computeroutput>T</computeroutput> becomes <computeroutput>T const &amp;</computeroutput> </para></listitem>
</itemizedlist>
</para></description><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public static functions"/></struct-specialization></namespace><overloaded-function name="as_expr"><signature><type><classname>result_of::as_expr</classname>&lt; T &gt;::reference</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype><description><para>The object to wrap.</para></description></parameter></signature><signature><type><classname>result_of::as_expr</classname>&lt; T const  &gt;::reference</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></signature><purpose>A function that wraps non-Proto expression types in Proto terminals and leaves Proto expression types alone. </purpose><description><para>The <computeroutput>as_expr()</computeroutput> function turns objects into Proto terminals if they are not Proto expression types already. Non-Proto types are held by value, if possible. Types which are already Proto types are left alone and returned by reference.</para><para>This function can be called either with an explicitly specified <computeroutput>Domain</computeroutput> parameter (i.e., <computeroutput>as_expr&lt;Domain&gt;(t)</computeroutput>), or without (i.e., <computeroutput>as_expr(t)</computeroutput>). If no domain is specified, <computeroutput>default_domain</computeroutput> is assumed.</para><para>If <computeroutput>is_expr&lt;T&gt;::value</computeroutput> is <computeroutput>true</computeroutput>, then the argument is returned unmodified, by reference. Otherwise, the argument is wrapped in a Proto terminal expression node according to the following rules. If <computeroutput>T</computeroutput> is a function type, let <computeroutput>A</computeroutput> be <computeroutput>T &amp;</computeroutput>. Otherwise, let <computeroutput>A</computeroutput> be the type <computeroutput>T</computeroutput> stripped of cv-qualifiers. Then, <computeroutput>as_expr()</computeroutput> returns <computeroutput>Domain()(terminal&lt;A&gt;::type::make(t))</computeroutput>.</para><para>
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></overloaded-function><overloaded-function name="as_child"><signature><type><classname>result_of::as_child</classname>&lt; T &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype><description><para>The object to wrap.</para></description></parameter></signature><signature><type><classname>result_of::as_child</classname>&lt; T const  &gt;::type</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter></signature><purpose>A function that wraps non-Proto expression types in Proto terminals (by reference) and returns Proto expression types by reference. </purpose><description><para>The <computeroutput>as_child()</computeroutput> function turns objects into Proto terminals if they are not Proto expression types already. Non-Proto types are held by reference. Types which are already Proto types are simply returned as-is.</para><para>This function can be called either with an explicitly specified <computeroutput>Domain</computeroutput> parameter (i.e., <computeroutput>as_child&lt;Domain&gt;(t)</computeroutput>), or without (i.e., <computeroutput>as_child(t)</computeroutput>). If no domain is specified, <computeroutput>default_domain</computeroutput> is assumed.</para><para>If <computeroutput>is_expr&lt;T&gt;::value</computeroutput> is <computeroutput>true</computeroutput>, then the argument is returned as-is. Otherwise, <computeroutput>as_child()</computeroutput> returns <computeroutput>Domain()(terminal&lt;T &amp;&gt;::type::make(t))</computeroutput>.</para><para>
This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></overloaded-function><overloaded-function name="child"><signature><type><classname>result_of::child</classname>&lt; Expr &amp;, N &gt;::type</type><template>
          <template-type-parameter name="N"/>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype><description><para>The Proto expression. </para></description></parameter></signature><signature><type><classname>result_of::child</classname>&lt; Expr const &amp;, N &gt;::type</type><template>
          <template-type-parameter name="N"/>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></signature><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Expr2"/>
        </template><parameter name="expr2"><paramtype>Expr2 &amp;</paramtype></parameter></signature><signature><type><emphasis>unspecified</emphasis></type><template>
          <template-type-parameter name="Expr2"/>
        </template><parameter name="expr2"><paramtype>Expr2 const &amp;</paramtype></parameter></signature><purpose>Return the Nth child of the specified Proto expression. </purpose><description><para>Return the Nth child of the specified Proto expression. If <computeroutput>N</computeroutput> is not specified, as in <computeroutput>child(expr)</computeroutput>, then <computeroutput>N</computeroutput> is assumed to be <computeroutput>mpl::long_&lt;0&gt;</computeroutput>. The child is returned by reference. If the expression is holding the child in a <computeroutput>ref_&lt;&gt;</computeroutput> wrapper, it is unwrapped before it is returned.</para><para>



</para></description><requires><para><computeroutput>is_expr&lt;Expr&gt;::value</computeroutput> is <computeroutput>true</computeroutput>. </para><para><computeroutput>N</computeroutput> is an MPL Integral Constant. </para><para><computeroutput>N::value == 0 || N::value &lt; Expr::proto_arity::value</computeroutput> </para></requires><returns><para>A reference to the Nth child </para></returns><throws><simpara>Will not throw.</simpara></throws></overloaded-function><overloaded-function name="child_c"><signature><type>result_of::child_c&lt; Expr &amp;, N &gt;::type</type><template>
          <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype><description><para>The Proto expression. </para></description></parameter></signature><signature><type>result_of::child_c&lt; Expr const &amp;, N &gt;::type</type><template>
          <template-nontype-parameter name="N"><type>long</type></template-nontype-parameter>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></signature><purpose>Return the Nth child of the specified Proto expression. </purpose><description><para>Return the Nth child of the specified Proto expression. The child is returned by reference. If the expression is holding the child in a <computeroutput>ref_&lt;&gt;</computeroutput> wrapper, it is unwrapped before it is returned.</para><para>



</para></description><requires><para><computeroutput>is_expr&lt;Expr&gt;::value</computeroutput> is <computeroutput>true</computeroutput>. </para><para><computeroutput>N == 0 || N &lt; Expr::proto_arity::value</computeroutput> </para></requires><returns><para>A reference to the Nth child </para></returns><throws><simpara>Will not throw.</simpara></throws></overloaded-function><overloaded-function name="value"><signature><type><classname>result_of::value</classname>&lt; Expr &amp; &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype><description><para>The Proto terminal expression. </para></description></parameter></signature><signature><type><classname>result_of::value</classname>&lt; Expr const &amp; &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></signature><purpose>Return the value stored within the specified Proto terminal expression. </purpose><description><para>Return the the value stored within the specified Proto terminal expression. The value is returned by reference.</para><para>



</para></description><requires><para><computeroutput>Expr::proto_tag</computeroutput> is <computeroutput>tag::terminal</computeroutput>. </para><para><computeroutput>N::value == 0</computeroutput> </para></requires><returns><para>A reference to the terminal's value </para></returns><throws><simpara>Will not throw.</simpara></throws></overloaded-function><overloaded-function name="left"><signature><type><classname>result_of::left</classname>&lt; Expr &amp; &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype><description><para>The Proto expression. </para></description></parameter></signature><signature><type><classname>result_of::left</classname>&lt; Expr const &amp; &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></signature><purpose>Return the left child of the specified binary Proto expression. </purpose><description><para>Return the left child of the specified binary Proto expression. The child is returned by reference.</para><para>



</para></description><requires><para><computeroutput>is_expr&lt;Expr&gt;::value</computeroutput> is <computeroutput>true</computeroutput>. </para><para><computeroutput>2 == Expr::proto_arity::value</computeroutput> </para></requires><returns><para>A reference to the left child </para></returns><throws><simpara>Will not throw.</simpara></throws></overloaded-function><overloaded-function name="right"><signature><type><classname>result_of::right</classname>&lt; Expr &amp; &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr &amp;</paramtype><description><para>The Proto expression. </para></description></parameter></signature><signature><type><classname>result_of::right</classname>&lt; Expr const &amp; &gt;::type</type><template>
          <template-type-parameter name="Expr"/>
        </template><parameter name="expr"><paramtype>Expr const &amp;</paramtype></parameter></signature><purpose>Return the right child of the specified binary Proto expression. </purpose><description><para>Return the right child of the specified binary Proto expression. The child is returned by reference.</para><para>



</para></description><requires><para><computeroutput>is_expr&lt;Expr&gt;::value</computeroutput> is <computeroutput>true</computeroutput>. </para><para><computeroutput>2 == Expr::proto_arity::value</computeroutput> </para></requires><returns><para>A reference to the right child </para></returns><throws><simpara>Will not throw.</simpara></throws></overloaded-function></namespace></namespace></header><header name="boost/proto/transform.hpp"><para>Includes all the transforms in the transform/ sub-directory. </para></header><header name="boost/proto/transform/arg.hpp"><para>Contains definition of the argN transforms. </para><namespace name="boost"><namespace name="proto"><struct name="_expr"><inherit access="public">transform&lt; boost::proto::_expr &gt;</inherit><purpose>A PrimitiveTransform that returns the current expression unmodified. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="result_type"><type>Expr</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>impl::expr_param</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>An expression </para></description></parameter><parameter name=""><paramtype>typename impl::state_param</paramtype></parameter><parameter name=""><paramtype>typename impl::data_param</paramtype></parameter><description><para>


</para></description><returns><para><computeroutput>expr</computeroutput> </para></returns><throws><simpara>Will not throw.</simpara></throws></method></method-group></struct></struct><struct name="_state"><inherit access="public">transform&lt; boost::proto::_state &gt;</inherit><purpose>A PrimitiveTransform that returns the current state unmodified. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="result_type"><type>State</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>impl::state_param</type><parameter name=""><paramtype>typename impl::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl::state_param</paramtype><description><para>The current state. </para></description></parameter><parameter name=""><paramtype>typename impl::data_param</paramtype></parameter><description><para>


</para></description><returns><para><computeroutput>state</computeroutput> </para></returns><throws><simpara>Will not throw.</simpara></throws></method></method-group></struct></struct><struct name="_data"><inherit access="public">transform&lt; boost::proto::_data &gt;</inherit><purpose>A PrimitiveTransform that returns the current data unmodified. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="result_type"><type>Data</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>impl::data_param</type><parameter name=""><paramtype>typename impl::expr_param</paramtype></parameter><parameter name=""><paramtype>typename impl::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl::data_param</paramtype></parameter><description><para>


</para></description><returns><para><computeroutput>data</computeroutput> </para></returns><throws><simpara>Will not throw.</simpara></throws></method></method-group></struct></struct><struct name="_child_c"><template>
      <template-nontype-parameter name="I"><type>int</type></template-nontype-parameter>
    </template><inherit access="public">transform&lt; boost::proto::_child_c&lt; I &gt; &gt;</inherit><purpose>A PrimitiveTransform that returns I-th child of the current expression. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="result_type"><type>result_of::child_c&lt; Expr, I &gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_of::child_c&lt; typename impl::expr_param, I &gt;::type</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>The current expression. </para></description></parameter><parameter name=""><paramtype>typename impl::state_param</paramtype></parameter><parameter name=""><paramtype>typename impl::data_param</paramtype></parameter><description><para>


</para></description><returns><para><computeroutput>proto::child_c&lt;I&gt;(expr)</computeroutput> </para></returns><throws><simpara>Will not throw.</simpara></throws></method></method-group></struct></struct><struct name="_byref"><inherit access="public">boost::proto::callable</inherit><purpose>A unary CallableTransform that wraps its argument in a <computeroutput>boost::reference_wrapper&lt;&gt;</computeroutput>. </purpose><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T &amp;)</template-arg></specialization><typedef name="type"><type>boost::reference_wrapper&lt; T &gt; const</type></typedef></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T)</template-arg></specialization><typedef name="type"><type>boost::reference_wrapper&lt; T const  &gt; const</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>boost::reference_wrapper&lt; T &gt; const</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T &amp;</paramtype><description><para>The object to wrap </para></description></parameter><description><para>


</para></description><returns><para><computeroutput>boost::ref(t)</computeroutput> </para></returns><throws><simpara>Will not throw.</simpara></throws></method><method name="operator()" cv="const"><type>boost::reference_wrapper&lt; T const  &gt; const</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group></struct><struct name="_byval"><inherit access="public">boost::proto::callable</inherit><purpose>A unary CallableTransform that strips references from its argument. </purpose><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(boost::reference_wrapper&lt; T &gt;)</template-arg></specialization><inherit access="public">boost::proto::_byval::result&lt; This(T)&gt;</inherit></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T &amp;)</template-arg></specialization><inherit access="public">boost::proto::_byval::result&lt; This(T)&gt;</inherit></struct-specialization><struct-specialization name="result"><template>
      <template-type-parameter name="This"/>
      <template-type-parameter name="T"/>
    </template><specialization><template-arg>This(T)</template-arg></specialization><typedef name="type"><type>T</type></typedef></struct-specialization><method-group name="public member functions"><method name="operator()" cv="const"><type>T const &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>T const &amp;</paramtype><description><para>The object to unref </para></description></parameter><description><para>


</para></description><returns><para><computeroutput>t</computeroutput> </para></returns><throws><simpara>Will not throw.</simpara></throws></method><method name="operator()" cv="const"><type>T &amp;</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype>boost::reference_wrapper&lt; T &gt; const &amp;</paramtype></parameter><description><para>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </para></description></method></method-group></struct></namespace></namespace></header><header name="boost/proto/transform/call.hpp"><para>Contains definition of the call&lt;&gt; transform. </para><namespace name="boost"><namespace name="proto"><struct name="call"><template>
      <template-type-parameter name="PrimitiveTransform"/>
    </template><purpose>Wrap <computeroutput>PrimitiveTransform</computeroutput> so that <computeroutput>when&lt;&gt;</computeroutput> knows it is callable. Requires that the parameter is actually a PrimitiveTransform. </purpose><description><para>This form of <computeroutput>call&lt;&gt;</computeroutput> is useful for annotating an arbitrary PrimitiveTransform as callable when using it with <computeroutput>when&lt;&gt;</computeroutput>. Consider the following transform, which is parameterized with another transform.</para><para><programlisting> template&lt;typename Grammar&gt;
 struct Foo
   : when&lt;
         unary_plus&lt;Grammar&gt;
       , Grammar(_child)   // May or may not work.
     &gt;
 {};
</programlisting></para><para>The problem with the above is that <computeroutput>when&lt;&gt;</computeroutput> may or may not recognize <computeroutput>Grammar</computeroutput> as callable, depending on how <computeroutput>Grammar</computeroutput> is implemented. (See <computeroutput>is_callable&lt;&gt;</computeroutput> for a discussion of this issue.) You can guard against the issue by wrapping <computeroutput>Grammar</computeroutput> in <computeroutput>call&lt;&gt;</computeroutput>, such as:</para><para><programlisting> template&lt;typename Grammar&gt;
 struct Foo
   : when&lt;
         unary_plus&lt;Grammar&gt;
       , call&lt;Grammar&gt;(_child)   // OK, this works
     &gt;
 {};
</programlisting></para><para>The above could also have been written as:</para><para><programlisting> template&lt;typename Grammar&gt;
 struct Foo
   : when&lt;
         unary_plus&lt;Grammar&gt;
       , call&lt;Grammar(_child)&gt;   // OK, this works, too
     &gt;
 {};
</programlisting> </para></description></struct><struct-specialization name="call"><template>
      <template-type-parameter name="Fun"/>
    </template><specialization><template-arg>Fun()</template-arg></specialization><inherit access="public">transform&lt; boost::proto::call&lt; Fun()&gt; &gt;</inherit><purpose>Either call the PolymorphicFunctionObject with 0 arguments, or invoke the PrimitiveTransform with 3 arguments. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><description><para>Either call the PolymorphicFunctionObject <computeroutput>Fun</computeroutput> with 0 arguments; or invoke the PrimitiveTransform <computeroutput>Fun</computeroutput> with 3 arguments: the current expression, state, and data.</para><para>If <computeroutput>Fun</computeroutput> is a nullary PolymorphicFunctionObject, return <computeroutput>Fun()()</computeroutput>. Otherwise, return <computeroutput>Fun()(expr, state, data)</computeroutput>.</para><para>
</para></description></struct></struct-specialization><struct-specialization name="call"><template>
      <template-type-parameter name="Fun"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>Fun(A0)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::call&lt; Fun(A0)&gt; &gt;</inherit><purpose>Either call the PolymorphicFunctionObject with 1 argument, or invoke the PrimitiveTransform with 3 arguments. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><description><para>Let <computeroutput>x</computeroutput> be <computeroutput>when&lt;_, A0&gt;()(expr, state, data)</computeroutput> and <computeroutput>X</computeroutput> be the type of <computeroutput>x</computeroutput>. If <computeroutput>Fun</computeroutput> is a unary PolymorphicFunctionObject that accepts <computeroutput>x</computeroutput>, then <computeroutput>type</computeroutput> is a typedef for <computeroutput>boost::result_of&lt;Fun(X)&gt;::type</computeroutput>. Otherwise, it is a typedef for <computeroutput>boost::result_of&lt;Fun(X, State, Data)&gt;::type</computeroutput>. Either call the PolymorphicFunctionObject with 1 argument: the result of applying the <computeroutput>A0</computeroutput> transform; or invoke the PrimitiveTransform with 3 arguments: result of applying the <computeroutput>A0</computeroutput> transform, the state, and the data.</para><para>Let <computeroutput>x</computeroutput> be <computeroutput>when&lt;_, A0&gt;()(expr, state, data)</computeroutput>. If <computeroutput>Fun</computeroutput> is a unary PolymorphicFunctionObject that accepts <computeroutput>x</computeroutput>, then return <computeroutput>Fun()(x)</computeroutput>. Otherwise, return <computeroutput>Fun()(x, state, data)</computeroutput>.</para><para>
</para></description></struct><struct name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
      <template-nontype-parameter name="B"><type>bool</type></template-nontype-parameter>
    </template><typedef name="a0"><type><classname>when</classname>&lt; _, A0 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="result_type"><type>boost::result_of&lt; <classname>Fun</classname>(a0)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>true</template-arg></specialization><typedef name="a0"><type><classname>when</classname>&lt; _, A0 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="result_type"><type>Fun::template impl&lt; a0, State, Data &gt;::result_type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization></struct-specialization><struct-specialization name="call"><template>
      <template-type-parameter name="Fun"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>Fun(A0</template-arg><template-arg>A1)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::call&lt; Fun(A0, A1)&gt; &gt;</inherit><purpose>Either call the PolymorphicFunctionObject with 2 arguments, or invoke the PrimitiveTransform with 3 arguments. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><description><para>Let <computeroutput>x</computeroutput> be <computeroutput>when&lt;_, A0&gt;()(expr, state, data)</computeroutput> and <computeroutput>X</computeroutput> be the type of <computeroutput>x</computeroutput>. Let <computeroutput>y</computeroutput> be <computeroutput>when&lt;_, A1&gt;()(expr, state, data)</computeroutput> and <computeroutput>Y</computeroutput> be the type of <computeroutput>y</computeroutput>. If <computeroutput>Fun</computeroutput> is a binary PolymorphicFunction object that accepts <computeroutput>x</computeroutput> and <computeroutput>y</computeroutput>, then <computeroutput>type</computeroutput> is a typedef for <computeroutput>boost::result_of&lt;Fun(X, Y)&gt;::type</computeroutput>. Otherwise, it is a typedef for <computeroutput>boost::result_of&lt;Fun(X, Y, Data)&gt;::type</computeroutput>. Either call the PolymorphicFunctionObject with 2 arguments: the result of applying the <computeroutput>A0</computeroutput> transform, and the result of applying the <computeroutput>A1</computeroutput> transform; or invoke the PrimitiveTransform with 3 arguments: the result of applying the <computeroutput>A0</computeroutput> transform, the result of applying the <computeroutput>A1</computeroutput> transform, and the data.</para><para>Let <computeroutput>x</computeroutput> be <computeroutput>when&lt;_, A0&gt;()(expr, state, data)</computeroutput>. Let <computeroutput>y</computeroutput> be <computeroutput>when&lt;_, A1&gt;()(expr, state, data)</computeroutput>. If <computeroutput>Fun</computeroutput> is a binary PolymorphicFunction object that accepts <computeroutput>x</computeroutput> and <computeroutput>y</computeroutput>, return <computeroutput>Fun()(x, y)</computeroutput>. Otherwise, return <computeroutput>Fun()(x, y, data)</computeroutput>.</para><para>
</para></description></struct><struct name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
      <template-nontype-parameter name="B"><type>bool</type></template-nontype-parameter>
    </template><typedef name="a0"><type><classname>when</classname>&lt; _, A0 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="a1"><type><classname>when</classname>&lt; _, A1 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="result_type"><type>boost::result_of&lt; <classname>Fun</classname>(a0, a1)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>true</template-arg></specialization><typedef name="a0"><type><classname>when</classname>&lt; _, A0 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="a1"><type><classname>when</classname>&lt; _, A1 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="result_type"><type>Fun::template impl&lt; a0, a1, Data &gt;::result_type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization></struct-specialization><struct-specialization name="call"><template>
      <template-type-parameter name="Fun"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>Fun(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::call&lt; Fun(A0, A1, A2)&gt; &gt;</inherit><purpose>Call the PolymorphicFunctionObject or the PrimitiveTransform with the current expression, state and data, transformed according to <computeroutput>A0</computeroutput>, <computeroutput>A1</computeroutput>, and <computeroutput>A2</computeroutput>, respectively. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><description><para>Let <computeroutput>x</computeroutput> be <computeroutput>when&lt;_, A0&gt;()(expr, state, data)</computeroutput>. Let <computeroutput>y</computeroutput> be <computeroutput>when&lt;_, A1&gt;()(expr, state, data)</computeroutput>. Let <computeroutput>z</computeroutput> be <computeroutput>when&lt;_, A2&gt;()(expr, state, data)</computeroutput>. Return <computeroutput>Fun()(x, y, z)</computeroutput>.</para><para>
</para></description></struct><struct name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
      <template-nontype-parameter name="B"><type>bool</type></template-nontype-parameter>
    </template><typedef name="a0"><type><classname>when</classname>&lt; _, A0 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="a1"><type><classname>when</classname>&lt; _, A1 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="a2"><type><classname>when</classname>&lt; _, A2 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="result_type"><type>boost::result_of&lt; <classname>Fun</classname>(a0, a1, a2)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct><struct-specialization name="impl2"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><specialization><template-arg>Expr</template-arg><template-arg>State</template-arg><template-arg>Data</template-arg><template-arg>true</template-arg></specialization><typedef name="a0"><type><classname>when</classname>&lt; _, A0 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="a1"><type><classname>when</classname>&lt; _, A1 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="a2"><type><classname>when</classname>&lt; _, A2 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="result_type"><type>Fun::template impl&lt; a0, a1, a2 &gt;::result_type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl2::expr_param</paramtype></parameter><parameter name="state"><paramtype>typename impl2::state_param</paramtype></parameter><parameter name="data"><paramtype>typename impl2::data_param</paramtype></parameter></method></method-group></struct-specialization></struct-specialization><struct-specialization name="call"><template>
      <template-type-parameter name="Fun"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>Fun(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::call&lt; Fun(A0, A1, A2, A3)&gt; &gt;</inherit><purpose>Call the PolymorphicFunctionObject <computeroutput>Fun</computeroutput> with the current expression, state and data, transformed according to <computeroutput>A0</computeroutput> through <computeroutput>AN</computeroutput>. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="a0"><type><classname>when</classname>&lt; _, A0 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="a1"><type><classname>when</classname>&lt; _, A1 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="a2"><type><classname>when</classname>&lt; _, A2 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="a3"><type><classname>when</classname>&lt; _, A3 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="result_type"><type>boost::result_of&lt; <classname>Fun</classname>(a0, a1, a2, a3)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>The current expression </para></description></parameter><parameter name="state"><paramtype>typename impl::state_param</paramtype><description><para>The current state </para></description></parameter><parameter name="data"><paramtype>typename impl::data_param</paramtype><description><para>An arbitrary data </para></description></parameter><description><para>Let <computeroutput>ax</computeroutput> be <computeroutput>when&lt;_, Ax&gt;()(expr, state, data)</computeroutput> for each <computeroutput>x</computeroutput> in <computeroutput>[0,N]</computeroutput>. Return <computeroutput>Fun()(a0, a1,... aN)</computeroutput>.</para><para>
</para></description></method></method-group></struct></struct-specialization><struct-specialization name="call"><template>
      <template-type-parameter name="Fun"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Fun(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::call&lt; Fun(A0, A1, A2, A3, A4)&gt; &gt;</inherit><purpose>Call the PolymorphicFunctionObject <computeroutput>Fun</computeroutput> with the current expression, state and data, transformed according to <computeroutput>A0</computeroutput> through <computeroutput>AN</computeroutput>. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="a0"><type><classname>when</classname>&lt; _, A0 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="a1"><type><classname>when</classname>&lt; _, A1 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="a2"><type><classname>when</classname>&lt; _, A2 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="a3"><type><classname>when</classname>&lt; _, A3 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="a4"><type><classname>when</classname>&lt; _, A4 &gt;::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><typedef name="result_type"><type>boost::result_of&lt; <classname>Fun</classname>(a0, a1, a2, a3, a4)&gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>The current expression </para></description></parameter><parameter name="state"><paramtype>typename impl::state_param</paramtype><description><para>The current state </para></description></parameter><parameter name="data"><paramtype>typename impl::data_param</paramtype><description><para>An arbitrary data </para></description></parameter><description><para>Let <computeroutput>ax</computeroutput> be <computeroutput>when&lt;_, Ax&gt;()(expr, state, data)</computeroutput> for each <computeroutput>x</computeroutput> in <computeroutput>[0,N]</computeroutput>. Return <computeroutput>Fun()(a0, a1,... aN)</computeroutput>.</para><para>
</para></description></method></method-group></struct></struct-specialization></namespace></namespace></header><header name="boost/proto/transform/fold.hpp"><para>Contains definition of the fold&lt;&gt; and reverse_fold&lt;&gt; transforms. </para><namespace name="boost"><namespace name="proto"><struct name="fold"><template>
      <template-type-parameter name="Sequence"/>
      <template-type-parameter name="State0"/>
      <template-type-parameter name="Fun"/>
    </template><inherit access="public">transform&lt; boost::proto::fold&lt; Sequence, State0, Fun &gt; &gt;</inherit><purpose>A PrimitiveTransform that invokes the <computeroutput>fusion::fold&lt;&gt;</computeroutput> algorithm to accumulate. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="sequence"><purpose>A Fusion sequence. </purpose><type>remove_reference&lt; typename <classname>when</classname>&lt; _, Sequence &gt;::template <classname>impl</classname>&lt; Expr, State, Data &gt;::result_type &gt;::type</type></typedef><typedef name="state0"><purpose>An initial state for the fold. </purpose><type>remove_reference&lt; typename <classname>when</classname>&lt; _, State0 &gt;::template <classname>impl</classname>&lt; Expr, State, Data &gt;::result_type &gt;::type</type></typedef><typedef name="fun"><purpose><computeroutput>fun(v)(e,s) == when&lt;_,Fun&gt;()(e,s,v)</computeroutput> </purpose><type><emphasis>unspecified</emphasis></type></typedef><typedef name="result_type"><type>fusion::result_of::fold&lt; sequence, state0, <classname>fun</classname> &gt;::type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>The current expression </para></description></parameter><parameter name="state"><paramtype>typename impl::state_param</paramtype><description><para>The current state </para></description></parameter><parameter name="data"><paramtype>typename impl::data_param</paramtype><description><para>An arbitrary data </para></description></parameter><description><para>Let <computeroutput>seq</computeroutput> be <computeroutput>when&lt;_, Sequence&gt;()(expr, state, data)</computeroutput>, let <computeroutput>state0</computeroutput> be <computeroutput>when&lt;_, State0&gt;()(expr, state, data)</computeroutput>, and let <computeroutput>fun(data)</computeroutput> be an object such that <computeroutput>fun(data)(expr, state)</computeroutput> is equivalent to <computeroutput>when&lt;_, Fun&gt;()(expr, state, data)</computeroutput>. Then, this function returns <computeroutput>fusion::fold(seq, state0, fun(data))</computeroutput>.</para><para>
</para></description></method></method-group></struct></struct><struct name="reverse_fold"><template>
      <template-type-parameter name="Sequence"/>
      <template-type-parameter name="State0"/>
      <template-type-parameter name="Fun"/>
    </template><inherit access="public">boost::proto::fold&lt; Sequence, State0, Fun &gt;</inherit><purpose>A PrimitiveTransform that is the same as the <computeroutput>fold&lt;&gt;</computeroutput> transform, except that it folds back-to-front instead of front-to-back. It uses the <computeroutput>_reverse</computeroutput> callable PolymorphicFunctionObject to create a <computeroutput>fusion::reverse_view&lt;&gt;</computeroutput> of the sequence before invoking <computeroutput>fusion::fold&lt;&gt;</computeroutput>. </purpose></struct></namespace></namespace></header><header name="boost/proto/transform/fold_tree.hpp"><para>Contains definition of the fold_tree&lt;&gt; and reverse_fold_tree&lt;&gt; transforms. </para><namespace name="boost"><namespace name="proto"><struct name="fold_tree"><template>
      <template-type-parameter name="Sequence"/>
      <template-type-parameter name="State0"/>
      <template-type-parameter name="Fun"/>
    </template><inherit access="public">transform&lt; boost::proto::fold_tree&lt; Sequence, State0, Fun &gt; &gt;</inherit><purpose>A PrimitiveTransform that recursively applies the <computeroutput>fold&lt;&gt;</computeroutput> transform to sub-trees that all share a common tag type. </purpose><description><para><computeroutput>fold_tree&lt;&gt;</computeroutput> is useful for flattening trees into lists; for example, you might use <computeroutput>fold_tree&lt;&gt;</computeroutput> to flatten an expression tree like <computeroutput>a | b | c</computeroutput> into a Fusion list like <computeroutput>cons(c, cons(b, cons(a)))</computeroutput>.</para><para><computeroutput>fold_tree&lt;&gt;</computeroutput> is easily understood in terms of a <computeroutput>recurse_if_&lt;&gt;</computeroutput> helper, defined as follows:</para><para><programlisting> template&lt;typename Tag, typename Fun&gt;
 struct recurse_if_
   : if_&lt;
         // If the current node has type type "Tag" ...
         is_same&lt;tag_of&lt;_&gt;, Tag&gt;()
         // ... recurse, otherwise ...
       , fold&lt;_, _state, recurse_if_&lt;Tag, Fun&gt; &gt;
         // ... apply the Fun transform.
       , Fun
     &gt;
 {};
</programlisting></para><para>With <computeroutput>recurse_if_&lt;&gt;</computeroutput> as defined above, <computeroutput>fold_tree&lt;Sequence, State0, Fun&gt;()(expr, state, data)</computeroutput> is equivalent to <computeroutput>fold&lt;Sequence, State0, recurse_if_&lt;Expr::proto_tag, Fun&gt; &gt;()(expr, state, data).</computeroutput> It has the effect of folding a tree front-to-back, recursing into child nodes that share a tag type with the parent node. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct></struct><struct name="reverse_fold_tree"><template>
      <template-type-parameter name="Sequence"/>
      <template-type-parameter name="State0"/>
      <template-type-parameter name="Fun"/>
    </template><inherit access="public">transform&lt; boost::proto::reverse_fold_tree&lt; Sequence, State0, Fun &gt; &gt;</inherit><purpose>A PrimitiveTransform that recursively applies the <computeroutput>reverse_fold&lt;&gt;</computeroutput> transform to sub-trees that all share a common tag type. </purpose><description><para><computeroutput>reverse_fold_tree&lt;&gt;</computeroutput> is useful for flattening trees into lists; for example, you might use <computeroutput>reverse_fold_tree&lt;&gt;</computeroutput> to flatten an expression tree like <computeroutput>a | b | c</computeroutput> into a Fusion list like <computeroutput>cons(a, cons(b, cons(c)))</computeroutput>.</para><para><computeroutput>reverse_fold_tree&lt;&gt;</computeroutput> is easily understood in terms of a <computeroutput>recurse_if_&lt;&gt;</computeroutput> helper, defined as follows:</para><para><programlisting> template&lt;typename Tag, typename Fun&gt;
 struct recurse_if_
   : if_&lt;
         // If the current node has type type "Tag" ...
         is_same&lt;tag_of&lt;_&gt;, Tag&gt;()
         // ... recurse, otherwise ...
       , reverse_fold&lt;_, _state, recurse_if_&lt;Tag, Fun&gt; &gt;
         // ... apply the Fun transform.
       , Fun
     &gt;
 {};
</programlisting></para><para>With <computeroutput>recurse_if_&lt;&gt;</computeroutput> as defined above, <computeroutput>reverse_fold_tree&lt;Sequence, State0, Fun&gt;()(expr, state, data)</computeroutput> is equivalent to <computeroutput>reverse_fold&lt;Sequence, State0, recurse_if_&lt;Expr::proto_tag, Fun&gt; &gt;()(expr, state, data).</computeroutput> It has the effect of folding a tree back-to-front, recursing into child nodes that share a tag type with the parent node. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct></struct></namespace></namespace></header><header name="boost/proto/transform/lazy.hpp"><para>Contains definition of the lazy&lt;&gt; transform. </para><namespace name="boost"><namespace name="proto"><struct name="lazy"><template>
      <template-type-parameter name="Object"/>
    </template><inherit access="public">transform&lt; boost::proto::lazy&lt; Object &gt; &gt;</inherit><purpose>A PrimitiveTransform that uses <computeroutput>make&lt;&gt;</computeroutput> to build a CallableTransform, and then uses <computeroutput>call&lt;&gt;</computeroutput> to apply it. </purpose><description><para><computeroutput>lazy&lt;&gt;</computeroutput> is useful as a higher-order transform, when the transform to be applied depends on the current state of the transformation. The invocation of the <computeroutput>make&lt;&gt;</computeroutput> transform evaluates any nested transforms, and the resulting type is treated as a CallableTransform, which is evaluated with <computeroutput>call&lt;&gt;</computeroutput>. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct></struct><struct-specialization name="lazy"><template>
      <template-type-parameter name="Object"/>
    </template><specialization><template-arg>Object()</template-arg></specialization><inherit access="public">transform&lt; boost::proto::lazy&lt; Object()&gt; &gt;</inherit><purpose>A PrimitiveTransform that uses <computeroutput>make&lt;&gt;</computeroutput> to build a CallableTransform, and then uses <computeroutput>call&lt;&gt;</computeroutput> to apply it. </purpose><description><para><computeroutput>lazy&lt;&gt;</computeroutput> is useful as a higher-order transform, when the transform to be applied depends on the current state of the transformation. The invocation of the <computeroutput>make&lt;&gt;</computeroutput> transform evaluates any nested transforms, and the resulting type is treated as a CallableTransform, which is evaluated with <computeroutput>call&lt;&gt;</computeroutput>. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct></struct-specialization><struct-specialization name="lazy"><template>
      <template-type-parameter name="Object"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>Object(A0)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::lazy&lt; Object(A0)&gt; &gt;</inherit><purpose>A PrimitiveTransform that uses <computeroutput>make&lt;&gt;</computeroutput> to build a CallableTransform, and then uses <computeroutput>call&lt;&gt;</computeroutput> to apply it. </purpose><description><para><computeroutput>lazy&lt;&gt;</computeroutput> is useful as a higher-order transform, when the transform to be applied depends on the current state of the transformation. The invocation of the <computeroutput>make&lt;&gt;</computeroutput> transform evaluates any nested transforms, and the resulting type is treated as a CallableTransform, which is evaluated with <computeroutput>call&lt;&gt;</computeroutput>. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct></struct-specialization><struct-specialization name="lazy"><template>
      <template-type-parameter name="Object"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>Object(A0</template-arg><template-arg>A1)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::lazy&lt; Object(A0, A1)&gt; &gt;</inherit><purpose>A PrimitiveTransform that uses <computeroutput>make&lt;&gt;</computeroutput> to build a CallableTransform, and then uses <computeroutput>call&lt;&gt;</computeroutput> to apply it. </purpose><description><para><computeroutput>lazy&lt;&gt;</computeroutput> is useful as a higher-order transform, when the transform to be applied depends on the current state of the transformation. The invocation of the <computeroutput>make&lt;&gt;</computeroutput> transform evaluates any nested transforms, and the resulting type is treated as a CallableTransform, which is evaluated with <computeroutput>call&lt;&gt;</computeroutput>. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct></struct-specialization><struct-specialization name="lazy"><template>
      <template-type-parameter name="Object"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>Object(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::lazy&lt; Object(A0, A1, A2)&gt; &gt;</inherit><purpose>A PrimitiveTransform that uses <computeroutput>make&lt;&gt;</computeroutput> to build a CallableTransform, and then uses <computeroutput>call&lt;&gt;</computeroutput> to apply it. </purpose><description><para><computeroutput>lazy&lt;&gt;</computeroutput> is useful as a higher-order transform, when the transform to be applied depends on the current state of the transformation. The invocation of the <computeroutput>make&lt;&gt;</computeroutput> transform evaluates any nested transforms, and the resulting type is treated as a CallableTransform, which is evaluated with <computeroutput>call&lt;&gt;</computeroutput>. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct></struct-specialization><struct-specialization name="lazy"><template>
      <template-type-parameter name="Object"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>Object(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::lazy&lt; Object(A0, A1, A2, A3)&gt; &gt;</inherit><purpose>A PrimitiveTransform that uses <computeroutput>make&lt;&gt;</computeroutput> to build a CallableTransform, and then uses <computeroutput>call&lt;&gt;</computeroutput> to apply it. </purpose><description><para><computeroutput>lazy&lt;&gt;</computeroutput> is useful as a higher-order transform, when the transform to be applied depends on the current state of the transformation. The invocation of the <computeroutput>make&lt;&gt;</computeroutput> transform evaluates any nested transforms, and the resulting type is treated as a CallableTransform, which is evaluated with <computeroutput>call&lt;&gt;</computeroutput>. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct></struct-specialization><struct-specialization name="lazy"><template>
      <template-type-parameter name="Object"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Object(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::lazy&lt; Object(A0, A1, A2, A3, A4)&gt; &gt;</inherit><purpose>A PrimitiveTransform that uses <computeroutput>make&lt;&gt;</computeroutput> to build a CallableTransform, and then uses <computeroutput>call&lt;&gt;</computeroutput> to apply it. </purpose><description><para><computeroutput>lazy&lt;&gt;</computeroutput> is useful as a higher-order transform, when the transform to be applied depends on the current state of the transformation. The invocation of the <computeroutput>make&lt;&gt;</computeroutput> transform evaluates any nested transforms, and the resulting type is treated as a CallableTransform, which is evaluated with <computeroutput>call&lt;&gt;</computeroutput>. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct></struct-specialization></namespace></namespace></header><header name="boost/proto/transform/make.hpp"><para>Contains definition of the make&lt;&gt; transform. </para><namespace name="boost"><namespace name="proto"><struct name="make"><template>
      <template-type-parameter name="Object"/>
    </template><inherit access="public">transform&lt; boost::proto::make&lt; Object &gt; &gt;</inherit><purpose>A PrimitiveTransform which computes a type by evaluating any nested transforms and then constructs an object of that type. </purpose><description><para>The <computeroutput>make&lt;&gt;</computeroutput> transform checks to see if <computeroutput>Object</computeroutput> is a template. If it is, the template type is disassembled to find nested transforms. Proto considers the following types to represent transforms:</para><para><itemizedlist>
<listitem><para>Function types </para></listitem>
<listitem><para>Function pointer types </para></listitem>
<listitem><para>Types for which <computeroutput>proto::is_callable&lt; type &gt;::value</computeroutput> is <computeroutput>true</computeroutput> </para></listitem>
</itemizedlist>
<computeroutput>make&lt;T&lt;X0,X1,...&gt; &gt;::result&lt;void(Expr, State, Data)&gt;::type</computeroutput> is evaluated as follows. For each <computeroutput>X</computeroutput> in <computeroutput>X0,X1,...</computeroutput>, do:</para><para><itemizedlist>
<listitem><para>If <computeroutput>X</computeroutput> is a template like <computeroutput>U&lt;Y0,Y1,...&gt;</computeroutput>, then let <computeroutput>X'</computeroutput> be <computeroutput>make&lt;U&lt;Y0,Y1,...&gt; &gt;::result&lt;void(Expr, State, Data)&gt;::type</computeroutput> (which evaluates this procedure recursively). Note whether any substitutions took place during this operation. </para></listitem>
<listitem><para>Otherwise, if <computeroutput>X</computeroutput> is a transform, then let <computeroutput>X'</computeroutput> be <computeroutput>when&lt;_, X&gt;::result&lt;void(Expr, State, Data)&gt;::type</computeroutput>. Note that a substitution took place. </para></listitem>
<listitem><para>Otherwise, let <computeroutput>X'</computeroutput> be <computeroutput>X</computeroutput>, and note that no substitution took place. </para></listitem>
<listitem><para>If any substitutions took place in any of the above steps and <computeroutput>T&lt;X0',X1',...&gt;</computeroutput> has a nested <computeroutput>type</computeroutput> typedef, the result type is <computeroutput>T&lt;X0',X1',...&gt;::type</computeroutput>. </para></listitem>
<listitem><para>Otherwise, the result type is <computeroutput>T&lt;X0',X1',...&gt;</computeroutput>.</para></listitem>
</itemizedlist>
Note that <computeroutput>when&lt;&gt;</computeroutput> is implemented in terms of <computeroutput>call&lt;&gt;</computeroutput> and <computeroutput>make&lt;&gt;</computeroutput>, so the above procedure is evaluated recursively. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="result_type"><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name=""><paramtype>typename impl::expr_param</paramtype></parameter><parameter name=""><paramtype>typename impl::state_param</paramtype></parameter><parameter name=""><paramtype>typename impl::data_param</paramtype></parameter><purpose>
</purpose></method></method-group></struct></struct><struct-specialization name="make"><template>
      <template-type-parameter name="Object"/>
    </template><specialization><template-arg>Object()</template-arg></specialization><inherit access="public">transform&lt; boost::proto::make&lt; Object()&gt; &gt;</inherit><purpose>A PrimitiveTransform which computes a type by evaluating any nested transforms and then constructs an object of that type with the current expression, state and data, transformed according to <computeroutput>A0</computeroutput> through <computeroutput>AN</computeroutput>. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="result_type"><purpose><computeroutput>make&lt;Object&gt;::result&lt;void(Expr, State, Data)&gt;::type</computeroutput> </purpose><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>The current expression </para></description></parameter><parameter name="state"><paramtype>typename impl::state_param</paramtype><description><para>The current state </para></description></parameter><parameter name="data"><paramtype>typename impl::data_param</paramtype><description><para>An arbitrary data </para></description></parameter><description><para>Let <computeroutput>ax</computeroutput> be <computeroutput>when&lt;_, Ax&gt;()(expr, state, data)</computeroutput> for each <computeroutput>x</computeroutput> in <computeroutput>[0,N]</computeroutput>. Let <computeroutput>T</computeroutput> be <computeroutput>result&lt;void(Expr, State, Data)&gt;::type</computeroutput>. Return <computeroutput>T(a0, a1,... aN)</computeroutput>.</para><para>
</para></description></method></method-group></struct></struct-specialization><struct-specialization name="make"><template>
      <template-type-parameter name="Object"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>Object(A0)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::make&lt; Object(A0)&gt; &gt;</inherit><purpose>A PrimitiveTransform which computes a type by evaluating any nested transforms and then constructs an object of that type with the current expression, state and data, transformed according to <computeroutput>A0</computeroutput> through <computeroutput>AN</computeroutput>. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="result_type"><purpose><computeroutput>make&lt;Object&gt;::result&lt;void(Expr, State, Data)&gt;::type</computeroutput> </purpose><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>The current expression </para></description></parameter><parameter name="state"><paramtype>typename impl::state_param</paramtype><description><para>The current state </para></description></parameter><parameter name="data"><paramtype>typename impl::data_param</paramtype><description><para>An arbitrary data </para></description></parameter><description><para>Let <computeroutput>ax</computeroutput> be <computeroutput>when&lt;_, Ax&gt;()(expr, state, data)</computeroutput> for each <computeroutput>x</computeroutput> in <computeroutput>[0,N]</computeroutput>. Let <computeroutput>T</computeroutput> be <computeroutput>result&lt;void(Expr, State, Data)&gt;::type</computeroutput>. Return <computeroutput>T(a0, a1,... aN)</computeroutput>.</para><para>
</para></description></method></method-group></struct></struct-specialization><struct-specialization name="make"><template>
      <template-type-parameter name="Object"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>Object(A0</template-arg><template-arg>A1)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::make&lt; Object(A0, A1)&gt; &gt;</inherit><purpose>A PrimitiveTransform which computes a type by evaluating any nested transforms and then constructs an object of that type with the current expression, state and data, transformed according to <computeroutput>A0</computeroutput> through <computeroutput>AN</computeroutput>. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="result_type"><purpose><computeroutput>make&lt;Object&gt;::result&lt;void(Expr, State, Data)&gt;::type</computeroutput> </purpose><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>The current expression </para></description></parameter><parameter name="state"><paramtype>typename impl::state_param</paramtype><description><para>The current state </para></description></parameter><parameter name="data"><paramtype>typename impl::data_param</paramtype><description><para>An arbitrary data </para></description></parameter><description><para>Let <computeroutput>ax</computeroutput> be <computeroutput>when&lt;_, Ax&gt;()(expr, state, data)</computeroutput> for each <computeroutput>x</computeroutput> in <computeroutput>[0,N]</computeroutput>. Let <computeroutput>T</computeroutput> be <computeroutput>result&lt;void(Expr, State, Data)&gt;::type</computeroutput>. Return <computeroutput>T(a0, a1,... aN)</computeroutput>.</para><para>
</para></description></method></method-group></struct></struct-specialization><struct-specialization name="make"><template>
      <template-type-parameter name="Object"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>Object(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::make&lt; Object(A0, A1, A2)&gt; &gt;</inherit><purpose>A PrimitiveTransform which computes a type by evaluating any nested transforms and then constructs an object of that type with the current expression, state and data, transformed according to <computeroutput>A0</computeroutput> through <computeroutput>AN</computeroutput>. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="result_type"><purpose><computeroutput>make&lt;Object&gt;::result&lt;void(Expr, State, Data)&gt;::type</computeroutput> </purpose><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>The current expression </para></description></parameter><parameter name="state"><paramtype>typename impl::state_param</paramtype><description><para>The current state </para></description></parameter><parameter name="data"><paramtype>typename impl::data_param</paramtype><description><para>An arbitrary data </para></description></parameter><description><para>Let <computeroutput>ax</computeroutput> be <computeroutput>when&lt;_, Ax&gt;()(expr, state, data)</computeroutput> for each <computeroutput>x</computeroutput> in <computeroutput>[0,N]</computeroutput>. Let <computeroutput>T</computeroutput> be <computeroutput>result&lt;void(Expr, State, Data)&gt;::type</computeroutput>. Return <computeroutput>T(a0, a1,... aN)</computeroutput>.</para><para>
</para></description></method></method-group></struct></struct-specialization><struct-specialization name="make"><template>
      <template-type-parameter name="Object"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>Object(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::make&lt; Object(A0, A1, A2, A3)&gt; &gt;</inherit><purpose>A PrimitiveTransform which computes a type by evaluating any nested transforms and then constructs an object of that type with the current expression, state and data, transformed according to <computeroutput>A0</computeroutput> through <computeroutput>AN</computeroutput>. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="result_type"><purpose><computeroutput>make&lt;Object&gt;::result&lt;void(Expr, State, Data)&gt;::type</computeroutput> </purpose><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>The current expression </para></description></parameter><parameter name="state"><paramtype>typename impl::state_param</paramtype><description><para>The current state </para></description></parameter><parameter name="data"><paramtype>typename impl::data_param</paramtype><description><para>An arbitrary data </para></description></parameter><description><para>Let <computeroutput>ax</computeroutput> be <computeroutput>when&lt;_, Ax&gt;()(expr, state, data)</computeroutput> for each <computeroutput>x</computeroutput> in <computeroutput>[0,N]</computeroutput>. Let <computeroutput>T</computeroutput> be <computeroutput>result&lt;void(Expr, State, Data)&gt;::type</computeroutput>. Return <computeroutput>T(a0, a1,... aN)</computeroutput>.</para><para>
</para></description></method></method-group></struct></struct-specialization><struct-specialization name="make"><template>
      <template-type-parameter name="Object"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Object(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::make&lt; Object(A0, A1, A2, A3, A4)&gt; &gt;</inherit><purpose>A PrimitiveTransform which computes a type by evaluating any nested transforms and then constructs an object of that type with the current expression, state and data, transformed according to <computeroutput>A0</computeroutput> through <computeroutput>AN</computeroutput>. </purpose><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="result_type"><purpose><computeroutput>make&lt;Object&gt;::result&lt;void(Expr, State, Data)&gt;::type</computeroutput> </purpose><type><emphasis>unspecified</emphasis></type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>The current expression </para></description></parameter><parameter name="state"><paramtype>typename impl::state_param</paramtype><description><para>The current state </para></description></parameter><parameter name="data"><paramtype>typename impl::data_param</paramtype><description><para>An arbitrary data </para></description></parameter><description><para>Let <computeroutput>ax</computeroutput> be <computeroutput>when&lt;_, Ax&gt;()(expr, state, data)</computeroutput> for each <computeroutput>x</computeroutput> in <computeroutput>[0,N]</computeroutput>. Let <computeroutput>T</computeroutput> be <computeroutput>result&lt;void(Expr, State, Data)&gt;::type</computeroutput>. Return <computeroutput>T(a0, a1,... aN)</computeroutput>.</para><para>
</para></description></method></method-group></struct></struct-specialization></namespace></namespace></header><header name="boost/proto/transform/pass_through.hpp"><para>Definition of the pass_through transform, which is the default transform of all of the expression generator metafunctions such as unary_plus&lt;&gt;, plus&lt;&gt; and nary_expr&lt;&gt;. </para><namespace name="boost"><namespace name="proto"><struct name="pass_through"><template>
      <template-type-parameter name="Grammar"/>
    </template><inherit access="public">transform&lt; boost::proto::pass_through&lt; Grammar &gt; &gt;</inherit><purpose>A PrimitiveTransform that transforms the child expressions of an expression node according to the corresponding children of a Grammar. </purpose><description><para>Given a Grammar such as <computeroutput>plus&lt;T0, T1&gt;</computeroutput>, an expression type that matches the grammar such as <computeroutput>plus&lt;E0, E1&gt;::type</computeroutput>, a state <computeroutput>S</computeroutput> and a data <computeroutput>V</computeroutput>, the result of applying the <computeroutput>pass_through&lt;plus&lt;T0, T1&gt; &gt;</computeroutput> transform is:</para><para><programlisting> plus&lt;
     T0::result&lt;void(E0, S, V)&gt;::type
   , T1::result&lt;void(E1, S, V)&gt;::type
 &gt;::type
</programlisting></para><para>The above demonstrates how child transforms and child expressions are applied pairwise, and how the results are reassembled into a new expression node with the same tag type as the original.</para><para>The explicit use of <computeroutput>pass_through&lt;&gt;</computeroutput> is not usually needed, since the expression generator metafunctions such as <computeroutput>plus&lt;&gt;</computeroutput> have <computeroutput>pass_through&lt;&gt;</computeroutput> as their default transform. So, for instance, these are equivalent:</para><para><programlisting> // Within a grammar definition, these are equivalent:
 when&lt; plus&lt;X, Y&gt;, pass_through&lt; plus&lt;X, Y&gt; &gt; &gt;
 when&lt; plus&lt;X, Y&gt;, plus&lt;X, Y&gt; &gt;
 when&lt; plus&lt;X, Y&gt; &gt; // because of when&lt;class X, class Y=X&gt;
 plus&lt;X, Y&gt;         // because plus&lt;&gt; is both a
                    //   grammar and a transform
</programlisting></para><para>For example, consider the following transform that promotes all <computeroutput>float</computeroutput> terminals in an expression to <computeroutput>double</computeroutput>.</para><para><programlisting> // This transform finds all float terminals in an expression and promotes
 // them to doubles.
 struct Promote
  : or_&lt;
         when&lt;terminal&lt;float&gt;, terminal&lt;double&gt;::type(_value) &gt;
         // terminal&lt;&gt;'s default transform is a no-op:
       , terminal&lt;_&gt;
         // nary_expr&lt;&gt; has a pass_through&lt;&gt; transform:
       , nary_expr&lt;_, vararg&lt;Promote&gt; &gt;
     &gt;
 {};
</programlisting> </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template></struct></struct></namespace></namespace></header><header name="boost/proto/transform/when.hpp"><para>Definition of when transform. </para><namespace name="boost"><namespace name="proto"><struct name="when"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="PrimitiveTransform"><default>Grammar</default></template-type-parameter>
    </template><purpose>A grammar element and a PrimitiveTransform that associates a transform with the grammar. </purpose><description><para>Use <computeroutput>when&lt;&gt;</computeroutput> to override a grammar's default transform with a custom transform. It is for used when composing larger transforms by associating smaller transforms with individual rules in your grammar, as in the following transform which counts the number of terminals in an expression.</para><para><programlisting> // Count the terminals in an expression tree.
 // Must be invoked with initial state == mpl::int_&lt;0&gt;().
 struct CountLeaves
   : or_&lt;
         when&lt;terminal&lt;_&gt;, mpl::next&lt;_state&gt;()&gt;
       , otherwise&lt;fold&lt;_, _state, CountLeaves&gt; &gt;
     &gt;
 {};
</programlisting></para><para>In <computeroutput>when&lt;G, T&gt;</computeroutput>, when <computeroutput>T</computeroutput> is a class type it is a PrimitiveTransform and the following equivalencies hold:</para><para><computeroutput>when&lt;G,T&gt;::result&lt;void(E,S,V)&gt;::type</computeroutput> is the same as <computeroutput>T::result&lt;void(E,S,V)&gt;::type</computeroutput>.</para><para><computeroutput>when&lt;G,T&gt;()(e,s,v)</computeroutput> is the same as <computeroutput>T()(e,s,v)</computeroutput>. </para></description><typedef name="proto_base_expr"><type>Grammar::proto_base_expr</type></typedef></struct><struct-specialization name="when"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="Fun"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>Fun *</template-arg></specialization><inherit access="public">boost::proto::when&lt; Grammar, Fun &gt;</inherit><purpose>A specialization that treats function pointer Transforms as if they were function type Transforms. </purpose><description><para>This specialization requires that <computeroutput>Fun</computeroutput> is actually a function type.</para><para>This specialization is required for nested transforms such as <computeroutput>when&lt;G, T0(T1(_))&gt;</computeroutput>. In C++, functions that are used as parameters to other functions automatically decay to funtion pointer types. In other words, the type <computeroutput>T0(T1(_))</computeroutput> is indistinguishable from <computeroutput>T0(T1(*)(_))</computeroutput>. This specialization is required to handle these nested function pointer type transforms properly. </para></description></struct-specialization><struct name="otherwise"><template>
      <template-type-parameter name="Fun"/>
    </template><inherit access="public">boost::proto::when&lt; _, Fun &gt;</inherit><purpose>Syntactic sugar for <computeroutput>when&lt;_, Fun&gt;</computeroutput>, for use in grammars to handle all the cases not yet handled. </purpose><description><para>Use <computeroutput>otherwise&lt;T&gt;</computeroutput> in your grammars as a synonym for <computeroutput>when&lt;_, T&gt;</computeroutput> as in the following transform which counts the number of terminals in an expression.</para><para><programlisting> // Count the terminals in an expression tree.
 // Must be invoked with initial state == mpl::int_&lt;0&gt;().
 struct CountLeaves
   : or_&lt;
         when&lt;terminal&lt;_&gt;, mpl::next&lt;_state&gt;()&gt;
       , otherwise&lt;fold&lt;_, _state, CountLeaves&gt; &gt;
     &gt;
 {};
</programlisting> </para></description></struct><struct-specialization name="when"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="R"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>R()</template-arg></specialization><inherit access="public">transform&lt; boost::proto::when&lt; Grammar, R()&gt; &gt;</inherit><purpose>A grammar element and a PrimitiveTransform that associates a transform with the grammar. </purpose><description><para>Use <computeroutput>when&lt;&gt;</computeroutput> to override a grammar's default transform with a custom transform. It is for used when composing larger transforms by associating smaller transforms with individual rules in your grammar, as in the following transform which counts the number of terminals in an expression.</para><para><programlisting> // Count the terminals in an expression tree.
 // Must be invoked with initial state == mpl::int_&lt;0&gt;().
 struct CountLeaves
   : or_&lt;
         when&lt;terminal&lt;_&gt;, mpl::next&lt;_state&gt;()&gt;
       , otherwise&lt;fold&lt;_, _state, CountLeaves&gt; &gt;
     &gt;
 {};
</programlisting></para><para>The <computeroutput>when&lt;G, R(A0,A1,...)&gt;</computeroutput> form accepts either a CallableTransform or an ObjectTransform as its second parameter. <computeroutput>when&lt;&gt;</computeroutput> uses <computeroutput>is_callable&lt;R&gt;::value</computeroutput> to distinguish between the two, and uses <computeroutput>call&lt;&gt;</computeroutput> to evaluate CallableTransforms and <computeroutput>make&lt;&gt;</computeroutput> to evaluate ObjectTransforms. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="call_"><type><classname>call</classname>&lt; R()&gt;</type></typedef><typedef name="make_"><type><classname>make</classname>&lt; R()&gt;</type></typedef><typedef name="which"><type>mpl::if_c&lt; <classname>is_callable</classname>&lt; R &gt;::value, <classname>call_</classname>, <classname>make_</classname> &gt;::type</type></typedef><typedef name="result_type"><type>which::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>The current expression </para></description></parameter><parameter name="state"><paramtype>typename impl::state_param</paramtype><description><para>The current state </para></description></parameter><parameter name="data"><paramtype>typename impl::data_param</paramtype><description><para>An arbitrary data </para></description></parameter><description><para>Evaluate <computeroutput>R(A0,A1,...)</computeroutput> as a transform either with <computeroutput>call&lt;&gt;</computeroutput> or with <computeroutput>make&lt;&gt;</computeroutput> depending on whether <computeroutput>is_callable&lt;R&gt;::value</computeroutput> is <computeroutput>true</computeroutput> or <computeroutput>false</computeroutput>.</para><para>


</para></description><requires><para><computeroutput>matches&lt;Expr, Grammar&gt;::value</computeroutput> is <computeroutput>true</computeroutput> </para></requires><returns><para><computeroutput>result&lt;void(Expr, State, Data)&gt;::impl()(expr, state, data)</computeroutput> </para></returns></method></method-group></struct><typedef name="proto_base_expr"><type>Grammar::proto_base_expr</type></typedef></struct-specialization><struct-specialization name="when"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="R"/>
      <template-type-parameter name="A0"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>R(A0)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::when&lt; Grammar, R(A0)&gt; &gt;</inherit><purpose>A grammar element and a PrimitiveTransform that associates a transform with the grammar. </purpose><description><para>Use <computeroutput>when&lt;&gt;</computeroutput> to override a grammar's default transform with a custom transform. It is for used when composing larger transforms by associating smaller transforms with individual rules in your grammar, as in the following transform which counts the number of terminals in an expression.</para><para><programlisting> // Count the terminals in an expression tree.
 // Must be invoked with initial state == mpl::int_&lt;0&gt;().
 struct CountLeaves
   : or_&lt;
         when&lt;terminal&lt;_&gt;, mpl::next&lt;_state&gt;()&gt;
       , otherwise&lt;fold&lt;_, _state, CountLeaves&gt; &gt;
     &gt;
 {};
</programlisting></para><para>The <computeroutput>when&lt;G, R(A0,A1,...)&gt;</computeroutput> form accepts either a CallableTransform or an ObjectTransform as its second parameter. <computeroutput>when&lt;&gt;</computeroutput> uses <computeroutput>is_callable&lt;R&gt;::value</computeroutput> to distinguish between the two, and uses <computeroutput>call&lt;&gt;</computeroutput> to evaluate CallableTransforms and <computeroutput>make&lt;&gt;</computeroutput> to evaluate ObjectTransforms. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="call_"><type><classname>call</classname>&lt; R(A0)&gt;</type></typedef><typedef name="make_"><type><classname>make</classname>&lt; R(A0)&gt;</type></typedef><typedef name="which"><type>mpl::if_c&lt; <classname>is_callable</classname>&lt; R &gt;::value, <classname>call_</classname>, <classname>make_</classname> &gt;::type</type></typedef><typedef name="result_type"><type>which::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>The current expression </para></description></parameter><parameter name="state"><paramtype>typename impl::state_param</paramtype><description><para>The current state </para></description></parameter><parameter name="data"><paramtype>typename impl::data_param</paramtype><description><para>An arbitrary data </para></description></parameter><description><para>Evaluate <computeroutput>R(A0,A1,...)</computeroutput> as a transform either with <computeroutput>call&lt;&gt;</computeroutput> or with <computeroutput>make&lt;&gt;</computeroutput> depending on whether <computeroutput>is_callable&lt;R&gt;::value</computeroutput> is <computeroutput>true</computeroutput> or <computeroutput>false</computeroutput>.</para><para>


</para></description><requires><para><computeroutput>matches&lt;Expr, Grammar&gt;::value</computeroutput> is <computeroutput>true</computeroutput> </para></requires><returns><para><computeroutput>result&lt;void(Expr, State, Data)&gt;::impl()(expr, state, data)</computeroutput> </para></returns></method></method-group></struct><typedef name="proto_base_expr"><type>Grammar::proto_base_expr</type></typedef></struct-specialization><struct-specialization name="when"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="R"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>R(A0</template-arg><template-arg>A1)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::when&lt; Grammar, R(A0, A1)&gt; &gt;</inherit><purpose>A grammar element and a PrimitiveTransform that associates a transform with the grammar. </purpose><description><para>Use <computeroutput>when&lt;&gt;</computeroutput> to override a grammar's default transform with a custom transform. It is for used when composing larger transforms by associating smaller transforms with individual rules in your grammar, as in the following transform which counts the number of terminals in an expression.</para><para><programlisting> // Count the terminals in an expression tree.
 // Must be invoked with initial state == mpl::int_&lt;0&gt;().
 struct CountLeaves
   : or_&lt;
         when&lt;terminal&lt;_&gt;, mpl::next&lt;_state&gt;()&gt;
       , otherwise&lt;fold&lt;_, _state, CountLeaves&gt; &gt;
     &gt;
 {};
</programlisting></para><para>The <computeroutput>when&lt;G, R(A0,A1,...)&gt;</computeroutput> form accepts either a CallableTransform or an ObjectTransform as its second parameter. <computeroutput>when&lt;&gt;</computeroutput> uses <computeroutput>is_callable&lt;R&gt;::value</computeroutput> to distinguish between the two, and uses <computeroutput>call&lt;&gt;</computeroutput> to evaluate CallableTransforms and <computeroutput>make&lt;&gt;</computeroutput> to evaluate ObjectTransforms. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="call_"><type><classname>call</classname>&lt; R(A0, A1)&gt;</type></typedef><typedef name="make_"><type><classname>make</classname>&lt; R(A0, A1)&gt;</type></typedef><typedef name="which"><type>mpl::if_c&lt; <classname>is_callable</classname>&lt; R &gt;::value, <classname>call_</classname>, <classname>make_</classname> &gt;::type</type></typedef><typedef name="result_type"><type>which::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>The current expression </para></description></parameter><parameter name="state"><paramtype>typename impl::state_param</paramtype><description><para>The current state </para></description></parameter><parameter name="data"><paramtype>typename impl::data_param</paramtype><description><para>An arbitrary data </para></description></parameter><description><para>Evaluate <computeroutput>R(A0,A1,...)</computeroutput> as a transform either with <computeroutput>call&lt;&gt;</computeroutput> or with <computeroutput>make&lt;&gt;</computeroutput> depending on whether <computeroutput>is_callable&lt;R&gt;::value</computeroutput> is <computeroutput>true</computeroutput> or <computeroutput>false</computeroutput>.</para><para>


</para></description><requires><para><computeroutput>matches&lt;Expr, Grammar&gt;::value</computeroutput> is <computeroutput>true</computeroutput> </para></requires><returns><para><computeroutput>result&lt;void(Expr, State, Data)&gt;::impl()(expr, state, data)</computeroutput> </para></returns></method></method-group></struct><typedef name="proto_base_expr"><type>Grammar::proto_base_expr</type></typedef></struct-specialization><struct-specialization name="when"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="R"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>R(A0</template-arg><template-arg>A1</template-arg><template-arg>A2)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::when&lt; Grammar, R(A0, A1, A2)&gt; &gt;</inherit><purpose>A grammar element and a PrimitiveTransform that associates a transform with the grammar. </purpose><description><para>Use <computeroutput>when&lt;&gt;</computeroutput> to override a grammar's default transform with a custom transform. It is for used when composing larger transforms by associating smaller transforms with individual rules in your grammar, as in the following transform which counts the number of terminals in an expression.</para><para><programlisting> // Count the terminals in an expression tree.
 // Must be invoked with initial state == mpl::int_&lt;0&gt;().
 struct CountLeaves
   : or_&lt;
         when&lt;terminal&lt;_&gt;, mpl::next&lt;_state&gt;()&gt;
       , otherwise&lt;fold&lt;_, _state, CountLeaves&gt; &gt;
     &gt;
 {};
</programlisting></para><para>The <computeroutput>when&lt;G, R(A0,A1,...)&gt;</computeroutput> form accepts either a CallableTransform or an ObjectTransform as its second parameter. <computeroutput>when&lt;&gt;</computeroutput> uses <computeroutput>is_callable&lt;R&gt;::value</computeroutput> to distinguish between the two, and uses <computeroutput>call&lt;&gt;</computeroutput> to evaluate CallableTransforms and <computeroutput>make&lt;&gt;</computeroutput> to evaluate ObjectTransforms. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="call_"><type><classname>call</classname>&lt; R(A0, A1, A2)&gt;</type></typedef><typedef name="make_"><type><classname>make</classname>&lt; R(A0, A1, A2)&gt;</type></typedef><typedef name="which"><type>mpl::if_c&lt; <classname>is_callable</classname>&lt; R &gt;::value, <classname>call_</classname>, <classname>make_</classname> &gt;::type</type></typedef><typedef name="result_type"><type>which::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>The current expression </para></description></parameter><parameter name="state"><paramtype>typename impl::state_param</paramtype><description><para>The current state </para></description></parameter><parameter name="data"><paramtype>typename impl::data_param</paramtype><description><para>An arbitrary data </para></description></parameter><description><para>Evaluate <computeroutput>R(A0,A1,...)</computeroutput> as a transform either with <computeroutput>call&lt;&gt;</computeroutput> or with <computeroutput>make&lt;&gt;</computeroutput> depending on whether <computeroutput>is_callable&lt;R&gt;::value</computeroutput> is <computeroutput>true</computeroutput> or <computeroutput>false</computeroutput>.</para><para>


</para></description><requires><para><computeroutput>matches&lt;Expr, Grammar&gt;::value</computeroutput> is <computeroutput>true</computeroutput> </para></requires><returns><para><computeroutput>result&lt;void(Expr, State, Data)&gt;::impl()(expr, state, data)</computeroutput> </para></returns></method></method-group></struct><typedef name="proto_base_expr"><type>Grammar::proto_base_expr</type></typedef></struct-specialization><struct-specialization name="when"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="R"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>R(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::when&lt; Grammar, R(A0, A1, A2, A3)&gt; &gt;</inherit><purpose>A grammar element and a PrimitiveTransform that associates a transform with the grammar. </purpose><description><para>Use <computeroutput>when&lt;&gt;</computeroutput> to override a grammar's default transform with a custom transform. It is for used when composing larger transforms by associating smaller transforms with individual rules in your grammar, as in the following transform which counts the number of terminals in an expression.</para><para><programlisting> // Count the terminals in an expression tree.
 // Must be invoked with initial state == mpl::int_&lt;0&gt;().
 struct CountLeaves
   : or_&lt;
         when&lt;terminal&lt;_&gt;, mpl::next&lt;_state&gt;()&gt;
       , otherwise&lt;fold&lt;_, _state, CountLeaves&gt; &gt;
     &gt;
 {};
</programlisting></para><para>The <computeroutput>when&lt;G, R(A0,A1,...)&gt;</computeroutput> form accepts either a CallableTransform or an ObjectTransform as its second parameter. <computeroutput>when&lt;&gt;</computeroutput> uses <computeroutput>is_callable&lt;R&gt;::value</computeroutput> to distinguish between the two, and uses <computeroutput>call&lt;&gt;</computeroutput> to evaluate CallableTransforms and <computeroutput>make&lt;&gt;</computeroutput> to evaluate ObjectTransforms. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="call_"><type><classname>call</classname>&lt; R(A0, A1, A2, A3)&gt;</type></typedef><typedef name="make_"><type><classname>make</classname>&lt; R(A0, A1, A2, A3)&gt;</type></typedef><typedef name="which"><type>mpl::if_c&lt; <classname>is_callable</classname>&lt; R &gt;::value, <classname>call_</classname>, <classname>make_</classname> &gt;::type</type></typedef><typedef name="result_type"><type>which::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>The current expression </para></description></parameter><parameter name="state"><paramtype>typename impl::state_param</paramtype><description><para>The current state </para></description></parameter><parameter name="data"><paramtype>typename impl::data_param</paramtype><description><para>An arbitrary data </para></description></parameter><description><para>Evaluate <computeroutput>R(A0,A1,...)</computeroutput> as a transform either with <computeroutput>call&lt;&gt;</computeroutput> or with <computeroutput>make&lt;&gt;</computeroutput> depending on whether <computeroutput>is_callable&lt;R&gt;::value</computeroutput> is <computeroutput>true</computeroutput> or <computeroutput>false</computeroutput>.</para><para>


</para></description><requires><para><computeroutput>matches&lt;Expr, Grammar&gt;::value</computeroutput> is <computeroutput>true</computeroutput> </para></requires><returns><para><computeroutput>result&lt;void(Expr, State, Data)&gt;::impl()(expr, state, data)</computeroutput> </para></returns></method></method-group></struct><typedef name="proto_base_expr"><type>Grammar::proto_base_expr</type></typedef></struct-specialization><struct-specialization name="when"><template>
      <template-type-parameter name="Grammar"/>
      <template-type-parameter name="R"/>
      <template-type-parameter name="A0"/>
      <template-type-parameter name="A1"/>
      <template-type-parameter name="A2"/>
      <template-type-parameter name="A3"/>
      <template-type-parameter name="A4"/>
    </template><specialization><template-arg>Grammar</template-arg><template-arg>R(A0</template-arg><template-arg>A1</template-arg><template-arg>A2</template-arg><template-arg>A3</template-arg><template-arg>A4)</template-arg></specialization><inherit access="public">transform&lt; boost::proto::when&lt; Grammar, R(A0, A1, A2, A3, A4)&gt; &gt;</inherit><purpose>A grammar element and a PrimitiveTransform that associates a transform with the grammar. </purpose><description><para>Use <computeroutput>when&lt;&gt;</computeroutput> to override a grammar's default transform with a custom transform. It is for used when composing larger transforms by associating smaller transforms with individual rules in your grammar, as in the following transform which counts the number of terminals in an expression.</para><para><programlisting> // Count the terminals in an expression tree.
 // Must be invoked with initial state == mpl::int_&lt;0&gt;().
 struct CountLeaves
   : or_&lt;
         when&lt;terminal&lt;_&gt;, mpl::next&lt;_state&gt;()&gt;
       , otherwise&lt;fold&lt;_, _state, CountLeaves&gt; &gt;
     &gt;
 {};
</programlisting></para><para>The <computeroutput>when&lt;G, R(A0,A1,...)&gt;</computeroutput> form accepts either a CallableTransform or an ObjectTransform as its second parameter. <computeroutput>when&lt;&gt;</computeroutput> uses <computeroutput>is_callable&lt;R&gt;::value</computeroutput> to distinguish between the two, and uses <computeroutput>call&lt;&gt;</computeroutput> to evaluate CallableTransforms and <computeroutput>make&lt;&gt;</computeroutput> to evaluate ObjectTransforms. </para></description><struct name="impl"><template>
      <template-type-parameter name="Expr"/>
      <template-type-parameter name="State"/>
      <template-type-parameter name="Data"/>
    </template><typedef name="call_"><type><classname>call</classname>&lt; R(A0, A1, A2, A3, A4)&gt;</type></typedef><typedef name="make_"><type><classname>make</classname>&lt; R(A0, A1, A2, A3, A4)&gt;</type></typedef><typedef name="which"><type>mpl::if_c&lt; <classname>is_callable</classname>&lt; R &gt;::value, <classname>call_</classname>, <classname>make_</classname> &gt;::type</type></typedef><typedef name="result_type"><type>which::template impl&lt; Expr, State, Data &gt;::result_type</type></typedef><method-group name="public member functions"><method name="operator()" cv="const"><type>result_type</type><parameter name="expr"><paramtype>typename impl::expr_param</paramtype><description><para>The current expression </para></description></parameter><parameter name="state"><paramtype>typename impl::state_param</paramtype><description><para>The current state </para></description></parameter><parameter name="data"><paramtype>typename impl::data_param</paramtype><description><para>An arbitrary data </para></description></parameter><description><para>Evaluate <computeroutput>R(A0,A1,...)</computeroutput> as a transform either with <computeroutput>call&lt;&gt;</computeroutput> or with <computeroutput>make&lt;&gt;</computeroutput> depending on whether <computeroutput>is_callable&lt;R&gt;::value</computeroutput> is <computeroutput>true</computeroutput> or <computeroutput>false</computeroutput>.</para><para>


</para></description><requires><para><computeroutput>matches&lt;Expr, Grammar&gt;::value</computeroutput> is <computeroutput>true</computeroutput> </para></requires><returns><para><computeroutput>result&lt;void(Expr, State, Data)&gt;::impl()(expr, state, data)</computeroutput> </para></returns></method></method-group></struct><typedef name="proto_base_expr"><type>Grammar::proto_base_expr</type></typedef></struct-specialization></namespace></namespace></header></library-reference>
