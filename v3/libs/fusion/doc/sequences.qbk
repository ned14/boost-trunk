[section Sequences]

Like __mpl__, the Sequence is a fundamental concept in Fusion. A Sequence
may or may not actually store or contain data. __containers__ are sequences
that hold data. __views__, on the other hand, are sequences that do not
store any data. Instead, they are proxies that impart an alternative
presentation over another sequence. All models of Sequence have an
associated __iterator__ type that can be used to iterate through the
Sequence's elements.

[heading Header]

    #include <boost/fusion/sequence.hpp>

[section Concepts]

Fusion Sequences are organized into a hierarchy of concepts.

[heading Traversal]

Fusion's sequence traversal related concepts parallel Fusion's
__iterator_concepts__. __forward_sequence__ is the most basic concept.
__bidirectional_sequence__ is a refinement of __forward_sequence__.
__random_access_sequence__ is a refinement of __bidirectional_sequence__.
These concepts pertain to sequence traversal.

[heading Associativity]

The __associative_sequence__ concept is orthogonal to traversal. An Associative
Sequence allows efficient retrieval of elements based on keys.

[section Forward Sequence]

[heading Description]

A Forward Sequence is a Sequence whose elements are arranged in a definite
order. The ordering is guaranteed not to change from iteration to
iteration. The requirement of a definite ordering allows the definition of
element-by-element equality (if the container's element type is Equality
Comparable) and of lexicographical ordering (if the container's element
type is LessThan Comparable).

[variablelist Notation
    [[`s`]       [A Forward Sequence]]
    [[`S`]       [A Forward Sequence type]]
    [[`o`]       [An arbitrary object]]
    [[`e`]       [A Sequence element]]
]

[heading Valid Expressions]

For any Forward Sequence the following expressions must be valid:

[table
    [[Expression]       [Return type]               [Type Requirements]     [Runtime Complexity]]
    [[`__begin__(s)`]       [__forward_iterator__]      []                      [Constant]]
    [[`__end__(s)`]         [__forward_iterator__]      []                      [Constant]]
    [[`__size__(s)`]        [__mpl_integral_constant__.
                        Convertible to int.]        []                      [Constant]]
    [[`__empty__(s)`]       [__mpl_boolean_constant__.
                        Convertible to bool.]       []                      [Constant]]
    [[`__front__(s)`]       [Any type]                  []                      [Constant]]
    [[`__front__(s) = o`]   [Any type]                  [`s` is mutable and
                                                    `e = o`, where `e`
                                                    is the first element
                                                    in the sequence, is
                                                    a valid expression.]    [Constant]]
]

[heading Result Type Expressions]

[table
    [[Expression]                   [Compile Time Complexity]]
    [[`__result_of_begin__<S>::type`]  [Amortized constant time]]
    [[`__result_of_end__<S>::type`]    [Amortized constant time]]
    [[`__result_of_size__<S>::type`]   [Unspecified]]
    [[`__result_of_empty__<S>::type`]  [Constant time]]
    [[`__result_of_front__<S>::type`]  [Amortized constant time]]
]

[heading Expression Semantics]

[table
    [[Expression]       [Semantics]]
    [[`__begin__(s)`]       [An iterator to the first element of the sequence; see __begin__.]]
    [[`__end__(s)`]         [A past-the-end iterator to the sequence; see __end__.]]
    [[`__size__(s)`]        [The size of the sequence; see __size__.]]
    [[`__empty__(s)`]       [A boolean Integral Constant `c` such that
                        `c::value == true` if and only if the sequence
                        is empty; see __empty__.]]
    [[`__front__(s)`]       [The first element in the sequence; see __front__.]]
]

[heading Invariants]

For any Forward Sequence s the following invariants always hold:

* `[__begin__(s), __end__(s))` is always a valid range.
* An __algorithm__ that iterates through the range `[__begin__(s), __end__(s))`
  will pass through every element of `s` exactly once.
* `__begin__(s)` is identical to `__end__(s))` if and only if `s` is empty.
* Two different iterations through `s` will access its elements in
  the same order.

[heading Models]

* __std_pair__
* __boost_array__
* __vector__
* __cons__
* __list__
* __set__
* __map__
* __single_view__
* __filter_view__
* __iterator_range__
* __joint_view__
* __transform_view__
* __reverse_view__
* __zip_view__

[endsect]

[section Bidirectional Sequence]

[heading Description]

A Bidirectional Sequence is a __forward_sequence__ whose iterators model
__bidirectional_iterator__.

[heading Refinement of]

__forward_sequence__

[variablelist Notation
    [[`s`]       [A Forward Sequence]]
    [[`S`]       [A Forward Sequence type]]
    [[`o`]       [An arbitrary object]]
    [[`e`]       [A Sequence element]]
]

[heading Valid Expressions]

In addition to the requirements defined in __forward_sequence__, for any
Bidirectional Sequence the following must be met:

[table
    [[Expression]       [Return type]                   [Type Requirements]     [Runtime Complexity]]
    [[`__begin__(s)`]       [__bidirectional_iterator__]    []                      [Constant]]
    [[`__end__(s)`]         [__bidirectional_iterator__]    []                      [Constant]]
    [[`__back__(s)`]        [Any type]                      []                      [Constant]]
    [[`__back__(s) = o`]    [Any type]                      [`s` is mutable and
                                                        `e = o`, where `e`
                                                        is the first element
                                                        in the sequence, is
                                                        a valid expression.]    [Constant]]
]

[heading Result Type Expressions]

[table
    [[Expression]                   [Compile Time Complexity]]
    [[`__result_of_begin__<S>::type`]  [Amortized constant time]]
    [[`__result_of_end__<S>::type`]    [Amortized constant time]]
    [[`__result_of_back__<S>::type`]   [Amortized constant time]]
]

[heading Expression Semantics]

The semantics of an expression are defined only where they differ from, or
are not defined in __forward_sequence__.

[table
    [[Expression]       [Semantics]]
    [[`__back__(s)`]        [The last element in the sequence; see __back__.]]
]

[heading Models]

* __std_pair__
* __boost_array__
* __vector__
* __reverse_view__
* __iterator_range__ (where adapted sequence is a Bidirectional Sequence)
* __transform_view__ (where adapted sequence is a Bidirectional Sequence)
* __zip_view__       (where adapted sequences are models Bidirectional Sequence)

[endsect]

[section Random Access Sequence]

[heading Description]

A Random Access Sequence is a __bidirectional_sequence__ whose iterators
model __random_access_iterator__. It guarantees constant time access to
arbitrary sequence elements.

[heading Refinement of]

__bidirectional_sequence__

[variablelist Notation
    [[`s`]       [A Random Access Sequence]]
    [[`S`]       [A Random Access Sequence type]]
    [[`N`]       [An __mpl_integral_constant__]]
    [[`o`]       [An arbitrary object]]
    [[`e`]       [A Sequence element]]
]

[heading Valid Expressions]

In addition to the requirements defined in __bidirectional_sequence__, for
any Random Access Sequence the following must be met:

[table
    [[Expression]       [Return type]                   [Type Requirements]     [Runtime Complexity]]
    [[`__begin__(s)`]       [__random_access_iterator__]    []                      [Constant]]
    [[`__end__(s)`]         [__random_access_iterator__]    []                      [Constant]]
    [[`__at__<N>(s)`]       [Any type]                      []                      [Constant]]
    [[`__at__<N>(s) = o`]   [Any type]                      [`s` is mutable and
                                                        `e = o`, where `e`
                                                        is the first element
                                                        in the sequence, is
                                                        a valid expression.]    [Constant]]
]

[heading Result Type Expressions]

[table
    [[Expression]                           [Compile Time Complexity]]
    [[`__result_of_begin__<S>::type`]          [Amortized constant time]]
    [[`__result_of_end__<S>::type`]            [Amortized constant time]]
    [[`__result_of_at__<S, N>::type`]          [Amortized constant time]]
    [[`__result_of_value_at__<S, N>::type`]    [Amortized constant time]]
]

[blurb __note__ `__result_of_at__<S, N>` returns the actual type returned by
`__at__<N>(s)`. In most cases, this is a reference. Hence, there is no way to
know the exact element type using `__result_of_at__<S, N>`.The element at `N`
may actually be a reference to begin with. For this purpose, you can use
`__result_of_value_at__<S, N>`.]

[heading Expression Semantics]

The semantics of an expression are defined only where they differ from, or
are not defined in __bidirectional_sequence__.

[table
    [[Expression]       [Semantics]]
    [[`__at__<N>(s)`]       [The Nth element from the beginning of the sequence; see __at__.]]
]

[heading Models]

* __std_pair__
* __boost_array__
* __vector__
* __reverse_view__
* __iterator_range__ (where adapted sequence is a Random Access Sequence)
* __transform_view__ (where adapted sequence is a Random Access Sequence)
* __zip_view__       (where adapted sequences are models Random Access Sequence)

[endsect]

[section Associative Sequence]

[heading Description]

An Associative Sequence allows efficient retrieval of elements based on keys.
Like associative sequences in __mpl__, and unlike associative containers in
__stl__, Fusion associative sequences have no implied ordering relation.
Instead, type identity is used to impose an equivalence relation on keys, and
the order in which sequence elements are traversed during iteration is left
unspecified. In addition, unlike __stl__, Associative Sequences have mutable
iterators. This is due to the fact that there is no associated ordering relation
and the runtime value of the keys themselves do not have any effect on the
associativity of the sequence.


[variablelist Notation
    [[`s`]       [An Associative Sequence]]
    [[`S`]       [An Associative Sequence type]]
    [[`K`]       [An arbitrary /key/ type]]
    [[`o`]       [An arbitrary object]]
    [[`e`]       [A Sequence element]]
]

[heading Valid Expressions]

For any Associative Sequence the following expressions must be valid:

[table
    [[Expression]           [Return type]               [Type Requirements]     [Runtime Complexity]]
    [[`__has_key__<K>(s)`]      [__mpl_boolean_constant__.
                            Convertible to bool.]       []                      [Constant]]
    [[`__at_key__<K>(s)`]       [Any type]                  []                      [Constant]]
    [[`__at_key__<K>(s) = o`]   [Any type]                  [`s` is mutable and
                                                        `e = o`, where `e`
                                                        is the first element
                                                        in the sequence, is
                                                        a valid expression.]    [Constant]]
]

[heading Result Type Expressions]

[table
    [[Expression]                               [Compile Time Complexity]]
    [[`__result_of_has_key__<S, K>::type`]         [Amortized constant time]]
    [[`__result_of_at_key__<S, K>::type`]          [Amortized constant time]]
    [[`__result_of_value_at_key__<S, K>::type`]    [Amortized constant time]]
]

[blurb __note__ `__result_of_at_key__<S, K>` returns the actual type returned
by `__at_key__<K>(s)`. In most cases, this is a reference. Hence, there is no
way to know the exact element type using `__result_of_at_key__<S, K>`.The
element at `K` may actually be a reference to begin with. For this purpose,
you can use `__result_of_value_at_key__<S, N>`.]

[heading Expression Semantics]

[table
    [[Expression]       [Semantics]]
    [[`__has_key__<K>(s)`]  [A boolean Integral Constant `c` such that
                        `c::value == true` if and only if there is
                        one or more elements with the key `k` in `s`;
                        see __has_key__.]]
    [[`__at_key__<K>(s)`]   [The element associated with the key
                        `K` in the sequence `s`; see __at__.]]
]

[heading Models]

* __set__
* __map__

[endsect]

[endsect]

[section Containers]

Fusion provides a few predefined sequences out of the box. These
/containers/ actually hold heterogenously typed data; unlike
__views__. These containers are more or less counterparts of those in __stl__.

[heading Header]

    #include <boost/fusion/sequence/container.hpp>

[section vector]

[heading Description]

`vector` is a __random_access_sequence__ of heterogenous typed
data structured as a simple `struct` where each element is held
as a member variable. `vector` is the simplest of the Fusion
sequence container, and in many cases the most efficient.

[heading Header]

    #include <boost/fusion/sequence/container/vector.hpp>
    #include <boost/fusion/sequence/container/vector/vector_fwd.hpp>

    // numbered forms
    #include <boost/fusion/sequence/container/vector/vector10.hpp>
    #include <boost/fusion/sequence/container/vector/vector20.hpp>
    #include <boost/fusion/sequence/container/vector/vector30.hpp>
    #include <boost/fusion/sequence/container/vector/vector40.hpp>
    #include <boost/fusion/sequence/container/vector/vector50.hpp>

[heading Synopsis]

[*Numbered forms]

    template <>
    struct vector0;

    template <typename T0>
    struct vector1;

    template <typename T0, typename T1>
    struct vector2;

    template <typename T0, typename T1, typename T2>
    struct vector3;

    ...

    template <typename T0, typename T1, typename T2..., typename TN>
    struct vectorN;

[*Variadic form]

    template <
        typename T0 = __unspecified__
      , typename T1 = __unspecified__
      , typename T2 = __unspecified__
        ...
      , typename TN = __unspecified__
    >
    struct vector;

The numbered form accepts the exact number of elements. Example:

    vector3<int, char, double>

The variadic form accepts `0` to `FUSION_MAX_VECTOR_SIZE` elements, where
`FUSION_MAX_VECTOR_SIZE` is a user definable predefined maximum that
defaults to `10`. Example:

    vector<int, char, double>

You may define the preprocessor constant `FUSION_MAX_VECTOR_SIZE` before
including any Fusion header to change the default. Example:

    #define FUSION_MAX_VECTOR_SIZE 20

[heading Template parameters]

[table
    [[Parameter]            [Description]               [Default]]
    [[`T0`...`TN`]          [Element types]             [['unspecified]]]
]

[heading Model of]

* __random_access_sequence__

[variablelist Notation
    [[`v`]              [Instance of `vector`]]
    [[`V`]              [A `vector` type]]
    [[`e0`...`en`]      [Heterogeneous values]]
    [[`s`]              [A __forward_sequence__]]
]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __random_access_sequence__.

[table
    [[Expression]           [Semantics]]
    [[`V()`]                [Creates a vector with default constructed elements.]]
    [[`V(e0, e1,... en)`]   [Creates a vector with elements `e0`...`en`.]]
    [[`V(s)`]               [Copy constructs a vector from a __forward_sequence__, `s`.]]
    [[`v = s`]              [Assigns to a vector, `v`, from a __forward_sequence__, `s`.]]
]

[heading Example]

    vector<int, float> v(12, 5.5f);
    std::cout << __at_c__<0>(v) << std::endl;
    std::cout << __at_c__<1>(v) << std::endl;

[endsect]

[section cons]

[heading Description]

`cons` is a simple __forward_sequence__. It is a lisp style recursive list
structure where `car` is the /head/ and `cdr` is the /tail/: usually
another cons structure or `nil`: the empty list. Fusion's __list__ is built
on top of this more primitive data structure. It is more efficient than
__vector__ when the target sequence is constructed piecemeal (a data at a
time). The runtime cost of access to each element is peculiarly constant
(see __recursive_inline__).

[heading Header]

    #include <boost/fusion/sequence/container/list/cons.hpp>

[heading Synopsis]

    template <typename Car, typename Cdr = nil>
    struct cons;

[heading Template parameters]

[table
    [[Parameter]            [Description]               [Default]]
    [[`Car`]                [Head type]                 []]
    [[`Cdr`]                [Tail type]                 [`nil`]]
]

[heading Model of]

* __forward_sequence__

[variablelist Notation
    [[`nil`]            [An empty `cons`]]
    [[`C`]              [A `cons` type]]
    [[`l`, `l2`]        [Instances of `cons`]]
    [[`car`]            [An arbitrary data]]
    [[`cdr`]            [Another `cons` list]]
    [[`s`]              [A __forward_sequence__]]
    [[`N`]              [An __mpl_integral_constant__]]
]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __forward_sequence__.

[table
    [[Expression]           [Semantics]]
    [[`nil()`]              [Creates an empty list.]]
    [[`C()`]                [Creates a cons with default constructed elements.]]
    [[`C(car)`]             [Creates a cons with `car` head and default constructed tail.]]
    [[`C(car, cdr)`]        [Creates a cons with `car` head and `cdr` tail.]]
    [[`C(s)`]               [Copy constructs a cons from a __forward_sequence__, `s`.]]
    [[`l = s`]              [Assigns to a cons, `l`, from a __forward_sequence__, `s`.]]
    [[`__at__<N>(l)`]           [The Nth element from the beginning of the sequence; see __at__.]]
]

[blurb __note__ `__at__<N>(l)` is provided for convenience and compatibility
with the original __tuple__ library, despite `cons` being a
__forward_sequence__ only (`at` is supposed to be a
__random_access_sequence__ requirement). The runtime complexity of __at__ is
constant (see __recursive_inline__).]

[heading Example]

    cons<int, cons<float> > l(12, cons<float>(5.5f));
    std::cout << __at_c__<0>(l) << std::endl;
    std::cout << __at_c__<1>(l) << std::endl;

[endsect]

[section list]

[heading Description]

`list` is a __forward_sequence__ of heterogenous typed data built on top of
__cons__. It is more efficient than __vector__ when the target sequence is
constructed piecemeal (a data at a time). The runtime cost of access to
each element is peculiarly constant (see __recursive_inline__).

[heading Header]

    #include <boost/fusion/sequence/container/list.hpp>
    #include <boost/fusion/sequence/container/list/list_forward.hpp>

[heading Synopsis]

    template <
        typename T0 = __unspecified__
      , typename T1 = __unspecified__
      , typename T2 = __unspecified__
        ...
      , typename TN = __unspecified__
    >
    struct list;

The variadic class interface accepts `0` to `FUSION_MAX_LIST_SIZE`
elements, where `FUSION_MAX_LIST_SIZE` is a user definable predefined
maximum that defaults to `10`. Example:

    list<int, char, double>

You may define the preprocessor constant `FUSION_MAX_LIST_SIZE` before
including any Fusion header to change the default. Example:

    #define FUSION_MAX_LIST_SIZE 20

[heading Template parameters]

[table
    [[Parameter]            [Description]               [Default]]
    [[`T0`...`TN`]          [Element types]             [['unspecified-type]]]
]

[heading Model of]

* __forward_sequence__

[variablelist Notation
    [[`L`]              [A `list` type]]
    [[`l`]              [An instance of `list`]]
    [[`e0`...`en`]      [Heterogeneous values]]
    [[`s`]              [A __forward_sequence__]]
    [[`N`]              [An __mpl_integral_constant__]]
]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __forward_sequence__.

[table
    [[Expression]           [Semantics]]
    [[`L()`]                [Creates a list with default constructed elements.]]
    [[`L(e0, e1,... en)`]   [Creates a list with elements `e0`...`en`.]]
    [[`L(s)`]               [Copy constructs a list from a __forward_sequence__, `s`.]]
    [[`l = s`]              [Assigns to a list, `l`, from a __forward_sequence__, `s`.]]
    [[`__at__<N>(l)`]           [The Nth element from the beginning of the sequence; see __at__.]]
]

[blurb __note__ `__at__<n>(l)` is provided for convenience and compatibility
with the original __tuple__ library, despite `list` being a
__forward_sequence__ only (__at__ is supposed to be a
__random_access_sequence__ requirement). The runtime complexity of __at__ is
constant (see __recursive_inline__).]

[heading Example]

    list<int, float> l(12, 5.5f);
    std::cout << __at_c__<0>(l) << std::endl;
    std::cout << __at_c__<1>(l) << std::endl;

[endsect]

[section set]

[heading Description]

set is an __associative_sequence__ of heteregenous typed data elements.
Type identity is used to impose an equivalence relation on keys. The
element's type is its key. A set may contain at most one element for each
key. Membership testing and element key lookup has constant runtime
complexity (see __overloaded_functions__).

[heading Header]

    #include <boost/fusion/sequence/container/set.hpp>

[heading Synopsis]

    template <
        typename T0 = __unspecified__
      , typename T1 = __unspecified__
      , typename T2 = __unspecified__
        ...
      , typename TN = __unspecified__
    >
    struct set;

The variadic class interface accepts `0` to `FUSION_MAX_SET_SIZE` elements,
where `FUSION_MAX_SET_SIZE` is a user definable predefined maximum that
defaults to `10`. Example:

    set<int, char, double>

You may define the preprocessor constant `FUSION_MAX_SET_SIZE` before
including any Fusion header to change the default. Example:

    #define FUSION_MAX_SET_SIZE 20

[heading Template parameters]

[table
    [[Parameter]            [Description]               [Default]]
    [[`T0`...`TN`]          [Element types]             [['unspecified-type]]]
]

[heading Model of]

* __associative_sequence__
* __forward_sequence__

[variablelist Notation
    [[`S`]              [A `set` type]]
    [[`s`]              [An instance of `set`]]
    [[`e0`...`en`]      [Heterogeneous values]]
    [[`fs`]             [A __forward_sequence__]]
]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __random_access_sequence__ and __associative_sequence__.

[table
    [[Expression]           [Semantics]]
    [[`S()`]                [Creates a set with default constructed elements.]]
    [[`S(e0, e1,... en)`]   [Creates a set with elements `e0`...`en`.]]
    [[`S(fs)`]              [Copy constructs a set from a __forward_sequence__ `fs`.]]
    [[`s = fs`]             [Assigns to a set, `s`, from a __forward_sequence__ `fs`.]]
]

[heading Example]

    typedef set<int, float> S;
    S s(12, 5.5f);
    std::cout << __at_key__<int>(s) << std::endl;
    std::cout << __at_key__<float>(s) << std::endl;
    std::cout << __result_of_has_key__<S, double>::value << std::endl;

[endsect]

[section map]

[heading Description]

map is an __associative_sequence__ of heteregenous typed data elements.
Each element is a key/data pair (see __fusion_pair__) where the key has no
data (type only). Type identity is used to impose an equivalence relation
on keys. A map may contain at most one element for each key. Membership
testing and element key lookup has constant runtime complexity (see
__overloaded_functions__).

[heading Header]

    #include <boost/fusion/sequence/container/map.hpp>

[heading Synopsis]

    template <
        typename T0 = __unspecified__
      , typename T1 = __unspecified__
      , typename T2 = __unspecified__
        ...
      , typename TN = __unspecified__
    >
    struct map;

The variadic class interface accepts `0` to `FUSION_MAX_MAP_SIZE` elements,
where `FUSION_MAX_MAP_SIZE` is a user definable predefined maximum that
defaults to `10`. Example:

    map<__pair__<int, char>, __pair__<char, char>, __pair__<double, char> >

You may define the preprocessor constant `FUSION_MAX_MAP_SIZE` before
including any Fusion header to change the default. Example:

    #define FUSION_MAX_MAP_SIZE 20

[heading Template parameters]

[table
    [[Parameter]            [Description]               [Default]]
    [[`T0`...`TN`]          [Element types]             [['unspecified-type]]]
]

[heading Model of]

* __associative_sequence__
* __forward_sequence__

[variablelist Notation
    [[`M`]              [A `map` type]]
    [[`m`]              [An instance of `map`]]
    [[`e0`...`en`]      [Heterogeneous key/value pairs (see __fusion_pair__)]]
    [[`s`]              [A __forward_sequence__]]
]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __random_access_sequence__ and __associative_sequence__.

[table
    [[Expression]           [Semantics]]
    [[`M()`]                [Creates a map with default constructed elements.]]
    [[`M(e0, e1,... en)`]   [Creates a map with element pairs `e0`...`en`.]]
    [[`M(s)`]               [Copy constructs a map from a __forward_sequence__ `s`.]]
    [[`m = s`]              [Assigns to a map, `m`, from a __forward_sequence__ `s`.]]
]

[heading Example]

    typedef map<
        __pair__<int, char>
      , __pair__<double, std::string> >
    map_type;

    map_type m(
        __fusion_make_pair__<int>('X')
      , __fusion_make_pair__<double>("Men"));

    std::cout << __at_key__<int>(m) << std::endl;
    std::cout << __at_key__<double>(m) << std::endl;

[endsect]

[endsect]

[section Views]

Views are sequences that do not actually contain data, but instead impart
an alternative presentation over the data from one or more underlying
sequences. Views are proxies. They provide an efficient yet purely
functional way to work on potentially expensive sequence operations. Views
are inherently lazy. Their elements are only computed on demand only when
the elements of the underlying sequence(s) are actually accessed. Views'
lazy nature make them very cheap to copy and be passed around by value.

[heading Header]

    #include <boost/fusion/sequence/view.hpp>

[section single_view]

`single_view` is a view into a value as a single element sequence.

[heading Header]

    #include <boost/fusion/sequence/view/single_view.hpp>

[heading Synopsis]

    template <typename T>
    struct single_view;

[heading Template parameters]

[table
    [[Parameter]            [Description]               [Default]]
    [[`T`]                  [Any type]                  []]
]

[heading Model of]

* __forward_sequence__

[variablelist Notation
    [[`S`]              [A `single_view` type]]
    [[`s`, `s2`]        [Instances of `single_view`]]
    [[`x`]              [An instance of `T`]]
]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __forward_sequence__.

[table
    [[Expression]           [Semantics]]
    [[`S(x)`]               [Creates a `single_view` from `x`.]]
    [[`S(s)`]               [Copy constructs a `single_view` from another `single_view`, `s`.]]
    [[`s = s2`]             [Assigns to a `single_view`, `s`, from another `single_view`, `s2`.]]
]

[heading Example]

    single_view<int> view(3);
    std::cout << view << std::endl;

[endsect]

[section filter_view]

[heading Description]

`filter_view` is a view into a subset of its underlying sequence's elements
satisfying a given predicate (an __mpl__ metafunction). The `filter_view`
presents only those elements for which its predicate evaluates to
`mpl::true_`.

[heading Header]

    #include <boost/fusion/sequence/view/filter_view.hpp>

[heading Synopsis]

    template <typename Sequence, typename Pred>
    struct filter_view;

[heading Template parameters]

[table
    [[Parameter]            [Description]               [Default]]
    [[`Sequence`]           [A __forward_sequence__]    []]
    [[`Pred`]               [Unary Metafunction
                             returning an `mpl::bool_`] []]
]

[heading Model of]

* __forward_sequence__

[variablelist Notation
    [[`F`]              [A `filter_view` type]]
    [[`f`, `f2`]        [Instances of `filter_view`]]
    [[`s`]              [A __forward_sequence__]]
]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __forward_sequence__.

[table
    [[Expression]           [Semantics]]
    [[`F(s)`]               [Creates a `filter_view` given a sequence, `s`.]]
    [[`F(f)`]               [Copy constructs a `filter_view` from another `filter_view`, `f`.]]
    [[`f = f2`]             [Assigns to a `filter_view`, `f`, from another `filter_view`, `f2`.]]
]

[heading Example]

    using boost::mpl::_;
    using boost::mpl::not_;
    using boost::is_class;

    typedef __vector__<std::string, char, long, bool, double> vector_type;

    vector_type v("a-string", '@', 987654, true, 6.6);
    filter_view<vector_type const, not_<is_class<_> > > view(v);
    std::cout << view << std::endl;

[endsect]

[section iterator_range]

[heading Description]

`iterator_range` presents a sub-range of its underlying sequence delimited
by a pair of iterators.

[heading Header]

    #include <boost/fusion/sequence/view/iterator_range.hpp>

[heading Synopsis]

    template <typename First, typename Last>
    struct iterator_range;

[heading Template parameters]

[table
    [[Parameter]            [Description]               [Default]]
    [[`First`]              [A fusion __iterator__]     []]
    [[`Last`]               [A fusion __iterator__]     []]
]

[heading Model of]

* __forward_sequence__, __bidirectional_sequence__ or
__random_access_sequence__ depending on the traversal characteristics (see
__traversal_concept__) of its underlying sequence.

[variablelist Notation
    [[`IR`]             [An `iterator_range` type]]
    [[`f`]              [An instance of `First`]]
    [[`l`]              [An instance of `Last`]]
    [[`ir`, `ir2`]      [Instances of `iterator_range`]]
]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __forward_sequence__.

[table
    [[Expression]           [Semantics]]
    [[`IR(f, l)`]           [Creates an `iterator_range` given iterators, `f` and `l`.]]
    [[`IR(ir)`]             [Copy constructs an `iterator_range` from another `iterator_range`, `ir`.]]
    [[`ir = ir2`]           [Assigns to a `iterator_range`, `ir`, from another `iterator_range`, `ir2`.]]
]

[heading Example]

    char const* s = "Ruby";
    typedef __vector__<int, char, double, char const*> vector_type;
    vector_type vec(1, 'x', 3.3, s);

    typedef __result_of_begin__<vector_type>::type A;
    typedef __result_of_end__<vector_type>::type B;
    typedef __result_of_next__<A>::type C;
    typedef __result_of_prior__<B>::type D;

    C c(vec);
    D d(vec);

    iterator_range<C, D> range(c, d);
    std::cout << range << std::endl;

[endsect]

[section joint_view]

[heading Description]

`joint_view` presents a view which is a concatenation of two sequences.

[heading Header]

    #include <boost/fusion/sequence/view/joint_view.hpp>

[heading Synopsis]

    template <typename Sequence1, typename Sequence2>
    struct joint_view;

[heading Template parameters]

[table
    [[Parameter]            [Description]                   [Default]]
    [[`Sequence1`]          [A __forward_sequence__]        []]
    [[`Sequence2`]          [A __forward_sequence__]        []]
]

[heading Model of]

* __forward_sequence__

[variablelist Notation
    [[`JV`]             [A `joint_view` type]]
    [[`s1`]             [An instance of `Sequence1`]]
    [[`s2`]             [An instance of `Sequence2`]]
    [[`jv`, `jv2`]      [Instances of `joint_view`]]
]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __forward_sequence__.

[table
    [[Expression]           [Semantics]]
    [[`JV(s1, s2)`]         [Creates a `joint_view` given sequences, `s1` and `s2`.]]
    [[`JV(jv)`]             [Copy constructs a `joint_view` from another `joint_view`, `jv`.]]
    [[`jv = jv2`]           [Assigns to a `joint_view`, `jv`, from another `joint_view`, `jv2`.]]
]

[heading Example]

    __vector__<int, char> v1(3, 'x');
    __vector__<std::string, int> v2("hello", 123);
    joint_view<
        __vector__<int, char>
      , __vector__<std::string, int>
    > view(v1, v2);
    std::cout << view << std::endl;

[endsect]

[section zip_view]

[heading Description]

`zip_view` presents a view which iterates over a collection of __sequence__s in parallel. A `zip_view`
is constructed from a __sequence__ of references to the component __sequence__s.

[heading Header]

    #include <boost/fusion/sequence/view/zip_view.hpp>

[heading Synopsis]

    template <typename Sequences>
    struct zip_view;

[heading Template parameters]

[table
    [[Parameter]            [Description]                   [Default]]
    [[`Sequences`]          [A __forward_sequence__ of references to other Fusion __sequence__s]        []]
]

[heading Model of]

* __forward_sequence__, __bidirectional_sequence__ or
__random_access_sequence__ depending on the traversal characteristics (see
__traversal_concept__) of its underlying sequence.

[variablelist Notation
    [[`ZV`]             [A `joint_view` type]]
    [[`s`]             [An instance of `Sequences`]]
    [[`zv1`, `zv2`]             [Instances of `ZV`]]
]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __forward_sequence__.

[table
    [[Expression]           [Semantics]]
    [[`ZV(s)`]              [Creates a `zip_view` given a sequence of references to the component __sequence__s.]]
    [[`ZV(zv1)`]             [Copy constructs a `zip_view` from another `zip_view`, `zv`.]]
    [[`zv1 = zv2`]           [Assigns to a `zip_view`, `zv`, from another `zip_view`, `zv2`.]]
]

[heading Example]
    typedef __vector__<int,int> vec1;
    typedef __vector__<char,char> vec2;
    vec1 v1(1,2);
    vec2 v2('a','b');
    typedef __vector__<vec1&, vec2&> sequences;
    std::cout << zip_view<sequences>(sequences(v1, v2)) << std::endl; // ((1 a) (2 b))

[endsect]

[section transform_view]

`transform_view` presents a transformed view of its underlying sequence
given a unary __poly_func_obj__. The `transform_view` inherits the
traversal characteristics (see __traversal_concept__) of its underlying
sequence.

[heading Header]

    #include <boost/fusion/sequence/view/transform_view.hpp>

[heading Synopsis]

[*Unary Version]

    template <typename Sequence, typename F>
    struct transform_view;

[*Binary Version]

    template <typename Sequence1, typename Sequence2, typename F>
    struct transform_view;

[heading Template parameters]

[table
    [[Parameter]            [Description]                           [Default]]
    [[`Sequence`]           [A __forward_sequence__]                []]
    [[`Sequence1`]          [A __forward_sequence__]                []]
    [[`Sequence2`]          [A __forward_sequence__]                []]
    [[`F`]                  [A __poly_func_obj__]                   []]
]

[heading Model of]

* __forward_sequence__, __bidirectional_sequence__ or
__random_access_sequence__ depending on the traversal characteristics (see
__traversal_concept__) of its underlying sequence.

[variablelist Notation
    [[`TV`]             [A `transform_view` type]]
    [[`BTV`]            [A binary `transform_view` type]]
    [[`UTV`]            [A unary `transform_view` type]]
    [[`f`]              [An instance of `F`]]
    [[`s`]              [An instance of `Sequence`]]
    [[`s1`]             [An instance of `Sequence1`]]
    [[`s2`]             [An instance of `Sequence2`]]
    [[`tv`, `tv2`]      [Instances of `transform_view`]]
]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __forward_sequence__, __bidirectional_sequence__ or
__random_access_sequence__ depending on the traversal characteristics (see
__traversal_concept__) of its underlying sequence.

[table
    [[Expression]           [Semantics]]
    [[`UTV(s, f)`]          [Creates a unary `transform_view` given sequence,
                             `s` and unary __poly_func_obj__, `f`.]]
    [[`BTV(s1, s2, f)`]     [Creates a binary `transform_view` given sequences, `s1` and `s2`
                             and unary __poly_func_obj__, `f`.]]
    [[`TV(tv)`]             [Copy constructs a `transform_view` from another `transform_view`, `tv`.]]
    [[`tv = tv2`]           [Assigns to a `transform_view`, `tv`, from another `transform_view`, `tv2`.]]
]

[heading Example]

    struct square
    {
        template <typename T>
        struct result
        {
            typedef T type;
        };

        template <typename T>
        T operator()(T x) const
        {
            return x * x;
        }
    };

    typedef __vector__<int, short, double> vector_type;
    vector_type vec(2, 5, 3.3);

    transform_view<vector_type, square> transform(vec, square());
    std::cout << transform << std::endl;

[endsect]

[section reverse_view]

`reverse_view` presents a reversed view of underlying sequence. The first
element will be its last and the last element will be its first.

[heading Header]

    #include <boost/fusion/sequence/view/reverse_view.hpp>

[heading Synopsis]

    template <typename Sequence>
    struct reverse_view;

[heading Template parameters]

[table
    [[Parameter]            [Description]                           [Default]]
    [[`Sequence`]           [A __bidirectional_sequence__]          []]
]

[heading Model of]

* __bidirectional_sequence__

[variablelist Notation
    [[`RV`]             [A `reverse_view` type]]
    [[`s`]              [An instance of `Sequence`]]
    [[`rv`, `rv2`]      [Instances of `reverse_view`]]
]

[heading Expression Semantics]

Semantics of an expression is defined only where it differs from, or is not
defined in __bidirectional_sequence__.

[table
    [[Expression]           [Semantics]]
    [[`RV(s)`]              [Creates a unary `reverse_view` given sequence, `s`.]]
    [[`RV(rv)`]             [Copy constructs a `reverse_view` from another `reverse_view`, `rv`.]]
    [[`rv = rv2`]           [Assigns to a `reverse_view`, `rv`, from another `reverse_view`, `rv2`.]]
]

[heading Example]

    typedef __vector__<int, short, double> vector_type;
    vector_type vec(2, 5, 3.3);

    reverse_view<vector_type> reverse(vec);
    std::cout << reverse << std::endl;

[endsect]

[endsect]

[section Adapted]

Fusion provides a couple of adapters for other sequences such as
`std::pair`, __mpl__ sequences, and `boost::array`. These adapters are
written using Fusion's non-intrusive __extension__ mechanism. If you wish
to use these sequences with fusion, simply include the necessary files and
they will be regarded as first-class, fully conforming fusion sequences
[footnote Fusion sequences may also be adapted as fully conforming __mpl__
sequences (see __intrinsics__). That way, we can have 2-way adaptation to
and from __mpl__ and Fusion].

[heading Header]

    #include <boost/fusion/sequence/adapted.hpp>

[section std::pair]

This module provides adapters for `std::pair`. Including the module header
makes `std::pair` a fully conforming __random_access_sequence__.

[heading Header]

    #include <boost/fusion/sequence/adapted/std_pair.hpp>

[heading Model of]

* __random_access_sequence__

[heading Example]

    std::pair<int, std::string> p(123, "Hola!!!");
    std::cout << __at_c__<0>(p) << std::endl;
    std::cout << __at_c__<1>(p) << std::endl;
    std::cout << p << std::endl;

[heading See also]

__std_pair_doc__, __tr1_tuple_pair__

[endsect]

[section mpl sequence]

This module provides adapters for __mpl__ sequences. Including the module
header makes all __mpl__ sequences fully conforming fusion sequences.

[heading Header]

    #include <boost/fusion/sequence/adapted/mpl.hpp>

[heading Model of]

* __forward_sequence__ (If the __mpl__ sequence is a forward sequence.)
* __bidirectional_sequence__ (If the __mpl__ sequence is a bidirectional sequence.)
* __random_access_sequence__ (If the __mpl__ sequence is a random access sequence.)

[heading Example]

    mpl::vector_c<int, 123, 456> vec_c;
    fusion::vector2<int, long> v(vec_c);
    std::cout << __at_c__<0>(v) << std::endl;
    std::cout << __at_c__<1>(v) << std::endl;

    v = mpl::vector_c<int, 456, 789>();
    std::cout << __at_c__<0>(v) << std::endl;
    std::cout << __at_c__<1>(v) << std::endl;

[heading See also]

__mpl__

[endsect]

[section boost::array]

This module provides adapters for `boost::array`. Including the module
header makes `boost::array` a fully conforming __random_access_sequence__.

[heading Header]

    #include <boost/fusion/sequence/adapted/array.hpp>

[heading Model of]

* __random_access_sequence__

[heading Example]

    boost::array<int,3> arr = {{1,2,3}};

    std::cout << *__begin__(arr) << std::endl;
    std::cout << *__next__(__begin__(arr)) << std::endl;
    std::cout << *__advance_c__<2>(__begin__(arr)) << std::endl;
    std::cout << *__prior__(__end__(arr)) << std::endl;
    std::cout << __at_c__<2>(arr) << std::endl;

[heading See also]

__boost_array_library__

[endsect]

[section boost::tuple]
This module provides adapters for `boost::tuple`. Including the module
header makes `boost::tuple` a fully conforming __forward_sequence__.

[heading Header]

    #include <boost/fusion/sequence/adapted/boost_tuple.hpp>

[heading Model of]

* __forward_sequence__

[heading Example]

    boost::tuple<int,std::string> example_tuple(101, "hello");
    std::cout << *boost::fusion::begin(example_tuple) << '\n';
    std::cout << *boost::fusion::next(boost::fusion::begin(example_tuple)) << '\n';

[heading See also]

__boost_tuple_library__

[endsect]

[section boost::variant]
This module provides adapters for `boost::variant`. Including the module
header makes `boost::variant` a fully conforming __forward_sequence__.
The variant acts as a sequence of the types that can be contained in the variant.
Accessing types not currently stored int the variant will lead to the variant
being populated with a default constructed value of that type.

[heading Header]

    #include <boost/fusion/sequence/adapted/variant.hpp>

[heading Model of]

* __forward_sequence__

[heading Example]

    boost::variant<int,std::string> example_variant = 101;
    std::cout << example_variant << '\n';
    *boost::fusion::find<std::string>(example_variant) = "hello";
    std::cout << example_variant << '\n';

[heading See also]

__boost_variant_library__

[endsect]

[endsect]

[section Intrinsics]

Intrinsics form the essential interface of every Fusion __sequence__. __stl__
counterparts of these functions are usually implemented as member
functions. Intrinsic functions, unlike __algorithms__, are not generic
across the full __sequence__ repertoire. They need to be implemented for
each Fusion __sequence__[footnote In practice, many of intrinsic functions
have default implementations that will work in majority of cases].

[heading Header]

    #include <boost/fusion/sequence/intrinsic.hpp>

[section Functions]

[section begin]

[heading Description]

Returns an iterator pointing to the first element in the sequence.

[heading Synopsis]

    template <typename Sequence>
    typename __result_of_begin__<Sequence>::type
    begin(Sequence& seq);

    template <typename Sequence>
    typename __result_of_begin__<Sequence const>::type
    begin(Sequence const& seq);

[heading Parameters]

[table
    [[Parameter]    [Requirement]                   [Description]]
    [[`seq`]        [Model of __forward_sequence__] [The sequence we wish to get an iterator from.]]
]

[heading Expression Semantics]

    begin(seq);

[*Return type]: __forward_iterator__ if `seq` is a __forward_sequence__
else, __bidirectional_iterator__ if `seq` is a __bidirectional_sequence__
else, __random_access_iterator__ if `seq` is a __random_access_sequence__.

[*Semantics]: Returns an iterator pointing to the first element in the sequence.

[heading Header]

    #include <boost/fusion/sequence/intrinsic/begin.hpp>

[heading Example]

    __vector__<int, int, int> v(1, 2, 3);
    assert(__deref__(begin(v)) == 1);

[endsect]

[section end]

[heading Description]

Returns an iterator pointing to one element past the end of the sequence.

[heading Synopsis]

    template <typename Sequence>
    typename __result_of_end__<Sequence>::type
    end(Sequence& seq);

    template <typename Sequence>
    typename __result_of_end__<Sequence const>::type
    end(Sequence const& seq);

[heading Parameters]

[table
    [[Parameter]    [Requirement]                   [Description]]
    [[`seq`]        [Model of __forward_sequence__] [The sequence we wish to get an iterator from.]]
]

[heading Expression Semantics]

    end(seq);

[*Return type]: __forward_iterator__ if `seq` is a __forward_sequence__
else, __bidirectional_iterator__ if `seq` is a __bidirectional_sequence__
else, __random_access_iterator__ if `seq` is a __random_access_sequence__.

[*Semantics]: Returns an iterator pointing to one element past the end of
the sequence.

[heading Header]

    #include <boost/fusion/sequence/intrinsic/end.hpp>

[heading Example]

    __vector__<int, int, int> v(1, 2, 3);
    assert(__deref__(__prior__(end(v))) == 3);

[endsect]

[section empty]

[heading Description]

Returns a type convertible to `bool` that evaluates to `true` if the
sequence is empty, else, evaluates to `false`.

[heading Synopsis]

    template <typename Sequence>
    typename __result_of_empty__<Sequence>::type
    empty(Sequence const& seq);

[heading Parameters]

[table
    [[Parameter]    [Requirement]                   [Description]]
    [[`seq`]        [Model of __forward_sequence__] [The sequence we wish to investigate.]]
]

[heading Expression Semantics]

    empty(seq);

[*Return type]: Convertible to `bool`.

[*Semantics]: Evaluates to `true` if the sequence is empty, else, evaluates
to `false`.

[heading Header]

    #include <boost/fusion/sequence/intrinsic/empty.hpp>

[heading Example]

    __vector__<int, int, int> v(1, 2, 3);
    assert(empty(v) == false);

[endsect]

[section front]

[heading Description]

Returns the first element in the sequence.

[heading Synopsis]

    template <typename Sequence>
    typename __result_of_front__<Sequence>::type
    front(Sequence& seq);

    template <typename Sequence>
    typename __result_of_front__<Sequence const>::type
    front(Sequence const& seq);

[heading Parameters]

[table
    [[Parameter]    [Requirement]                   [Description]]
    [[`seq`]        [Model of __forward_sequence__] [The sequence we wish to investigate.]]
]

[heading Expression Semantics]

    front(seq);

[*Return type]: Returns a reference to the first element in the sequence
`seq` if `seq` is mutable and `e = o`, where `e` is the first element in
the sequence, is a valid expression. Else, returns a type convertable to
the first element in the sequence.

[*Precondition]: `__empty__(seq) == false`

[*Semantics]: Returns the first element in the sequence.

[heading Header]

    #include <boost/fusion/sequence/intrinsic/front.hpp>

[heading Example]

    __vector__<int, int, int> v(1, 2, 3);
    assert(front(v) == 1);

[endsect]

[section back]

[heading Description]

Returns the last element in the sequence.

[heading Synopsis]

    template <typename Sequence>
    typename __result_of_back__<Sequence>::type
    back(Sequence& seq);

    template <typename Sequence>
    typename __result_of_back__<Sequence const>::type
    back(Sequence const& seq);

[heading Parameters]

[table
    [[Parameter]    [Requirement]                           [Description]]
    [[`seq`]        [Model of __bidirectional_sequence__]   [The sequence we wish to investigate.]]
]

[heading Expression Semantics]

    back(seq);

[*Return type]: Returns a reference to the last element in the sequence
`seq` if `seq` is mutable and `e = o`, where `e` is the last element in the
sequence, is a valid expression. Else, returns a type convertable to the
last element in the sequence.

[*Precondition]: `__empty__(seq) == false`

[*Semantics]: Returns the last element in the sequence.

[heading Header]

    #include <boost/fusion/sequence/intrinsic/back.hpp>

[heading Example]

    __vector__<int, int, int> v(1, 2, 3);
    assert(back(v) == 3);

[endsect]

[section size]

[heading Description]

Returns a type convertible to `int` that evaluates the number of elements
in the sequence.

[heading Synopsis]

    template <typename Sequence>
    typename __result_of_size__<Sequence>::type
    size(Sequence const& seq);

[heading Parameters]

[table
    [[Parameter]    [Requirement]                   [Description]]
    [[`seq`]        [Model of __forward_sequence__] [The sequence we wish to investigate.]]
]

[heading Expression Semantics]

    size(seq);

[*Return type]: Convertible to `int`.

[*Semantics]: Returns the number of elements in the sequence.

[heading Header]

    #include <boost/fusion/sequence/intrinsic/size.hpp>

[heading Example]

    __vector__<int, int, int> v(1, 2, 3);
    assert(size(v) == 3);

[endsect]

[section at]

[heading Description]

Returns the N-th element from the beginning of the sequence.

[heading Synopsis]

    template <typename N, typename Sequence>
    typename __result_of_at__<Sequence, N>::type
    at(Sequence& seq);

    template <typename N, typename Sequence>
    typename __result_of_at__<Sequence const, N>::type
    at(Sequence const& seq);

[heading Parameters]

[table
    [[Parameter]    [Requirement]                           [Description]]
    [[`seq`]        [Model of __random_access_sequence__]   [The sequence we wish to investigate.]]
    [[`N`]          [An __mpl_integral_constant__]          [An index from the beginning of the
                                                             sequence.]]
]

[heading Expression Semantics]

    at<N>(seq);

[*Return type]: Returns a reference to the N-th element from the beginning
of the sequence `seq` if `seq` is mutable and `e = o`, where `e` is the N-th
element from the beginning of the sequence, is a valid expression. Else,
returns a type convertable to the N-th element from the beginning of the
sequence.

[*Precondition]: `0 <= N::value < __size__(s)`

[*Semantics]: Equivalent to

    __deref__(__advance__<N>(__begin__(s)))

[heading Header]

    #include <boost/fusion/sequence/intrinsic/at.hpp>

[heading Example]

    __vector__<int, int, int> v(1, 2, 3);
    assert(at<mpl::int_<1> >(v) == 2);

[endsect]

[section at_c]

[heading Description]

Returns the N-th element from the beginning of the sequence.

[heading Synopsis]

    template <int N, typename Sequence>
    typename __result_of_at_c__<Sequence, N>::type
    at_c(Sequence& seq);

    template <int N, typename Sequence>
    typename __result_of_at_c__<Sequence const, N>::type
    at_c(Sequence const& seq);

[heading Parameters]

[table
    [[Parameter]    [Requirement]                           [Description]]
    [[`seq`]        [Model of __random_access_sequence__]   [The sequence we wish to investigate.]]
    [[`N`]          [An integral constant]                  [An index from the beginning of the
                                                             sequence.]]
]

[heading Expression Semantics]

    at_c<N>(seq);

[*Return type]: Returns a reference to the N-th element from the beginning
of the sequence `seq` if `seq` is mutable and `e = o`, where `e` is the N-th
element from the beginning of the sequence, is a valid expression. Else,
returns a type convertable to the N-th element from the beginning of the
sequence.

[*Precondition]: `0 <= N < __size__(s)`

[*Semantics]: Equivalent to

    __deref__(__advance__<N>(__begin__(s)))

[heading Header]

    #include <boost/fusion/sequence/intrinsic/at_c.hpp>

[heading Example]

    __vector__<int, int, int> v(1, 2, 3);
    assert(at_c<1>(v) == 2);

[endsect]

[section has_key]

[heading Description]

Returns a type convertible to `bool` that evaluates to `true` if the
sequence contains an element associated with a Key, else, evaluates to
`false`.

[heading Synopsis]

    template <typename Key, typename Sequence>
    typename __result_of_has_key__<Sequence, Key>::type
    has_key(Sequence const& seq);

[heading Parameters]

[table
    [[Parameter]    [Requirement]                       [Description]]
    [[`seq`]        [Model of __associative_sequence__] [The sequence we wish to investigate.]]
    [[`Key`]        [Any type]                          [The queried key.]]
]

[heading Expression Semantics]

    has_key<Key>(seq);

[*Return type]: Convertible to `bool`.

[*Semantics]: Evaluates to `true` if the sequence contains an element
associated with Key, else, evaluates to `false`.

[heading Header]

    #include <boost/fusion/sequence/intrinsic/has_key.hpp>

[heading Example]

    __set__<int, char, bool> s(1, 'x', true);
    assert(has_key<char>(s) == true);

[endsect]

[section at_key]

[heading Description]

Returns the element associated with a Key from the sequence.

[heading Synopsis]

    template <typename Key, typename Sequence>
    typename __result_of_at_key__<Sequence, Key>::type
    at_key(Sequence& seq);

    template <typename Key, typename Sequence>
    typename __result_of_at_key__<Sequence const, Key>::type
    at_key(Sequence const& seq);

[heading Parameters]

[table
    [[Parameter]    [Requirement]                           [Description]]
    [[`seq`]        [Model of __associative_sequence__]     [The sequence we wish to investigate.]]
    [[`Key`]        [Any type]                              [The queried key.]]
]

[heading Expression Semantics]

    at_key<Key>(seq);

[*Return type]: Returns a reference to the element associated with Key from
the sequence `seq` if `seq` is mutable and `e = o`, where `e` is the
element associated with Key, is a valid expression. Else, returns a type
convertable to the element associated with Key.

[*Precondition]: `has_key<Key>(seq) == true`

[*Semantics]: Returns the element associated with Key.

[heading Header]

    #include <boost/fusion/sequence/intrinsic/at_key.hpp>

[heading Example]

    __set__<int, char, bool> s(1, 'x', true);
    assert(at_key<char>(s) == 'x');

[endsect]

[section swap]

[heading Description]

Performs an element by element swap of the elements in 2 sequences.

[heading Synopsis]
    template<typename Seq1, typename Seq2>
    void swap(Seq1& seq1, Seq2& seq2);

[heading Parameters]

[table
    [[Parameters]    [Requirement]                           [Description]]
    [[`seq1`, `seq2`]        [Models of __forward_sequence__][The sequences whos elements we wish to swap.]]
]

[heading Expression Semantics]

    swap(seq1, seq2);

[*Return type]: `void`

[*Precondition]: `__size__(seq1) == __size__(seq2)`

[*Semantics]: Calls `swap(a1, b1)` for corresponding elements in `seq1` and `seq2`.

[heading Header]
    #include <boost/fusion/sequence/intrinsic/swap.hpp>

[heading Example]
    __vector__<int, std::string> v1(1, "hello"), v2(2, "world");
    swap(v1, v2);
    assert(v1 == __make_vector__(2, "world"));
    assert(v2 == __make_vector__(1, "hello"));

[endsect]

[endsect]

[section Metafunctions]

[section begin]

[heading Description]
Returns the result type of __begin__.

[heading Synopsis]
    template<typename Seq>
    struct begin
    {
        typedef __unspecified__ type;
    };

[table Parameters
    [[Parameter]    [Requirement]   [Description]]
    [[`Seq`][A model of __forward_sequence__][Argument sequence]]
]

[heading Expression Semantics]
    result_of::begin<Seq>::type

[*Return type]: An iterator modelling the same traversal concept as `Seq`.

[*Semantics]: Returns the type of an iterator to the first element of `Seq`.

[heading Header]
    #include <boost/fusion/sequence/intrinsic/begin.hpp>

[heading Example]
    typedef __vector__<int> vec;
    typedef __result_of_begin__<vec>::type it;
    BOOST_MPL_ASSERT((boost::is_same<__result_of_deref__<it>::type, int&>))

[endsect]

[section end]

[heading Description]
Returns the result type of __end__.

[heading Synopsis]
    template<typename Seq>
    struct end
    {
        typedef __unspecified__ type;
    };

[table Parameters
    [[Parameter]    [Requirement]   [Description]]
    [[`Seq`][A model of __forward_sequence__][Argument sequence]]
]

[heading Expression Semantics]
    result_of::end<Seq>::type

[*Return type]: A model of the same traversal concept as `Seq`.

[*Semantics]: Returns the type of an iterator one past the end of `Seq`.

[heading Header]
    #include <boost/fusion/sequence/intrinsic/end.hpp>

[heading Example]
    typedef __vector__<int> vec;
    typedef __result_of_prior__<__result_of_end__<vec>::type>::type first;
    BOOST_MPL_ASSERT((__result_of_equal_to__<first, __result_of_begin__<vec>::type>))

[endsect]

[section empty]

[heading Description]
Returns the result type of __empty__.

[heading Synopsis]
    template<typename Seq>
    struct empty
    {
        typedef __unspecified__ type;
    };

[table Parameters
    [[Parameter]    [Requirement]   [Description]]
    [[`Seq`][A model of __forward_sequence__][Argument sequence]]
]

[heading Expression Semantics]
    result_of::empty<Seq>::type

[*Return type]: An __mpl_integral_constant__

[*Semantics]: Returns `mpl::true_` if `Seq` has zero elements, `mpl::false_` otherwise.

[heading Header]
    #include <boost/fusion/sequence/intrinsic/empty.hpp>

[heading Example]
    typedef __vector__<> empty_vec;
    typedef __vector__<int,float,char> vec;

    BOOST_MPL_ASSERT((__result_of_empty__<empty_vec>));
    BOOST_MPL_ASSERT_NOT((__result_of_empty__<vec>));

[endsect]

[section front]

[heading Description]
Returns the result type of __front__.

[heading Synopsis]
    template<typename Seq>
    struct front
    {
        typedef __unspecified__ type;
    };

[table Parameters
    [[Parameter]    [Requirement]   [Description]]
    [[`Seq`][A model of __forward_sequence__][Argument sequence]]
]

[heading Expression Semantics]
    result_of::front<Seq>::type

[*Return type]: Any type

[*Semantics]: The type returned by dereferencing an iterator to the first element in `Seq`. Equivalent to `__result_of_deref__<__result_of_begin__<Seq>::type>::type`.

[heading Header]
    #include <boost/fusion/sequence/intrinsic/front.hpp>

[heading Example]
    typedef __vector__<int,char> vec;
    BOOST_MPL_ASSERT((boost::is_same<__result_of_front__<vec>::type, int&>));

[endsect]

[section back]

[heading Description]
Returns the result type of __back__.

[heading Synopsis]
    template<typename Seq>
    struct back
    {
        typedef __unspecified__ type;
    };

[table Parameters
    [[Parameter]    [Requirement]   [Description]]
    [[`Seq`][A model of __forward_sequence__][Argument sequence]]
]

[heading Expression Semantics]
    result_of::back<Seq>::type

[*Return type]:  Any type

[*Semantics]: The type returned by dereferencing an iterator to the last element in the sequence. Equivalent to `__result_of_deref__<__result_of_prior__<__result_of_end__<Seq>::type>::type>::type`.

[heading Header]
    #include <boost/fusion/sequence/intrinsic/back.hpp>

[heading Example]
    typedef __vector__<int,char> vec;
    BOOST_MPL_ASSERT((boost::is_same<__result_of_back__<vec>::type, char&>));

[endsect]

[section size]

[heading Description]
Returns the result type of __size__.

[heading Synopsis]
    template<typename Seq>
    struct size
    {
        typedef __unspecified__ type;
    };

[table Parameters
    [[Parameter]    [Requirement]   [Description]]
    [[`Seq`][A model of __forward_sequence__][Argument sequence]]
]

[heading Expression Semantics]
    result_of::size<Seq>::type

[*Return type]: An __mpl_integral_constant__.

[*Semantics]: Returns the number of elements in `Seq`.

[heading Header]
    #include <boost/fusion/sequence/intrinsic/size.hpp>

[heading Example]
    typedef __vector__<int,float,char> vec;
    typedef __result_of_size__<vec>::type size_mpl_integral_constant;
    BOOST_MPL_ASSERT_RELATION(size_mpl_integral_constant::value, ==, 3);

[endsect]

[section at]

[heading Description]

Returns the result type of __at__[footnote __result_of_at__ reflects the
actual return type of the function __at__. __sequence__s typically return
references to its elements via the __at__ function. If you want to get
the actual element type, use __result_of_value_at__].

[heading Synopsis]
    template<
        typename Seq,
        typename N>
    struct at
    {
        typedef __unspecified__ type;
    };

[table Parameters
    [[Parameter]    [Requirement]   [Description]]
    [[`Seq`][A model of __forward_sequence__][Argument sequence]]
    [[`N`][An __mpl_integral_constant__][Index of element]]
]

[heading Expression Semantics]
    result_of::at<Seq, N>::type

[*Return type]: Any type.

[*Semantics]: Returns the result type of using __at__ to access the `N`th element of `Seq`.

[heading Header]
    #include <boost/fusion/sequence/intrinsic/at.hpp>

[heading Example]
    typedef __vector__<int,float,char> vec;
    BOOST_MPL_ASSERT((boost::is_same<__result_of_at__<vec, boost::mpl::int_<1> >::type, float&>));

[endsect]

[section at_c]

[heading Description]

Returns the result type of __at_c__[footnote __result_of_at_c__ reflects
the actual return type of the function __at_c__. __sequence__s typically
return references to its elements via the __at_c__ function. If you want to
get the actual element type, use __result_of_value_at_c__].

[heading Synopsis]
    template<
        typename Seq,
        int M>
    struct at_c
    {
        typedef __unspecified__ type;
    };

[table Parameters
    [[Parameter]    [Requirement]   [Description]]
    [[`Seq`][A model of __forward_sequence__][Argument sequence]]
    [[`M`][Positive integer index][Index of element]]
]

[heading Expression Semantics]
    result_of::at_c<Seq, M>::type

[*Return type]: Any type

[*Semantics]: Returns the result type of using __at_c__ to access the `M`th element of `Seq`.

[heading Header]
    #include <boost/fusion/sequence/intrinsic/at.hpp>

[heading Example]
    typedef __vector__<int,float,char> vec;
    BOOST_MPL_ASSERT((boost::is_same<__result_of_at_c__<vec, 1>::type, float&>));

[endsect]

[section value_at]

[heading Description]

Returns the actual type at a given index from the __sequence__.

[heading Synopsis]
    template<
        typename Seq,
        typename N>
    struct value_at
    {
        typedef __unspecified__ type;
    };

[table Parameters
    [[Parameter]    [Requirement]   [Description]]
    [[`Seq`][A model of __forward_sequence__][Argument sequence]]
    [[`N`][An __mpl_integral_constant__][Index of element]]
]

[heading Expression Semantics]
    result_of::value_at<Seq, N>::type

[*Return type]: Any type.

[*Semantics]: Returns the actual type at the `N`th element of `Seq`.

[heading Header]
    #include <boost/fusion/sequence/intrinsic/value_at.hpp>

[heading Example]
    typedef __vector__<int,float,char> vec;
    BOOST_MPL_ASSERT((boost::is_same<__result_of_value_at__<vec, boost::mpl::int_<1> >::type, float>));

[endsect]

[section value_at_c]

[heading Description]

Returns the actual type at a given index from the __sequence__.

[heading Synopsis]
    template<
        typename Seq,
        int M>
    struct value_at_c
    {
        typedef __unspecified__ type;
    };

[table Parameters
    [[Parameter]    [Requirement]   [Description]]
    [[`Seq`][A model of __forward_sequence__][Argument sequence]]
    [[`M`][Positive integer index][Index of element]]
]

[heading Expression Semantics]
    result_of::value_at_c<Seq, M>::type

[*Return type]: Any type

[*Semantics]: Returns the actual type at the `M`th element of `Seq`.

[heading Header]
    #include <boost/fusion/sequence/intrinsic/value_at.hpp>

[heading Example]
    typedef __vector__<int,float,char> vec;
    BOOST_MPL_ASSERT((boost::is_same<__result_of_value_at_c__<vec, 1>::type, float>));

[endsect]

[section has_key]

[heading Description]
Returns the result type of __has_key__.

[heading Synopsis]
    template<
        typename Seq,
        typename Key>
    struct has_key
    {
        typedef __unspecified__ type;
    };

[table Parameters
    [[Parameter]    [Requirement]   [Description]]
    [[`Seq`][A model of __forward_sequence__][Argument sequence]]
    [[`Key`][Any type][Key type]]
]

[heading Expression Semantics]
    result_of::has_key<Seq, Key>::type

[*Return type]: An __mpl_integral_constant__.

[*Semantics]: Returns `mpl::true_` if `Seq` contains an element with key type `Key`, returns `mpl::false_` otherwise.

[heading Header]
    #include <boost/fusion/sequence/intrinsic/has_key.hpp>

[heading Example]
    typedef __map__<__pair__<int, char>, __pair__<char, char>, __pair__<double, char> > mymap;
    BOOST_MPL_ASSERT((__result_of_has_key__<mymap, int>));
    BOOST_MPL_ASSERT_NOT((__result_of_has_key__<mymap, void*>));

[endsect]

[section at_key]

[heading Description]

Returns the result type of __at_key__[footnote __result_of_at_key__
reflects the actual return type of the function __at_key__. __sequence__s
typically return references to its elements via the __at_key__ function. If
you want to get the actual element type, use __result_of_value_at_key__].

[heading Synopsis]
    template<
        typename Seq,
        typename Key>
    struct at_key
    {
        typedef __unspecified__ type;
    };

[table Parameters
    [[Parameter]    [Requirement]   [Description]]
    [[`Seq`][A model of __forward_sequence__][Argument sequence]]
    [[`Key`][Any type][Key type]]
]

[heading Expression Semantics]
    result_of::at_key<Seq, Key>::type

[*Return type]: Any type.

[*Semantics]: Returns the result of using __at_key__ to access the element with key type `Key` in `Seq`.

[heading Header]
    #include <boost/fusion/sequence/intrinsic/at_key.hpp>

[heading Example]
    typedef __map__<__pair__<int, char>, __pair__<char, char>, __pair__<double, char> > mymap;
    BOOST_MPL_ASSERT((boost::is_same<__result_of_at_key__<mymap, int>::type, char&>));

[endsect]

[section value_at_key]

[heading Description]
Returns the actual element type associated with a Key from the __sequence__.

[heading Synopsis]
    template<
        typename Seq,
        typename Key>
    struct value_at_key
    {
        typedef __unspecified__ type;
    };

[table Parameters
    [[Parameter]    [Requirement]   [Description]]
    [[`Seq`][A model of __forward_sequence__][Argument sequence]]
    [[`Key`][Any type][Key type]]
]

[heading Expression Semantics]
    result_of::value_at_key<Seq, Key>::type

[*Return type]: Any type.

[*Semantics]: Returns the actual element type associated with key type
`Key` in `Seq`.

[heading Header]
    #include <boost/fusion/sequence/intrinsic/value_at_key.hpp>

[heading Example]
    typedef __map__<__pair__<int, char>, __pair__<char, char>, __pair__<double, char> > mymap;
    BOOST_MPL_ASSERT((boost::is_same<__result_of_at_key__<mymap, int>::type, char>));

[endsect]

[section swap]

[heading Description]
Returns the return type of swap.

[heading Synopsis]
    template<typename Seq1, typename Seq2>
    struct swap
    {
        typedef void type;
    };

[table Parameters
    [[Parameters]    [Requirement]   [Description]]
    [[`Seq1`, `Seq2`][Models of __forward_sequence__][The sequences being swapped]]
]

[heading Expression Semantics]
    result_of::swap<Seq1, Seq2>::type

[*Return type]: `void`.

[*Semantics]: Always returns `void`.

[heading Header]
    #include <boost/fusion/sequence/intrinsic/swap.hpp>

[endsect]

[endsect]

[endsect]

[section Generation]

These are the functions that you can use to generate various forms of
__containers__ from elemental values.

[heading Header]

    #include <boost/fusion/sequence/generation.hpp>

[section Functions]

[section make_list]

[heading Description]

Create a __list__ from one or more values.

[heading Synopsis]

    template <typename T0, typename T1,... typename TN>
    typename __result_of_make_list__<T0, T1,... TN>::type
    make_list(T0 const& x0, T1 const& x1... TN const& xN);

The variadic function accepts `0` to `FUSION_MAX_LIST_SIZE` elements, where
`FUSION_MAX_LIST_SIZE` is a user definable predefined maximum that defaults
to `10`. You may define the preprocessor constant `FUSION_MAX_LIST_SIZE`
before including any Fusion header to change the default. Example:

    #define FUSION_MAX_LIST_SIZE 20

[heading Parameters]

[table
    [[Parameter]        [Requirement]                   [Description]]
    [[`x0, x1,... xN`]  [Instances of `T0, T1,... TN`]  [The arguments to `make_list`]]
]

[heading Expression Semantics]

    make_list(x0, x1,... xN);

[*Return type]: __result_of_make_list__`<T0, T1,... TN>::type`

[*Semantics]: Create a __list__ from `x0, x1,... xN`.

[heading Header]

    #include <boost/fusion/sequence/generation/make_list.hpp>

[heading Example]

    make_list(123, "hello", 12.5)

[heading See also]

__note_boost_ref__

[endsect]

[section make_cons]

[heading Description]

Create a __cons__ from `car` (/head/) and optional `cdr` (/tail/).

[heading Synopsis]

    template <typename Car>
    typename __result_of_make_cons__<Car>::type
    make_cons(Car const& car);

    template <typename Car, typename Cdr>
    typename __result_of_make_cons__<Car, Cdr>::type
    make_cons(Car const& car, Cdr const& cdr);

[heading Parameters]

[table
    [[Parameter]        [Requirement]                   [Description]]
    [[`car`]            [Instance of `Car`]             [The list's head]]
    [[`cdr`]            [Instance of `Cdr`]             [The list's tail (optional)]]
]

[heading Expression Semantics]

    make_cons(car, cdr);

[*Return type]: __result_of_make_cons__`<Car, Cdr>::type` or
__result_of_make_cons__`<Car>::type`

[*Semantics]: Create a __cons__ from `car` (/head/) and optional `cdr` (/tail/).

[heading Header]

    #include <boost/fusion/sequence/generation/make_cons.hpp>

[heading Example]

    make_cons('x', make_cons(123))

[heading See also]

__note_boost_ref__

[endsect]

[section make_vector]

[heading Description]

Create a __vector__ from one or more values.

[heading Synopsis]

    template <typename T0, typename T1,... typename TN>
    typename __result_of_make_vector__<T0, T1,... TN>::type
    make_vector(T0 const& x0, T1 const& x1... TN const& xN);

The variadic function accepts `0` to `FUSION_MAX_VECTOR_SIZE` elements,
where `FUSION_MAX_VECTOR_SIZE` is a user definable predefined maximum that
defaults to `10`. You may define the preprocessor constant
`FUSION_MAX_VECTOR_SIZE` before including any Fusion header to change the
default. Example:

    #define FUSION_MAX_VECTOR_SIZE 20

[heading Parameters]

[table
    [[Parameter]        [Requirement]                   [Description]]
    [[`x0, x1,... xN`]  [Instances of `T0, T1,... TN`]  [The arguments to `make_vector`]]
]

[heading Expression Semantics]

    make_vector(x0, x1,... xN);

[*Return type]: __result_of_make_vector__`<T0, T1,... TN>::type`

[*Semantics]: Create a __vector__ from `x0, x1,... xN`.

[heading Header]

    #include <boost/fusion/sequence/generation/make_vector.hpp>

[heading Example]

    make_vector(123, "hello", 12.5)

[heading See also]

__note_boost_ref__

[endsect]

[section make_set]

[heading Description]

Create a __set__ from one or more values.

[heading Synopsis]

    template <typename T0, typename T1,... typename TN>
    typename __result_of_make_set__<T0, T1,... TN>::type
    make_set(T0 const& x0, T1 const& x1... TN const& xN);

The variadic function accepts `0` to `FUSION_MAX_VECTOR_SIZE`[footnote
`set` is implemented in terms of the vector. That is why we reuse
`FUSION_MAX_VECTOR_SIZE`] elements, where `FUSION_MAX_VECTOR_SIZE` is a user
definable predefined maximum that defaults to `10`. You may define the
preprocessor constant `FUSION_MAX_VECTOR_SIZE` before including any Fusion
header to change the default. Example:

    #define FUSION_MAX_VECTOR_SIZE 20

[heading Parameters]

[table
    [[Parameter]        [Requirement]                   [Description]]
    [[`x0, x1,... xN`]  [Instances of `T0, T1,... TN`]  [The arguments to `make_set`]]
]

[heading Expression Semantics]

    make_set(x0, x1,... xN);

[*Return type]: __result_of_make_set__`<T0, T1,... TN>::type`

[*Semantics]: Create a __set__ from `x0, x1,... xN`.

[*Precondition]: There may be no duplicate key types.

[heading Header]

    #include <boost/fusion/sequence/generation/make_set.hpp>

[heading Example]

    make_set(123, "hello", 12.5)

[heading See also]

__note_boost_ref__

[endsect]

[section make_map]

[heading Description]

Create a __map__ from one or more key/data pairs.

[heading Synopsis]

    template <
        typename K0, typename K1,... typename KN
      , typename T0, typename T1,... typename TN>
    typename __result_of_make_map__<K0, K0,... KN, T0, T1,... TN>::type
    make_map(T0 const& x0, T1 const& x1... TN const& xN);

The variadic function accepts `0` to `FUSION_MAX_VECTOR_SIZE`[footnote
`map` is implemented in terms of the vector. That is why we reuse
`FUSION_MAX_VECTOR_SIZE`] elements, where `FUSION_MAX_VECTOR_SIZE` is a user
definable predefined maximum that defaults to `10`. You may define the
preprocessor constant `FUSION_MAX_VECTOR_SIZE` before including any Fusion
header to change the default. Example:

    #define FUSION_MAX_VECTOR_SIZE 20

[heading Parameters]

[table
    [[Parameter]        [Requirement]                   [Description]]
    [[`K0, K1,... KN`]  [The key types]                 [Keys associated with `x0, x1,... xN`]]
    [[`x0, x1,... xN`]  [Instances of `T0, T1,... TN`]  [The arguments to `make_map`]]
]

[heading Expression Semantics]

    make_map<K0, K1,... KN>(x0, x1,... xN);

[*Return type]: __result_of_make_map__`<K0, K0,... KN, T0, T1,... TN>::type`

[*Semantics]: Create a __map__ from `K0, K1,... KN` keys and
`x0, x1,... xN` data.

[*Precondition]: There may be no duplicate key types.

[heading Header]

    #include <boost/fusion/sequence/generation/make_map.hpp>

[heading Example]

    make_map(
        __fusion_make_pair__<int>('X')
      , __fusion_make_pair__<double>("Men"))

[heading See also]

__note_boost_ref__, __fusion_pair__

[endsect]

[section Tiers]

Tiers are sequences, where all elements are non-const reference types. They
are constructed with a call to a couple of /tie/ function templates. The
succeeding sections document the various /tier/ flavors.

* __list_tie__
* __vector_tie__
* __map_tie__

Example:

    int i; char c; double d;
      ...
    __vector_tie__(i, c, a);

The __vector_tie__ function creates a __vector__ of type
`__vector__<int&, char&, double&>`. The same result could be achieved with the call
__make_vector__(__boost_ref_call__(i), __boost_ref_call__(c), __boost_ref_call__(a))
[footnote see __boost_ref__ for details about `ref`].

A /tie/ can be used to 'unpack' another tuple into variables. E.g.:

    int i; char c; double d;
    __vector_tie__(i, c, d) = __make_vector__(1,'a', 5.5);
    std::cout << i << " " <<  c << " " << d;

This code prints 1 a 5.5 to the standard output stream. A sequence
unpacking operation like this is found for example in ML and Python. It is
convenient when calling functions which return sequences.

[heading Ignore]

There is also an object called /ignore/ which allows you to ignore an
element assigned by a sequence. The idea is that a function may return a
sequence, only part of which you are interested in. For example:

    char c;
    __vector_tie__(ignore, c) = __make_vector__(1, 'a');

[endsect]

[section list_tie]

[heading Description]

Constructs a tie using a __list__ sequence.

[heading Synopsis]

    template <typename T0, typename T1,... typename TN>
    __list__<T0&, T1&,... TN&>
    list_tie(T0& x0, T1& x1... TN& xN);

The variadic function accepts `0` to `FUSION_MAX_LIST_SIZE` elements, where
`FUSION_MAX_LIST_SIZE` is a user definable predefined maximum that defaults
to `10`. You may define the preprocessor constant `FUSION_MAX_LIST_SIZE`
before including any Fusion header to change the default. Example:

    #define FUSION_MAX_LIST_SIZE 20

[heading Parameters]

[table
    [[Parameter]        [Requirement]                       [Description]]
    [[`x0, x1,... xN`]  [Instances of `T0, T1,... TN`]      [The arguments to `list_tie`]]
]

[heading Expression Semantics]

    list_tie(x0, x1,... xN);

[*Return type]: __list__<T0&, T1&,... TN&>

[*Semantics]: Create a __list__ of references from `x0, x1,... xN`.

[heading Header]

    #include <boost/fusion/sequence/generation/list_tie.hpp>

[heading Example]

    int i = 123;
    double d = 123.456;
    list_tie(i, d)

[endsect]

[section vector_tie]

[heading Description]

Constructs a tie using a __vector__ sequence.

[heading Synopsis]

    template <typename T0, typename T1,... typename TN>
    __vector__<T0&, T1&,... TN&>
    vector_tie(T0& x0, T1& x1... TN& xN);

The variadic function accepts `0` to `FUSION_MAX_VECTOR_SIZE` elements,
where `FUSION_MAX_VECTOR_SIZE` is a user definable predefined maximum that
defaults to `10`. You may define the preprocessor constant
`FUSION_MAX_VECTOR_SIZE` before including any Fusion header to change the
default. Example:

    #define FUSION_MAX_VECTOR_SIZE 20

[heading Parameters]

[table
    [[Parameter]        [Requirement]                       [Description]]
    [[`x0, x1,... xN`]  [Instances of `T0, T1,... TN`]      [The arguments to `vector_tie`]]
]

[heading Expression Semantics]

    vector_tie(x0, x1,... xN);

[*Return type]: __vector__<T0&, T1&,... TN&>

[*Semantics]: Create a __vector__ of references from `x0, x1,... xN`.

[heading Header]

    #include <boost/fusion/sequence/generation/vector_tie.hpp>

[heading Example]

    int i = 123;
    double d = 123.456;
    vector_tie(i, d)

[endsect]

[section map_tie]

[heading Description]

Constructs a tie using a __map__ sequence.

[heading Synopsis]

    template <typename K0, typename K1,... typename KN, typename D0, typename D1,... typename DN>
    __map__<__pair__<K0, D0&>, __pair__<K1, D1&>,... __pair__<KN, DN&> >
    map_tie(D0& d0, D1& d1... DN& dN);

The variadic function accepts `0` to `FUSION_MAX_MAP_SIZE` elements,
where `FUSION_MAX_MAP_SIZE` is a user definable predefined maximum that
defaults to `10`, and a corresponding number of key types.
You may define the preprocessor constant  `FUSION_MAX_MAP_SIZE` before
including any Fusion header to change the default. Example:

    #define FUSION_MAX_MAP_SIZE 20

[heading Parameters]

[table
    [[Parameter]        [Requirement]                       [Description]]
    [[`K0, K1,... KN`]  [Any type][The key types associated with each of the `x1,x2,...,xN` values]]
    [[`x0, x1,... xN`]  [Instances of `T0, T1,... TN`]                      [The arguments to `map_tie`]]
]

[heading Expression Semantics]

    map_tie<K0, K1,... KN>(x0, x1,... xN);

[*Return type]: __map__<__pair__<K0, D0&>, __pair__<K1, D1&>,... __pair__<KN, DN&> >

[*Semantics]: Create a __map__ of references from `x0, x1,... xN` with keys `K0, K1,... KN`

[heading Header]

    #include <boost/fusion/sequence/generation/map_tie.hpp>

[heading Example]

    struct int_key;
    struct double_key;
    ...
    int i = 123;
    double d = 123.456;
    map_tie<int_key, double_key>(i, d)

[endsect]

[endsect]

[section MetaFunctions]

[section make_list]

[heading Description]

Returns the result type of __make_list__.

[heading Synopsis]

    template <typename T0, typename T1,... typename TN>
    struct make_list;

The variadic function accepts `0` to `FUSION_MAX_LIST_SIZE` elements, where
`FUSION_MAX_LIST_SIZE` is a user definable predefined maximum that defaults
to `10`. You may define the preprocessor constant `FUSION_MAX_LIST_SIZE`
before including any Fusion header to change the default. Example:

    #define FUSION_MAX_LIST_SIZE 20

[heading Parameters]

[table
    [[Parameter]        [Requirement]       [Description]]
    [[`T0, T1,... TN`]  [Any type]          [Template arguments to `make_list`]]
]

[heading Expression Semantics]

    result_of::make_list<T0, T1,... TN>::type

[*Return type]: A __list__ with elements of types converted following the
rules for __element_conversion__.

[*Semantics]: Create a __list__ from `T0, T1,... TN`.

[heading Header]

    #include <boost/fusion/sequence/generation/make_list.hpp>

[heading Example]

    result_of::make_list<int, const char(&)[7], double>::type

[endsect]

[section make_cons]

[heading Description]

Returns the result type of __make_cons__.

[heading Synopsis]

    template <typename Car, typename Cdr = nil>
    struct make_cons;

[heading Parameters]

[table
    [[Parameter]        [Requirement]               [Description]]
    [[`Car`]            [Any type]                  [The list's head type]]
    [[`Cdr`]            [A `cons`]                  [The list's tail type (optional)]]
]

[heading Expression Semantics]

    result_of::make_cons<Car, Cdr>::type

[*Return type]: A __cons__ with head element, `Car`, of type converted
following the rules for __element_conversion__, and tail, `Cdr`.

[*Semantics]: Create a __cons__ from `Car` (/head/) and optional `Cdr` (/tail/).

[heading Header]

    #include <boost/fusion/sequence/generation/make_cons.hpp>

[heading Example]

    result_of::make_cons<char, result_of::make_cons<int>::type>::type

[endsect]

[section make_vector]

[heading Description]

Returns the result type of __make_vector__.

[heading Synopsis]

    template <typename T0, typename T1,... typename TN>
    struct make_vector;

The variadic function accepts `0` to `FUSION_MAX_VECTOR_SIZE` elements,
where `FUSION_MAX_VECTOR_SIZE` is a user definable predefined maximum that
defaults to `10`. You may define the preprocessor constant
`FUSION_MAX_VECTOR_SIZE` before including any Fusion header to change the
default. Example:

    #define FUSION_MAX_VECTOR_SIZE 20

[heading Parameters]

[table
    [[Parameter]        [Requirement]       [Description]]
    [[`T0, T1,... TN`]  [Any type]          [Template arguments to `make_vector`]]
]

[heading Expression Semantics]

    result_of::make_vector<T0, T1,... TN>::type

[*Return type]: A __vector__ with elements of types converted following the
rules for __element_conversion__.

[*Semantics]: Create a __vector__ from `T0, T1,... TN`.

[heading Header]

    #include <boost/fusion/sequence/generation/make_list.hpp>

[heading Example]

    result_of::make_vector<int, const char(&)[7], double>::type

[endsect]

[section make_set]

[heading Description]

Returns the result type of __make_set__.

[heading Synopsis]

    template <typename T0, typename T1,... typename TN>
    struct make_set;

The variadic function accepts `0` to `FUSION_MAX_VECTOR_SIZE`[footnote
`set` is implemented in terms of the vector. That is why we reuse
`FUSION_MAX_VECTOR_SIZE`] elements, where `FUSION_MAX_VECTOR_SIZE` is a user
definable predefined maximum that defaults to `10`. You may define the
preprocessor constant `FUSION_MAX_VECTOR_SIZE` before including any Fusion
header to change the default. Example:

    #define FUSION_MAX_VECTOR_SIZE 20

[heading Parameters]

[table
    [[Parameter]        [Requirement]       [Description]]
    [[`T0, T1,... TN`]  [Any type]          [The arguments to `make_set`]]
]

[heading Expression Semantics]

    result_of::make_set<T0, T1,... TN>::type

[*Return type]: A __set__ with elements of types converted following the
rules for __element_conversion__.

[*Semantics]: Create a __set__ from `T0, T1,... TN`.

[*Precondition]: There may be no duplicate key types.

[heading Header]

    #include <boost/fusion/sequence/generation/make_set.hpp>

[heading Example]

    result_of::make_set<int, char, double>::type

[endsect]

[section make_map]

[heading Description]

Returns the result type of __make_map__.

[heading Synopsis]

    template <
        typename K0, typename K1,... typename KN
      , typename T0, typename T1,... typename TN>
    struct make_map;

The variadic function accepts `0` to `FUSION_MAX_VECTOR_SIZE`[footnote
`map` is implemented in terms of the vector. That is why we reuse
`FUSION_MAX_VECTOR_SIZE`] elements, where `FUSION_MAX_VECTOR_SIZE` is a user
definable predefined maximum that defaults to `10`. You may define the
preprocessor constant `FUSION_MAX_VECTOR_SIZE` before including any Fusion
header to change the default. Example:

    #define FUSION_MAX_VECTOR_SIZE 20

[heading Parameters]

[table
    [[Parameter]        [Requirement]           [Description]]
    [[`K0, K1,... KN`]  [Any type]              [Keys associated with `T0, T1,... TN`]]
    [[`T0, T1,... TN`]  [Any type]              [Data associated with keys `K0, K1,... KN`]]
]

[heading Expression Semantics]

    resulf_of::make_map<K0, K1,... KN, T0, T1,... TN>::type;

[*Return type]: __result_of_make_map__`<K0, K0,... KN, T0, T1,... TN>::type`

[*Semantics]: A __map__ with __fusion_pair__ elements where the
`second_type` is converted following the rules for __element_conversion__.

[*Precondition]: There may be no duplicate key types.

[heading Header]

    #include <boost/fusion/sequence/generation/make_map.hpp>

[heading Example]

    result_of::make_map<int, double, char, double>::type

[heading See also]

__fusion_pair__

[endsect]

[section list_tie]

[heading Description]

Returns the result type of __list_tie__.

[heading Synopsis]

    template <typename T0, typename T1,... typename TN>
    struct list_tie;

The variadic function accepts `0` to `FUSION_MAX_LIST_SIZE` elements, where
`FUSION_MAX_LIST_SIZE` is a user definable predefined maximum that defaults
to `10`. You may define the preprocessor constant `FUSION_MAX_LIST_SIZE`
before including any Fusion header to change the default. Example:

    #define FUSION_MAX_LIST_SIZE 20

[heading Parameters]

[table
    [[Parameter]        [Requirement]       [Description]]
    [[`T0, T1,... TN`]  [Any type]          [The arguments to `list_tie`]]
]

[heading Expression Semantics]

    result_of::list_tie<T0, T1,... TN>::type;

[*Return type]: __list__<T0&, T1&,... TN&>

[*Semantics]: Create a __list__ of references from `T0, T1,... TN`.

[heading Header]

    #include <boost/fusion/sequence/generation/list_tie.hpp>

[heading Example]

    result_of::list_tie<int, double>::type

[endsect]

[section vector_tie]

[heading Description]

Returns the result type of __vector_tie__.

[heading Synopsis]

    template <typename T0, typename T1,... typename TN>
    struct vector_tie;

The variadic function accepts `0` to `FUSION_MAX_VECTOR_SIZE` elements,
where `FUSION_MAX_VECTOR_SIZE` is a user definable predefined maximum that
defaults to `10`. You may define the preprocessor constant
`FUSION_MAX_VECTOR_SIZE` before including any Fusion header to change the
default. Example:

    #define FUSION_MAX_VECTOR_SIZE 20

[heading Parameters]

[table
    [[Parameter]        [Requirement]       [Description]]
    [[`T0, T1,... TN`]  [Any type]          [The arguments to `vector_tie`]]
]

[heading Expression Semantics]

    result_of::vector_tie<T0, T1,... TN>::type;

[*Return type]: __vector__<T0&, T1&,... TN&>

[*Semantics]: Create a __vector__ of references from `T0, T1,... TN`.

[heading Header]

    #include <boost/fusion/sequence/generation/vector_tie.hpp>

[heading Example]

    result_of::vector_tie<int, double>::type

[endsect]

[section map_tie]

[heading Description]

Returns the result type of __map_tie__.

[heading Synopsis]

    template <typename K0, typename K1,... typename KN, typename D0, typename D1,... typename DN>
    struct map_tie;

The variadic function accepts `0` to `FUSION_MAX_MAP_SIZE` elements,
where `FUSION_MAX_MAP_SIZE` is a user definable predefined maximum that
defaults to `10`. You may define the preprocessor constant
`FUSION_MAX_MAP_SIZE` before including any Fusion header to change the
default. Example:

    #define FUSION_MAX_MAP_SIZE 20

[heading Parameters]

[table
    [[Parameter]        [Requirement]       [Description]]
    [[`K0, K1,... KN`]  [Any type]          [The key types for `map_tie`]]
    [[`D0, D1,... DN`]  [Any type]          [The arguments types for `map_tie`]]
]

[heading Expression Semantics]

    result_of::map_tie<K0, K1,... KN, D0, D1,... DN>::type;

[*Return type]: __map__<__pair__<K0, D0&>, __pair__<K1, D1&>,... __pair__<KN, DN&> >

[*Semantics]: Create a __map__ of references from `D0, D1,... DN` with keys `K0, K1,... KN`

[heading Header]

    #include <boost/fusion/sequence/generation/map_tie.hpp>

[heading Example]

    struct int_key;
    struct double_key;
    ...
    result_of::map_tie<int_key, double_key, int, double>::type

[endsect]

[endsect]

[endsect]

[section Conversion]

All fusion sequences can be converted to one of the __containers__ types
using one of these conversion functions.

[heading Header]

    #include <boost/fusion/sequence/conversion.hpp>

[section Functions]

[section as_list]

[heading Description]

Convert a fusion sequence to a __list__.

[heading Synopsis]

    template <typename Sequence>
    typename result_of::as_list<Sequence>::type
    as_list(Sequence& seq);

    template <typename Sequence>
    typename result_of::as_list<Sequence const>::type
    as_list(Sequence const& seq);

[heading Parameters]

[table
    [[Parameter]    [Requirement]               [Description]]
    [[`seq`]        [An instance of Sequence]   [The sequence to convert.]]
]

[heading Expression Semantics]

    as_list(seq);

[*Return type]: __result_of_as_list__`<Sequence>::type`

[*Semantics]: Convert a fusion sequence, `seq`, to a __list__.

[heading Header]

    #include <boost/fusion/sequence/conversion/as_list.hpp>

[heading Example]

    as_list(__make_vector__('x', 123, "hello"))

[endsect]

[section as_vector]

[heading Description]

Convert a fusion sequence to a __vector__.

[heading Synopsis]

    template <typename Sequence>
    typename result_of::as_vector<Sequence>::type
    as_vector(Sequence& seq);

    template <typename Sequence>
    typename result_of::as_vector<Sequence const>::type
    as_vector(Sequence const& seq);

[heading Parameters]

[table
    [[Parameter]    [Requirement]               [Description]]
    [[`seq`]        [An instance of Sequence]   [The sequence to convert.]]
]

[heading Expression Semantics]

    as_vector(seq);

[*Return type]: __result_of_as_vector__`<Sequence>::type`

[*Semantics]: Convert a fusion sequence, `seq`, to a __vector__.

[heading Header]

    #include <boost/fusion/sequence/conversion/as_vector.hpp>

[heading Example]

    as_vector(__make_list__('x', 123, "hello"))

[endsect]

[section as_set]

[heading Description]

Convert a fusion sequence to a __set__.

[heading Synopsis]

    template <typename Sequence>
    typename result_of::as_set<Sequence>::type
    as_set(Sequence& seq);

    template <typename Sequence>
    typename result_of::as_set<Sequence const>::type
    as_set(Sequence const& seq);

[heading Parameters]

[table
    [[Parameter]    [Requirement]               [Description]]
    [[`seq`]        [An instance of Sequence]   [The sequence to convert.]]
]

[heading Expression Semantics]

    as_set(seq);

[*Return type]: __result_of_as_set__`<Sequence>::type`

[*Semantics]: Convert a fusion sequence, `seq`, to a __set__.

[*Precondition]: There may be no duplicate key types.

[heading Header]

    #include <boost/fusion/sequence/conversion/as_set.hpp>

[heading Example]

    as_set(__make_vector__('x', 123, "hello"))

[endsect]

[section as_map]

[heading Description]

Convert a fusion sequence to a __map__.

[heading Synopsis]

    template <typename Sequence>
    typename result_of::as_map<Sequence>::type
    as_map(Sequence& seq);

    template <typename Sequence>
    typename result_of::as_map<Sequence const>::type
    as_map(Sequence const& seq);

[heading Parameters]

[table
    [[Parameter]    [Requirement]               [Description]]
    [[`seq`]        [An instance of Sequence]   [The sequence to convert.]]
]

[heading Expression Semantics]

    as_map(seq);

[*Return type]: __result_of_as_map__`<Sequence>::type`

[*Semantics]: Convert a fusion sequence, `seq`, to a __map__.

[*Precondition]: The elements of the sequence are assumed to be
__fusion_pair__s. There may be no duplicate __fusion_pair__ key types.

[heading Header]

    #include <boost/fusion/sequence/conversion/as_map.hpp>

[heading Example]

    as_map(__make_vector__(
        __fusion_make_pair__<int>('X')
      , __fusion_make_pair__<double>("Men")))

[endsect]

[endsect]

[section Metafunctions]

[section as_list]

[heading Description]

Returns the result type of __as_list__.

[heading Synopsis]

    template <typename Sequence>
    struct as_list;

[heading Parameters]

[table
    [[Parameter]    [Requirement]               [Description]]
    [[`Sequence`]   [A fusion __sequence__]     [The sequence type to convert.]]
]

[heading Expression Semantics]

    result_of::as_list<Sequence>::type;

[*Return type]: A __list__ with same elements as the input sequence,
`Sequence`.

[*Semantics]: Convert a fusion sequence, `Sequence`, to a __list__.

[heading Header]

    #include <boost/fusion/sequence/conversion/as_list.hpp>

[heading Example]

    result_of::as_list<__vector__<char, int> >::type

[endsect]

[section as_vector]

[heading Description]

Returns the result type of __as_vector__.

[heading Synopsis]

    template <typename Sequence>
    struct as_vector;

[heading Parameters]

[table
    [[Parameter]    [Requirement]               [Description]]
    [[`Sequence`]   [A fusion __sequence__]     [The sequence to convert.]]
]

[heading Expression Semantics]

    result_of::as_vector<Sequence>::type;

[*Return type]: A __vector__ with same elements as the input sequence,
`Sequence`.

[*Semantics]: Convert a fusion sequence, `Sequence`, to a __vector__.

[heading Header]

    #include <boost/fusion/sequence/conversion/as_vector.hpp>

[heading Example]

    result_of::as_vector<__list__<char, int> >::type

[endsect]

[section as_set]

[heading Description]

Returns the result type of __as_set__.

[heading Synopsis]

    template <typename Sequence>
    struct as_set;

[heading Parameters]

[table
    [[Parameter]    [Requirement]               [Description]]
    [[`Sequence`]   [A fusion __sequence__]     [The sequence to convert.]]
]

[heading Expression Semantics]

    result_of::as_set<Sequence>::type;

[*Return type]: A __set__ with same elements as the input sequence,
`Sequence`.

[*Semantics]: Convert a fusion sequence, `Sequence`, to a __set__.

[*Precondition]: There may be no duplicate key types.

[heading Header]

    #include <boost/fusion/sequence/conversion/as_set.hpp>

[heading Example]

    result_of::as_set<__vector__<char, int> >::type

[endsect]

[section as_map]

[heading Description]

Returns the result type of __as_map__.

[heading Synopsis]

    template <typename Sequence>
    struct as_map;

[heading Parameters]

[table
    [[Parameter]    [Requirement]               [Description]]
    [[`Sequence`]   [A fusion __sequence__]     [The sequence to convert.]]
]

[heading Expression Semantics]

    result_of::as_map<Sequence>::type;

[*Return type]: A __map__ with same elements as the input sequence,
`Sequence`.

[*Semantics]: Convert a fusion sequence, `Sequence`, to a __map__.

[*Precondition]: The elements of the sequence are assumed to be
__fusion_pair__s. There may be no duplicate __fusion_pair__ key types.

[heading Header]

    #include <boost/fusion/sequence/conversion/as_map.hpp>

[heading Example]

    result_of::as_map<__vector__<
        __fusion_pair__<int, char>
      , __fusion_pair__<double, std::string> > >::type

[endsect]

[endsect]

[endsect]

[section Operators]

These operators, like the __algorithms__, work generically on all Fusion
sequences. All conforming Fusion sequences automatically get these
operators for free.

[section I/O]

The I/O operators: `<<` and `>>` work generically on all Fusion sequences.
The global `operator<<` has been overloaded for generic output streams such
that __sequence__s are output by recursively calling `operator<<` for each
element. Analogously, the global `operator>>` has been overloaded to
extract __sequence__s from generic input streams by recursively calling
`operator>>` for each element.

The default delimiter between the elements is space, and the __sequence__
is enclosed in parenthesis. For Example:

    __vector__<float, int, std::string> a(1.0f, 2, std::string("Howdy folks!");
    cout << a;

outputs the __vector__ as: (1.0 2 Howdy folks!)

The library defines three manipulators for changing the default behavior:

[variablelist Manipulators
    [[`tuple_open(arg)`]        [Defines the character that is output before the first element.]]
    [[`tuple_close(arg)`]       [Defines the character that is output after the last element.]]
    [[`tuple_delimiter(arg)`]   [Defines the delimiter character between elements.]]
]

The argument to `tuple_open`, `tuple_close` and `tuple_delimiter` may be a
`char`, `wchar_t`, a C-string, or a wide C-string.

Example:

    std::cout << tuple_open('[') << tuple_close(']') << tuple_delimiter(", ") << a;

outputs the same __vector__, `a` as: [1.0, 2, Howdy folks!]

The same manipulators work with `operator>>` and `istream` as well. Suppose
the `std::cin` stream contains the following data:

    (1 2 3) [4:5]

The code:

    __vector__<int, int, int> i;
    __vector__<int, int> j;

    std::cin >> i;
    std::cin >> set_open('[') >> set_close(']') >> set_delimiter(':');
    std::cin >> j;

reads the data into the __vector__s `i` and `j`.

Note that extracting __sequence__s with `std::string` or C-style string
elements does not generally work, since the streamed __sequence__
representation may not be unambiguously parseable.

[heading Header]

    #include <boost/fusion/sequence/io.hpp>

[section in]

[heading Description]

Read a __sequence__ from an input stream.

[heading Synopsis]

    template <typename IStream, typename Sequence>
    IStream&
    operator>>(IStream& is, Sequence& seq);

[heading Parameters]

[table
    [[Parameter]    [Requirement]           [Description]]
    [[is]           [An input stream.]      [Stream to extract information from.]]
    [[seq]          [A __sequence__.]       [The sequence to read.]]
]

[heading Expression Semantics]

    is >> seq

[*Return type]: IStream&

[*Semantics]: For each element, `e`, in sequence, `seq`, call `is >> e`.

[heading Header]

    #include <boost/fusion/sequence/io/in.hpp>

[heading Example]

    __vector__<int, std::string, char> v;
    std::cin >> v;

[endsect]

[section out]

[heading Description]

Write a __sequence__ to an output stream.

[heading Synopsis]

    template <typename OStream, typename Sequence>
    OStream&
    operator<<(OStream& os, Sequence& seq);

[heading Parameters]

[table
    [[Parameter]    [Requirement]           [Description]]
    [[os]           [An output stream.]     [Stream to write information to.]]
    [[seq]          [A __sequence__.]       [The sequence to write.]]
]

[heading Expression Semantics]

    os << seq

[*Return type]: OStream&

[*Semantics]: For each element, `e`, in sequence, `seq`, call `os << e`.

[heading Header]

    #include <boost/fusion/sequence/io/out.hpp>

[heading Example]

    std::cout << __make_vector__(123, "Hello", 'x') << std::endl;

[endsect]

[endsect]

[section Comparison]

The Comparison operators: `==`, `!=`, `<`, `<=`, `>=` and `>=` work
generically on all Fusion sequences. Comparison operators are "short-
circuited": elementary comparisons start from the first elements and are
performed only until the result is clear.

[heading Header]

    #include <boost/fusion/sequence/comparison.hpp>

[section equal]

[heading Description]

Compare two sequences for equality.

[heading Synopsis]

    template <typename Seq1, typename Seq2>
    bool
    operator==(Seq1 const& a, Seq2 const& b);

[heading Parameters]

[table
    [[Parameter]    [Requirement]                       [Description]]
    [[`a, b`]       [Instances of __sequence__]         [__sequence__s to compare]]
]

[heading Expression Semantics]

    a == b

[*Return type]: `bool`

[*Requirements]:

For each element, `e1`, in  sequence `a`, and for each element, `e2`, in
sequence `b`, `a == b` is a valid expression returning a type that is
convertible to bool.

An attempt to compare two Sequences of different lengths results in a
compile time error.

[*Semantics]:

For each element, `e1`, in  sequence `a`, and for each element, `e2`, in
sequence `b`, `e1 == e2` returns true. For any 2 zero length __sequence__s,
e and f, e == f  returns true.

[heading Header]

    #include <boost/fusion/sequence/comparison/equal_to.hpp>

[heading Example]

    __vector__<int, char> v1(5, 'a');
    __vector__<int, char> v2(5, 'a');
    assert(v1 == v2);

[endsect]

[section not equal]

Compare two sequences for inequality.

[heading Synopsis]

    template <typename Seq1, typename Seq2>
    bool
    operator!=(Seq1 const& a, Seq2 const& b);

[heading Parameters]

[table
    [[Parameter]    [Requirement]                       [Description]]
    [[`a, b`]       [Instances of __sequence__]         [__sequence__s to compare]]
]

[heading Expression Semantics]

    a != b

[*Return type]: `bool`

[*Requirements]:

For each element, `e1`, in  sequence `a`, and for each element, `e2`, in
sequence `b`, `a == b` is a valid expression returning a type that is
convertible to bool.

An attempt to compare two Sequences of different lengths results in a
compile time error.

[*Semantics]:

Returns !(a == b).

[heading Header]

    #include <boost/fusion/sequence/comparison/not_equal_to.hpp>

[heading Example]

    __vector__<int, char> v3(5, 'b');
    __vector__<int, char> t4(2, 'a');
    assert(v1 != v3);
    assert(v1 != t4);
    assert(!(v1 != v2));

[endsect]

[section less than]

Lexicographically compare two sequences.

[heading Synopsis]

    template <typename Seq1, typename Seq2>
    bool
    operator<(Seq1 const& a, Seq2 const& b);

[heading Parameters]

[table
    [[Parameter]    [Requirement]                       [Description]]
    [[`a, b`]       [Instances of __sequence__]         [__sequence__s to compare]]
]

[heading Expression Semantics]

    a < b

[*Return type]: `bool`

[*Requirements]:

For each element, `e1`, in  sequence `a`, and for each element, `e2`, in
sequence `b`, `a < b` is a valid expression returning a type that is
convertible to bool.

An attempt to compare two Sequences of different lengths results in a
compile time error.

[*Semantics]: Returns the lexicographical comparison of between `a` and `b`.

[heading Header]

    #include <boost/fusion/sequence/comparison/less.hpp>

[heading Example]

    __vector__<int, float> v1(4, 3.3f);
    __vector__<short, float> v2(5, 3.3f);
    __vector__<long, double> v3(5, 4.4);
    assert(v1 < v2);
    assert(v2 < v3);

[endsect]

[section less than equal]

Lexicographically compare two sequences.

[heading Synopsis]

    template <typename Seq1, typename Seq2>
    bool
    operator<=(Seq1 const& a, Seq2 const& b);

[heading Parameters]

[table
    [[Parameter]    [Requirement]                       [Description]]
    [[`a, b`]       [Instances of __sequence__]         [__sequence__s to compare]]
]

[heading Expression Semantics]

    a <= b

[*Return type]: `bool`

[*Requirements]:

For each element, `e1`, in  sequence `a`, and for each element, `e2`, in
sequence `b`, `a < b` is a valid expression returning a type that is
convertible to bool.

An attempt to compare two Sequences of different lengths results in a
compile time error.

[*Semantics]: Returns !(b < a).

[heading Header]

    #include <boost/fusion/sequence/comparison/less_equal.hpp>

[heading Example]

    __vector__<int, float> v1(4, 3.3f);
    __vector__<short, float> v2(5, 3.3f);
    __vector__<long, double> v3(5, 4.4);
    assert(v1 <= v2);
    assert(v2 <= v3);

[endsect]

[section greater than]

Lexicographically compare two sequences.

[heading Synopsis]

    template <typename Seq1, typename Seq2>
    bool
    operator>(Seq1 const& a, Seq2 const& b);

[heading Parameters]

[table
    [[Parameter]    [Requirement]                       [Description]]
    [[`a, b`]       [Instances of __sequence__]         [__sequence__s to compare]]
]

[heading Expression Semantics]

    a > b

[*Return type]: `bool`

[*Requirements]:

For each element, `e1`, in  sequence `a`, and for each element, `e2`, in
sequence `b`, `a < b` is a valid expression returning a type that is
convertible to bool.

An attempt to compare two Sequences of different lengths results in a
compile time error.

[*Semantics]: Returns b < a.

[heading Header]

    #include <boost/fusion/sequence/comparison/less_equal.hpp>

[heading Example]

    __vector__<int, float> v1(4, 3.3f);
    __vector__<short, float> v2(5, 3.3f);
    __vector__<long, double> v3(5, 4.4);
    assert(v2 > v1);
    assert(v3 > v2);

[endsect]

[section greater than equal]

Lexicographically compare two sequences.

[heading Synopsis]

    template <typename Seq1, typename Seq2>
    bool
    operator>=(Seq1 const& a, Seq2 const& b);

[heading Parameters]

[table
    [[Parameter]    [Requirement]                       [Description]]
    [[`a, b`]       [Instances of __sequence__]         [__sequence__s to compare]]
]

[heading Expression Semantics]

    a >= b

[*Return type]: `bool`

[*Requirements]:

For each element, `e1`, in  sequence `a`, and for each element, `e2`, in
sequence `b`, `a < b` is a valid expression returning a type that is
convertible to bool.

An attempt to compare two Sequences of different lengths results in a
compile time error.

[*Semantics]: Returns !(a < b).

[heading Header]

    #include <boost/fusion/sequence/comparison/greater_equal.hpp>

[heading Example]

    __vector__<int, float> v1(4, 3.3f);
    __vector__<short, float> v2(5, 3.3f);
    __vector__<long, double> v3(5, 4.4);
    assert(v2 >= v1);
    assert(v3 >= v2);

[endsect]

[endsect]

[endsect]

[endsect]

